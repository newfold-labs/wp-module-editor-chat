{"version":3,"file":"chat-editor.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAA2C;AACW;AAC8C;AAC+C;AAC1D;AACoF;AACtK;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,OAAO;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS,GAAG,aAAa;AACzD,0CAA0C,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,uBAAuB,qEAAwB;AAC/C,gBAAgB,sCAAsC;AACtD,2BAA2B,gEAAY,WAAW,+DAAW;AAC7D;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB,WAAW,SAAS,gCAAgC,MAAM,cAAc,KAAK;AAClI,mBAAmB,+DAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,6BAA6B,sEAAkB,qBAAqB,2EAAuB;AAC3F;AACA;AACA;AACA,kCAAkC,qEAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mEAAmE;AAC3G;AACA;AACA;AACA,qFAAqF,qBAAqB;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAA0B,+EAA+E,kBAAkB;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mCAAmC,8DAAU,sBAAsB,+DAAW;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iCAAiC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,4BAA4B,+EAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,2EAAoB,GAAG,mFAAmF;AACnH,8CAA8C,2BAA2B,0BAA0B,iBAAiB;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA,WAAW,iFAAoC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA,wCAAwC,SAAS,eAAe,gBAAgB,oBAAoB,gBAAgB,EAAE,SAAS;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,8DAAuB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+CAA+C,0CAA0C,IAAI;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,8DAAuB;AACjE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA,WAAW,gEAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,SAAS;AACxE;AACA,KAAK;AACL;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA,KAAK;AACL;AACA;AACA,wBAAwB,SAAS;AACjC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6EAA6E,mCAAmC,8DAAuB,GAAG,IAAI;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,oCAAoC,iBAAiB,iBAAiB,gDAAgD,gBAAgB,YAAY;AAClJ;AACA;AACA;AACA,mBAAmB,gEAAmB;AACtC;AACA;AACA,mBAAmB,kFAAqC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4DAA4D,kEAAkE;AACrI;AACA;AACA;AACA;AACA,wFAAwF,iCAAiC;AACzH;AACA;AACA;AACA,gGAAgG,oCAAoC;AACpI;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,6DAA6D,6FAA6F;AAC1J;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,WAAW,8DAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACO,+DAA+D,uHAAuH;AAC7L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACO,8DAA8D,uFAAuF;AAC5J;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,4CAA4C,kCAAkC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,UAAU;AACxE;AACO,8DAA8D,iDAAiD,IAAI;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO,wDAAwD,mCAAmC;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,WAAW,6EAAgC;AAC3C;AACA,gC;;;;;;;;;;;;;;;;;;;;;ACvzBoE;AAC+hB;AAC5hB;AACS;AACN;AAC0C;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,IAAI;AACzD,+DAA+D,IAAI;AACnE,mDAAmD,IAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACO,qBAAqB,yDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,+EAAsB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,wEAAiC;AACpF;AACA;AACA,aAAa;AACb;AACA;AACA,qDAAqD,0EAAmC;AACxF;AACA;AACA,aAAa;AACb;AACA;AACA,uDAAuD,4EAAqC;AAC5F;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kFAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sEAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA,sBAAsB,qEAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iEAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gEAAS,CAAC,0DAAmB;AACtE;AACA;AACA;AACA,8BAA8B,+CAAQ,CAAC,gDAAS,gDAAgD,aAAa;AAC7G;AACA,wBAAwB,SAAS;AACjC;AACA,wBAAwB,oCAAoC;AAC5D;AACA,8BAA8B,+CAAQ,CAAC,gDAAS;AAChD;AACA;AACA,8BAA8B,+CAAQ,CAAC,gDAAS;AAChD;AACA;AACA;AACA;AACA,iDAAiD,gEAAS,CAAC,6DAAsB;AACjF;AACA;AACA;AACA;AACA,kCAAkC,+CAAQ,CAAC,gDAAS,iDAAiD,aAAa;AAClH;AACA;AACA;AACA;AACA,yCAAyC,gEAAS,CAAC,yDAAkB;AACrE;AACA;AACA;AACA,8BAA8B,+CAAQ,CAAC,gDAAS,+CAA+C,aAAa;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gEAAS,CAAC,iEAA0B;AAC7E;AACA;AACA,8BAA8B,+CAAQ,CAAC,gDAAS,6CAA6C,aAAa;AAC1G;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA,iDAAiD,gEAAS,CAAC,6DAAsB;AACjF;AACA;AACA;AACA;AACA,kCAAkC,+CAAQ,CAAC,gDAAS,iDAAiD,aAAa;AAClH;AACA;AACA;AACA;AACA,yCAAyC,gEAAS,CAAC,gEAAyB;AAC5E;AACA;AACA,8BAA8B,+CAAQ,CAAC,gDAAS,4CAA4C,aAAa;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,YAAY,gBAAgB,OAAO;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8DAAuB;AAC5D;AACA;AACA;AACA,aAAa,EAAE,6DAAsB;AACrC;AACA,0EAA0E,OAAO;AACjF;AACA,iBAAiB,kEAA2B;AAC5C,+EAA+E,uBAAuB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,OAAO;AAC5F;AACA;AACA;AACA;AACA;AACA,qFAAqF,OAAO;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,OAAO;AAC9F;AACA;AACA,oGAAoG,OAAO;AAC3G;AACA;AACA;AACA;AACA;AACA,mFAAmF,OAAO;AAC1F;AACA;AACA;AACA;AACA,yFAAyF,OAAO;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8GAA8G,OAAO;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,OAAO;AACxG;AACA;AACA;AACA;AACA,oGAAoG,OAAO;AAC3G;AACA;AACA;AACA;AACA,8FAA8F,OAAO;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,OAAO;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6FAA6B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iGAAiC;AACzC;AACA;AACA,8BAA8B,gBAAgB,EAAE,wDAAiB;AACjE;AACA;AACA,8BAA8B,uCAAuC,EAAE,2DAAoB;AAC3F;AACA;AACA,8BAA8B,sCAAsC,SAAS,EAAE,wDAAiB;AAChG;AACA;AACA,8BAA8B,+BAA+B,EAAE,4DAAqB;AACpF;AACA;AACA,8BAA8B,gCAAgC,EAAE,8DAAuB;AACvF;AACA;AACA,8BAA8B,kCAAkC,EAAE,gEAAyB;AAC3F;AACA;AACA,8BAA8B,4CAA4C,EAAE,wEAAiC;AAC7G;AACA;AACA,8BAA8B,kCAAkC,EAAE,+DAAwB;AAC1F;AACA;AACA,8BAA8B,uCAAuC,EAAE,wDAAiB;AACxF;AACA;AACA,8BAA8B,yCAAyC,EAAE,wDAAiB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2DAAoB;AAC9D;AACA;AACA,sBAAsB,+CAAQ,CAAC,gDAAS,0BAA0B,YAAY;AAC9E;AACA,4CAA4C,8BAA8B;AAC1E;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAAQ,CAAC,gDAAS,yBAAyB,aAAa;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAQ,CAAC,gDAAS,+EAA+E,8BAA8B;AACjK;AACA;AACA;AACA,yCAAyC,+CAAQ;AACjD;AACA;AACA,8BAA8B,+CAAQ,CAAC,gDAAS,0DAA0D,uDAAuD;AACjK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,8BAA8B,EAAE,4DAAqB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mEAA4B;AACxD;AACA,uCAAuC,UAAU,uBAAuB,0BAA0B;AAClG;AACA;AACA;AACA,uCAAuC,UAAU;AACjD;AACA,gBAAgB,0BAA0B;AAC1C,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4CAA4C;AAC/E;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;AC7mB+E;AAC0C;AACvC;AACd;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yEAAmB;AACjD;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAiB;AACvC;AACA;AACA;AACA,2BAA2B,8CAAI;AAC/B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAiB;AACvC;AACA,4CAA4C,4BAA4B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,oBAAoB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sEAAgB;AAC7C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,oBAAoB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,WAAW;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,uDAAuD;AACnI;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,qCAAqC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8EAAuB;AAC5D;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2DAAoB;AAChE,gCAAgC,kEAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qEAAqE,MAAM;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yEAAyE,uDAAuD;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAiB;AACvC;AACA,6BAA6B,8CAAI;AACjC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB,uDAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qCAAqC;AACzD;AACA;AACA,uCAAuC,kCAAkC,2DAAgB,oCAAoC;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B,EAAE,sEAA4B;AACvF;AACA;AACA,yCAAyC,8CAAI;AAC7C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,kCAAkC,uDAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oCAAoC,EAAE,sEAA4B;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,8CAAI;AACjD;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,sCAAsC,uDAAiB;AACvD;AACA;AACA;AACA;AACA,6FAA6F,KAAK;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAyB;AAC7C;AACA,2CAA2C,4BAA4B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,mBAAmB;AAC9E;AACA;AACA;AACA;AACA;AACA,0CAA0C,2DAAoB;AAC9D,2BAA2B,2DAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,YAAY;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,oBAAoB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0C;;;;;;;;;;;;;;;AC5dA;AACA;AACA;AACA;AACA;AACA;AAC2E;AAC3E;AACA;AACA;AACA;AACA;AACA,6DAA6D,6BAA6B;AAC1F;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,+BAA+B;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,2DAAoB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA,sDAAsD,8BAA8B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAQ,CAAC,gDAAS,yBAAyB,aAAa;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,+CAAQ,CAAC,gDAAS,+EAA+E,8BAA8B;AAC1K;AACA;AACA;AACA;AACA;AACA,6CAA6C,+CAAQ;AACrD,oCAAoC;AACpC;AACA;AACA;AACA;AACA,uCAAuC,+CAAQ,CAAC,gDAAS,0DAA0D,uDAAuD;AAC1K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B,YAAY,+CAA+C,OAAO;AAC7F;AACA;AACA;AACA;AACA,mCAAmC,YAAY,8DAA8D,OAAO;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B,YAAY,+CAA+C,OAAO;AAC7F;AACA;AACA;AACA;AACA,mCAAmC,YAAY,0EAA0E,OAAO;AAChI;AACA;AACA;AACA;AACA,mCAAmC,YAAY,sEAAsE,OAAO;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,sC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;;;;;;;;;;;;;;ACnLA;AACA;AACA;AACA;AAC+B;AACO;AACtC;AACO;AACP,kDAAkD;AAClD;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,+CAAa,GAAG,GAAG;AAClC;AACA;AACA;AACA,eAAe,+CAAa;AAC5B;AACA,eAAe,0CAAW;AAC1B;AACA;AACA;AACO;AACP;AACA;AACA,uBAAuB,kDAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,6BAA6B,uDAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;;;AChNA;AACA;AACA;AACA,oCAAoC;AACpC;AACsC;AACmD;AACpC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACO;AACP,QAAQ,0DAAU;AAClB;AACA,eAAe,qDAAmB;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW,mEAAe;AAC1B;AACA;AACA,KAAK;AACL;AACO;AACP,kBAAkB,8DAAc;AAChC;AACA;AACA;AACA;AACA,kBAAkB,+DAAe;AACjC;AACA;AACA;AACA;AACA;AACO;AACP,mBAAmB,yDAAS;AAC5B;AACA;AACA;AACA;AACA;AACA,kD;;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,uCAAuC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3C4B;AAC5B;AACA;AACA;AACO,sBAAsB,uCACrB;AACR;AACA;AACA;AACA,kBAAkB,gDAAc;AAChC;AACA;AACA,SAAS;AACT,eAAe,yCAAO;AACtB;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC,IAAI,mEAAmE;AACxE;AACA;AACA;AACO,6CAA6C,+CAAa;AACjE,cAAc,0CAAQ;AACtB,2BAA2B,yCAAO;AAClC,cAAc,0CAAQ;AACtB,sBAAsB,yCAAO,CAAC,0CAAQ;AACtC,8BAA8B,yCAAO,CAAC,0CAAQ;AAC9C,2CAA2C,yCAAO,CAAC,0CAAQ;AAC3D,mBAAmB,0CAAQ;AAC3B,4BAA4B,0CAAQ;AACpC,yBAAyB,0CAAQ;AACjC,sBAAsB,0CAAQ;AAC9B,gDAAgD,2CAAS;AACzD,2CAA2C,yCAAO,CAAC,0CAAQ;AAC3D,uCAAuC,yCAAO,CAAC,0CAAQ;AACvD,uCAAuC,2CAAS;AAChD,CAAC;AACD;AACA;AACA;AACO,4BAA4B,+CAAa;AAChD,YAAY,0CAAQ;AACpB;AACA;AACA;AACA,sBAAsB,yCAAO,CAAC,0CAAQ;AACtC,8BAA8B,yCAAO,CAAC,0CAAQ;AAC9C,8BAA8B,yCAAO,CAAC,0CAAQ;AAC9C,2BAA2B,yCAAO,CAAC,0CAAQ;AAC3C,2CAA2C,yCAAO,CAAC,0CAAQ;AAC3D,sDAAsD,yCAAO,CAAC,0CAAQ;AACtE;AACA;AACA,gDAAgD,yCAAO,CAAC,0CAAQ;AAChE,2DAA2D,yCAAO,CAAC,0CAAQ;AAC3E,4BAA4B,0CAAQ;AACpC,mDAAmD,yCAAO,CAAC,0CAAQ;AACnE,8DAA8D,yCAAO,CAAC,0CAAQ;AAC9E,sCAAsC,yCAAO,CAAC,0CAAQ;AACtD,2CAA2C,2CAAS;AACpD,CAAC;AACD;AACA;AACA;AACA;AACO,qCAAqC,+CAAa;AACzD,YAAY,0CAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,sBAAsB,yCAAO,CAAC,0CAAQ;AACtC,8BAA8B,yCAAO,CAAC,0CAAQ;AAC9C,8BAA8B,yCAAO,CAAC,0CAAQ;AAC9C,2BAA2B,yCAAO,CAAC,0CAAQ;AAC3C,0BAA0B,yCAAO,CAAC,0CAAQ;AAC1C,6BAA6B,yCAAO,CAAC,0CAAQ;AAC7C,2CAA2C,yCAAO,CAAC,0CAAQ;AAC3D,8CAA8C,yCAAO,CAAC,0CAAQ;AAC9D,8CAA8C,yCAAO,CAAC,0CAAQ;AAC9D,2CAA2C,yCAAO,CAAC,0CAAQ;AAC3D,8CAA8C,yCAAO,CAAC,0CAAQ;AAC9D,8CAA8C,yCAAO,CAAC,0CAAQ;AAC9D,iDAAiD,yCAAO,CAAC,0CAAQ;AACjE,oDAAoD,yCAAO,CAAC,0CAAQ;AACpE,oDAAoD,yCAAO,CAAC,0CAAQ;AACpE,2CAA2C,yCAAO,CAAC,0CAAQ;AAC3D,sDAAsD,yCAAO,CAAC,0CAAQ;AACtE,8BAA8B,yCAAO,CAAC,0CAAQ;AAC9C,2BAA2B,yCAAO,CAAC,0CAAQ;AAC3C,sBAAsB,yCAAO,CAAC,0CAAQ;AACtC,2BAA2B,0CAAQ;AACnC,8BAA8B,yCAAO,CAAC,0CAAQ;AAC9C,0BAA0B,yCAAO,CAAC,0CAAQ;AAC1C,gCAAgC,2CAAS;AACzC,iCAAiC,2CAAS;AAC1C,qCAAqC,2CAAS;AAC9C,sCAAsC,2CAAS;AAC/C;AACA;AACA,2CAA2C,2CAAS;AACpD,CAAC;AACD;AACA;AACA;AACA;AACA;AACO,8CAA8C,0CAAQ;AAC7D;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACO,0BAA0B,0CACtB;AACX,kBAAkB,0CAAQ;AAC1B,cAAc,0CAAQ;AACtB,gBAAgB,0CAAQ;AACxB,gBAAgB,iDAAe;AAC/B,WAAW,0CAAQ;AACnB,mBAAmB,0CAAQ;AAC3B,CAAC;AACD;AACA;AACA;AACA;AACO,iCAAiC,0CAAQ;AAChD,WAAW,0CAAQ;AACnB,uBAAuB,0CAAQ;AAC/B,eAAe,0CAAQ;AACvB,CAAC;AACD;AACA;AACA;AACO,0DAA0D,2CAAS;AAC1E;AACA;AACA;AACO,kCAAkC,0CAC9B;AACX,mBAAmB,yCAAO;AAC1B,gCAAgC,0CAAQ;AACxC,iBAAiB,yCAAO,CAAC,0CAAQ;AACjC,oBAAoB,yCAAO,CAAC,0CAAQ;AACpC,iBAAiB,0CAAQ;AACzB;AACA;AACA,WAAW,0CAAQ;AACnB,cAAc,yCAAO,CAAC,0CAAQ;AAC9B;AACA,gBAAgB,0CAAQ;AACxB;AACA,UAAU,uCAAK;AACf,iBAAiB,0CAAQ;AACzB,sBAAsB,0CAAQ;AAC9B,wBAAwB,0CAAQ;AAChC,CAAC;AACD;AACA;AACA;AACA;AACO,qCAAqC,0CACjC;AACX,eAAe,0CAAQ;AACvB,mBAAmB,0CAAQ;AAC3B,yBAAyB,0CAAQ;AACjC,8BAA8B,0CAAQ;AACtC,CAAC;AACD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO,2CAA2C,0CACvC;AACX,WAAW,0CAAQ;AACnB,uBAAuB,0CAAQ;AAC/B,CAAC;AACD;AACA;AACA;AACA;AACO,0CAA0C,0CACtC;AACX,WAAW,0CAAQ;AACnB,qBAAqB,0CAAQ;AAC7B,CAAC;AACD;AACA,gC;;;;;;;;;;;;;;;;;;;;ACrMoD;AACub;AAC1a;AACuB;AACxF;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kEAA2B;AAC/D;AACA,SAAS;AACT,oCAAoC,iEAA0B;AAC9D;AACA,SAAS;AACT,+BAA+B,wDAAiB;AAChD;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,mCAAmC,2DAAoB;AACvD;AACA;AACA,8BAA8B,+CAAQ,CAAC,gDAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mCAAmC,kEAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,+CAAQ;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,aAAa,8BAA8B,UAAU;AACpH;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,mCAAmC;AACpH;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAQ,CAAC,gDAAS,mCAAmC,OAAO;AAC9F;AACA;AACA,yBAAyB,6EAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4DAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mCAAmC,6DAAsB;AACzD;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+CAAQ,CAAC,gDAAS,yCAAyC,uDAAuD;AAChJ;AACA,aAAa;AACb,mCAAmC,8DAAuB;AAC1D;AACA;AACA;AACA;AACA,kCAAkC,+CAAQ,CAAC,gDAAS,mCAAmC,sBAAsB;AAC7G;AACA;AACA,wBAAwB,6EAAU;AAClC,kCAAkC,+CAAQ,CAAC,gDAAS,0DAA0D,YAAY;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAQ,CAAC,gDAAS,sDAAsD,sBAAsB;AAChI;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,yCAAyC,+CAAQ;AACjD;AACA;AACA,8BAA8B,+CAAQ,CAAC,gDAAS,2CAA2C,uDAAuD;AAClJ;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+CAAQ,WAAW,gDAAS;AAC9C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kEAAuB,aAAa,iEAAsB;AAC1E;AACA;AACA,qBAAqB,2DAAgB;AACrC;AACA;AACA,qBAAqB,gEAAqB;AAC1C;AACA;AACA;AACA,iEAAiE,wBAAwB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAQ,WAAW,gDAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,MAAM;AACrG;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,4DAAqB;AAC3E;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4GAA4G,MAAM;AACnI;AACA;AACA;AACA;AACA,iGAAiG,MAAM;AACvG;AACA;AACA;AACA;AACA;AACA,mCAAmC,uEAA4B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,wDAAwD;AACxD;AACA;AACA,aAAa;AACb;AACA;AACA,yCAAyC;AACzC;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,gDAAS;AACzF;AACA,yDAAyD,qBAAqB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT,gFAAgF,MAAM;AACtF;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA;AACA,8FAA8F,6BAA6B;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kEAAuB;AACvC;AACA;AACA;AACA,kCAAkC,+CAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,yBAAyB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAuB;AACnC;AACA;AACA;AACA,0BAA0B,+CAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,4CAA4C,+CAAQ,eAAe,+CAAQ,CAAC,gDAAS;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,6DAAsB;AACnF;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,0BAA0B,+CAAQ,CAAC,gDAAS;AAC5C;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D,wBAAwB;AACxB;AACA,oBAAoB,6EAAU;AAC9B;AACA;AACA,kEAAkE,QAAQ;AAC1E,gCAAgC;AAChC;AACA;AACA;AACA;AACA,uCAAuC,+CAAQ,CAAC,gDAAS,wBAAwB,QAAQ;AACzF;AACA;AACA;AACA;AACA;AACA,uCAAuC,+CAAQ,CAAC,gDAAS,wBAAwB,QAAQ;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,QAAQ;AACtE,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+CAAQ,eAAe,+CAAQ,CAAC,gDAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0EAA0E;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D,yBAAyB,4DAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI,sDAAsD;AAC3E,4FAA4F,MAAM;AAClG;AACA,gDAAgD,+CAAQ,gBAAgB,+CAAQ,CAAC,gDAAS;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gEAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gDAAgD,+CAAQ,WAAW,gDAAS,wCAAwC,SAAS;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG,UAAU;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,uDAAuD,sDAAsD;AAC7G;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6BAA6B,EAAE,0DAAmB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8BAA8B,EAAE,4DAAqB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gCAAgC,EAAE,6DAAsB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,yBAAyB,4DAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E,iCAAiC,4DAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE,yBAAyB,4DAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mFAAgB;AACvC;AACA;AACA,2BAA2B,kFAAe;AAC1C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mFAAgB;AACvC;AACA,2BAA2B,kFAAe;AAC1C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,2DAAgB;AAClE;AACA;AACA;AACA;AACA,qCAAqC,+CAAQ,CAAC,gDAAS;AACvD;AACA;AACA;AACA;AACA,gFAAgF,WAAW,cAAc,QAAQ;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAQ,CAAC,gDAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAQ,CAAC,gDAAS;AAC7C,aAAa,IAAI,YAAY;AAC7B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,8BAA8B,+CAAQ,CAAC,gDAAS;AAChD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,yCAAyC,mEAA4B;AACrE;AACA;AACA,qBAAqB;AACrB;AACA,wBAAwB,6EAAU;AAClC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,8BAA8B,+CAAQ,CAAC,gDAAS,yBAAyB,OAAO;AAChF;AACA;AACA,oBAAoB,6EAAU;AAC9B,8BAA8B,+CAAQ,CAAC,gDAAS,uCAAuC,OAAO,0BAA0B,YAAY,QAAQ,OAAO;AACnJ;AACA;AACA;AACA;AACA;AACA,yCAAyC,mEAA4B;AACrE;AACA;AACA,qBAAqB;AACrB;AACA,wBAAwB,6EAAU;AAClC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;AC7jCA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2EAA2E;AAClH;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtC4B;AACrB;AACA;AACA;AACA;AACP;AACO;AACP;AACA;AACA;AACA;AACA;AACA,2BAA2B,0CAAQ;AACnC;AACA;AACA;AACO,4BAA4B,yCAAO,EAAE,0CAAQ,IAAI,0CAAQ;AAChE;AACA;AACA;AACO,qBAAqB,0CAAQ;AACpC;AACA;AACA;AACO,iCAAiC,+CAAa;AACrD;AACA;AACA;AACA;AACA,SAAS,yCAAO,EAAE,0CAAQ,IAAI,2CAAM;AACpC;AACA;AACA;AACA,kBAAkB,0CAAQ;AAC1B,CAAC;AACM,2BAA2B,0CAAQ;AAC1C,SAAS,0CAAQ;AACjB,CAAC;AACD;AACA;AACA;AACA;AACO,kCAAkC,0CAAQ;AACjD,YAAY,0CAAQ;AACpB,CAAC;AACD,0BAA0B,+CAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,gCAAgC,0CAAQ;AACxC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACO;AACA,sBAAsB,0CAAQ;AACrC,YAAY,0CAAQ;AACpB;AACA,CAAC;AACD,kCAAkC,0CAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,2BAA2B,0CAAQ;AAC1C,YAAY,0CAAQ;AACpB;AACA,CAAC;AACM,qBAAqB,+CAAa;AACzC;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACO,wBAAwB,yCAAO,EAAE,0CAAQ,IAAI,0CAAQ;AAC5D;AACA;AACA;AACO,6BAA6B,0CACzB;AACX,aAAa,2CAAS;AACtB;AACA;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACO,kCAAkC,0CAC9B;AACX,aAAa,2CAAS;AACtB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACO,oCAAoC,0CAChC;AACX,aAAa,2CAAS;AACtB;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,+BAA+B;AACnD;AACA,qBAAqB,uBAAuB,eAAe,6BAA6B,KAAK,4BAA4B,iEAAiE,4BAA4B;AACtN;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACO,mCAAmC,0CAC/B;AACX,aAAa,2CAAS;AACtB;AACA,WAAW,0CAAQ;AACnB;AACA;AACA;AACA,cAAc,0CAAQ;AACtB;AACA;AACA;AACA,iBAAiB,0CAAQ;AACzB;AACA;AACA;AACA,cAAc,2CAAS;AACvB,KAAK;AACL,CAAC;AACD;AACA;AACA,oBAAoB,kCAAkC;AACtD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,8BAA8B;AAClD;AACO;AACA,6BAA6B,yCAAO;AAC3C;AACA;AACA;AACA;AACA;AACO,8BAA8B,yCAAO;AAC5C;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0CAAQ;AACpB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACD;AACA;AACA;AACA;AACO,mBAAmB,0CAAQ;AAClC;AACA;AACA;AACA,SAAS,0CAAQ;AACjB;AACA;AACA;AACA,cAAc,0CAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yCAAO,CAAC,0CAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2CAAM;AACjB,CAAC;AACD;AACA;AACA;AACA;AACO,oBAAoB,0CAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yCAAO;AAClB,CAAC;AACD;AACA;AACA;AACO,2BAA2B,0CAAQ;AAC1C;AACA,UAAU,0CAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAAQ;AACnB,CAAC;AACD;AACA;AACA;AACA;AACO;AACP;AACA;AACA,aAAa,0CAAQ;AACrB;AACA;AACA;AACA,gBAAgB,0CAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0CAAQ;AACzB,CAAC;AACD,wCAAwC,gDAAc,CAAC,0CAAQ;AAC/D,mBAAmB,2CAAS;AAC5B,CAAC,GAAG,0CAAQ,CAAC,0CAAQ,IAAI,2CAAS;AAClC,oCAAoC,8CAAY;AAChD;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,CAAC,EAAE,gDAAc,CAAC,0CAAQ;AAC1B;AACA;AACA,CAAC,GAAG,0CAAQ,CAAC,0CAAQ,IAAI,2CAAS;AAClC;AACA;AACA;AACO,oCAAoC,+CAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+CACM;AACpB;AACA;AACA;AACA,kBAAkB,+CACM;AACxB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qBAAqB,+CACG;AACxB;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACO,oCAAoC,+CAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+CACM;AACpB;AACA;AACA;AACA,eAAe,+CACS;AACxB;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACO,iCAAiC,0CAAQ;AAChD;AACA;AACA;AACA,kBAAkB,0CAAQ,CAAC,0CAAQ;AACnC;AACA;AACA;AACA,cAAc,0CACC;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CACI;AACf;AACA;AACA;AACA,qBAAqB,2CAAS;AAC9B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA,qBAAqB,0CAAQ;AAC7B;AACA;AACA,CAAC;AACD;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACM;AACP;AACA;AACA;AACO,iCAAiC,0CAAQ;AAChD;AACA;AACA;AACA,kBAAkB,0CAAQ,CAAC,0CAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0CACE;AACf;AACA;AACA;AACA,qBAAqB,2CAAS;AAC9B,KAAK;AACL;AACA;AACA;AACA;AACA,eAAe,0CACA;AACf;AACA;AACA;AACA,mBAAmB,2CAAS;AAC5B;AACA;AACA;AACA,qBAAqB,2CAAS;AAC9B,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,0CACI;AACf;AACA;AACA;AACA,qBAAqB,2CAAS;AAC9B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,qBAAqB,0CAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0CAAQ;AAC1B,CAAC;AACD;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACD;AACO,uBAAuB,0CAAQ;AACtC;AACA;AACA;AACA,cAAc,0CAAQ;AACtB;AACA;AACA;AACA,WAAW,4CAAU,CAAC,0CAAQ;AAC9B;AACA;AACA;AACA,aAAa,4CAAU,CAAC,0CAAQ;AAChC,CAAC;AACM,yCAAyC,0CAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACO;AACP;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACO,yBAAyB,2CAAM;AACtC;AACA;AACA;AACA;AACO,mBAAmB,0CAAQ;AAClC,YAAY,0CAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,SAAS,yCAAO,EAAE,0CAAQ,IAAI,2CAAM;AACpC;AACA;AACA;AACA,eAAe,0CAAQ;AACvB;AACA;AACA;AACA,mBAAmB,0CAAQ;AAC3B,kBAAkB,4CAAU,CAAC,0CAAQ;AACrC;AACA;AACA;AACA,mBAAmB,4CAAU,CAAC,0CAAQ;AACtC,CAAC;AACD;AACA;AACA;AACO;AACP;AACA,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACD;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,gBAAgB,0CAAQ;AACxB,KAAK;AACL,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,gBAAgB,0CAAQ;AACxB,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB,CAAC;AACD;AACA;AACA;AACO;AACP,WAAW,yCAAO;AAClB,CAAC;AACD;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,gBAAgB,0CAAQ;AACxB,KAAK;AACL,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO,+BAA+B,0CAAQ;AAC9C;AACA;AACA;AACA,SAAS,0CAAQ;AACjB;AACA;AACA;AACA,cAAc,4CAAU,CAAC,0CAAQ;AACjC;AACA;AACA;AACA;AACA,WAAW,0CAAQ,CAAC,0CAAQ,IAAI,2CAAS;AACzC,CAAC;AACM;AACP;AACA;AACA;AACA,UAAU,0CAAQ;AAClB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,qBAAqB,0CAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,IAAI,kCAAkC;AAChC;AACP;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACO,mBAAmB,2CAAM;AAChC;AACA;AACA;AACO,0BAA0B,0CAAQ;AACzC;AACA;AACA;AACA,cAAc,yCAAO;AACrB;AACA;AACA;AACA,cAAc,0CAAQ;AACtB;AACA;AACA;AACA,kBAAkB,gDAAc,GAAG,cAAc;AACjD,CAAC;AACD;AACA;AACA;AACO,uBAAuB,0CAAQ;AACtC;AACA;AACA;AACA;AACA;AACA,SAAS,0CAAQ;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB,4CAAU,CAAC,0CAAQ;AACpC;AACA;AACA;AACA,cAAc,4CAAU,CAAC,0CAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4CAAU,CAAC,+CAAa,GAAG;AACtC,CAAC;AACD;AACA;AACA;AACO,+BAA+B,0CAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA,iBAAiB,0CAAQ;AACzB;AACA;AACA;AACA;AACA;AACA,iBAAiB,4CAAU,CAAC,0CAAQ;AACpC;AACA;AACA;AACA,cAAc,4CAAU,CAAC,0CAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4CAAU,CAAC,+CAAa,GAAG;AACtC,CAAC;AACD;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB,CAAC;AACD;AACA;AACA;AACO;AACP,eAAe,yCAAO;AACtB,CAAC;AACD;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB,CAAC;AACD;AACA;AACA;AACO;AACP,uBAAuB,yCAAO;AAC9B,CAAC;AACM;AACP;AACA,sEAAsE;AACtE;AACA;AACA;AACA,SAAS,0CAAQ;AACjB,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACD;AACA;AACA;AACO;AACP,cAAc,yCAAO,CAAC,yCAAO;AAC7B,CAAC;AACD;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACM;AACP;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACM;AACP;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,SAAS,0CAAQ;AACjB,CAAC;AACD;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACD;AACA;AACA;AACA;AACO,6BAA6B,0CAAQ;AAC5C;AACA;AACA;AACA,UAAU,0CAAQ;AAClB;AACA;AACA;AACA,iBAAiB,4CAAU,CAAC,0CAAQ;AACpC;AACA;AACA;AACA,cAAc,4CAAU,CAAC,2CAAS;AAClC,CAAC;AACD;AACA;AACA;AACO,qBAAqB,0CAAQ;AACpC;AACA;AACA;AACA;AACA;AACA,iBAAiB,4CAAU,CAAC,0CAAQ;AACpC;AACA;AACA;AACA,eAAe,4CAAU,CAAC,yCAAO;AACjC;AACA;AACA;AACA;AACA,WAAW,4CAAU,CAAC,+CAAa,GAAG;AACtC,CAAC;AACD;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB,CAAC;AACD;AACA;AACA;AACO;AACP,aAAa,yCAAO;AACpB,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,UAAU,0CAAQ;AAClB;AACA;AACA;AACA,eAAe,0CAAQ,CAAC,0CAAQ,IAAI,0CAAQ;AAC5C,CAAC;AACD;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACD;AACA;AACA;AACO,0BAA0B,0CAAQ;AACzC,UAAU,2CAAS;AACnB;AACA;AACA;AACA,UAAU,0CAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAAQ,CAAC,0CAAQ,IAAI,2CAAS;AACzC,CAAC;AACD;AACA;AACA;AACO,2BAA2B,0CAAQ;AAC1C,UAAU,2CAAS;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0CAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAAQ,CAAC,0CAAQ,IAAI,2CAAS;AACzC,CAAC;AACD;AACA;AACA;AACO,2BAA2B,0CAAQ;AAC1C,UAAU,2CAAS;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0CAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAAQ,CAAC,0CAAQ,IAAI,2CAAS;AACzC,CAAC;AACD;AACA;AACA;AACA;AACO,6BAA6B,0CAAQ;AAC5C,UAAU,2CAAS;AACnB;AACA;AACA;AACA;AACA,UAAU,0CAAQ;AAClB;AACA;AACA;AACA;AACA,QAAQ,0CAAQ;AAChB;AACA;AACA;AACA;AACA,WAAW,0CAAQ,CAAC,0CAAQ,IAAI,2CAAS;AACzC;AACA;AACA;AACA;AACA,WAAW,0CAAQ,CAAC,0CAAQ,IAAI,2CAAS;AACzC,CAAC;AACD;AACA;AACA;AACO,+BAA+B,0CAAQ;AAC9C,UAAU,2CAAS;AACnB,cAAc,yCAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAAQ,CAAC,0CAAQ,IAAI,2CAAS;AACzC,CAAC;AACD;AACA;AACA;AACA;AACA;AACO;AACP,UAAU,2CAAS;AACnB,CAAC;AACD;AACA;AACA;AACO,2BAA2B,yCAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,0CAAQ;AAC3C;AACA;AACA,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,iBAAiB,0CAAQ;AACzB,cAAc,yCAAO;AACrB,CAAC;AACD;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,0CAAQ;AAC7C;AACA;AACA;AACA,WAAW,0CAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,kBAAkB,2CAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2CAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2CAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2CAAS;AAC5B,CAAC;AACD;AACA;AACA;AACO,4BAA4B,0CAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2CAAM;AACvB,CAAC;AACD;AACA;AACA;AACO,mBAAmB,0CAAQ;AAClC;AACA;AACA;AACA;AACA;AACA,iBAAiB,0CAAQ;AACzB;AACA;AACA;AACA;AACA,iBAAiB,0CACF;AACf,cAAc,2CAAS;AACvB,oBAAoB,0CAAQ,CAAC,0CAAQ;AACrC,kBAAkB,yCAAO,CAAC,0CAAQ;AAClC,KAAK;AACL,kBAAkB,2CAAS;AAC3B;AACA;AACA;AACA;AACA;AACA,kBAAkB,0CACH;AACf,cAAc,2CAAS;AACvB,oBAAoB,0CAAQ,CAAC,0CAAQ;AACrC,kBAAkB,yCAAO,CAAC,0CAAQ;AAClC,KAAK;AACL,kBAAkB,2CAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAAQ,CAAC,0CAAQ,IAAI,2CAAS;AACzC,CAAC;AACD;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB,CAAC;AACD;AACA;AACA;AACO;AACP,WAAW,yCAAO;AAClB,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yCAAO;AACpB;AACA;AACA;AACA;AACA;AACA,uBAAuB,0CAAQ,CAAC,0CAAQ,IAAI,2CAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2CAAS;AACtB,CAAC;AACD;AACA;AACA;AACO;AACP,gBAAgB,2CAAS;AACzB,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,UAAU,0CAAQ;AAClB;AACA;AACA;AACA,eAAe,0CAAQ,CAAC,0CAAQ,IAAI,2CAAS;AAC7C,CAAC;AACD;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACD;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACD;AACA;AACA;AACA;AACO,qCAAqC,0CAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2CAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0CAAQ;AACxB,CAAC;AACD;AACA;AACA;AACA;AACO,2BAA2B,2CAAM;AACxC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0CAAQ;AACpB;AACA;AACA;AACA,UAAU,2CAAS;AACnB,CAAC;AACD;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACD;AACA;AACA;AACA;AACO,wBAAwB,0CAAQ;AACvC;AACA;AACA;AACA,UAAU,0CAAQ;AAClB,CAAC;AACD;AACA;AACA;AACO,+BAA+B,0CAAQ;AAC9C;AACA;AACA;AACA,WAAW,yCAAO;AAClB;AACA;AACA;AACA,kBAAkB,0CAAQ;AAC1B;AACA;AACA;AACA,mBAAmB,0CAAQ;AAC3B;AACA;AACA;AACA,0BAA0B,0CAAQ;AAClC,CAAC;AACD;AACA;AACA;AACO,yBAAyB,0CAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2CAAM;AAChB,CAAC;AACD;AACA;AACA;AACA;AACO,gCAAgC,0CAAQ;AAC/C,UAAU,2CAAS;AACnB,eAAe,0CAAQ;AACvB,aAAa,yCAAO;AACpB,uBAAuB,0CAAQ,GAAG;AAClC,aAAa,2CAAS;AACtB;AACA;AACA;AACA;AACA,WAAW,0CAAQ,CAAC,0CAAQ,IAAI,2CAAS;AACzC,CAAC;AACD;AACA;AACA;AACA;AACO,8BAA8B,sDAAoB;AACzD;AACA;AACA;AACA;AACO,0CAA0C,sDAAoB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,0CAAQ;AAC7C;AACA,aAAa,yCAAO,qCAAqC,yCAAO;AAChE;AACA;AACA;AACA;AACA,WAAW,0CAAQ,CAAC,0CAAQ,IAAI,2CAAS;AACzC,CAAC;AACD;AACA;AACA;AACO;AACP,cAAc,yCAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0CAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2CAAM;AAC1B,iBAAiB,0CAAQ;AACzB;AACA;AACA;AACA;AACA;AACA,eAAe,0CAAQ;AACvB,mBAAmB,yCAAO,CAAC,0CAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yCAAO;AAClB;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA,CAAC;AACD;AACA;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;AACA;AACA;AACO,kCAAkC,yCAAO;AAChD;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB,0CAAQ;AAC3B,CAAC;AACD;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8CAAY,0CAA0C,0CAAQ,CAAC,0CAAQ,IAAI,yCAAO,EAAE,0CAAQ,IAAI,0CAAQ,IAAI,2CAAS,IAAI,yCAAO,CAAC,0CAAQ;AACtJ,CAAC;AACD;AACA;AACA;AACA;AACO,wCAAwC,0CAAQ;AACvD,UAAU,2CAAS;AACnB;AACA;AACA;AACA,SAAS,0CAAQ;AACjB,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACO,8BAA8B,0CAAQ;AAC7C,UAAU,2CAAS;AACnB;AACA;AACA;AACA,UAAU,0CAAQ;AAClB,CAAC;AACD;AACA;AACA;AACO;AACP,SAAS,yCAAO;AAChB;AACA;AACA;AACA,cAAc,0CAAQ;AACtB;AACA;AACA;AACA,cAAc,0CAAQ;AACtB;AACA;AACA;AACA,eAAe,0CAAQ;AACvB,KAAK;AACL,aAAa,0CACE;AACf;AACA;AACA;AACA,mBAAmB,0CAAQ,CAAC,0CAAQ,IAAI,0CAAQ;AAChD,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACM;AACP;AACA,uEAAuE,wBAAwB;AAC/F;AACA;AACA;AACO;AACP;AACA,iFAAiF,wBAAwB;AACzG;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,+CAAa;AAC7B;AACA;AACA;AACA,gBAAgB,yCAAO,CAAC,0CAAQ;AAChC;AACA;AACA;AACA,eAAe,4CAAU,CAAC,0CAAQ;AAClC;AACA;AACA;AACA,iBAAiB,4CAAU,CAAC,2CAAS;AACrC,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACO,mBAAmB,0CAAQ;AAClC;AACA;AACA;AACA,SAAS,0CAAQ;AACjB;AACA;AACA;AACA,UAAU,0CAAQ;AAClB;AACA;AACA;AACA;AACA,WAAW,0CAAQ,CAAC,0CAAQ,IAAI,2CAAS;AACzC,CAAC;AACD;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACD;AACA;AACA;AACO;AACP,WAAW,yCAAO;AAClB,CAAC;AACD;AACA;AACA;AACO;AACP,YAAY,2CAAS;AACrB;AACA,CAAC;AACD;AACO,4BAA4B,yCAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,yCAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,yCAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,yCAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,yCAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,yCAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B,KAAK,IAAI,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,0DAA0D,oCAAoC;AAC9F;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;ACngEA;AACA;AACA;AACsB;AACgB;AACtC;AACA,oBAAoB,gCAAG;AACvB;AACA;AACA;AACA;AACA,KAAK;AACL,uBAAuB,wCAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yB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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,cAAc,EAAE,+BAA+B,IAAI,GAAG,EAAE,eAAe,IAAI,GAAG,EAAE,aAAa,IAAI,gBAAgB,IAAI,GAAG,EAAE,gBAAgB,IAAI,GAAG,IAAI,SAAS,IAAI,gBAAgB,IAAI,GAAG,EAAE,gBAAgB,IAAI,GAAG,IAAI,SAAS,IAAI,gBAAgB,IAAI,GAAG,EAAE,gBAAgB,IAAI,GAAG,IAAI,SAAS,IAAI,aAAa,IAAI,iBAAiB,IAAI,GAAG,IAAI,SAAS,IAAI,iBAAiB,IAAI,UAAU,IAAI,uCAAuC,EAAE,gDAAgD,IAAI,GAAG,IAAI,SAAS,IAAI,aAAa,IAAI,gBAAgB,IAAI,GAAG,IAAI,SAAS,IAAI,2CAA2C,8CAA8C,EAAE,yDAAyD,aAAa,EAAE,0CAA0C,eAAe,EAAE,mCAAmC,eAAe,EAAE,gCAAgC,eAAe,EAAE,gCAAgC,eAAe,EAAE,gCAAgC,eAAe,EAAE,mCAAmC,iBAAiB,EAAE,iCAAiC,iBAAiB,EAAE;AACnoC;AACA;AACA;AACA;AACA,gCAAgC,EAAE,mBAAmB,EAAE,iBAAiB,EAAE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+GAA+G,EAAE,EAAE,EAAE;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe,EAAE,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE,EAAE,WAAW;AAClC;AACA;AACA;AACA,4DAA4D,GAAG,EAAE,GAAG;AACpE;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,kFAAkF,IAAI,WAAW,IAAI;AACrG;AACA,mBAAmB;AACnB;AACA;AACA;AACA,4BAA4B,IAAI;AAChC;AACA,qDAAqD,IAAI;AACzD;AACA,wBAAwB;AACxB;AACA;AACA;AACA,kBAAkB;AAClB,gC;;;;;;;;;;AC3Ja;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,UAAU,GAAG,WAAW,GAAG,WAAW,GAAG,eAAe,GAAG,iBAAiB,GAAG,gBAAgB,GAAG,sBAAsB,GAAG,kBAAkB,GAAG,aAAa,GAAG,YAAY,GAAG,kBAAkB,GAAG,iBAAiB,GAAG,mBAAmB,GAAG,WAAW,GAAG,iBAAiB,GAAG,WAAW,GAAG,SAAS;AACvS,eAAe,mBAAO,CAAC,sGAAQ;AAC/B,gBAAgB,mBAAO,CAAC,wGAAS;AACjC,aAAa,mBAAO,CAAC,sGAAQ;AAC7B,qCAAoC,EAAE,qCAAqC,oBAAoB,EAAC;AAChG,uCAAsC,EAAE,qCAAqC,sBAAsB,EAAC;AACpG,6CAA4C,EAAE,qCAAqC,4BAA4B,EAAC;AAChH,uCAAsC,EAAE,qCAAqC,sBAAsB,EAAC;AACpG,+CAA8C,EAAE,qCAAqC,8BAA8B,EAAC;AACpH,6CAA4C,EAAE,qCAAqC,4BAA4B,EAAC;AAChH,8CAA6C,EAAE,qCAAqC,6BAA6B,EAAC;AAClH,wCAAuC,EAAE,qCAAqC,uBAAuB,EAAC;AACtG,cAAc,mBAAO,CAAC,wGAAS;AAC/B,yCAAwC,EAAE,qCAAqC,yBAAyB,EAAC;AACzG,8CAA6C,EAAE,qCAAqC,8BAA8B,EAAC;AACnH,kDAAiD,EAAE,qCAAqC,kCAAkC,EAAC;AAC3H,4CAA2C,EAAE,qCAAqC,4BAA4B,EAAC;AAC/G,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA,wDAAwD,SAAS;AACjE,kBAAkB,SAAS,EAAE,UAAU,EAAE,KAAK;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,kBAAkB,UAAU,IAAI,UAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,IAAI;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,kBAAkB,UAAU,EAAE,QAAQ,IAAI,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,uCAAuC,WAAW;AAClD,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,kBAAkB,WAAW;AAC7B;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA,iBAAiB,qCAAqC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC,sBAAsB,SAAS,EAAE,KAAK,GAAG,OAAO,EAAE,KAAK,GAAG,KAAK,EAAE,KAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc,EAAE,WAAW,EAAE,WAAW,EAAE,cAAc;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO,WAAW,UAAU,GAAG,UAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,sBAAsB;AACtB;AACA,0CAA0C,kBAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,IAAI;AAC/D,gDAAgD,IAAI,GAAG,EAAE;AACzD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,IAAI;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,SAAS,KAAK,WAAW;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ,QAAQ,GAAG,QAAQ,YAAY;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,OAAO;AACvG;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,qFAAqF,QAAQ,EAAE,IAAI,EAAE,OAAO;AAC5G;AACA;AACA,4DAA4D,EAAE;AAC9D;AACA,iC;;;;;;;;;;ACxrBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,sBAAsB,GAAG,aAAa,GAAG,gBAAgB,GAAG,sBAAsB;AACvG,eAAe,mBAAO,CAAC,sGAAQ;AAC/B;AACA;AACA,qCAAqC,MAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qBAAqB,sBAAsB,sBAAsB;AAClE,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB,IAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO,EAAE,WAAW;AACtC;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA,2CAA2C,0BAA0B,GAAG,UAAU;AAClF;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,KAAK;AACvD,oCAAoC,UAAU,EAAE,eAAe;AAC/D,SAAS;AACT;AACA;AACA;AACA;AACA,kDAAkD,KAAK;AACvD;AACA,SAAS;AACT;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,KAAK,EAAE,KAAK,EAAE,MAAM,IAAI,GAAG,EAAE,aAAa;AACtF;AACA;AACA,4CAA4C,KAAK,EAAE,EAAE,EAAE,aAAa;AACpE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,kBAAkB;AAClB,iC;;;;;;;;;;AC9Ia;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,wBAAwB,GAAG,wBAAwB,GAAG,mBAAmB,GAAG,yBAAyB,GAAG,oBAAoB;AACnJ,kBAAkB,mBAAO,CAAC,0GAAW;AACrC,eAAe,mBAAO,CAAC,8FAAQ;AAC/B,gBAAgB,mBAAO,CAAC,gGAAS;AACjC,oBAAoB;AACpB,gBAAgB,SAAS,sCAAsC,QAAQ;AACvE;AACA,yBAAyB;AACzB,gBAAgB,qBAAqB;AACrC,iCAAiC,QAAQ,oBAAoB,YAAY;AACzE,iCAAiC,QAAQ;AACzC;AACA;AACA,YAAY,KAAK;AACjB,YAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA,mBAAmB;AACnB;AACA,YAAY,KAAK;AACjB,YAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,+BAA+B,yBAAyB,wEAAwE,wBAAwB;AACxJ;AACA,wBAAwB;AACxB,wBAAwB,iDAAiD;AACzE;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB,GAAG,EAAE;AACxE,mCAAmC,IAAI,mEAAmE,IAAI;AAC9G,uCAAuC,IAAI,oCAAoC,iBAAiB,GAAG,QAAQ;AAC3G;AACA,2CAA2C,IAAI;AAC/C,2CAA2C,IAAI;AAC/C;AACA,KAAK;AACL;AACA,oBAAoB;AACpB;AACA;AACA,+BAA+B,yBAAyB,0EAA0E,IAAI,yBAAyB,wBAAwB,QAAQ,IAAI;AACnM,iCAAiC,uBAAuB;AACxD;AACA;AACA,YAAY,+BAA+B;AAC3C;AACA,0CAA0C,mBAAmB,GAAG,KAAK;AACrE;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA,mCAAmC;AACnC;AACA;AACA,gDAAgD;AAChD,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW,IAAI,cAAc;AAC1D;AACA,gCAAgC,UAAU,EAAE,wDAAwD;AACpG;AACA;AACA;AACA,2BAA2B,eAAe,iBAAiB,IAAI,0BAA0B;AACzF,uEAAuE,cAAc,GAAG,QAAQ;AAChG;AACA,wCAAwC,QAAQ,EAAE,sDAAsD;AACxG;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD,YAAY,iCAAiC;AAC7C,YAAY,+CAA+C;AAC3D,8HAA8H;AAC9H;AACA;AACA;AACA;AACA,qFAAqF,aAAa,EAAE,WAAW;AAC/G;AACA;AACA;AACA;AACA,kC;;;;;;;;;;AC1Ha;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,0BAA0B,GAAG,kBAAkB,GAAG,qBAAqB,GAAG,iBAAiB;AACnH,kBAAkB,mBAAO,CAAC,0GAAW;AACrC,2BAA2B,mBAAO,CAAC,+HAA6B;AAChE,gBAAgB,mBAAO,CAAC,gGAAS;AACjC,kBAAkB,mBAAO,CAAC,oGAAW;AACrC,eAAe,mBAAO,CAAC,8FAAQ;AAC/B,mBAAmB,mBAAO,CAAC,4GAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF;AACvF,YAAY,aAAa;AACzB,YAAY,gBAAgB;AAC5B,oDAAoD,2BAA2B;AAC/E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC,SAAS,aAAa;AACnF;AACA;AACA;AACA;AACA,6CAA6C,qBAAqB,MAAM,sBAAsB;AAC9F;AACA,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F,gBAAgB,WAAW;AAC3B;AACA,mCAAmC,gCAAgC;AACnE;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sBAAsB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,iCAAiC,gCAAgC;AACjE;AACA;AACA;AACA;AACA,iC;;;;;;;;;;ACjPa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,0GAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf,iC;;;;;;;;;;AC3Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,oGAAW;AACrC;AACA;AACA,gDAAgD,KAAK,UAAU,OAAO;AACtE;AACA;AACA;AACA;AACA,kBAAe;AACf,qC;;;;;;;;;;ACXa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,oBAAoB,GAAG,mBAAmB,GAAG,iBAAiB;AACjI,eAAe,mBAAO,CAAC,8FAAQ;AAC/B,cAAc,mBAAO,CAAC,gEAAiB;AACvC,iBAAiB,mBAAO,CAAC,iHAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,YAAY,wBAAwB;AACpC;AACA,sBAAsB;AACtB;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D,sCAAsC,OAAO;AAC7C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,IAAI;AAC3C;AACA;AACA,qBAAqB;AACrB,mC;;;;;;;;;;AC1Ja;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB,2BAA2B;AAC7C,kBAAkB,2BAA2B;AAC7C,iBAAiB,0B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A;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,YAAY,cAAc;AAC1B;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,yBAAyB;AACzB;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sC;;;;;;;;;;ACjDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,sBAAsB,GAAG,qBAAqB,GAAG,8BAA8B,GAAG,oBAAoB,GAAG,sBAAsB,GAAG,gBAAgB;AAC5K,gBAAgB,mBAAO,CAAC,iGAAU;AAClC,wBAAwB,mBAAO,CAAC,yHAAiB;AACjD,iBAAiB,mBAAO,CAAC,mGAAW;AACpC,kBAAkB,mBAAO,CAAC,2GAAY;AACtC,eAAe,mBAAO,CAAC,+FAAS;AAChC;AACA;AACA;AACA;AACA,CAAC,eAAe,gBAAgB,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B,oEAAoE,KAAK;AACzE;AACA;AACA,mCAAmC,UAAU,+BAA+B,KAAK,OAAO,KAAK;AAC7F,8CAA8C,KAAK;AACnD,yDAAyD,KAAK;AAC9D;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,gDAAgD,UAAU,iBAAiB,UAAU;AACrF,8DAA8D,KAAK;AACnE,gDAAgD,MAAM;AACtD;AACA;AACA;AACA;AACA,gD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qBAAqB,EAAE,wCAAwC,+BAA+B,GAAG,mBAAmB,GAAG;AAC7R;AACA;AACA;AACA,kEAAkE,uBAAuB,GAAG,6BAA6B;AACzH,gEAAgE,uBAAuB,GAAG,2BAA2B;AACrH,wEAAwE,uBAAuB,GAAG,mCAAmC;AACrI,8DAA8D,uBAAuB,GAAG,yBAAyB;AACjH;AACA,wEAAwE,uBAAuB,GAAG,+BAA+B;AACjI,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE,KAAK;AACL;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC,8DAA8D,aAAa;AAC3E,+BAA+B,aAAa,qDAAqD,aAAa;AAC9G,+BAA+B,aAAa,qDAAqD,aAAa;AAC9G;AACA;AACA;AACA,gGAAgG,OAAO;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW,MAAM,uBAAuB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oCAAoC;AAChD;AACA,sEAAsE,cAAc;AACpF;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6CAA6C;AACvE;AACA;AACA,qCAAqC,qBAAqB,cAAc,IAAI;AAC5E;AACA;AACA,iDAAiD,cAAc;AAC/D,kDAAkD,qBAAqB;AACvE,qCAAqC,qBAAqB,iBAAiB,IAAI,IAAI,WAAW,IAAI,SAAS;AAC3G;AACA;AACA;AACA,YAAY,sDAAsD;AAClE;AACA;AACA,mCAAmC,wBAAwB,wFAAwF,gBAAgB,GAAG,wBAAwB;AAC9L;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA,uCAAuC,wBAAwB;AAC/D;AACA;AACA,2BAA2B,8BAA8B;AACzD;AACA,uCAAuC,UAAU;AACjD;AACA,uCAAuC,UAAU;AACjD;AACA;AACA,YAAY,2CAA2C;AACvD,YAAY,QAAQ;AACpB;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wBAAwB,MAAM,eAAe;AACpF;AACA;AACA;AACA,YAAY,qBAAqB,aAAa,IAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,EAAE,4BAA4B,uBAAuB;AAC/F;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,sDAAsD,eAAe,iBAAiB,QAAQ;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS,gBAAgB,+BAA+B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B,sCAAsC,YAAY,oBAAoB,kDAAkD;AACxH;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,mCAAmC;AACnD,qDAAqD,YAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iGAAiG;AAC5I;AACA;AACA;AACA;AACA;AACA,4EAA4E,yBAAyB,GAAG;AACxG,4CAA4C,kBAAkB,GAAG,WAAW;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mCAAmC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,MAAM;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,MAAM;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,KAAK,EAAE,qEAAqE;AACnH,uCAAuC,MAAM,KAAK,KAAK;AACvD;AACA;AACA;AACA;AACA,gCAAgC,aAAa,EAAE,IAAI,8BAA8B,UAAU;AAC3F;AACA;AACA,eAAe;AACf,iC;;;;;;;;;;ACvgBa;AACb,8CAA6C,EAAE,aAAa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zG,2CAA0C,EAAE,qCAAqC,6BAA6B,EAAC;AAC/G,2BAA2B,mBAAO,CAAC,8HAA4B;AAC/D,oBAAoB,mBAAO,CAAC,gHAAqB;AACjD,gBAAgB,mBAAO,CAAC,wGAAiB;AACzC,kBAAkB,mBAAO,CAAC,kGAAW;AACrC,kBAAkB,mBAAO,CAAC,kHAAmB;AAC7C,kBAAkB,mBAAO,CAAC,4GAAmB;AAC7C,mBAAmB,mBAAO,CAAC,gIAA6B;AACxD,eAAe,mBAAO,CAAC,sGAAgB;AACvC,uBAAuB,mBAAO,CAAC,uGAAkB;AACjD,cAAc,mBAAO,CAAC,oGAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAA6C;AAClF,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8BAA8B,IAAI,kBAAkB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,gBAAgB,aAAa;AAC7B,gDAAgD,SAAS,yCAAyC;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,aAAa;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,MAAM;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA,6CAA6C,KAAK,gBAAgB,YAAY;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B,mDAAmD,UAAU,YAAY;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,qCAAqC,KAAK;AAChD;AACA;AACA;AACA;AACA,2BAA2B,QAAQ,EAAE,gBAAgB,EAAE,UAAU;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2CAA2C;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,GAAG;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;AACA;AACA;AACA;AACA,gCAAgC,IAAI,WAAW,IAAI,IAAI,eAAe;AACtE;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,iBAAiB,SAAS,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA,uCAAuC,KAAK;AAC5C;AACA,uCAAuC,KAAK;AAC5C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,4DAA4D,SAAS;AACrE;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA,UAAU,aAAa;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,gC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzmBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA,cAAc,mBAAO,CAAC,gEAAiB;AACvC;AACA,kBAAe;AACf,iC;;;;;;;;;;ACNa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,kBAAe;AACf;AACA,sC;;;;;;;;;;ACvBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY,mBAAO,CAAC,kDAAU;AAC9B;AACA,kBAAe;AACf,+B;;;;;;;;;;ACLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf,4C;;;;;;;;;;ACVa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B;AAC/B,kBAAkB,mBAAO,CAAC,sHAAuB;AACjD,eAAe,mBAAO,CAAC,0GAAoB;AAC3C;AACA,gBAAgB,UAAU,OAAO,mDAAmD,KAAK;AACzF,eAAe,UAAU,OAAO,wBAAwB,SAAS,KAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,iCAAiC;AAC7C;AACA,qDAAqD,KAAK;AAC1D;AACA,wBAAwB,mBAAmB;AAC3C,qCAAqC,KAAK,KAAK,aAAa;AAC5D;AACA;AACA,2DAA2D,KAAK,KAAK,aAAa,IAAI;AACtF;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAqD;AACjF;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B;AAC/B,kBAAe;AACf,2C;;;;;;;;;;AChDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,oGAAS;AAChC,kBAAkB,mBAAO,CAAC,sHAAuB;AACjD,gBAAgB,mBAAO,CAAC,4GAAqB;AAC7C,eAAe,mBAAO,CAAC,0GAAoB;AAC3C;AACA;AACA,eAAe,QAAQ,wBAAwB,sBAAsB,2BAA2B;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAiD;AACjE;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW,MAAM,uBAAuB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,KAAK,MAAM,EAAE;AACrG;AACA;AACA;AACA;AACA;AACA,wGAAwG,+BAA+B,QAAQ,IAAI;AACnJ;AACA;AACA;AACA;AACA,gDAAgD,KAAK,GAAG,IAAI;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAe;AACf,gD;;;;;;;;;;ACzGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,0GAAoB;AAC3C;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iCAAiC;AAC5E;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,kBAAe;AACf,iC;;;;;;;;;;ACtBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,oGAAS;AAChC;AACA;AACA;AACA;AACA;AACA,aAAa,yCAAyC;AACtD;AACA,kBAAe;AACf,iC;;;;;;;;;;ACXa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,sHAAuB;AACjD,eAAe,mBAAO,CAAC,0GAAoB;AAC3C;AACA,gBAAgB,UAAU,YAAY;AACtC,sDAAsD,KAAK;AAC3D,sDAAsD,KAAK,mBAAmB,KAAK;AACnF,eAAe,UAAU,YAAY,4CAA4C,eAAe,KAAK,uBAAuB,eAAe,IAAI,iBAAiB,KAAK;AACrK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC;AACtD;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,KAAK;AAC9D,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,KAAK,KAAK,IAAI;AACzD;AACA,2CAA2C,MAAM,KAAK,KAAK,KAAK,IAAI;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,KAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA,yCAAyC,MAAM;AAC/C;AACA,2CAA2C,OAAO,KAAK,IAAI;AAC3D;AACA;AACA,2CAA2C,OAAO,IAAI,IAAI;AAC1D;AACA;AACA;AACA,+CAA+C,OAAO,KAAK,IAAI;AAC/D;AACA;AACA,KAAK;AACL;AACA,kBAAe;AACf,oC;;;;;;;;;;AC9Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,GAAG,4BAA4B,GAAG,aAAa;AACzE,kBAAkB,mBAAO,CAAC,sHAAuB;AACjD,eAAe,mBAAO,CAAC,0GAAoB;AAC3C,eAAe,mBAAO,CAAC,oGAAS;AAChC,aAAa;AACb,gBAAgB,UAAU,6BAA6B;AACvD;AACA,+CAA+C,cAAc,EAAE,MAAM,gBAAgB,UAAU;AAC/F,KAAK;AACL,eAAe,UAAU,8CAA8C,wBAAwB,YAAY,SAAS;AACpH,uBAAuB,gBAAgB;AACvC,iBAAiB,UAAU;AAC3B,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,uCAAuC,aAAa,MAAM,iDAAiD;AAC3G;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA,2CAA2C,2BAA2B;AACtE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,kBAAe;AACf,wC;;;;;;;;;;ACpFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,sHAAuB;AACjD,eAAe,mBAAO,CAAC,0GAAoB;AAC3C;AACA,gBAAgB,QAAQ,uCAAuC,gBAAgB;AAC/E,eAAe,QAAQ,wBAAwB,kBAAkB,iBAAiB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA,6DAA6D,QAAQ;AACrE;AACA,oCAAoC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Ae;AACf,iC;;;;;;;;;;AC3Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,oGAAS;AAChC,kBAAkB,mBAAO,CAAC,sHAAuB;AACjD,eAAe,mBAAO,CAAC,0GAAoB;AAC3C,eAAe,mBAAO,CAAC,0GAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC;AACtD,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,MAAM,kBAAkB,KAAK;AAC7F;AACA;AACA;AACA;AACA;AACA,2CAA2C,iCAAiC,QAAQ,IAAI;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,uDAAuD,MAAM,GAAG,IAAI;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA,kBAAe;AACf,6C;;;;;;;;;;AC1Ea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,mBAAO,CAAC,gHAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf,uC;;;;;;;;;;ACXa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,mBAAO,CAAC,wHAAwB;AACnD,eAAe,mBAAO,CAAC,oGAAS;AAChC,eAAe,mBAAO,CAAC,0GAAoB;AAC3C,+BAA+B,mBAAO,CAAC,8IAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb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;;;;;;;;;;ACfa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,mBAAmB;AACrC,oBAAoB,mBAAO,CAAC,oHAAyB;AACrD,eAAe,mBAAO,CAAC,oGAAS;AAChC,kBAAkB,mBAAO,CAAC,sHAAuB;AACjD,gBAAgB,mBAAO,CAAC,4GAAqB;AAC7C,kBAAkB,mBAAO,CAAC,sGAAe;AACzC,eAAe,mBAAO,CAAC,0GAAoB;AAC3C;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC,gBAAgB,mDAAmD;AACnE,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,gDAAgD,IAAI,UAAU;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,MAAM;AAClB;AACA,uCAAuC,mBAAmB;AAC1D,8BAA8B,4BAA4B,UAAU,EAAE;AACtE;AACA,mBAAmB;AACnB;AACA,YAAY,UAAU;AACtB,YAAY,kCAAkC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,8CAA8C;AAC7F,iCAAiC;AACjC;AACA;AACA,SAAS;AACT,yCAAyC,GAAG,aAAa,mBAAmB;AAC5E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD,gEAAgE,yBAAyB,aAAa,MAAM,IAAI,wBAAwB,UAAU,KAAK,KAAK;AAC5J,+DAA+D,wBAAwB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,OAAO;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,OAAO;AAC1E;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,kBAAe;AACf,+B;;;;;;;;;;ACzHa;AACb,8CAA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CnF;AACA;AACA,uDAAuD,KAAK;AAC5D;AACA,4BAA4B,MAAM;AAClC;AACA,uCAAuC,GAAG;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,uCAAuC,EAAE,EAAE,GAAG;AAC9C,kDAAkD,KAAK,GAAG,EAAE;AAC5D;AACA;AACA,sDAAsD,MAAM,kCAAkC,MAAM;AACpG;AACA,mDAAmD,QAAQ,GAAG,KAAK;AACnE,sDAAsD,QAAQ,GAAG,KAAK;AACtE;AACA;AACA,iBAAiB;AACjB,8CAA8C,QAAQ,GAAG,KAAK,MAAM,EAAE;AACtE,aAAa;AACb;AACA;AACA;AACA;AACA,oDAAoD,EAAE,EAAE,GAAG,qCAAqC,GAAG,IAAI,IAAI,EAAE,EAAE,GAAG,oCAAoC,IAAI,GAAG,KAAK,GAAG,EAAE,KAAK,KAAK,GAAG,EAAE;AACtL;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA,kBAAe;AACf,uC;;;;;;;;;;AC/Da;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5FO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;;;;;;;;;;;;;;AC7C4C;AAC1C;AACP,qBAAqB,8DAAiB;AACtC;AACA;AACA;AACA;AACA;AACA,iBAAiB,mCAAmC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;;;;ACrBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;ACbO;AACP;AACA,WAAW,sCAAsC;AACjD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACP6B;AACH;AACS;AACE;AACP;AACE;AACC;AACE;AACC;AACC;AACA;AACF;AACD;AACG;AACA;AACH;AACQ;AACL;AACJ;AACO;AACL;AACD;AACI;AACF;AACA;AACE;AACA;AACD;AACC;AACF;AACH;AACG;AACD;AACI;AACJ;AACE;AACH;AACG;AACkB;AACvD,iEAAe,iEAAe,EAAC;;;;;;;;;;;;;;;;;;;ACvCe;AACG;AACM;AACR;AACxC;AACP;AACA;AACA;AACA,+BAA+B,uDAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,+BAA+B,8DAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB,MAAM,oEAAe;AAC1C;AACA;AACA;AACA;AACA,gEAAgE,2BAA2B;AAC3F,uBAAuB,4DAAW;AAClC;AACA,kDAAkD,4DAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7DU;;;;;;;;;;;;;;;;ACA8C;AACjD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oEAAe;AAC7B;AACA;AACA;;;;;;;;;;;;;;;;;;AChB+C;AACiB;AACtB;AACnC;AACP;AACA;AACA;AACA;AACA,qCAAqC,yDAAqB;AAC1D,oBAAoB,sDAAQ;AAC5B;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,4EAAyB;AACjC;AACA;AACA,QAAQ,4EAAyB;AACjC;AACA;AACA,QAAQ,4EAAyB;AACjC,QAAQ,4EAAyB;AACjC;AACA;AACA;;;;;;;;;;;;;;;;ACzBgE;AACzD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4EAAyB;AACjD;AACA;AACA,wBAAwB,4EAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4EAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA,wBAAwB,4EAAyB;AACjD;AACA;AACA,wBAAwB,4EAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4EAAyB;AAC7C;AACA;AACA;AACA,gBAAgB,4EAAyB;AACzC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChDO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACJ0C;AACnC;AACP,WAAW,sDAAQ;AACnB;;;;;;;;;;;;;;;;ACH0C;AACnC;AACP,WAAW,sDAAQ;AACnB;;;;;;;;;;;;;;;;ACHgE;AACzD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4EAAyB;AACzC;AACA;AACA;AACA,gBAAgB,4EAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7C0C;AACnC;AACP;AACA,WAAW,sDAAQ;AACnB;AACA;AACA;;;;;;;;;;;;;;;;;ACN0C;AACH;AAChC;AACP;AACA,UAAU,sDAAQ;AAClB,UAAU,oDAAW;AACrB;;;;;;;;;;;;;;;ACNO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACL0C;AAC1C;AACA;AACA;AACA;AACA;AACO;AACP;AACA,QAAQ,sDAAQ;AAChB;AACA;AACA,SAAS;AACT,QAAQ,sDAAQ;AAChB;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnDO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpB0C;AACG;AACN;AAChC;AACP;AACA,eAAe,0DAAc;AAC7B;AACA,iBAAiB,sDAAQ;AACzB;AACA;AACA,KAAK,KAAK,oDAAW;AACrB,mBAAmB,sDAAQ;AAC3B;AACA;AACA,KAAK,KAAK,oDAAW;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;ACzBO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACfuC;AAChC;AACP;AACA;AACA;AACA,iBAAiB,oDAAW;AAC5B;AACA;AACA,aAAa;AACb;AACA;;;;;;;;;;;;;;;ACVO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACT0C;AACK;AACxC;AACP;AACA;AACA;AACA;AACA,sBAAsB,wDAAiB;AACvC;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAiB;AACjC;AACA;AACA;AACA;AACA;AACA,qBAAqB,sDAAQ;AAC7B;AACA;AACA,SAAS;AACT;AACA,qBAAqB;AACrB,yBAAyB;AACzB;AACA,iBAAiB,sDAAQ;AACzB;AACA;AACA,KAAK;AACL,qBAAqB,gBAAgB,cAAc;AACnD;;;;;;;;;;;;;;;;AChCkF;AAC3E;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kEAAe;AAC/B;AACA;AACA;AACA;AACA,wBAAwB,4EAAyB;AACjD;AACA;AACA,wBAAwB,4EAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4EAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA,wBAAwB,4EAAyB;AACjD;AACA;AACA,wBAAwB,4EAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4EAAyB;AAC7C;AACA;AACA;AACA,gBAAgB,4EAAyB;AACzC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnD0C;AACnC;AACP;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAQ;AAClC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sDAAQ;AACvB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvE0C;AACH;AAChC;AACP;AACA,eAAe,sDAAQ;AACvB;AACA,wBAAwB,sDAAQ;AAChC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,yBAAyB,oDAAW;AACpC,iBAAiB;AACjB;AACA;AACA;AACA,UAAU,oDAAW;AACrB;;;;;;;;;;;;;;;;ACpB0C;AACnC;AACP;AACA,eAAe,sDAAQ;AACvB;AACA;AACA,eAAe,sDAAQ;AACvB;AACA,cAAc,sDAAQ;AACtB;AACA;AACA,KAAK;AACL,cAAc,sDAAQ;AACtB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnB0C;AACnC;AACP,WAAW,sDAAQ;AACnB;;;;;;;;;;;;;;;;ACH0C;AACnC;AACP,WAAW,sDAAQ;AACnB;;;;;;;;;;;;;;;;;;;;ACHgD;AACN;AACG;AACE;AACR;AAChC;AACP;AACA;AACA;AACA;AACA,uCAAuC,yDAAqB;AAC5D;AACA;AACA;AACA;AACA;AACA,uBAAuB,sDAAQ;AAC/B;AACA;AACA,iBAAiB,KAAK,oDAAW;AACjC,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA,8BAA8B,sDAAQ;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uCAAuC,yDAAqB;AAC5D;AACA,gBAAgB,mBAAmB,EAAE,0DAAc;AACnD;AACA;AACA;AACA;AACA;AACA,4CAA4C,yDAAqB;AACjE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,4CAA4C,yDAAqB;AACjE,gDAAgD,yDAAqB;AACrE;AACA,gBAAgB,mBAAmB,EAAE,4DAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5DgE;AACtB;AACnC;AACP,kBAAkB,sDAAQ;AAC1B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4EAAyB;AACjC;AACA;AACA,QAAQ,4EAAyB;AACjC;AACA;AACA;;;;;;;;;;;;;;;;;ACnBgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,uBAAuB,GAAG;AAC1B;AACA,+BAA+B,GAAG;AAClC;AACA;AACA;AACA,wGAAwG,GAAG;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB,KAAK,gBAAgB;AAClF;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,wBAAwB,EAAE,eAAe,EAAE,eAAe,EAAE,eAAe,EAAE,eAAe,GAAG;AAC/F;AACA;AACA;AACA,uEAAuE,EAAE;AACzE,2EAA2E,EAAE;AAC7E;AACA;AACA;AACA,uBAAuB,IAAI,GAAG,EAAE,aAAa,IAAI,GAAG,IAAI,WAAW,IAAI,GAAG,EAAE,WAAW,IAAI,GAAG,IAAI,WAAW,IAAI,GAAG,EAAE,WAAW,IAAI,GAAG,IAAI,WAAW,IAAI,GAAG,EAAE,WAAW,IAAI,GAAG,IAAI,WAAW,IAAI,GAAG,EAAE,WAAW,IAAI,GAAG,IAAI,WAAW,IAAI,GAAG,EAAE,WAAW,IAAI,GAAG,IAAI,WAAW,IAAI,mCAAmC,EAAE,SAAS,IAAI,MAAM,EAAE,iCAAiC,EAAE,SAAS,IAAI;AACnY,8BAA8B,IAAI,GAAG,IAAI,YAAY,IAAI,cAAc,IAAI,GAAG,IAAI,eAAe,IAAI,GAAG,IAAI,aAAa,IAAI,cAAc,IAAI,GAAG,IAAI,cAAc,IAAI,EAAE,IAAI,cAAc,IAAI,GAAG,IAAI,cAAc,IAAI,EAAE,IAAI,cAAc,IAAI,GAAG,IAAI,cAAc,IAAI,EAAE,IAAI,cAAc,IAAI,GAAG,IAAI,cAAc,IAAI,EAAE,IAAI,aAAa,IAAI,gBAAgB,IAAI,EAAE,IAAI,kBAAkB,IAAI,EAAE,IAAI,uBAAuB,IAAI,EAAE,IAAI,aAAa,GAAG,YAAY,IAAI,EAAE,IAAI,GAAG,IAAI,oBAAoB,IAAI,OAAO,IAAI,UAAU,IAAI,mBAAmB,IAAI,OAAO,IAAI,oBAAoB,IAAI,GAAG,IAAI,qBAAqB,IAAI,OAAO,IAAI,UAAU,IAAI,mBAAmB,IAAI,OAAO,IAAI;AAC5pB,6BAA6B,EAAE,kBAAkB,EAAE,mBAAmB,EAAE;AACxE,gCAAgC,EAAE,kBAAkB,EAAE,sBAAsB,EAAE;AAC9E,4BAA4B,GAAG;AAC/B;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4EAAyB;AAC7C;AACA;AACA;AACA;AACA,oBAAoB,4EAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2CAA2C;AAC1F;AACA;AACA,8CAA8C,2CAA2C;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4EAAyB;AAC7C;AACA;AACA,oBAAoB,4EAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4EAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oCAAoC;AACxE,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gBAAgB,mBAAmB;AAC3E,SAAS;AACT;AACA;AACA,QAAQ,4EAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sCAAsC;AAC1E,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gBAAgB,oBAAoB;AAC5E,SAAS;AACT;AACA;AACA,QAAQ,4EAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0SAA0S;AAC1S;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,cAAc,GAAG,UAAU;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU,EAAE,wBAAwB;AAC1E;AACA;AACA;AACA;AACA;AACA,+BAA+B,UAAU,EAAE,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU,YAAY,UAAU;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,4BAA4B;AACvF;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/V0C;AACnC;AACP;AACA;AACA;AACA;AACA;AACA,+BAA+B,sDAAQ;AACvC;AACA,+DAA+D,EAAE;AACjE,aAAa;AACb;AACA,6BAA6B,sDAAQ;AACrC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sDAAQ;AACvC;AACA,+DAA+D,EAAE;AACjE,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/BuC;AAChC;AACP;AACA,aAAa,oDAAW;AACxB;AACA;;;;;;;;;;;;;;;;;ACL0C;AACnC;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA,6DAA6D;AAC7D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sDAAQ;AAC/B;AACA,uDAAuD,EAAE;AACzD,KAAK;AACL;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;;;;;;;;;;;;;;;;AC/EuC;AAChC;AACP,WAAW,oDAAW;AACtB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACH+C;AACA;AACI;AACE;AACE;AACA;AACJ;AACF;AACM;AACA;AACN;AACgB;AACV;AACR;AACc;AACV;AACF;AACQ;AACJ;AACA;AACI;AACA;AACF;AACF;AACN;AACM;AACF;AACQ;AACR;AACI;AACE;AAClD;AACP;AACA,aAAa,yDAAqB;AAClC,mBAAmB,mEAAc;AACjC,aAAa,yDAAqB;AAClC,mBAAmB,mEAAc;AACjC,aAAa,yDAAqB;AAClC,mBAAmB,mEAAc;AACjC,aAAa,yDAAqB;AAClC,mBAAmB,kEAAc;AACjC,aAAa,yDAAqB;AAClC,mBAAmB,oEAAe;AAClC,aAAa,yDAAqB;AAClC,mBAAmB,8DAAY;AAC/B,aAAa,yDAAqB;AAClC,mBAAmB,yEAAiB;AACpC,aAAa,yDAAqB;AAClC,mBAAmB,+DAAY;AAC/B,aAAa,yDAAqB;AAClC,mBAAmB,gEAAa;AAChC,aAAa,yDAAqB;AAClC,aAAa,yDAAqB;AAClC,mBAAmB,iEAAa;AAChC,aAAa,yDAAqB;AAClC,mBAAmB,+EAAoB;AACvC,aAAa,yDAAqB;AAClC,mBAAmB,iEAAa;AAChC,aAAa,yDAAqB;AAClC,mBAAmB,mEAAc;AACjC,aAAa,yDAAqB;AAClC,mBAAmB,qEAAe;AAClC,aAAa,yDAAqB;AAClC,mBAAmB,+DAAY;AAC/B,aAAa,yDAAqB;AAClC,mBAAmB,2EAAkB;AACrC,aAAa,yDAAqB;AAClC,mBAAmB,uEAAgB;AACnC,aAAa,yDAAqB;AAClC,mBAAmB,uEAAgB;AACnC,aAAa,yDAAqB;AAClC,mBAAmB,6DAAW;AAC9B,aAAa,yDAAqB;AAClC,mBAAmB,6DAAW;AAC9B,aAAa,yDAAqB;AAClC;AACA,aAAa,yDAAqB;AAClC,mBAAmB,qEAAe;AAClC,aAAa,yDAAqB;AAClC,aAAa,yDAAqB;AAClC,mBAAmB,iEAAa;AAChC,aAAa,yDAAqB;AAClC,mBAAmB,oEAAe;AAClC,aAAa,yDAAqB;AAClC,mBAAmB,4DAAW;AAC9B,aAAa,yDAAqB;AAClC,mBAAmB,qEAAe;AAClC,aAAa,yDAAqB;AAClC,mBAAmB,oEAAe;AAClC,aAAa,yDAAqB;AAClC,mBAAmB,oEAAe;AAClC,aAAa,yDAAqB;AAClC,mBAAmB,uEAAgB;AACnC,aAAa,yDAAqB;AAClC,mBAAmB,gEAAa;AAChC,aAAa,yDAAqB;AAClC,mBAAmB,uEAAgB;AACnC,aAAa,yDAAqB;AAClC,aAAa,yDAAqB;AAClC,aAAa,yDAAqB;AAClC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxGyC;AACL;AACW;AAC/C;AACA,iBAAiB,iDAAO;AACxB;AACA;AACA;AACA,oBAAoB,sDAAQ;AAC5B;AACA;AACA,aAAa,WAAW,4DAAW;AACnC,SAAS,KAAK;AACd;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sDAAQ;AACzB;AACA;AACA;AACA;AACA,SAAS,YAAY,4DAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2B;;;;;;;;;;;;;;;;;;ACtFc;AAClC,qBAAqB,kDAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,0DAA0D;AAC1D,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,MAAM;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kDAAI;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpI8C;AAC9C,uBAAuB,sDAAe;AACX;AACpB;AACP;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACR4B;AACW;AACE;AACP;AACP;AACG;;;;;;;;;;;;;;;ACLvB;AACP;AACA,sEAAsE,UAAU;AAChF;AACA;AACA,CAAC,8BAA8B;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLY;AACI;AACxC;AACP,YAAY,mCAAmC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kCAAkC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP,wBAAwB,uDAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sDAAe,eAAe,sDAAe;AACzE;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACO;AACP;AACA,CAAC;AACM,4BAA4B,wBAAwB;AACpD,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA;;;;;;;;;;;;AC5GG;;;;;;;;;;;;;;;;;;ACAH;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,IAAI;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB;AACd;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpImC;AACL;AACjB;AACb,iEAAe,yCAAC,EAAC;;;;;;;;;;;;;;;;;ACH6B;AACW;AACzD;AACA;AACA;AACA,aAAa,sDAAY;AACzB,mCAAmC,2DAAa;AAChD;AACA;AACA;AACA,sCAAsC,eAAe,aAAa,eAAe;AACjF;AACA;AACA,aAAa,sDAAY;AACzB,yDAAyD,+BAA+B,kDAAI,wBAAwB;AACpH;AACA,aAAa,sDAAY;AACzB,wDAAwD,kDAAI,8BAA8B;AAC1F;AACA,aAAa,sDAAY;AACzB;AACA;AACA,aAAa,sDAAY;AACzB,+DAA+D,kDAAI,2BAA2B;AAC9F;AACA,aAAa,sDAAY;AACzB,sDAAsD,kDAAI,2BAA2B,cAAc,eAAe;AAClH;AACA,aAAa,sDAAY;AACzB;AACA;AACA,aAAa,sDAAY;AACzB;AACA;AACA,aAAa,sDAAY;AACzB;AACA;AACA,aAAa,sDAAY;AACzB;AACA;AACA,8DAA8D,0BAA0B;AACxF;AACA,qCAAqC,SAAS,oDAAoD,0BAA0B;AAC5H;AACA;AACA;AACA,iEAAiE,4BAA4B;AAC7F;AACA;AACA,+DAA+D,0BAA0B;AACzF;AACA;AACA,oBAAoB,kDAAI;AACxB;AACA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;AACA,aAAa,sDAAY;AACzB;AACA,gDAAgD,sEAAsE,EAAE,eAAe;AACvI;AACA,iDAAiD,iEAAiE,EAAE,eAAe;AACnI;AACA,4CAA4C,oGAAoG,EAAE,cAAc;AAChK;AACA,4CAA4C,oGAAoG,EAAE,cAAc;AAChK;AACA,0CAA0C,oGAAoG,EAAE,gCAAgC;AAChL;AACA;AACA;AACA,aAAa,sDAAY;AACzB;AACA,gDAAgD,qEAAqE,EAAE,eAAe;AACtI;AACA,iDAAiD,iEAAiE,EAAE,eAAe;AACnI;AACA,4CAA4C,mFAAmF,EAAE,cAAc;AAC/I;AACA,4CAA4C,mFAAmF,EAAE,cAAc;AAC/I;AACA,0CAA0C,yFAAyF,EAAE,gCAAgC;AACrK;AACA;AACA;AACA,aAAa,sDAAY;AACzB;AACA;AACA,aAAa,sDAAY;AACzB;AACA;AACA,aAAa,sDAAY;AACzB,sDAAsD,iBAAiB;AACvE;AACA,aAAa,sDAAY;AACzB;AACA;AACA;AACA;AACA,YAAY,kDAAI;AAChB;AACA,aAAa;AACb;AACA,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5GgC;AACG;AACR;AAC2F;AACvE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAO;AACf,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kDAAQ;AAC1C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4DAA4D;AACxE;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,gBAAgB,UAAU;AAC1B;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,+DAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,wBAAwB,+DAAa;AACrC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,8DAAW;AACnC;AACA;AACA;AACA,4BAA4B,+DAAa;AACzC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,YAAY,8DAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,wBAAwB,+DAAa;AACrC;AACA,yCAAyC,mCAAmC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,wBAAwB,+DAAa;AACrC;AACA;AACA;AACA,iDAAiD,6BAA6B;AAC9E,uBAAuB,8DAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6BAA6B,mBAAmB,8DAAO;AACzF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,wBAAwB,+DAAa;AACrC;AACA,+CAA+C,mCAAmC;AAClF,8BAA8B,8DAAO;AACrC;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAY;AAClC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sBAAsB,gCAAgC;AACtD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8BAA8B;AACpD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;A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EAAE,kBAAkB,EAAE,sBAAsB,EAAE;AACtF;AACA,gCAAgC,EAAE,KAAK,EAAE,KAAK,EAAE;AAChD;AACA,gCAAgC,EAAE;AAClC;AACA,mHAAmH,EAAE;AACrH,iCAAiC,gBAAgB;AACjD;AACA;AACA;AACA,gCAAgC,mBAAmB,OAAO,EAAE,gBAAgB;AAC5E;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA,0DAA0D;AAC1D,yCAAyC,mBAAmB,GAAG,kBAAkB;AACjF;AACA;AACA,0BAA0B,sBAAsB;AAChD;AACA;AACO;AACP,mBAAmB,gBAAgB,GAAG,sBAAsB;AAC5D;AACA;AACA;AACA,4BAA4B,EAAE,MAAM,EAAE;AACtC,eAAe,MAAM,GAAG,eAAe;AACvC,0BAA0B,MAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAa;AACxC;AACA,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC,0BAA0B,2DAAa;AACvC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA,2BAA2B,8DAAW;AACtC;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC,8BAA8B,sDAAY;AAC1C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC,8BAA8B,sDAAY;AAC1C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wEAAiB;AACzC,kCAAkC,sDAAY;AAC9C;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,wBAAwB,wEAAiB;AACzC,kCAAkC,sDAAY;AAC9C;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC;AACA,8BAA8B,sDAAY;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC;AACA,8BAA8B,sDAAY;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC;AACA,8BAA8B,sDAAY;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC;AACA,8BAA8B,sDAAY;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC;AACA,8BAA8B,sDAAY;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC;AACA,8BAA8B,sDAAY;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC;AACA,8BAA8B,sDAAY;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC;AACA,8BAA8B,sDAAY;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC;AACA,8BAA8B,sDAAY;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC,8BAA8B,sDAAY;AAC1C,sCAAsC,iDAAiD;AACvF;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC,8BAA8B,sDAAY;AAC1C,sCAAsC,yBAAyB;AAC/D;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC,8BAA8B,sDAAY;AAC1C,sCAAsC,uBAAuB;AAC7D;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC,8BAA8B,sDAAY;AAC1C;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC,8BAA8B,sDAAY;AAC1C;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC,8BAA8B,sDAAY;AAC1C;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC;AACA,8BAA8B,sDAAY;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC;AACA,8BAA8B,sDAAY;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC;AACA,8BAA8B,sDAAY;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC;AACA,8BAA8B,sDAAY;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC;AACA,8BAA8B,sDAAY;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC;AACA,8BAA8B,sDAAY;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,gBAAgB,kDAAI;AACpB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAkB,sDAAY;AAC9B,eAAe,4DAAS;AACxB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gCAAgC,kBAAkB,4DAAS,oBAAoB;AAC/E;AACA;AACA,gCAAgC,gBAAgB,4DAAS,oBAAoB;AAC7E;AACA;AACA,gCAAgC,kBAAkB,4DAAS,oBAAoB;AAC/E;AACA;AACA,gCAAgC,iBAAiB,4DAAS,oBAAoB;AAC9E;AACA;AACA,gCAAgC,mBAAmB,4DAAS,oBAAoB;AAChF;AACA;AACA,gCAAgC,iBAAiB,4DAAS,oBAAoB;AAC9E;AACA;AACA,gCAAgC,kBAAkB,4DAAS,oBAAoB;AAC/E;AACA;AACA,gCAAgC,iBAAiB,4DAAS,oBAAoB;AAC9E;AACA;AACA,gCAAgC,mBAAmB,4DAAS,oBAAoB;AAChF;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAS;AACxB,SAAS;AACT;AACA;AACA,gCAAgC,gBAAgB,4DAAS,oBAAoB;AAC7E;AACA;AACA,gCAAgC,eAAe,4DAAS,oBAAoB;AAC5E;AACA;AACA,gCAAgC,iBAAiB,4DAAS,oBAAoB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAS;AACxB,SAAS;AACT;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,4DAAS;AACxB,SAAS;AACT;AACA;AACA,gCAAgC,qBAAqB,4DAAS,oBAAoB;AAClF;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAS;AACxB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAS;AACxB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAS;AACxB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAS;AACxB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAS;AACxB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAS;AACxB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAS;AACxB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2BAA2B,4DAAS;AACpC;AACA;AACA;AACA;AACA,4CAA4C,cAAc;AAC1D,SAAS;AACT;AACA;AACA;AACA;AACA,4CAA4C,qBAAqB;AACjE,SAAS;AACT;AACA;AACA;AACA;AACA,4CAA4C,qBAAqB;AACjE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAa;AACxC;AACA,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC,0BAA0B,2DAAa;AACvC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA;AACA,2BAA2B,8DAAW;AACtC;AACA;AACA,qBAAqB,kDAAI;AACzB;AACA,oBAAoB,wEAAiB;AACrC,8BAA8B,sDAAY;AAC1C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC,8BAA8B,sDAAY;AAC1C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC,8BAA8B,sDAAY;AAC1C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC,8BAA8B,sDAAY;AAC1C;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC,8BAA8B,sDAAY;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,gBAAgB,kDAAI;AACpB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iDAAiD,4DAAS;AAC1D;AACA;AACA,kDAAkD,4DAAS;AAC3D;AACA;AACA,iDAAiD,4DAAS;AAC1D;AACA;AACA,kDAAkD,4DAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4DAAS;AACtC,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qBAAqB,4DAAS;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAS;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAS;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAS;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAS;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAS;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA,qBAAqB,4DAAS;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAS;AAC9B,SAAS;AACT;AACA;AACA;AACA,qBAAqB,4DAAS;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,kDAAI;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAa;AACxC;AACA;AACA;AACA,2BAA2B,8DAAW;AACtC;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC,8BAA8B,sDAAY;AAC1C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC,8BAA8B,sDAAY;AAC1C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC,8BAA8B,sDAAY;AAC1C;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,gBAAgB,kDAAI;AACpB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,wEAAiB;AACzB,kBAAkB,sDAAY;AAC9B,sBAAsB,2DAAa;AACnC;AACA,SAAS;AACT,eAAe,0DAAO;AACtB;AACA;AACA,iDAAiD,4DAAS;AAC1D;AACA;AACA,kDAAkD,4DAAS;AAC3D;AACA;AACA,iDAAiD,4DAAS;AAC1D;AACA;AACA,kDAAkD,4DAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4DAAS;AACtC,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAS;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAS;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAS;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAS;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAS;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAa;AACxC;AACA,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC,0BAA0B,2DAAa;AACvC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA,eAAe,yDAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAa;AACxC;AACA,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC,0BAA0B,2DAAa;AACvC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA;AACA;AACA,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA,2BAA2B,8DAAW;AACtC;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC,8BAA8B,sDAAY;AAC1C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC,8BAA8B,sDAAY;AAC1C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,gBAAgB,kDAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAS;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAS;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,2BAA2B,2DAAa;AACxC;AACA,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC,0BAA0B,2DAAa;AACvC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA,eAAe,yDAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,2BAA2B,2DAAa;AACxC;AACA,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC,0BAA0B,2DAAa;AACvC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA,eAAe,yDAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,2BAA2B,2DAAa;AACxC;AACA,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC,0BAA0B,2DAAa;AACvC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA,eAAe,yDAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,QAAQ,wEAAiB;AACzB,kBAAkB,sDAAY;AAC9B,sBAAsB,2DAAa;AACnC;AACA,SAAS;AACT,eAAe,0DAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,2BAA2B,2DAAa;AACxC;AACA,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC,0BAA0B,2DAAa;AACvC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA,eAAe,yDAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,gBAAgB,cAAc;AAC9B;AACA,+BAA+B,2DAAa;AAC5C,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC,0BAA0B,2DAAa;AACvC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,gBAAgB,wEAAiB;AACjC,mCAAmC,sDAAY,WAAW,sDAAY;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,wEAAiB;AACjC,0BAA0B,sDAAY;AACtC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,wEAAiB;AACjC,0BAA0B,sDAAY;AACtC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,uBAAuB,8DAAW;AAClC,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT,eAAe,8DAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2BAA2B,4DAAS,oBAAoB;AACjF,SAAS;AACT;AACA;AACA;AACA;AACA,yBAAyB,2BAA2B,4DAAS,oBAAoB;AACjF,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB,4DAAS,oBAAoB;AAC7E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAI;AACzB,yBAAyB;AACzB;AACA;AACA;AACA;AACA,2BAA2B,2DAAa;AACxC;AACA,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC,0BAA0B,2DAAa;AACvC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA,gBAAgB,cAAc;AAC9B,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D,iCAAiC,uCAAuC;AACxE,qBAAqB;AACrB;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC,8BAA8B,sDAAY;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA,uBAAuB,8DAAW;AAClC,aAAa;AACb;AACA;AACA,mBAAmB,8DAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4DAAS;AAClD;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,oBAAoB;AACpB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,kDAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,kDAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kDAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,kDAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6BAA6B,kDAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,kDAAQ;AACpE,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,kDAAQ;AACnE,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,gBAAgB,MAAM;AACtB,+BAA+B,2DAAa;AAC5C,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC,0BAA0B,2DAAa;AACvC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC;AACA;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,cAAc;AACjF;AACA;AACA;AACA,8DAA8D,uBAAuB,sBAAsB,cAAc;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB,+DAAa;AAC/B,kBAAkB,+DAAa;AAC/B;AACA,iBAAiB;AACjB;AACA,uBAAuB,2DAAa,qBAAqB,2DAAa;AACtE,sBAAsB,kDAAI;AAC1B,2BAA2B,kDAAI;AAC/B,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB;AACjB;AACA,uBAAuB,2DAAa,oBAAoB,2DAAa;AACrE;AACA,qBAAqB;AACrB;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB;AACjB;AACA,uBAAuB,2DAAa,mBAAmB,2DAAa;AACpE,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACO;AACP;AACA,gBAAgB,cAAc;AAC9B;AACA,gBAAgB,gEAAS,gBAAgB,gEAAS;AAClD,uBAAuB,0DAAO;AAC9B;AACA;AACA;AACA,gBAAgB,wEAAiB;AACjC,0BAA0B,sDAAY;AACtC,iBAAiB;AACjB,uBAAuB,0DAAO;AAC9B;AACA,gBAAgB,8DAAO,gBAAgB,8DAAO;AAC9C;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA,gBAAgB,cAAc;AAC9B,+BAA+B,2DAAa;AAC5C,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC,0BAA0B,2DAAa;AACvC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA;AACA,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC;AACA;AACA;AACA;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA;AACA;AACA,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iCAAiC;AACjC;AACA;AACA,uBAAuB,8DAAW;AAClC,aAAa;AACb;AACA;AACA,mBAAmB,8DAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B,+BAA+B,2DAAa;AAC5C,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC,0BAA0B,2DAAa;AACvC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mBAAmB,8DAAW;AAC9B;AACA;AACA,mBAAmB,8DAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B,+BAA+B,2DAAa;AAC5C,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC,0BAA0B,2DAAa;AACvC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,gBAAgB,cAAc;AAC9B,+BAA+B,2DAAa;AAC5C,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC,0BAA0B,2DAAa;AACvC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA;AACA;AACA;AACA,gBAAgB,wEAAiB;AACjC,0BAA0B,sDAAY;AACtC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,wEAAiB;AACjC,0BAA0B,sDAAY;AACtC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAO;AAClC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB,4DAAS,oBAAoB;AAC7E,SAAS;AACT;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB,4DAAS,oBAAoB;AAC7E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB,+BAA+B,2DAAa;AAC5C,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC,0BAA0B,2DAAa;AACvC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA;AACA,mBAAmB,gEAAS;AAC5B;AACA;AACA,+EAA+E,uDAAW,IAAI,uDAAe;AAC7G;AACA,0BAA0B,sDAAY;AACtC;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,mBAAmB,gEAAS;AAC5B;AACA;AACA,+EAA+E,uDAAW,IAAI,uDAAe;AAC7G;AACA,0BAA0B,sDAAY;AACtC;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAE;AACrB,kCAAkC,kDAAQ;AAC1C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAE;AACrB;AACA;AACA,8BAA8B,kDAAQ;AACtC;AACA;AACA;AACA;AACA,8BAA8B,kDAAQ;AACtC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA,mCAAmC,6CAA6C;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,YAAY,wEAAiB;AAC7B;AACA,sBAAsB,sDAAY;AAClC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA,YAAY,wEAAiB;AAC7B,0BAA0B,kDAAI;AAC9B;AACA,sBAAsB,sDAAY;AAClC,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAiB;AAC7B;AACA,sBAAsB,sDAAY;AAClC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA,eAAe,yDAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA,iCAAiC,kDAAI;AACrC;AACA,+BAA+B,2DAAa,8BAA8B,2DAAa;AACvF,mCAAmC,kDAAI;AACvC,YAAY,wEAAiB;AAC7B,0BAA0B,kDAAI;AAC9B;AACA,sBAAsB,sDAAY;AAClC,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA;AACA,kCAAkC,kDAAI;AACtC;AACA;AACA,mCAAmC,kDAAI;AACvC,YAAY,wEAAiB;AAC7B;AACA,sBAAsB,sDAAY;AAClC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA,eAAe,yDAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB,+BAA+B,2DAAa;AAC5C,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC,0BAA0B,2DAAa;AACvC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA,+CAA+C,2DAAa;AAC5D,eAAe,yDAAE;AACjB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA,gBAAgB,wEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAO;AACtC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,+BAA+B,0DAAO;AACtC;AACA,+BAA+B,4DAAK;AACpC;AACA,+BAA+B,4DAAK;AACpC;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B,0DAAO;AAClC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,2BAA2B,0DAAO;AAClC;AACA,2BAA2B,4DAAK;AAChC;AACA,2BAA2B,4DAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,2BAA2B,0DAAO;AAClC;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,sDAAsD,6CAA6C;AACnG;AACA,+BAA+B,0DAAO;AACtC;AACA;AACA;AACA,iCAAiC;AACjC,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,qBAAqB,8DAAO;AAC5B,2BAA2B,0DAAO;AAClC;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,sDAAsD,6CAA6C;AACnG,yBAAyB,8DAAO;AAChC,+BAA+B,0DAAO;AACtC;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,QAAQ,kDAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,kBAAkB,2CAA2C;AAC7D;AACA;AACA,KAAK;AACL;AACwC;AACjC;AACP;AACA;AACA,2BAA2B,2DAAa;AACxC,mBAAmB,yDAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,2BAA2B,2DAAa;AACxC,mBAAmB,yDAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,gBAAgB,MAAM;AACtB;AACA,+BAA+B,2DAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,YAAY,8DAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kDAAQ;AACnD,6BAA6B;AAC7B;AACA,yBAAyB;AACzB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kDAAQ;AAC/C,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,2BAA2B,2DAAa;AACxC;AACA,YAAY,wEAAiB;AAC7B,sBAAsB,sDAAY;AAClC,0BAA0B,2DAAa;AACvC;AACA,aAAa;AACb,mBAAmB,0DAAO;AAC1B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACA;AACP;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACO;AACP;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,2BAA2B,0DAAO;AAClC;AACA;AACA,2BAA2B,4DAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,0DAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA,gBAAgB,8DAAO;AACvB;AACA;AACA;AACA;AACA,eAAe,8DAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,kBAAkB;AAC7G,yCAAyC,aAAa;AACtD;AACA;AACO,mCAAmC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0CAA0C;AACjF;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,+BAA+B,0CAA0C;AACzE;AACA;AACA,SAAS;AACT;AACA;AACmD;AAC5C;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yCAAyC,sBAAsB;AAC/D,yCAAyC,sBAAsB;AAC/D;AACA;AACA;AACA,KAAK;AACL,yCAAyC,sBAAsB;AAC/D,qCAAqC,sBAAsB;AAC3D;AACw3B;AACj3B,cAAc,0DAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9mHQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAknB;;;;;;;;;;;;;;;;;;;;;ACA7mB;AACD;AACjC;AACP,WAAW,0DAAmB,CAAC,kDAAiB;AAChD;AACO;AACP,WAAW,0DAAmB,CAAC,kDAAiB;AAChD;AACO;AACP,WAAW,2DAAoB,CAAC,mDAAkB;AAClD;AACO;AACP,WAAW,0DAAmB,CAAC,kDAAiB;AAChD;AACO;AACP,WAAW,wDAAiB,CAAC,gDAAe;AAC5C;;;;;;;;;;;;;;;;;;;;;AChBA;AACyC;AACzC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AAClD;AACO;AACP,IAAI,kDAAW;AACf;AACA,KAAK;AACL;AACA;AACO;AACP,WAAW,kDAAW;AACtB;AACA;AACO;AACP;AACA,CAAC,sDAAsD;;;;;;;;;;;;;;;;;;AC9Bd;AACI;AACL;AACxC;AACA,IAAI,qDAAS;AACb;AACA;AACA;AACA,+BAA+B,uDAAgB;AAC/C;AACA,SAAS;AACT;AACA,+BAA+B,wDAAiB;AAChD;AACA,SAAS;AACT;AACA;AACA;AACA,2DAA2D,gEAA0B;AACrF,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,2DAA2D,gEAA0B;AACrF,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR;AACO,iBAAiB,wDAAiB;AAClC,qBAAqB,wDAAiB;AAC7C;AACA,CAAC;AACD;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/CyC;AACZ;AACD;AACA;AACD;AACC;AAC5B;AAC0C;AACR;AAClC,sDAAM,CAAC,0DAAE;AACyL;AACjI;AACV;AACR;AAC/C;AACA;AACA;AACkF;AAClD;AACM;;;;;;;;;;;;;;;;;;;ACnBiB;AAChB;AACN;AACQ;AACzC;AACA;AACA,OAAO,wCAAQ;AACf,OAAO,uCAAO;AACd,SAAS,oCAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,IAAI;AACxD;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA,+DAA+D,UAAU;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,QAAQ;AAChF;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+BAA+B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,KAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+DAAc;AACpD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvkBmC;AACtB;AACiB;AAC9B,iEAAe,yCAAC,EAAC;;;;;;;;;;;;;;;;;;;;;;;;ACHwB;AACD;AACjC,qCAAqC,wDAAiB;AAC7D,IAAI,2DAAoB;AACxB,IAAI,wDAAuB;AAC3B,CAAC;AACM;AACP,WAAW,wDAAiB;AAC5B;AACO,iCAAiC,wDAAiB;AACzD,IAAI,uDAAgB;AACpB,IAAI,wDAAuB;AAC3B,CAAC;AACM;AACP,WAAW,oDAAa;AACxB;AACO,iCAAiC,wDAAiB;AACzD,IAAI,uDAAgB;AACpB,IAAI,wDAAuB;AAC3B,CAAC;AACM;AACP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;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA,WAAW,gEAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP,cAAc,iDAAU;AACxB;AACA;AACA;AACA;AACA;AACA,WAAW,gEAAoB;AAC/B,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,gEAAoB;AAC/B,KAAK;AACL;AACO,6BAA6B,wDAAiB;AACrD,IAAI,mDAAY;AAChB;AACA,yDAAyD,yEAAuB;AAChF;AACA;AACA,uCAAuC,oDAAa;AACpD,2CAA2C,oDAAa;AACxD,uCAAuC,oDAAa;AACpD,wCAAwC,iDAAU;AAClD,CAAC;AACM;AACP;AACA;AACA;AACA;AACA,WAAW,gEAAoB;AAC/B,KAAK;AACL;AACO,6BAA6B,wDAAiB;AACrD,IAAI,mDAAY;AAChB;AACA,yDAAyD,yEAAuB;AAChF,uCAAuC,oDAAa;AACpD,2CAA2C,oDAAa;AACxD,uCAAuC,oDAAa;AACpD,wCAAwC,iDAAU;AAClD,CAAC;AACM;AACP;AACA;AACA;AACA,WAAW,gEAAoB;AAC/B,KAAK;AACL;AACO,8BAA8B,wDAAiB;AACtD,IAAI,oDAAa;AACjB;AACA,yDAAyD,0EAAwB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA,eAAe,gEAAoB;AACnC;AACA,SAAS;AACT;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA,eAAe,gEAAoB;AACnC;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,WAAW,gEAAoB;AAC/B,KAAK;AACL;AACyB;AACzB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACO;AACP;AACA;AACA;AACA,WAAW,gEAAoB;AAC/B,KAAK;AACL;AACO,iCAAiC,wDAAiB;AACzD,IAAI,uDAAgB;AACpB;AACA,yDAAyD,6EAA2B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;AACM;AACP;AACA;AACA;AACA,WAAW,gEAAoB;AAC/B,KAAK;AACL;AACO,8BAA8B,wDAAiB;AACtD,IAAI,oDAAa;AACjB;AACA,yDAAyD,0EAAwB;AACjF,4CAA4C,oDAAa;AACzD,4CAA4C,oDAAa;AACzD,8CAA8C,iDAAU;AACxD,CAAC;AACM;AACP,WAAW,iDAAU;AACrB;AACO,mCAAmC,wDAAiB;AAC3D,IAAI,yDAAkB;AACtB;AACA,yDAAyD,+EAA6B;AACtF;AACA;AACA,sBAAsB,2DAAoB;AAC1C;AACA;AACA;AACA,oCAAoC,sDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA,KAAK;AACL;AACO,kCAAkC,wDAAiB;AAC1D,IAAI,wDAAiB;AACrB;AACA,yDAAyD,8EAA4B;AACrF;AACA,CAAC;AACM;AACP;AACA;AACA;AACA,KAAK;AACL;AACO,uCAAuC,wDAAiB;AAC/D,IAAI,6DAAsB;AAC1B;AACA,yDAAyD,8EAA4B;AACrF;AACA,CAAC;AACM;AACP;AACA;AACA;AACA,KAAK;AACL;AACO,kCAAkC,wDAAiB;AAC1D,IAAI,wDAAiB;AACrB;AACA,yDAAyD,8EAA4B;AACrF;AACA,CAAC;AACM;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACO,iCAAiC,wDAAiB;AACzD,IAAI,uDAAgB;AACpB;AACA,yDAAyD,6EAA2B;AACpF;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA,yEAAyE,6DAAiB;AAC1F,SAAS;AACT,KAAK;AACL;AACO,kCAAkC,wDAAiB;AAC1D,IAAI,wDAAiB;AACrB;AACA,yDAAyD,8EAA4B;AACrF;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA,yEAAyE,6DAAiB;AAC1F,SAAS;AACT,KAAK;AACL;AACO,qCAAqC,wDAAiB;AAC7D,IAAI,2DAAoB;AACxB;AACA,yDAAyD,iFAA+B;AACxF;AACA,CAAC;AACM;AACP;AACA;AACA;AACA,WAAW,gEAAoB;AAC/B,KAAK;AACL;AACO,iCAAiC,wDAAiB;AACzD,IAAI,uDAAgB;AACpB;AACA,yDAAyD,6EAA2B;AACpF;AACA,CAAC;AACM;AACP;AACA;AACA;AACA,KAAK;AACL;AACO,+BAA+B,wDAAiB;AACvD,IAAI,qDAAc;AAClB;AACA,yDAAyD,2EAAyB;AAClF;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AAC2B;AACpB,6BAA6B,wDAAiB;AACrD,IAAI,mDAAY;AAChB;AACA,yDAAyD,yEAAuB;AAChF,CAAC;AACM;AACP,WAAW,gDAAS;AACpB;AACO,8BAA8B,wDAAiB;AACtD,IAAI,oDAAa;AACjB;AACA,yDAAyD,0EAAwB;AACjF;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO,+BAA+B,wDAAiB;AACvD;AACA,IAAI,qDAAc;AAClB,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO,kCAAkC,wDAAiB;AAC1D,IAAI,wDAAiB;AACrB;AACA,yDAAyD,8EAA4B;AACrF;AACA,CAAC;AACM;AACP;AACA;AACA;AACA,KAAK;AACL;AACO,yCAAyC,wDAAiB;AACjE,IAAI,+DAAwB;AAC5B;AACA,yDAAyD,qFAAmC;AAC5F,CAAC;AACM;AACP;AACA;AACA;AACA,WAAW,gEAAoB;AAC/B,KAAK;AACL;AACO,8BAA8B,wDAAiB;AACtD,IAAI,oDAAa;AACjB;AACA,yDAAyD,0EAAwB;AACjF;AACA,CAAC;AACM;AACP;AACA;AACA;AACA,KAAK;AACL;AACO,iCAAiC,wDAAiB;AACzD,IAAI,uDAAgB;AACpB;AACA,yDAAyD,6EAA2B;AACpF;AACA,CAAC;AACM;AACP;AACA;AACA;AACA,KAAK;AACL;AACO,kCAAkC,wDAAiB;AAC1D,IAAI,wDAAiB;AACrB;AACA,yDAAyD,8EAA4B;AACrF,CAAC;AACM;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACiC;AAC1B,gCAAgC,wDAAiB;AACxD,IAAI,sDAAe;AACnB;AACA,yDAAyD,4EAA0B;AACnF,CAAC;AACD;AACO;AACP,mBAAmB,qDAAc;AACjC;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP,WAAW,mDAAY;AACvB;AACO,gCAAgC;AACvC,WAAW,mDAAY;AACvB;AACA;AACO;AACP,WAAW,wDAAiB;AAC5B;AACA;AACO,iBAAiB,oDAAa;AAC9B,aAAa,gDAAS;AAC7B,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,WAAW,gEAAoB;AAC/B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACqC;AACrC;AACO,gCAAgC,uDAAgB;AACvD;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpoCsC;AACQ;AACN;AACN;AAClC;AACO;AACP;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP,eAAe,yDAAwB;AACvC;AACA,WAAW,qDAAoB;AAC/B;AACA;AACA,KAAK;AACL;AACA;AACO;AACP,eAAe,yDAAwB;AACvC;AACA,WAAW,qDAAoB;AAC/B;AACA;AACA,KAAK;AACL;AAGgB;AAChB;AACO;AACP,eAAe,4DAA2B;AAC1C;AACA,WAAW,qDAAoB;AAC/B;AACA;AACA,KAAK;AACL;AACA;AACO;AACP,eAAe,4DAA2B;AAC1C;AACA,WAAW,qDAAoB;AAC/B;AACA;AACA,KAAK;AACL;AAGgB;AAChB;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP,eAAe,2DAA0B;AACzC;AACA,WAAW,qDAAoB;AAC/B;AACA,KAAK;AACL;AACA;AACO;AACP,eAAe,wDAAuB;AACtC;AACA,WAAW,qDAAoB;AAC/B;AACA,KAAK;AACL;AACA;AACO;AACP,eAAe,wDAAuB;AACtC;AACA,WAAW,qDAAoB;AAC/B;AACA,KAAK;AACL;AACA;AACO;AACP,eAAe,2DAA0B;AACzC;AACA,WAAW,qDAAoB;AAC/B;AACA,KAAK;AACL;AACA;AACO;AACP,mBAAmB,0DAAyB;AAC5C;AACA,WAAW,qDAAoB;AAC/B;AACA,KAAK;AACL;AACA;AACA;AACO;AACP,eAAe,0DAAyB;AACxC;AACA,WAAW,qDAAoB;AAC/B;AACA,KAAK;AACL;AACA;AACO;AACP,eAAe,6DAA4B;AAC3C;AACA,WAAW,qDAAoB;AAC/B;AACA,KAAK;AACL;AACA;AACO;AACP,eAAe,sDAAqB;AACpC;AACA;AACA,WAAW,qDAAoB;AAC/B;AACA,KAAK;AACL;AACA;AACO;AACP,eAAe,0DAAyB;AACxC;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP,eAAe,0DAAyB;AACxC;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP,eAAe,yDAAwB;AACvC;AACA;AACA,WAAW,qDAAoB;AAC/B;AACA,KAAK;AACL;AACA;AACO;AACP,eAAe,2DAA0B;AACzC;AACA;AACA,WAAW,qDAAoB;AAC/B;AACA,KAAK;AACL;AACA;AACO;AACP,eAAe,yDAAwB;AACvC;AACA;AACA,WAAW,qDAAoB;AAC/B;AACA,KAAK;AACL;AACA;AACO;AACP,eAAe,yDAAwB;AACvC;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP,eAAe,yDAAwB;AACvC;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP,eAAe,0DAAyB;AACxC;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP,iCAAiC,6CAAY;AAC7C;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,6CAA6C,iDAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACO;AACP;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA,yEAAyE,kDAAiB;AAC1F,SAAS;AACT,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP,iBAAiB,qDAAoB;AACrC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oCAAoC,2CAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E,oCAAoC,2CAAU;AAC9C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP,mBAAmB,iDAAgB;AACnC;AACA,WAAW,qDAAoB;AAC/B,KAAK;AACL;AACA;AACA;AACA;AACO;AACP,mBAAmB,iDAAgB,GAAG,mBAAmB;AACzD;AACA;AACA,6BAA6B,0DAAyB;AACtD,YAAY,0DAAyB,aAAa,0BAA0B;AAC5E,SAAS;AACT;AACA,+BAA+B;AAC/B;AACA;AACA;AACO;AACP,mBAAmB,iDAAgB,GAAG,eAAe;AACrD;AACA;AACA,6BAA6B,0DAAyB;AACtD,YAAY,0DAAyB,aAAa,0BAA0B;AAC5E,SAAS;AACT;AACA,+BAA+B;AAC/B;AACA;AACA;AACO;AACP,mBAAmB,qDAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAiB;AACrD,wCAAwC,oDAAmB;AAC3D,sCAAsC,mDAAkB;AACxD,uCAAuC,qCAAqC;AAC5E,yCAAyC,sCAAsC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACO,6DAA6D;AACpE,mBAAmB,qDAAoB;AACvC;AACA,WAAW,qDAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzjCA,YAAY,WAAW;AACW;AACM;AACN;AAC3B,gCAAgC,kDAAiB;AACxD;AACA,gCAAgC;AAChC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACO,wCAAwC,kDAAiB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACM,2CAA2C,kDAAiB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACM;AACP,cAAc,kDAAiB;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,cAAc,wDAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACM,4CAA4C,kDAAiB;AACpE,+BAA+B;AAC/B;AACA;AACA;AACA,+BAA+B,0DAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAe;AACzC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,CAAC;AACM,4CAA4C,kDAAiB;AACpE,+BAA+B;AAC/B,+BAA+B,0DAAyB;AACxD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,CAAC;AACM,uCAAuC,kDAAiB;AAC/D;AACA;AACA;AACA;AACA,gBAAgB,6CAAY;AAC5B,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sDAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACM,uCAAuC,kDAAiB;AAC/D;AACA;AACA;AACA;AACA,gBAAgB,6CAAY;AAC5B,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sDAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACM,0CAA0C,kDAAiB;AAClE;AACA;AACA;AACA;AACA,gBAAgB,6CAAY;AAC5B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sDAAqB;AACzC,2BAA2B,qCAAqC,IAAI,sCAAsC;AAC1G;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACM,yCAAyC,kDAAiB;AACjE;AACA;AACA;AACA;AACA,gBAAgB,6CAAY;AAC5B,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACM,yCAAyC,kDAAiB;AACjE;AACA;AACA;AACA;AACA,gBAAgB,6CAAY;AAC5B,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACM,4CAA4C,kDAAiB;AACpE;AACA;AACA;AACA;AACA,gBAAgB,6CAAY;AAC5B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAwB;AAC/C;AACA;AACA;AACA,2BAA2B,uCAAuC,IAAI,wCAAwC;AAC9G;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACM,4CAA4C,kDAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kCAAkC,IAAI;AAC1E;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,uDAAuD;AACvD,CAAC;AACM,qCAAqC,kDAAiB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACM,yCAAyC,kDAAiB;AACjE,kCAAkC,kDAAiB;AACnD;AACA,CAAC;AACM,yCAAyC,kDAAiB;AACjE,kCAAkC,kDAAiB;AACnD;AACA,CAAC;AACM,wCAAwC,kDAAiB;AAChE;AACA,yBAAyB,iDAAgB;AACzC,sEAAsE,EAAE,cAAc,EAAE,aAAa;AACrG;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACM,0CAA0C,kDAAiB;AAClE;AACA,mCAAmC,iDAAgB,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACM,wCAAwC,kDAAiB;AAChE;AACA,oCAAoC,iDAAgB,aAAa;AACjE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,+BAA+B,kDAAiB;AAChD;AACA;AACO,wCAAwC,kDAAiB;AAChE;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,wCAAwC,kDAAiB;AAChE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACM,yCAAyC,kDAAiB;AACjE;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;AC9jBD;AACO;AACP;AACA,CAAC;AAC+B;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,aAAa;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,uCAAuC,aAAa;AACpD;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACO;AACP;AACA,qEAAqE,KAAK;AAC1E;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3EO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,EAAE;AACpD;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AClCyC;AACP;AAClC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,uCAAuC,2DAA0B;AACjE;AACA;AACA;AACA,KAAK;AACL;AACO,kBAAkB,sDAAY;AAC9B,sBAAsB,sDAAY,6BAA6B,eAAe;AAC9E;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP,0BAA0B;AAC1B;AACA;AACA;AACA,4DAA4D,QAAQ;AACpE;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,4DAA4D,QAAQ;AACpE;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE,kEAAkE,YAAY;AAC9E;AACA;AACA;AACA;AACA,6DAA6D,YAAY;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,0BAA0B,IAAI;AAC9B;AACA,0BAA0B,4BAA4B;AACtD;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrL0B;AACC;AACC;AACC;AACD;AACE;AACI;AACM;AACO;AACf;AACP;AACA;AACW;AACuB;AACM;AAClB;;;;;;;;;;;;;;;;;ACfa;AAC6B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA,yCAAyC,oBAAoB;AAC7D;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAiB;AACpC,wBAAwB,qEAAa;AACrC;AACA,sCAAsC,2BAA2B;AACjE,6CAA6C,yCAAyC;AACtF,sCAAsC,2BAA2B;AACjE,gCAAgC,eAAe;AAC/C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D,eAAe,2DAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAW;AACnB,uBAAuB,4DAAQ;AAC/B;AACA,gBAAgB,iCAAiC;AACjD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9FyF;AAC/C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,YAAY,sDAAsD;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,2EAA2E;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA,mBAAmB,uDAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,6CAA6C,qBAAqB,IAAI;AACtE;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA,iBAAiB,2DAAO,qBAAqB,4CAA4C;AACzF;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAO;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2DAAO;AAC3C;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACA,8CAA8C,2DAAO;AACrD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,cAAc,2DAAO;AACrB;AACA;AACA,KAAK;AACL,cAAc,2DAAO;AACrB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gDAAgD,2DAAO;AACvD;AACA;AACA,KAAK;AACL;AACA,UAAU,2DAAO;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAO;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2DAAO;AACxC;AACA;AACA,aAAa;AACb;AACA,oCAAoC,2DAAO;AAC3C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,2DAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACO;AACP;AACA,IAAI,2DAAO;AACX;AACA;AACA;AACO;AACP;AACA,IAAI,2DAAO;AACX;AACA;AACA;AACA;AACO;AACP;AACA,IAAI,2DAAO;AACX;AACA;AACA;AACA;AACA;AACO;AACP;AACA,IAAI,2DAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI,2DAAO;AACX;AACA;AACA;AACO;AACP;AACA,IAAI,2DAAO;AACX;AACA;AACA;AACA;AACO;AACP;AACA,IAAI,2DAAO;AACX;AACA;AACA;AACO;AACP;AACA,IAAI,2DAAO;AACX;AACA;AACA;AACO;AACP;AACA,IAAI,2DAAO;AACX;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,qEAAiB,GAAG,sCAAsC;AAC9E;AACA;AACA;AACA;AACA,YAAY,2DAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+DAAW;AACvB,2BAA2B,4DAAQ;AACnC;AACA;AACA;AACA;AAC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+BAA+B,IAAI,GAAG,EAAE,YAAY,IAAI,iBAAiB,IAAI,iBAAiB,IAAI,IAAI,IAAI;AACjH;AACO,qCAAqC,EAAE,sBAAsB,EAAE,qBAAqB,EAAE;AACtF;AACP;AACA;AACO,wBAAwB,MAAM,gCAAgC,KAAK,6CAA6C,KAAK;AACrH,6CAA6C,KAAK,0BAA0B,GAAG;AACtF;AACA,qCAAqC;AAC9B,yBAAyB,KAAK;AACrC,iHAAiH,EAAE;AACnH,kHAAkH,EAAE;AAC7G,0CAA0C,WAAW;AAC5D;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA,qBAAqB,KAAK;AAC1B,qBAAqB,KAAK,gBAAgB,EAAE,gBAAgB;AAC5D,aAAa,KAAK;AAClB;AACA;AACO;AACP,0BAA0B,iBAAiB;AAC3C;AACA;AACO;AACP,8BAA8B,2BAA2B;AACzD;AACA;AACA;AACA,4CAA4C,EAAE,KAAK,EAAE;AACrD;AACA;AACA,yBAAyB,KAAK,KAAK,eAAe;AAClD,0BAA0B,WAAW,MAAM,UAAU;AACrD;AACO;AACP,qCAAqC,EAAE,qBAAqB,GAAG,uBAAuB;AACtF,0BAA0B,MAAM;AAChC;AACO;AACA;AACA;AACA;AACP;AACyB;AACzB;AACmC;AACnC;AACO;AACP;AACO;AACP;AACO;AACP;AACA;AACA;AACA,sCAAsC,EAAE,YAAY,EAAE,QAAQ;AAC9D;AACA;AACA;AACA,sCAAsC,EAAE,QAAQ;AAChD;AACA;AACO,8BAA8B,GAAG;AACjC;AACA;AACP;AACO,+BAA+B,GAAG;AAClC;AACA;AACP;AACO,iCAAiC,GAAG;AACpC;AACA;AACP;AACO,iCAAiC,GAAG;AACpC;AACA;AACP;AACO,iCAAiC,IAAI;AACrC;AACA;;;;;;;;;;;;;;;;;;;ACpIP;AACO;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C,0BAA0B;AAC1B,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClD+B;AACJ;AACH;AAC2C;AAClC;AACN;AACM;AACjC,+BAA+B,kDAAiB;AACvD;AACA,sBAAsB;AACtB,yBAAyB;AACzB,yCAAyC;AACzC,wBAAwB,iDAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4BAA4B,6CAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6CAAY;AACpD,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6CAAY;AAChD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kCAAkC,IAAI,0BAA0B;AACjH;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gDAAe;AACnB;AACA;AACA,0BAA0B,oDAAS;AACnC,qCAAqC,gBAAgB,IAAI;AACzD;AACA;AACA,uBAAuB,yDAAc,yCAAyC,gBAAgB,IAAI,yBAAyB;AAC3H;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL,CAAC;AACiC;AAC3B,iCAAiC,kDAAiB;AACzD;AACA,uEAAuE,+CAAc;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACM,uCAAuC,kDAAiB;AAC/D;AACA,IAAI,6DAA4B;AAChC;AACA,CAAC;AACM,+BAA+B,kDAAiB;AACvD,kCAAkC,6CAAY;AAC9C;AACA,CAAC;AACM,+BAA+B,kDAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,YAAY;AAClE,sCAAsC,6CAAY;AAClD;AACA;AACA,sCAAsC,6CAAY;AAClD;AACA,CAAC;AACM,gCAAgC,kDAAiB;AACxD,kCAAkC,8CAAa;AAC/C;AACA,CAAC;AACM,8BAA8B,kDAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,CAAC;AACM,gCAAgC,kDAAiB;AACxD,kCAAkC,8CAAa;AAC/C;AACA,CAAC;AACM,iCAAiC,kDAAiB;AACzD,kCAAkC,+CAAc;AAChD;AACA,CAAC;AACM,+BAA+B,kDAAiB;AACvD,kCAAkC,6CAAY;AAC9C;AACA,CAAC;AACM,gCAAgC,kDAAiB;AACxD,kCAAkC,8CAAa;AAC/C;AACA,CAAC;AACM,+BAA+B,kDAAiB;AACvD,kCAAkC,6CAAY;AAC9C;AACA,CAAC;AACM,8BAA8B,kDAAiB;AACtD,kCAAkC,4CAAW;AAC7C;AACA,CAAC;AACM,gCAAgC,kDAAiB;AACxD,kCAAkC,8CAAa;AAC/C;AACA,CAAC;AACM,sCAAsC,kDAAiB;AAC9D,kCAAkC,iDAAgB;AAClD;AACA,CAAC;AACM,kCAAkC,kDAAiB;AAC1D,kCAAkC,6CAAY;AAC9C;AACA,CAAC;AACM,kCAAkC,kDAAiB;AAC1D,kCAAkC,6CAAY;AAC9C;AACA,CAAC;AACM,sCAAsC,kDAAiB;AAC9D,kCAAkC,iDAAgB;AAClD;AACA,CAAC;AACM,+BAA+B,kDAAiB;AACvD,kCAAkC,6CAAY;AAC9C;AACA;AACA,CAAC;AACM,+BAA+B,kDAAiB;AACvD,kCAAkC,6CAAY;AAC9C;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,CAAC;AACM,8BAA8B,kDAAiB;AACtD,kCAAkC,4CAAW;AAC7C;AACA;AACA,CAAC;AACM,iCAAiC,kDAAiB;AACzD,kCAAkC,+CAAc;AAChD;AACA,CAAC;AACM,iCAAiC,kDAAiB;AACzD,kCAAkC,+CAAc,GAAG;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,kDAAiB;AACzD,kCAAkC,+CAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD;AACO;AACP,SAAS,kDAAiB;AAC1B;AACA;AACA;AACA;AACA;AACO,oCAAoC,kDAAiB;AAC5D,kCAAkC,kDAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACM,+BAA+B,kDAAiB;AACvD,kCAAkC,6CAAY;AAC9C;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,kDAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACM,6CAA6C,kDAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACM,iCAAiC,kDAAiB;AACzD;AACA,iDAAiD,+CAAc;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW,IAAI;AAC5C,SAAS;AACT;AACA;AACA,CAAC;AACM,uCAAuC,kDAAiB;AAC/D,IAAI,6DAA4B;AAChC,gCAAgC;AAChC,CAAC;AACM,kCAAkC,kDAAiB;AAC1D;AACA,wBAAwB,gDAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACM,iCAAiC,kDAAiB;AACzD;AACA,wBAAwB,+CAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACM,uCAAuC,kDAAiB;AAC/D,IAAI,6DAA4B;AAChC,gCAAgC;AAChC,CAAC;AACM,iCAAiC,kDAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACM,oCAAoC,kDAAiB;AAC5D;AACA,wBAAwB,kDAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACM,+BAA+B,kDAAiB;AACvD;AACA,wBAAwB,gDAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACM,8BAA8B,kDAAiB;AACtD;AACA;AACA,CAAC;AACM,kCAAkC,kDAAiB;AAC1D;AACA;AACA,CAAC;AACM,gCAAgC,kDAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACM,+BAA+B,kDAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACM,+BAA+B,kDAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B,IAAI;AAC1D;AACA,SAAS;AACT;AACA;AACA,CAAC;AACD;AACA;AACA,6BAA6B,kDAAiB;AAC9C;AACA;AACA;AACO,gCAAgC,kDAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kDAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,EAAE;AACzD;AACA;AACA,kBAAkB,kDAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+BAA+B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO,iCAAiC,kDAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb,SAAS;AACT;AACA,wBAAwB,4CAAW;AACnC,IAAI,gDAAe;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qBAAqB,8CAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+BAA+B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,oCAAoC,kDAAiB;AAC5D;AACA;AACA;AACA,wBAAwB,4CAAW;AACnC;AACA,wBAAwB,wCAAG;AAC3B;AACA;AACA,sBAAsB,yCAAQ;AAC9B,4BAA4B,EAAE,aAAa,eAAe,EAAE,eAAe;AAC3E;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,8BAA8B,UAAU;AACxC;AACA;AACA,wCAAwC;AACxC;AACA;AACA,sBAAsB,yCAAQ;AAC9B;AACA;AACA,+BAA+B,IAAI,IAAI,eAAe;AACtD;AACA;AACA;AACA,cAAc,GAAG;AACjB,gBAAgB,GAAG;AACnB,qDAAqD,GAAG;AACxD;AACA,kCAAkC,EAAE,oBAAoB,EAAE;AAC1D,aAAa;AACb;AACA;AACA;AACA,cAAc,GAAG;AACjB,gBAAgB,GAAG;AACnB,wBAAwB,EAAE;AAC1B;AACA,UAAU;AACV,sBAAsB,EAAE,MAAM,GAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,GAAG;AACjB,mDAAmD,GAAG;AACtD;AACA,gCAAgC,EAAE,oBAAoB,EAAE;AACxD,WAAW;AACX;AACA;AACA,cAAc,GAAG;AACjB,gBAAgB,GAAG;AACnB,wBAAwB,EAAE;AAC1B;AACA,UAAU;AACV,sBAAsB,EAAE,MAAM,GAAG;AACjC;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,kCAAkC;AAClC;AACA;AACA;AACA;AACA,qBAAqB,8CAAa;AAClC,iBAAiB,kDAAiB;AAClC,uBAAuB,gDAAe;AACtC,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,6CAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,mDAAkB,WAAW,4CAAW;AAC3G,KAAK;AACL;AACA;AACO,gCAAgC,kDAAiB;AACxD;AACA,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,gDAAe;AACnB;AACA;AACA,mCAAmC,oBAAoB,gDAAe,sBAAsB;AAC5F;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,mDAAkB,WAAW,4CAAW;AAC/G,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO,8BAA8B,kDAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACM;AACP;AACA,kDAAiB;AACjB;AACA;AACA;AACA,IAAI,gDAAe;AACnB;AACA;AACA;AACA;AACA,gFAAgF,4BAA4B;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,iBAAiB,4CAAW;AAC5B;AACA;AACA;AACA;AACA;AACA,gFAAgF,uBAAuB;AACvG;AACA;AACA,sEAAsE,UAAU;AAChF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,aAAa,8CAAa;AAC1B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACM,uCAAuC,kDAAiB;AAC/D;AACA;AACA;AACA,yCAAyC,0BAA0B;AACnE,2CAA2C,0BAA0B;AACrE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,QAAQ,mDAAkB,OAAO,mDAAkB;AACnD;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+BAA+B;AAC5D;AACA,QAAQ,6CAAY;AACpB;AACA;AACA;AACA,qEAAqE,sCAAsC;AAC3G;AACA;AACA;AACA;AACO,gCAAgC,kDAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B,0CAA0C;AACtE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,6BAA6B,kDAAiB;AAC9C;AACA;AACA;AACO,iCAAiC,kDAAiB;AACzD;AACA;AACA;AACA,aAAa,mDAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,+BAA+B;AAC3F;AACA;AACA;AACA,uDAAuD,kDAAiB;AACxE;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,mDAAmD,kDAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,wBAAwB;AAC/E;AACA;AACA;AACA;AACA;AACA,oBAAoB,+CAAc;AAClC;AACA;AACA;AACA,+DAA+D,gCAAgC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,mDAAkB,WAAW,4CAAW;AAC1G;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,wDAAwD,+BAA+B;AACvF;AACA;AACA;AACA,mDAAmD,kDAAiB;AACpE;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,+CAA+C,kDAAiB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,8BAA8B,kDAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qDAAqD,wBAAwB;AAC7E,yDAAyD,0BAA0B;AACnF;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,YAAY,sDAAqB;AACjC,iCAAiC,kDAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,mDAAkB,WAAW,4CAAW;AAC9F,aAAa;AACb;AACA;AACA;AACA,YAAY,sDAAqB;AACjC,iCAAiC,kDAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,mDAAkB,WAAW,4CAAW;AAChG,aAAa;AACb;AACA;AACA;AACA;AACO,8BAA8B,kDAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,oDAAoD,yBAAyB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,kDAAiB;AACvD;AACA,mBAAmB,mDAAkB;AACrC;AACA;AACA,wCAAwC;AACxC,uBAAuB,sDAAqB;AAC5C,6CAA6C,iDAAgB;AAC7D,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACM,kCAAkC,kDAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,6CAA6C,iDAAgB,UAAU,iDAAgB;AACvF,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACM,+BAA+B,kDAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACM,oCAAoC,kDAAiB;AAC5D;AACA;AACA;AACA,sBAAsB,qDAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,sBAAsB,oDAAmB;AACzC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACO,mCAAmC,kDAAiB;AAC3D;AACA;AACA;AACA,IAAI,gDAAe;AACnB;AACA,KAAK;AACL,IAAI,gDAAe;AACnB;AACA,yCAAyC,gDAAe,iBAAiB;AACzE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,wCAAwC,kDAAiB;AAChE;AACA;AACA;AACA,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB;AACA;AACA;AACA;AACA,CAAC;AACM,mCAAmC,kDAAiB;AAC3D;AACA,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB;AACA,yCAAyC,gDAAe,iBAAiB;AACzE,KAAK;AACL,IAAI,gDAAe;AACnB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,kCAAkC,kDAAiB;AAC1D;AACA;AACA;AACA,IAAI,gDAAe;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACO,mCAAmC,kDAAiB;AAC3D;AACA;AACA,IAAI,gDAAe;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,sCAAsC,kDAAiB;AAC9D;AACA,IAAI,gDAAe;AACnB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO,kCAAkC,kDAAiB;AAC1D;AACA;AACA;AACA,sBAAsB,qDAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,CAAC;AACM,gCAAgC,kDAAiB;AACxD;AACA,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,mDAAkB,WAAW,4CAAW;AACvG,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,mDAAkB,WAAW,4CAAW;AAC/F,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,CAAC;AACM,8BAA8B,kDAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,CAAC;AACM,+BAA+B,kDAAiB;AACvD;AACA,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAwC;AACnE;AACO,gCAAgC,kDAAiB;AACxD;AACA,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4BAA4B;AAC7D;AACO,mCAAmC,kDAAiB;AAC3D;AACA,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACO,0CAA0C,kDAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,8BAA8B;AAClH;AACA;AACA;AACA,kEAAkE,iBAAiB;AACnF;AACA;AACA;AACA;AACA,kCAAkC,oDAAmB;AACrD,4BAA4B,iDAAgB,IAAI,KAAK;AACrD;AACA;AACA,8DAA8D,KAAK;AACnE;AACA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,CAAC;AACM,mCAAmC,kDAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gDAAK;AACtD;AACA;AACA,uBAAuB,gDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,qDAAU;AACjE;AACA;AACA,6BAA6B,qDAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACM,kCAAkC,kDAAiB;AAC1D;AACA;AACA,uFAAuF,0BAA0B;AACjH;AACA,CAAC;AACM,+BAA+B,kDAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB;AACA;AACA;AACA;AACA,CAAC;AACM,iCAAiC,kDAAiB;AACzD,IAAI,iDAAgB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAAU;AACtC;AACA;;;;;;;;;;;;;;;;;;;;;AC9iEiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,8CAA8C,0DAAc;AAC5D;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0CAA0C,0BAA0B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,SAAS;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,GAAG;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,iBAAiB,cAAc,cAAc;AACrH;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,wEAAwE,cAAc;AACtF,iCAAiC;AACjC,qBAAqB,mBAAmB,yBAAyB,IAAI,YAAY,GAAG,GAAG;AACvF;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,gCAAgC,UAAU,GAAG,YAAY;AACzD,uDAAuD,cAAc;AACrE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,GAAG;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yDAAyD;AAChE,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACO,mEAAmE;AAC1E,YAAY,yBAAyB;AACrC,oCAAoC,wBAAwB,2BAA2B;AACvF;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpbA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA,KAAK;AACL;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qGAAqG;AACrG;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,EAAE;AACpD;AACA;AACO;AACA;AACA;AACP,iCAAiC;AACjC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACO;AACP;AACA,uBAAuB;AACvB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,cAAc,MAAM;AACpB;AACO;AACP;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,IAAI;AAC9D;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,0DAA0D,IAAI;AAC9D;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,+CAA+C;AAC/C;AACA,SAAS;AACT,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,+CAA+C;AAC/C;AACA,SAAS;AACT,KAAK;AACL;AACA;AACO;AACP;AACA;AACA,6BAA6B;AAC7B,+CAA+C;AAC/C;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,8DAA8D,IAAI;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,8DAA8D,IAAI;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,8CAA8C;AAC9C;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACO;AACP,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;AC1oBO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJoC;AACD;AACnC,iEAAe,yDAAE,EAAC;;;;;;;;;;;;;;;;ACFsB;AACxC;AACA;AACA,kBAAkB,8BAA8B;AAChD,gBAAgB,+BAA+B;AAC/C,iBAAiB,+BAA+B;AAChD,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,wEAAwE,eAAe,kBAAkB,SAAS;AAClH;AACA,yDAAyD,SAAS,kBAAkB,SAAS;AAC7F;AACA;AACA;AACA,6DAA6D,6DAAuB,kBAAkB;AACtG,2EAA2E,qDAAe,oBAAoB;AAC9G;AACA;AACA;AACA;AACA,6DAA6D,0BAA0B,EAAE,KAAK,EAAE,0BAA0B,EAAE,sBAAsB;AAClJ,wDAAwD,0BAA0B,EAAE,KAAK,EAAE,yBAAyB;AACpH;AACA;AACA;AACA;AACA;AACA,uDAAuD,cAAc,UAAU,KAAK,EAAE,0BAA0B,EAAE,YAAY;AAC9H;AACA,mDAAmD,cAAc,UAAU,KAAK,EAAE,yBAAyB;AAC3G;AACA;AACA;AACA;AACA,6DAA6D,aAAa;AAC1E;AACA,8DAA8D,cAAc;AAC5E;AACA,6DAA6D,gBAAgB;AAC7E;AACA,gEAAgE,eAAe;AAC/E,0BAA0B,iDAAiD;AAC3E;AACA;AACA,gEAAgE,cAAc;AAC9E;AACA,8BAA8B,mCAAmC,MAAM,iCAAiC,IAAI,qDAAe,mBAAmB;AAC9I;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzGwC;AACxC;AACA;AACA,kBAAkB,mCAAmC;AACrD,gBAAgB,iCAAiC;AACjD,iBAAiB,oCAAoC;AACrD,eAAe,oCAAoC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,kEAAkE,eAAe,eAAe,SAAS;AACzG;AACA,mDAAmD,SAAS,eAAe,SAAS;AACpF;AACA;AACA;AACA,uDAAuD,6DAAuB,kBAAkB;AAChG,wEAAwE,qDAAe,oBAAoB;AAC3G;AACA;AACA;AACA;AACA,oDAAoD,yBAAyB,EAAE,IAAI,EAAE,0BAA0B,EAAE,yBAAyB;AAC1I,gDAAgD,yBAAyB,EAAE,IAAI,EAAE,yBAAyB;AAC1G;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc,EAAE,IAAI,EAAE,0BAA0B,EAAE,YAAY;AAClH,gDAAgD,cAAc,EAAE,IAAI,EAAE,yBAAyB;AAC/F;AACA;AACA;AACA;AACA,4CAA4C,cAAc;AAC1D;AACA,4CAA4C,cAAc;AAC1D;AACA,4CAA4C,gBAAgB;AAC5D;AACA,2CAA2C,gBAAgB;AAC3D,iCAAiC,gDAAgD;AACjF;AACA;AACA,uCAAuC,eAAe;AACtD;AACA,yCAAyC,mCAAmC,IAAI,qDAAe,mBAAmB;AAClH;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxGwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,mEAAmE,eAAe,aAAa,SAAS;AACxG;AACA,oDAAoD,SAAS,aAAa,SAAS;AACnF;AACA;AACA;AACA,yDAAyD,6DAAuB,kBAAkB;AAClG,+DAA+D,qDAAe,oBAAoB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,4BAA4B,UAAU,aAAa,EAAE,IAAI,EAAE,0BAA0B,EAAE,KAAK;AACxJ;AACA,wDAAwD,4BAA4B,eAAe,IAAI,EAAE,yBAAyB;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,cAAc,UAAU,aAAa,EAAE,IAAI,EAAE,0BAA0B,EAAE,KAAK;AACxI;AACA,sDAAsD,cAAc,eAAe,IAAI,EAAE,yBAAyB;AAClH;AACA;AACA;AACA;AACA,sEAAsE,cAAc;AACpF;AACA,yEAAyE,cAAc;AACvF;AACA,mEAAmE,gBAAgB;AACnF;AACA,4EAA4E,eAAe;AAC3F,sCAAsC,gDAAgD;AACtF;AACA;AACA,gEAAgE,cAAc;AAC9E;AACA,uCAAuC,yCAAyC,IAAI,qDAAe,mBAAmB;AACtH;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA,kDAAkD,aAAa;AAC/D;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3JwC;AACxC;AACA;AACA,kBAAkB,qCAAqC;AACvD,gBAAgB,mCAAmC;AACnD,iBAAiB,sCAAsC;AACvD,eAAe,sCAAsC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,iEAAiE,eAAe,YAAY,SAAS;AACrG;AACA,kDAAkD,SAAS,YAAY,SAAS;AAChF;AACA;AACA;AACA,sDAAsD,6DAAuB,kBAAkB;AAC/F,4DAA4D,qDAAe,oBAAoB;AAC/F;AACA;AACA;AACA;AACA,uDAAuD,4BAA4B,aAAa,IAAI,EAAE,0BAA0B,EAAE,0BAA0B;AAC5J,mDAAmD,4BAA4B,UAAU,IAAI,EAAE,yBAAyB;AACxH;AACA;AACA;AACA;AACA;AACA,sDAAsD,cAAc,aAAa,IAAI,EAAE,0BAA0B,EAAE,YAAY;AAC/H;AACA,kDAAkD,cAAc,UAAU,IAAI,EAAE,yBAAyB;AACzG;AACA;AACA;AACA;AACA,kEAAkE,cAAc;AAChF;AACA;AACA,mEAAmE,cAAc;AACjF;AACA,gEAAgE,gBAAgB;AAChF;AACA,iEAAiE,eAAe;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa,EAAE,gDAAgD;AACzF;AACA;AACA,oEAAoE,cAAc;AAClF;AACA,qCAAqC,kCAAkC,MAAM,mCAAmC,IAAI,qDAAe,mBAAmB;AACtJ;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA,+CAA+C,aAAa;AAC5D;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvHwC;AACxC;AACA;AACA,kBAAkB,qCAAqC;AACvD,gBAAgB,iCAAiC;AACjD,iBAAiB,oCAAoC;AACrD,eAAe,oCAAoC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,mEAAmE,eAAe,eAAe,SAAS;AAC1G;AACA,oDAAoD,SAAS,eAAe,SAAS;AACrF;AACA;AACA;AACA,wDAAwD,6DAAuB,kBAAkB;AACjG,4DAA4D,qDAAe,sBAAsB;AACjG;AACA;AACA;AACA;AACA,yDAAyD,4BAA4B,aAAa,KAAK,EAAE,0BAA0B,EAAE,0BAA0B;AAC/J,qDAAqD,4BAA4B,MAAM,KAAK,EAAE,yBAAyB;AACvH;AACA;AACA;AACA;AACA;AACA,0DAA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A+D,cAAc;AAC7E;AACA,0BAA0B,0DAA0D,IAAI,qDAAe,mBAAmB;AAC1H;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClHwC;AACxC;AACA;AACA,kBAAkB,mCAAmC;AACrD,gBAAgB,iCAAiC;AACjD,iBAAiB,oCAAoC;AACrD,eAAe,oCAAoC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,qEAAqE,eAAe,aAAa,SAAS;AAC1G;AACA,sDAAsD,SAAS,aAAa,SAAS;AACrF;AACA;AACA;AACA,0DAA0D,6DAAuB,kBAAkB;AACnG,8DAA8D,qDAAe,oBAAoB;AACjG;AACA;AACA;AACA;AACA,sDAAsD,wBAAwB,EAAE,IAAI,EAAE,0BAA0B,EAAE,2BAA2B;AAC7I,kDAAkD,wBAAwB,EAAE,IAAI,EAAE,0BAA0B;AAC5G;AACA;AACA;AACA;AACA;AACA,uDAAuD,cAAc,EAAE,IAAI,EAAE,0BAA0B,EAAE,aAAa;AACtH;AACA,mDAAmD,cAAc,EAAE,IAAI,EAAE,0BAA0B;AACnG;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA,2DAA2D,cAAc;AACzE;AACA,uDAAuD,gBAAgB;AACvE;AACA,iEAAiE,gBAAgB;AACjF,oCAAoC,gDAAgD;AACpF;AACA;AACA,kEAAkE,eAAe;AACjF;AACA,0BAA0B,yEAAyE,IAAI,qDAAe,mBAAmB;AACzI;AACA,kDAAkD,aAAa;AAC/D;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3GwC;AACxC;AACA;AACA,kBAAkB,qCAAqC;AACvD,gBAAgB,gCAAgC;AAChD,iBAAiB,gCAAgC;AACjD,eAAe,gCAAgC;AAC/C,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA,kDAAkD,SAAS,aAAa,SAAS;AACjF;AACA;AACA;AACA,sDAAsD,6DAAuB,kBAAkB;AAC/F,0DAA0D,qDAAe,oBAAoB;AAC7F;AACA;AACA;AACA;AACA,gDAAgD,yBAAyB,UAAU,IAAI,EAAE,0BAA0B,EAAE,0BAA0B;AAC/I,4CAA4C,yBAAyB,QAAQ,IAAI,EAAE,yBAAyB;AAC5G;AACA;AACA;AACA;AACA;AACA,kDAAkD,cAAc,UAAU,IAAI,EAAE,0BAA0B,EAAE,YAAY;AACxH;AACA,8CAA8C,cAAc,QAAQ,IAAI,EAAE,yBAAyB;AACnG;AACA;AACA;AACA;AACA,+DAA+D,cAAc;AAC7E;AACA;AACA,6DAA6D,cAAc;AAC3E;AACA,4DAA4D,gBAAgB;AAC5E;AACA,iEAAiE,eAAe;AAChF,kCAAkC,gDAAgD;AAClF;AACA;AACA,gEAAgE,cAAc;AAC9E;AACA,0CAA0C,iCAAiC,IAAI,qDAAe,mBAAmB;AACjH;AACA,yCAAyC,aAAa;AACtD;AACA;AACA;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5GwC;AACxC;AACA;AACA,kBAAkB,kCAAkC;AACpD,gBAAgB,+BAA+B;AAC/C,iBAAiB,kCAAkC;AACnD,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,mEAAmE,eAAe,cAAc,SAAS;AACzG;AACA,oDAAoD,SAAS,cAAc,SAAS;AACpF;AACA;AACA;AACA,wDAAwD,6DAAuB,kBAAkB;AACjG,2DAA2D,qDAAe,oBAAoB;AAC9F;AACA;AACA;AACA;AACA,uDAAuD,0BAA0B,OAAO,IAAI,EAAE,0BAA0B,EAAE,4BAA4B;AACtJ,mDAAmD,0BAA0B,OAAO,IAAI,EAAE,yBAAyB;AACnH;AACA;AACA;AACA;AACA;AACA,0DAA0D,cAAc,OAAO,IAAI,EAAE,0BAA0B,EAAE,YAAY;AAC7H;AACA,sDAAsD,cAAc,OAAO,IAAI,EAAE,yBAAyB;AAC1G;AACA;AACA;AACA;AACA,wEAAwE,cAAc;AACtF;AACA,qEAAqE,cAAc;AACnF;AACA,oEAAoE,gBAAgB;AACpF;AACA,+EAA+E,eAAe;AAC9F,mCAAmC,gDAAgD;AACnF;AACA;AACA,8DAA8D,cAAc;AAC5E;AACA,kCAAkC,kCAAkC,SAAS,iCAAiC,IAAI,qDAAe,mBAAmB;AACpJ;AACA,8CAA8C,aAAa;AAC3D;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5GwC;AACxC;AACA;AACA,kBAAkB,mCAAmC;AACrD,gBAAgB,8BAA8B;AAC9C,iBAAiB,kCAAkC;AACnD,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,uEAAuE,eAAe,aAAa,SAAS;AAC5G;AACA,wDAAwD,SAAS,aAAa,SAAS;AACvF;AACA;AACA;AACA,4DAA4D,6DAAuB,kBAAkB;AACrG,8DAA8D,qDAAe,oBAAoB;AACjG;AACA;AACA;AACA;AACA;AACA,gEAAgE,mBAAmB,UAAU,IAAI,EAAE,0BAA0B,EAAE,2BAA2B;AAC1J,4DAA4D,mBAAmB,QAAQ,IAAI,EAAE,yBAAyB;AACtH;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,QAAQ,UAAU,IAAI,EAAE,0BAA0B,EAAE,YAAY;AACjI;AACA,6DAA6D,QAAQ,QAAQ,IAAI,EAAE,yBAAyB;AAC5G;AACA;AACA;AACA;AACA,kEAAkE,cAAc;AAChF;AACA,iEAAiE,cAAc;AAC/E;AACA,6DAA6D,gBAAgB;AAC7E;AACA,4EAA4E,eAAe;AAC3F,mCAAmC,gDAAgD;AACnF;AACA;AACA,gEAAgE,cAAc;AAC9E;AACA,+BAA+B,kCAAkC,aAAa,iCAAiC,IAAI,qDAAe,mBAAmB;AACrJ;AACA,4CAA4C,6CAA6C;AACzF;AACA;AACA;AACA,4CAA4C,6CAA6C;AACzF;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnIwC;AACxC;AACA;AACA,kBAAkB,qCAAqC;AACvD,gBAAgB,kCAAkC;AAClD,iBAAiB,kCAAkC;AACnD,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,iEAAiE,gBAAgB,UAAU,UAAU;AACrG;AACA,kDAAkD,UAAU,UAAU,UAAU;AAChF;AACA;AACA;AACA,sDAAsD,6DAAuB,mBAAmB;AAChG;AACA,yDAAyD,qDAAe,qBAAqB;AAC7F;AACA;AACA;AACA;AACA,yCAAyC,yBAAyB,OAAO,IAAI,EAAE,0BAA0B,EAAE,uBAAuB;AAClI;AACA,qCAAqC,yBAAyB,OAAO,IAAI,EAAE,0BAA0B;AACrG;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc,OAAO,IAAI,EAAE,0BAA0B,EAAE,aAAa;AAC7G;AACA,qCAAqC,cAAc,OAAO,IAAI,EAAE,0BAA0B;AAC1F;AACA;AACA;AACA;AACA,qDAAqD,cAAc;AACnE;AACA;AACA,qDAAqD,cAAc;AACnE;AACA;AACA,uDAAuD,gBAAgB;AACvE;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA,0BAA0B,iDAAiD;AAC3E;AACA;AACA,iDAAiD,eAAe;AAChE;AACA,8BAA8B,oCAAoC,UAAU,qDAAe,mBAAmB;AAC9G;AACA,yCAAyC,aAAa;AACtD;AACA;AACA;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjHwC;AACxC;AACA;AACA,kBAAkB,yCAAyC;AAC3D,gBAAgB,qCAAqC;AACrD,iBAAiB,oCAAoC;AACrD,eAAe,oCAAoC;AACnD,kBAAkB,4BAA4B;AAC9C,kBAAkB,2CAA2C;AAC7D,eAAe,oCAAoC;AACnD,gBAAgB,kCAAkC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,yEAAyE,eAAe,QAAQ,SAAS;AACzG;AACA,0DAA0D,SAAS,QAAQ,SAAS;AACpF;AACA;AACA;AACA,8DAA8D,6DAAuB,kBAAkB;AACvG,8EAA8E,qDAAe,oBAAoB;AACjH;AACA;AACA;AACA;AACA,2CAA2C,gBAAgB,cAAc,IAAI,EAAE,0BAA0B,EAAE,YAAY;AACvH;AACA,yDAAyD,IAAI,EAAE,yBAAyB;AACxF;AACA;AACA;AACA;AACA;AACA,2CAA2C,gBAAgB,cAAc,IAAI,EAAE,0BAA0B,EAAE,YAAY;AACvH;AACA,yDAAyD,IAAI,EAAE,yBAAyB;AACxF;AACA;AACA;AACA;AACA,gEAAgE,cAAc;AAC9E;AACA,iEAAiE,cAAc;AAC/E;AACA,mEAAmE,gBAAgB;AACnF;AACA,yFAAyF,eAAe;AACxG;AACA,uCAAuC,gDAAgD;AACvF;AACA;AACA,+DAA+D,eAAe;AAC9E;AACA,0BAA0B,qEAAqE,IAAI,qDAAe,mBAAmB;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/GwC;AACxC;AACA;AACA,kBAAkB,mCAAmC;AACrD,gBAAgB,+BAA+B;AAC/C,iBAAiB,iCAAiC;AAClD,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,mEAAmE,eAAe,SAAS,SAAS;AACpG;AACA,oDAAoD,SAAS,SAAS,SAAS;AAC/E;AACA;AACA;AACA,wDAAwD,6DAAuB,kBAAkB;AACjG,gFAAgF,qDAAe,oBAAoB;AACnH;AACA;AACA;AACA;AACA,uDAAuD,6BAA6B,MAAM,IAAI,EAAE,0BAA0B,EAAE,YAAY;AACxI,mDAAmD,6BAA6B,OAAO,IAAI,EAAE,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sC;AACjL;AACA;AACA;AACA,2EAA2E,cAAc,cAAc,cAAc;AACrH,uCAAuC,SAAS,aAAa,WAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS,EAAE,MAAM,QAAQ,eAAe;AACnF;AACA;AACA,6BAA6B,eAAe,EAAE,oBAAoB;AAClE,oCAAoC,eAAe,EAAE,mBAAmB;AACxE,uCAAuC,SAAS,EAAE,MAAM,QAAQ,WAAW;AAC3E;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB,OAAO,SAAS,EAAE,IAAI,EAAE,IAAI,EAAE,0BAA0B,EAAE,YAAY;AACvH;AACA,0BAA0B,6BAA6B,OAAO,SAAS,EAAE,IAAI,EAAE,IAAI,EAAE,yBAAyB;AAC9G;AACA;AACA;AACA;AACA;AACA,sDAAsD,cAAc;AACpE;AACA,uDAAuD,cAAc;AACrE;AACA,mDAAmD,gBAAgB;AACnE;AACA,0DAA0D,eAAe;AACzE;AACA;AACA;AACA;AACA;AACA,0BAA0B,MAAM,KAAK,UAAU;AAC/C;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA,8BAA8B,mCAAmC,SAAS,mCAAmC,IAAI,qDAAe,mBAAmB;AACnJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,MAAM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrNwC;AACxC;AACA;AACA,kBAAkB,kCAAkC;AACpD,gBAAgB,8BAA8B;AAC9C,iBAAiB,8BAA8B;AAC/C,eAAe,8BAA8B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,2EAA2E,eAAe,mBAAmB,SAAS;AACtH;AACA,4DAA4D,SAAS,mBAAmB,SAAS;AACjG;AACA;AACA;AACA,gEAAgE,6DAAuB,kBAAkB;AACzG,mEAAmE,qDAAe,oBAAoB;AACtG;AACA;AACA;AACA;AACA,wCAAwC,yBAAyB,kBAAkB,IAAI,EAAE,0BAA0B,EAAE,sBAAsB;AAC3I,qDAAqD,yBAAyB,YAAY,IAAI,EAAE,yBAAyB;AACzH;AACA;AACA;AACA;AACA;AACA,0DAA0D,cAAc,mBAAmB,IAAI,EAAE,0BAA0B,EAAE,YAAY;AACzI;AACA,sDAAsD,cAAc,YAAY,IAAI,EAAE,yBAAyB;AAC/G;AACA;AACA;AACA;AACA,mDAAmD,cAAc;AACjE;AACA,mDAAmD,cAAc;AACjE;AACA,mDAAmD,gBAAgB;AACnE;AACA,kDAAkD,gBAAgB;AAClE,sCAAsC,gDAAgD;AACtF;AACA;AACA,4CAA4C,eAAe;AAC3D;AACA,0CAA0C,iCAAiC,IAAI,qDAAe,mBAAmB;AACjH;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3GwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,uEAAuE,eAAe,cAAc,SAAS;AAC7G;AACA,wDAAwD,SAAS,cAAc,SAAS;AACxF;AACA;AACA;AACA,4DAA4D,6DAAuB,kBAAkB;AACrG,wEAAwE,qDAAe,oBAAoB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,8CAA8C,UAAU,IAAI,EAAE,0BAA0B,EAAE,KAAK;AAChK;AACA,6DAA6D,8CAA8C,OAAO,IAAI,EAAE,yBAAyB;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,mCAAmC,UAAU,IAAI,EAAE,0BAA0B,EAAE,KAAK;AACtJ;AACA,8DAA8D,mCAAmC,OAAO,IAAI,EAAE,yBAAyB;AACvI;AACA;AACA;AACA;AACA,sDAAsD,cAAc;AACpE;AACA,wDAAwD,cAAc;AACtE;AACA,0DAA0D,gBAAgB;AAC1E;AACA,6DAA6D,gBAAgB;AAC7E,+BAA+B,gDAAgD;AAC/E;AACA;AACA,2DAA2D,cAAc;AACzE;AACA,0CAA0C,mCAAmC,IAAI,qDAAe,mBAAmB;AACnH;AACA,sCAAsC,kCAAkC;AACxE;AACA;AACA;AACA,qCAAqC,kCAAkC;AACvE;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClJwC;AACxC;AACA;AACA,kBAAkB,oCAAoC;AACtD,gBAAgB,gCAAgC;AAChD,iBAAiB,gCAAgC;AACjD,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,uEAAuE,eAAe,aAAa,SAAS;AAC5G;AACA,wDAAwD,SAAS,aAAa,SAAS;AACvF;AACA;AACA;AACA,4DAA4D,6DAAuB,kBAAkB;AACrG,0EAA0E,qDAAe,oBAAoB;AAC7G;AACA;AACA;AACA;AACA,wDAAwD,yBAAyB,WAAW,IAAI,EAAE,0BAA0B,EAAE,wBAAwB;AACtJ,oDAAoD,yBAAyB,UAAU,IAAI,EAAE,yBAAyB;AACtH;AACA;AACA;AACA;AACA;AACA,wDAAwD,cAAc,WAAW,IAAI,EAAE,0BAA0B,EAAE,YAAY;AAC/H;AACA,oDAAoD,cAAc,UAAU,IAAI,EAAE,yBAAyB;AAC3G;AACA;AACA;AACA;AACA,wEAAwE,cAAc;AACtF;AACA,yEAAyE,cAAc;AACvF;AACA,qEAAqE,gBAAgB;AACrF;AACA,oEAAoE,eAAe;AACnF,0BAA0B,iDAAiD;AAC3E;AACA;AACA,kEAAkE,cAAc;AAChF;AACA,+CAA+C,iCAAiC,IAAI,qDAAe,mBAAmB;AACtH;AACA,+CAA+C,aAAa;AAC5D;AACA;AACA;AACA,+CAA+C,aAAa;AAC5D;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzGwC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACK;AACA;AACL;;;;;;;;;;;;;;;;AChDA;AACxC;AACA;AACA,kBAAkB,gCAAgC;AAClD,gBAAgB,+BAA+B;AAC/C,iBAAiB,gCAAgC;AACjD,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,wDAAwD,UAAU,+BAA+B,eAAe;AAChH;AACA,oDAAoD,UAAU,oBAAoB,SAAS;AAC3F;AACA;AACA;AACA,0DAA0D,6DAAuB,kBAAkB;AACnG,kEAAkE,qDAAe,oBAAoB;AACrG;AACA;AACA;AACA;AACA,6DAA6D,yBAAyB,OAAO,IAAI,EAAE,0BAA0B,EAAE,uBAAuB;AACtJ,yDAAyD,yBAAyB,KAAK,IAAI,EAAE,yBAAyB;AACtH;AACA;AACA;AACA;AACA;AACA,6DAA6D,cAAc,OAAO,IAAI,EAAE,0BAA0B,EAAE,YAAY;AAChI;AACA,yDAAyD,cAAc,KAAK,IAAI,EAAE,yBAAyB;AAC3G;AACA;AACA;AACA;AACA,mEAAmE,cAAc;AACjF;AACA;AACA,kEAAkE,cAAc;AAChF;AACA,qEAAqE,gBAAgB;AACrF;AACA,yEAAyE,eAAe;AACxF,gCAAgC,gDAAgD;AAChF;AACA;AACA,iEAAiE,cAAc;AAC/E;AACA,iCAAiC,kDAAkD,IAAI,qDAAe,mBAAmB;AACzH;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA,wCAAwC,aAAa;AACrD;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5GwC;AACxC;AACA;AACA,kBAAkB,kCAAkC;AACpD,gBAAgB,6BAA6B;AAC7C,iBAAiB,iCAAiC;AAClD,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,kEAAkE,eAAe,aAAa,SAAS;AACvG;AACA,mDAAmD,SAAS,aAAa,SAAS;AAClF;AACA;AACA;AACA,uDAAuD,6DAAuB,kBAAkB;AAChG,6DAA6D,qDAAe,oBAAoB;AAChG;AACA;AACA;AACA;AAC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ACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9GwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,2CAA2C,SAAS,4BAA4B,eAAe;AAC/F;AACA,uCAAuC,SAAS,iBAAiB,SAAS;AAC1E;AACA;AACA;AACA,2CAA2C,6DAAuB,kBAAkB;AACpF,iDAAiD,qDAAe,qBAAqB;AACrF;AACA;AACA;AACA;AACA,8BAA8B,+DAA+D,EAAE,aAAa,EAAE,0BAA0B,EAAE,0BAA0B;AACpK;AACA,0BAA0B,+DAA+D,YAAY,KAAK,EAAE,0BAA0B,EAAE,aAAa;AACrJ;AACA;AACA;AACA;AACA;AACA,8BAA8B,+DAA+D,EAAE,aAAa,EAAE,0BAA0B,EAAE,0BAA0B;AACpK;AACA,0BAA0B,+DAA+D,YAAY,KAAK,EAAE,0BAA0B,EAAE,aAAa;AACrJ;AACA;AACA;AACA;AACA,wDAAwD,cAAc;AACtE;AACA;AACA,yDAAyD,cAAc;AACvE;AACA,uDAAuD,gBAAgB;AACvE;AACA,sDAAsD,eAAe;AACrE,sCAAsC,gDAAgD;AACtF;AACA;AACA,gDAAgD,eAAe;AAC/D;AACA,oCAAoC,oCAAoC,MAAM,oCAAoC,IAAI,qDAAe,mBAAmB;AACxJ;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+DAA+D;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1MwC;AACxC;AACA;AACA,kBAAkB,iCAAiC;AACnD,gBAAgB,iCAAiC;AACjD,iBAAiB,kCAAkC;AACnD,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,iEAAiE,eAAe,YAAY,SAAS;AACrG;AACA,kDAAkD,SAAS,YAAY,SAAS;AAChF;AACA;AACA;AACA,sDAAsD,6DAAuB,kBAAkB;AAC/F,0DAA0D,qDAAe,oBAAoB;AAC7F;AACA;AACA;AACA;AACA,yDAAyD,6BAA6B,SAAS,IAAI,EAAE,0BAA0B,EAAE,0BAA0B;AAC3J,qDAAqD,6BAA6B,UAAU,IAAI,EAAE,yBAAyB;AAC3H;AACA;AACA;AACA;AACA;AACA,uDAAuD,cAAc,SAAS,IAAI,EAAE,0BAA0B,EAAE,YAAY;AAC5H;AACA,mDAAmD,cAAc,UAAU,IAAI,EAAE,yBAAyB;AAC1G;AACA;AACA;AACA;AACA,oEAAoE,cAAc;AAClF;AACA;AACA,mEAAmE,cAAc;AACjF;AACA,gEAAgE,gBAAgB;AAChF;AACA,0EAA0E,eAAe;AACzF,kCAAkC,gDAAgD;AAClF;AACA;AACA,6DAA6D,cAAc;AAC3E;AACA,0BAA0B,sEAAsE,IAAI,qDAAe,mBAAmB;AACtI;AACA,yCAAyC,aAAa;AACtD;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5GwC;AACxC;AACA;AACA,kBAAkB,mCAAmC;AACrD,gBAAgB,iCAAiC;AACjD,iBAAiB,mCAAmC;AACpD,eAAe,mCAAmC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,mEAAmE,eAAe,aAAa,SAAS;AACxG;AACA,oDAAoD,SAAS,aAAa,SAAS;AACnF;AACA;AACA;AACA,wDAAwD,6DAAuB,kBAAkB;AACjG,0EAA0E,qDAAe,oBAAoB;AAC7G;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB,EAAE,aAAa,EAAE,IAAI,EAAE,0BAA0B,EAAE,wBAAwB;AAC1J,kDAAkD,yBAAyB,SAAS,IAAI,EAAE,yBAAyB;AACnH;AACA;AACA;AACA;AACA;AACA,sDAAsD,cAAc,EAAE,aAAa,EAAE,IAAI,EAAE,0BAA0B,EAAE,YAAY;AACnI;AACA,kDAAkD,cAAc,SAAS,IAAI,EAAE,yBAAyB;AACxG;AACA;AACA;AACA;AACA,sEAAsE,cAAc;AACpF;AACA,uEAAuE,cAAc;AACrF;AACA,mEAAmE,gBAAgB;AACnF;AACA,2EAA2E,eAAe;AAC1F,0BAA0B,iDAAiD;AAC3E;AACA;AACA,0DAA0D,cAAc;AA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nD,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,6DAA6D,eAAe,WAAW,SAAS;AAChG;AACA,8CAA8C,SAAS,WAAW,SAAS;AAC3E;AACA;AACA;AACA,kDAAkD,6DAAuB,kBAAkB;AAC3F,mDAAmD,qDAAe,oBAAoB;AACtF;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB,IAAI,IAAI,EAAE,0BAA0B,EAAE,2BAA2B;AACpI,uCAAuC,wBAAwB,IAAI,IAAI,EAAE,0BAA0B;AACnG;AACA;AACA;AACA;AACA;AACA,2CAA2C,aAAa,IAAI,IAAI,EAAE,0BAA0B,EAAE,aAAa;AAC3G;AACA,uCAAuC,aAAa,IAAI,IAAI,EAAE,0BAA0B;AACxF;AACA;AACA;AACA;AACA,4CAA4C,cAAc;AAC1D;AACA,4CAA4C,cAAc;AAC1D;AACA,4CAA4C,gBAAgB;AAC5D;AACA,2CAA2C,gBAAgB;AAC3D,gCAAgC,gDAAgD;AAChF;AACA;AACA,sCAAsC,eAAe;AACrD;AACA,6CAA6C,iCAAiC,IAAI,qDAAe,mBAAmB;AACpH;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5GwC;AACxC;AACA;AACA,kBAAkB,8BAA8B;AAChD,gBAAgB,8BAA8B;AAC9C,iBAAiB,iCAAiC;AAClD,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,kFAAkF,eAAe,cAAc,SAAS;AACxH;AACA,mEAAmE,SAAS,cAAc,SAAS;AACnG;AACA;AACA;AACA,uEAAuE,6DAAuB,kBAAkB;AAChH,4EAA4E,qDAAe,oBAAoB;AAC/G;AACA;AACA;AACA;AACA,8DAA8D,2BAA2B,cAAc,IAAI,EAAE,0BAA0B,EAAE,2BAA2B;AACpK;AACA,0DAA0D,2BAA2B,iBAAiB,IAAI,EAAE,yBAAyB;AACrI;AACA;AACA;AACA;AACA;AACA,8DAA8D,2BAA2B,cAAc,IAAI,EAAE,0BAA0B,EAAE,2BAA2B;AACpK;AACA,0DAA0D,2BAA2B,iBAAiB,IAAI,EAAE,yBAAyB;AACrI;AACA;AACA;AACA;AACA,+EAA+E,cAAc;AAC7F;AACA,8EAA8E,cAAc;AAC5F;AACA,wEAAwE,gBAAgB;AACxF;AACA,kFAAkF,eAAe;AACjG,8CAA8C,gDAAgD;AAC9F;AACA;AACA,yEAAyE,cAAc;AACvF;AACA,8CAA8C,iCAAiC,IAAI,qDAAe,mBAAmB;AACrH;AACA,gDAAgD,aAAa;AAC7D;AACA;AACA;AACA,kDAAkD,aAAa;AAC/D;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5GwC;AACxC;AACA;AACA,kBAAkB,4BAA4B;AAC9C,gBAAgB,6BAA6B;AAC7C,iBAAiB,4BAA4B;AAC7C,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,0DAA0D,gBAAgB,WAAW,UAAU;AAC/F;AACA,2CAA2C,UAAU,WAAW,UAAU;AAC1E;AACA;AACA;AACA,+CAA+C,6DAAuB,mBAAmB;AACzF;AACA,kDAAkD,qDAAe,qBAAqB;AACtF;AACA;AACA;AACA;AACA,uCAAuC,yBAAyB,OAAO,IAAI,EAAE,0BAA0B,EAAE,0BAA0B;AACnI;AACA,mCAAmC,yBAAyB,OAAO,IAAI,EAAE,0BAA0B;AACnG;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc,OAAO,IAAI,EAAE,0BAA0B,EAAE,aAAa;AAC7G;AACA,qCAAqC,cAAc,OAAO,IAAI,EAAE,0BAA0B;AAC1F;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA,+CAA+C,gBAAgB;AAC/D;AACA,0BAA0B,iDAAiD;AAC3E;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA,+BAA+B,2CAA2C,IAAI,qDAAe,mBAAmB;AAChH;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjHwC;AACxC;AACA;AACA,kBAAkB,iCAAiC;AACnD,gBAAgB,4BAA4B;AAC5C,iBAAiB,4BAA4B;AAC7C,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,iEAAiE,eAAe,aAAa,SAAS;AACtG;AACA,kDAAkD,SAAS,aAAa,SAAS;AACjF;AACA;AACA;AACA,yDAAyD,6DAAuB,kBAAkB;AAClG,2DAA2D,qDAAe,oBAAoB;AAC9F;AACA;AACA;AACA;AACA,yDAAyD,yBAAyB,UAAU,IAAI,EAAE,0BAA0B,EAAE,2BAA2B;AACzJ,qDAAqD,yBAAyB,QAAQ,IAAI,EAAE,yBAAyB;AACrH;AACA;AACA;AACA;AACA;AACA,0DAA0D,cAAc,UAAU,IAAI,EAAE,0BAA0B,EAAE,YAAY;AAChI;AACA,sDAAsD,cAAc,QAAQ,IAAI,EAAE,yBAAyB;AAC3G;AACA;AACA;AACA;AACA,gEAAgE,cAAc;AAC9E;AACA,iEAAiE,cAAc;AAC/E;AACA,4DAA4D,gBAAgB;AAC5E;AACA,0EAA0E,eAAe;AACzF,0BAA0B,iDAAiD;AAC3E;AACA;AACA,gEAAgE,cAAc;AAC9E;AACA,+BAA+B,kCAAkC,cAAc,iCAAiC,IAAI,qDAAe,mBAAmB;AACtJ;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3GwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,kEAAkE,eAAe,aAAa,SAAS;AACvG;AACA,mDAAmD,SAAS,aAAa,SAAS;AAClF;AACA;AACA;AACA,uDAAuD,6DAAuB,kBAAkB;AAChG,8DAA8D,qDAAe,oBAAoB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,4BAA4B,cAAc,IAAI,EAAE,0BAA0B,EAAE,KAAK;AACxJ;AACA,mEAAmE,4BAA4B,QAAQ,IAAI,EAAE,yBAAyB;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,cAAc,cAAc,IAAI,EAAE,0BAA0B,EAAE,KAAK;AAC5I;AACA,qEAAqE,cAAc,QAAQ,IAAI,EAAE,yBAAyB;AAC1H;AACA;AACA;AACA;AACA,oEAAoE,cAAc;AAClF;AACA,wEAAwE,cAAc;AACtF;AACA,iEAAiE,gBAAgB;AACjF;AACA,8EAA8E,eAAe;AAC7F,mCAAmC,gDAAgD;AACnF;AACA;AACA,8DAA8D,cAAc;AAC5E;AACA,sCAAsC,qCAAqC,MAAM,iCAAiC,IAAI,qDAAe,mBAAmB;AACxJ;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA,8CAA8C,aAAa;AAC3D;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3JwC;AACxC;AACA;AACA,kBAAkB,+BAA+B;AACjD,gBAAgB,+BAA+B;AAC/C,iBAAiB,kCAAkC;AACnD,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,sEAAsE,eAAe,YAAY,SAAS;AAC1G;AACA,uDAAuD,SAAS,YAAY,SAAS;AACrF;AACA;AACA;AACA,2DAA2D,6DAAuB,kBAAkB;AACpG,oEAAoE,qDAAe,oBAAoB;AACvG;AACA;AACA;AACA;AACA,4DAA4D,4BAA4B,QAAQ,IAAI,EAAE,0BAA0B,EAAE,2BAA2B;AAC7J,wDAAwD,4BAA4B,EAAE,IAAI,EAAE,yBAAyB;AACrH;AACA;AACA;AACA;AACA;AACA,4DAA4D,cAAc,QAAQ,IAAI,EAAE,0BAA0B,EAAE,YAAY;AAChI;AACA,wDAAwD,cAAc,EAAE,IAAI,EAAE,yBAAyB;AACvG;AACA;AACA;AACA;AACA,gEAAgE,cAAc;AAC9E;AACA;AACA,iEAAiE,cAAc;AAC/E;AACA,8DAA8D,gBAAgB;AAC9E;AACA,oEAAoE,eAAe;AACnF,qCAAqC,gDAAgD;AACrF;AACA;AACA,mEAAmE,cAAc;AACjF;AACA,qCAAqC,8CAA8C,IAAI,qDAAe,mBAAmB;AACzH;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA,gDAAgD,aAAa;AAC7D;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5GwC;AACxC;AACA;AACA,kBAAkB,gCAAgC;AAClD,gBAAgB,+BAA+B;AAC/C,iBAAiB,uCAAuC;AACxD,eAAe,uCAAuC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,sEAAsE,eAAe,SAAS,SAAS;AACvG;AACA,uDAAuD,SAAS,SAAS,SAAS;AAClF;AACA;AACA;AACA,2DAA2D,6DAAuB,kBAAkB;AACpG,yDAAyD,qDAAe,oBAAoB;AAC5F;AACA;AACA;AACA;AACA,sDAAsD,0BAA0B,SAAS,IAAI,EAAE,0BAA0B,EAAE,yBAAyB;AACpJ;AACA,iDAAiD,0BAA0B,SAAS,IAAI,EAAE,yBAAyB;AACnH;AACA;AACA;AACA;AACA;AACA,sDAAsD,0BAA0B,SAAS,IAAI,EAAE,0BAA0B,EAAE,YAAY;AACvI;AACA,kDAAkD,0BAA0B,SAAS,IAAI,EAAE,yBAAyB;AACpH;AACA;AACA;AACA;AACA,+DAA+D,cAAc;AAC7E;AACA;AACA,+DAA+D,cAAc;AAC7E;AACA,+DAA+D,gBAAgB;AAC/E;AACA,qEAAqE,eAAe;AACpF,qCAAqC,gDAAgD;AACrF;AACA;AACA,kEAAkE,cAAc;AAChF;AACA,0BAA0B,0DAA0D,IAAI,qDAAe,mBAAmB;AAC1H;AACA,2CAA2C,yBAAyB;AACpE;AACA;AACA;AACA,2CAA2C,yBAAyB;AACpE;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7GwC;AACxC;AACA;AACA,kBAAkB,oDAAoD;AACtE,gBAAgB,iDAAiD;AACjE,iBAAiB,kDAAkD;AACnE,eAAe,kDAAkD;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,6EAA6E,eAAe,gBAAgB,SAAS;AACrH;AACA,8DAA8D,SAAS,gBAAgB,SAAS;AAChG;AACA;AACA;AACA,kEAAkE,6DAAuB,kBAAkB;AAC3G,gEAAgE,qDAAe,qBAAqB;AACpG;AACA;AACA;AACA;AACA,gEAAgE,2BAA2B,EAAE,IAAI,EAAE,0BAA0B,EAAE,6BAA6B;AAC5J;AACA,4DAA4D,2BAA2B,EAAE,IAAI,EAAE,0BAA0B;AACzH;AACA;AACA;AACA;AACA;AACA,kEAAkE,cAAc,EAAE,IAAI,EAAE,0BAA0B,EAAE,aAAa,qBAAqB;AACtJ;AACA,8DAA8D,cAAc,EAAE,IAAI,EAAE,0BAA0B;AAC9G;AACA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA,2CAA2C,cAAc;AACzD;AACA,2CAA2C,gBAAgB;AAC3D;AACA,0CAA0C,gBAAgB;AAC1D,gCAAgC,gDAAgD;AAChF;AACA;AACA,qCAAqC,eAAe;AACpD;AACA,+CAA+C,mCAAmC,IAAI,qDAAe,mBAAmB;AACxH;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7GwC;AACxC;AACA;AACA,kBAAkB,iCAAiC;AACnD,gBAAgB,6BAA6B;AAC7C,iBAAiB,+BAA+B;AAChD,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,yEAAyE,gBAAgB,YAAY,SAAS;AAC9G;AACA,0DAA0D,UAAU,YAAY,SAAS;AACzF;AACA;AACA;AACA,qDAAqD,6DAAuB,kBAAkB;AAC9F,6DAA6D,qDAAe,oBAAoB;AAChG;AACA;AACA;AACA;AACA,yCAAyC,uBAAuB,OAAO,KAAK,EAAE,0BAA0B,EAAE,wBAAwB;AAClI,qCAAqC,uBAAuB,OAAO,KAAK,EAAE,yBAAyB;AACnG;AACA;AACA;AACA;AACA;AACA,6CAA6C,cAAc,OAAO,KAAK,EAAE,0BAA0B,EAAE,YAAY;AACjH;AACA,yCAAyC,cAAc,OAAO,KAAK,EAAE,yBAAyB;AAC9F;AACA;AACA;AACA;AACA,wEAAwE,cAAc;AACtF;AACA;AACA,uEAAuE,cAAc;AACrF;AACA,+DAA+D,gBAAgB;AAC/E;AACA,yEAAyE,eAAe;AACxF,4CAA4C,gDAAgD;AAC5F;AACA;AACA,oEAAoE,eAAe;AACnF;AACA,8CAA8C,qDAAe,mBAAmB;AAChF;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7GwC;AACxC;AACA;AACA,kBAAkB,kCAAkC;AACpD,gBAAgB,8BAA8B;AAC9C,iBAAiB,6BAA6B;AAC9C,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,kEAAkE,eAAe,WAAW,SAAS;AACrG;AACA,mDAAmD,SAAS,WAAW,SAAS;AAChF;AACA;AACA;AACA,uDAAuD,6DAAuB,kBAAkB;AAChG,yEAAyE,qDAAe,oBAAoB;AAC5G;AACA;AACA;AACA;AACA,kDAAkD,yBAAyB,EAAE,IAAI,EAAE,0BAA0B,EAAE,qBAAqB;AACpI,8CAA8C,yBAAyB,EAAE,IAAI,EAAE,yBAAyB;AACxG;AACA;AACA;AACA;AACA;AACA,kDAAkD,cAAc,EAAE,IAAI,EAAE,0BAA0B,EAAE,YAAY;AAChH,8CAA8C,cAAc,EAAE,IAAI,EAAE,yBAAyB;AAC7F;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA,+CAA+C,cAAc;AAC7D;AACA,+CAA+C,gBAAgB;AAC/D;AACA,8CAA8C,gBAAgB;AAC9D,mCAAmC,gDAAgD;AACnF;AACA;AACA,yCAAyC,eAAe;AACxD;AACA,4CAA4C,mCAAmC,IAAI,qDAAe,mBAAmB;AACrH;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxGyB;AACzB;AACA,6BAAe,sCAAY;AAC3B,WAAW,kDAAE;AACb;;;;;;;;;;;;;;;;ACJwC;AACxC;AACA;AACA,kBAAkB,kCAAkC;AACpD,gBAAgB,gCAAgC;AAChD,iBAAiB,mCAAmC;AACpD,eAAe,mCAAmC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,6EAA6E,eAAe,aAAa,SAAS;AAClH;AACA,8DAA8D,SAAS,aAAa,SAAS;AAC7F;AACA;AACA;AACA,kEAAkE,6DAAuB,kBAAkB;AAC3G,+DAA+D,qDAAe,oBAAoB;AAClG;AACA;AACA;AACA;AACA,6DAA6D,4BAA4B,EAAE,aAAa,EAAE,IAAI,EAAE,0BAA0B,EAAE,2BAA2B;AACvK,yDAAyD,4BAA4B,OAAO,IAAI,EAAE,yBAAyB;AAC3H;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc,EAAE,aAAa,EAAE,IAAI,EAAE,0BAA0B,EAAE,YAAY;AACxI;AACA,uDAAuD,cAAc,OAAO,IAAI,EAAE,yBAAyB;AAC3G;AACA;AACA;AACA;AACA,wEAAwE,cAAc;AACtF;AACA,4EAA4E,cAAc;AAC1F;AACA,mEAAmE,gBAAgB;AACnF;AACA,8EAA8E,eAAe;AAC7F,uCAAuC,gDAAgD;AACvF;AACA;AACA,kEAAkE,cAAc;AAChF;AACA,4CAA4C,iCAAiC,IAAI,qDAAe,mBAAmB;AACnH;AACA,8CAA8C,aAAa;AAC3D;AACA;AACA;AACA,iDAAiD,aAAa;AAC9D;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3GwC;AACxC;AACA;AACA,kBAAkB,4BAA4B;AAC9C,gBAAgB,6BAA6B;AAC7C,iBAAiB,6BAA6B;AAC9C,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,oDAAoD,gBAAgB,aAAa,UAAU;AAC3F;AACA,qCAAqC,UAAU,aAAa,UAAU;AACtE;AACA;AACA;AACA,yCAAyC,6DAAuB,mBAAmB;AACnF,oCAAoC,qDAAe,qBAAqB;AACxE;AACA;AACA;AACA;AACA,uCAAuC,yBAAyB,KAAK,IAAI,EAAE,0BAA0B,EAAE,wBAAwB;AAC/H,mCAAmC,yBAAyB,KAAK,IAAI,EAAE,0BAA0B;AACjG;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc,KAAK,IAAI,EAAE,0BAA0B,EAAE,aAAa;AAC3G;AACA,qCAAqC,cAAc,KAAK,IAAI,EAAE,0BAA0B;AACxF;AACA;AACA;AACA;AACA,0CAA0C,cAAc;AACxD;AACA;AACA,0CAA0C,cAAc;AACxD;AACA,0CAA0C,gBAAgB;AAC1D;AACA,+CAA+C,gBAAgB;AAC/D,8BAA8B,gDAAgD;AAC9E;AACA;AACA,oCAAoC,eAAe;AACnD;AACA,0CAA0C,iCAAiC,IAAI,qDAAe,mBAAmB;AACjH;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7GwC;AACxC;AACA;AACA,kBAAkB,uCAAuC;AACzD,gBAAgB,sCAAsC;AACtD,iBAAiB,yCAAyC;AAC1D,eAAe,yCAAyC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,oEAAoE,eAAe,mBAAmB,SAAS;AAC/G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mCAAmC,eAAe;AAClD;AACA,uCAAuC,qDAAe,mBAAmB;AACzE;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5GwC;AACxC;AACA;AACA,kBAAkB,wBAAwB;AAC1C,gBAAgB,yBAAyB;AACzC,iBAAiB,wBAAwB;AACzC,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA,oDAAoD,eAAe,OAAO,SAAS;AACnF;AACA,qCAAqC,SAAS,OAAO,SAAS;AAC9D;AACA;AACA;AACA,yCAAyC,6DAAuB,kBAAkB;AAClF,0CAA0C,qDAAe,oBAAoB;AAC7E;AACA;AACA;AACA;AACA,sCAAsC,qBAAqB,KAAK,IAAI,EAAE,0BAA0B,EAAE,qBAAqB;AACvH,kCAAkC,qBAAqB,KAAK,IAAI,EAAE,yBAAyB;AAC3F;AACA;AACA;AACA;AACA;AACA,sCAAsC,cAAc,KAAK,IAAI,EAAE,0BAA0B,EAAE,YAAY;AACvG;AACA,kCAAkC,cAAc,KAAK,IAAI,EAAE,yBAAyB;AACpF;AACA;AACA;AACA;AACA,yCAAyC,cAAc;AACvD;AACA;AACA,yCAAyC,cAAc;AACvD;AACA,0CAA0C,gBAAgB;AAC1D;AACA,2CAA2C,eAAe;AAC1D,8BAA8B,gDAAgD;AAC9E;AACA;AACA,oCAAoC,eAAe;AACnD;AACA,iCAAiC,iCAAiC,GAAG,qDAAe,kBAAkB;AACtG;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;AAC3B;AACA;AACA;AACA;;;;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B;AACA;AACA;AACO;AACP,WAAW,mDAAY;AACvB;AACO,oCAAoC,wDAAiB;AAC5D,IAAI,sDAAe;AACnB;AACA,CAAC;AACD;AACO;AACP,WAAW,mDAAY;AACvB;AACO,uCAAuC,wDAAiB;AAC/D,IAAI,yDAAkB;AACtB;AACA,CAAC;AACD;AACA;AACA,WAAW,sDAAe;AAC1B;AACmC;AAC5B,kCAAkC,wDAAiB;AAC1D,IAAI,oDAAa;AACjB;AACA,CAAC;AACD;AACA;AACA,WAAW,iDAAU;AACrB;AACyB;AAClB,iCAAiC,wDAAiB;AACzD,IAAI,mDAAY;AAChB;AACA,CAAC;AACD;AACO;AACP,WAAW,gDAAS;AACpB;AACO,qCAAqC,wDAAiB;AAC7D,IAAI,uDAAgB;AACpB;AACA,CAAC;AACD;AACO;AACP,WAAW,oDAAa;AACxB;AACO,mCAAmC,wDAAiB;AAC3D,IAAI,qDAAc;AAClB;AACA,CAAC;AACD;AACO;AACP,WAAW,kDAAW;AACtB;AACO,kCAAkC,wDAAiB;AAC1D,IAAI,oDAAa;AACjB;AACA,CAAC;AACD;AACA;AACA,WAAW,iDAAU;AACrB;AACyB;AAClB,kCAAkC,wDAAiB;AAC1D,IAAI,oDAAa;AACjB;AACA,CAAC;AACD;AACO;AACP,WAAW,iDAAU;AACrB;AACO,mCAAmC,wDAAiB;AAC3D,IAAI,qDAAc;AAClB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,WAAW,0DAAoB;AAC/B,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACO,oCAAoC,wDAAiB;AAC5D,IAAI,sDAAe;AACnB;AACA,IAAI,qDAAe;AACnB,CAAC;AACD;AACO;AACP;AACA;AACA,0BAA0B;AAC1B,WAAW,0DAAoB;AAC/B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,0DAAoB;AAC/B,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,0DAAoB;AAC/B,KAAK;AACL;AACA;AACA;AACO;AACP,WAAW,iDAAW;AACtB;AACA;AACO;AACP,WAAW,qDAAe;AAC1B;AACA;AACO;AACP,WAAW,iDAAW;AACtB;AACA;AACO;AACP,WAAW,+CAAS;AACpB;AACA;AACA;AACO;AACP,WAAW,+CAAS;AACpB;AACA;AACO;AACP,WAAW,kDAAY;AACvB;AACA;AACO;AACP,WAAW,mDAAa;AACxB;AACA;AACO;AACP,wBAAwB,sCAAsC;AAC9D;AACO,mCAAmC,wDAAiB;AAC3D,IAAI,qDAAc;AAClB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,WAAW,0DAAoB;AAC/B,KAAK;AACL;AACO,iCAAiC,wDAAiB;AACzD;AACA,IAAI,mDAAY;AAChB,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,0DAAoB;AAC/B,KAAK;AACL;AACO,gDAAgD,wDAAiB;AACxE,IAAI,kEAA2B;AAC/B;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,0DAAoB;AAC/B,KAAK;AACL;AACO,0CAA0C,wDAAiB;AAClE,IAAI,4DAAqB;AACzB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACO,mCAAmC,wDAAiB;AAC3D,IAAI,qDAAc;AAClB;AACA,CAAC;AACD;AACO;AACP,6CAA6C,oDAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0DAAoB;AAC/B,KAAK;AACL;AACO,oCAAoC,wDAAiB;AAC5D,IAAI,sDAAe;AACnB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,0DAAoB;AAC/B,KAAK;AACL;AACA;AACO;AACP,cAAc,iDAAU;AACxB;AACA;AACA;AACA;AACA;AACA,WAAW,0DAAoB;AAC/B,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,0DAAoB;AAC/B,KAAK;AACL;AACO,iCAAiC,wDAAiB;AACzD,IAAI,mDAAY;AAChB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,0DAAoB;AAC/B,KAAK;AACL;AACO,iCAAiC,wDAAiB;AACzD,IAAI,mDAAY;AAChB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,WAAW,0DAAoB;AAC/B,KAAK;AACL;AACO,kCAAkC,wDAAiB;AAC1D,IAAI,oDAAa;AACjB;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0DAAoB;AAC/B,KAAK;AACL;AACyB;AACzB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACO;AACP;AACA;AACA;AACA,WAAW,0DAAoB;AAC/B,KAAK;AACL;AACO,qCAAqC,wDAAiB;AAC7D,IAAI,uDAAgB;AACpB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,WAAW,0DAAoB;AAC/B,KAAK;AACL;AACO,kCAAkC,wDAAiB;AAC1D,IAAI,oDAAa;AACjB;AACA,CAAC;AACD;AACO;AACP,WAAW,iDAAU;AACrB;AACO,uCAAuC,wDAAiB;AAC/D,IAAI,yDAAkB;AACtB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACO,sCAAsC,wDAAiB;AAC9D,IAAI,wDAAiB;AACrB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACO,2CAA2C,wDAAiB;AACnE,IAAI,6DAAsB;AAC1B;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACO,sCAAsC,wDAAiB;AAC9D,IAAI,wDAAiB;AACrB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACO,qCAAqC,wDAAiB;AAC7D,IAAI,uDAAgB;AACpB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA;AACA,yEAAyE,uDAAiB;AAC1F,SAAS;AACT,KAAK;AACL;AACO,sCAAsC,wDAAiB;AAC9D,IAAI,wDAAiB;AACrB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA;AACA,yEAAyE,uDAAiB;AAC1F,SAAS;AACT,KAAK;AACL;AACO,yCAAyC,wDAAiB;AACjE,IAAI,2DAAoB;AACxB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,WAAW,0DAAoB;AAC/B,KAAK;AACL;AACO,qCAAqC,wDAAiB;AAC7D,IAAI,uDAAgB;AACpB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACO,mCAAmC,wDAAiB;AAC3D,IAAI,qDAAc;AAClB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AAC2B;AACpB,iCAAiC,wDAAiB;AACzD,IAAI,mDAAY;AAChB;AACA,CAAC;AACD;AACO;AACP,WAAW,gDAAS;AACpB;AACO,kCAAkC,wDAAiB;AAC1D,IAAI,oDAAa;AACjB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACO,mCAAmC,wDAAiB;AAC3D;AACA,IAAI,qDAAc;AAClB,CAAC;AACD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO,sCAAsC,wDAAiB;AAC9D,IAAI,wDAAiB;AACrB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACO,6CAA6C,wDAAiB;AACrE,IAAI,+DAAwB;AAC5B;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,WAAW,0DAAoB;AAC/B,KAAK;AACL;AACO,kCAAkC,wDAAiB;AAC1D,IAAI,oDAAa;AACjB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACyB;AAClB,qCAAqC,wDAAiB;AAC7D,IAAI,uDAAgB;AACpB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACO,oCAAoC,wDAAiB;AAC5D,IAAI,sDAAe;AACnB;AACA,CAAC;AACD;AACA;AACO;AACP,mBAAmB,qDAAc;AACjC;AACA,WAAW,0DAAoB;AAC/B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,mDAAY;AACvB;AACA;AACA;AACO,gCAAgC;AACvC,WAAW,mDAAY;AACvB;AACA;AACA;AACO;AACP,WAAW,wDAAiB;AAC5B;AACA;AACO,iBAAiB,oDAAa;AAC9B,aAAa,gDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACqC;AACrC;AACO,gCAAgC,uDAAgB;AACvD;AACA;AACA;AACA,CAAC;AACD;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;AACO,sCAAsC,wDAAiB;AAC9D,IAAI,wDAAiB;AACrB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACiC;;;;;;;;;;;;;;;;;;;AC55BjC;AACA;AACA;AACkD;AACF;AAChD,2BAA2B,sDAAI,CAAC,sDAAG;AACnC;AACA;AACA,yBAAyB,sDAAI,CAAC,uDAAI;AAClC;AACA,GAAG;AACH,CAAC;AACD,iEAAe,KAAK,EAAC;AACrB,iC;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACkD;AACF;AAChD,gCAAgC,sDAAI,CAAC,sDAAG;AACxC;AACA;AACA,yBAAyB,sDAAI,CAAC,uDAAI;AAClC;AACA,GAAG;AACH,CAAC;AACD,iEAAe,UAAU,EAAC;AAC1B,uC;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACkD;AACF;AAChD,+BAA+B,sDAAI,CAAC,sDAAG;AACvC;AACA;AACA,yBAAyB,sDAAI,CAAC,uDAAI;AAClC;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD,iEAAe,SAAS,EAAC;AACzB,sC;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACkD;AACF;AAChD,gCAAgC,sDAAI,CAAC,sDAAG;AACxC;AACA;AACA,yBAAyB,sDAAI,CAAC,uDAAI;AAClC;AACA,GAAG;AACH,CAAC;AACD,iEAAe,UAAU,EAAC;AAC1B,uC;;;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACwE;AAC1B;AACE;AAChD;AACA;AACA;AACA,kBAAkB,8DAAW;AAC7B,gBAAgB;AAChB;AACA;AACA,CAAC;AACD,sBAAsB,sDAAI,CAAC,uDAAI;AAC/B;AACA;AACA;AACA;AACA,WAAW,wDAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,wDAAQ;AACd;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,uBAAuB,wDAAQ;AAC/B;AACA;AACA;AACA;AACA,OAAO;AACP,0BAA0B,sDAAI;AAC9B;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA,kBAAkB,yDAAM;AACxB;AACA;AACA,CAAC;AACD,sBAAsB,sDAAI,CAAC,uDAAI;AAC/B;AACA;AACA;AACA,KAAK;AACL,0BAA0B,sDAAI;AAC9B;AACA;AACA;AACA,UAAU;AACV;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA,iEAAe,UAAU,EAAC;AAC1B,iC;;;;;;;;;;;;;;;;AC3EA;AACA;AACA;AACuD;AACvD,iEAAe,qEAAiB;AAChC;AACA;AACA,0CAA0C,aAAa,GAAG,cAAc;AACxE;AACA,CAAC,CAAC,EAAC;AACH,iC;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACwB;;AAExB;AACA;AACA;AAC8C;;AAE9C;AACA;AACA;AACmE;AACnB;AACE;AACQ;AAC1D;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oCAAoC,sDAAI,CAAC,kEAAuB;AAChE,UAAU,wDAAU;AACpB;AACA,GAAG;AACH,sBAAsB,uDAAK,CAAC,uDAAS;AACrC,4BAA4B,uDAAK;AACjC;AACA,kDAAkD,sDAAI;AACtD;AACA;AACA,OAAO;AACP,KAAK,gBAAgB,uDAAK;AAC1B,iBAAiB,gDAAI;AACrB;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,iEAAe,uBAAuB,EAAC;AACvC,iC;;;;;;;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACyC;AACQ;;AAEjD;AACA;AACA;AACmE;AAC3B;AACQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB,sDAAI,CAAC,2DAAQ;AAChC;AACA,CAAC;AACc;AACf;AACA;AACA;AACA;AACA,CAAC;AACD,sBAAsB,sDAAI,CAAC,kEAAuB;AAClD;AACA,0BAA0B,sDAAI,CAAC,oDAAU;AACzC;AACA,6BAA6B,MAAM,GAAG,OAAO;AAC7C;AACA,iBAAiB,MAAM;AACvB;AACA,OAAO;AACP,KAAK;AACL;AACA,kBAAkB,wDAAK;AACvB;AACA;AACA;AACA,GAAG;AACH;AACA,iC;;;;;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AAC+C;AACU;;AAEzD;AACA;AACA;AACsD;AACe;;AAErE;AACA;AACA;AACA,WAAW,0BAA0B;AACrC,YAAY,SAAS;AACrB;AACA;AACgD;AAChD;AACA;AACA;AACA;AACA,OAAO,yDAAM;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,qBAAqB,0DAAS,kBAAkB,yCAAc;AAC9D;AACA;AACA;AACA,IAAI,EAAE,4DAAW,CAAC,yCAAc;AAChC,sBAAsB,sDAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,iEAAe,uEAAwB,yBAAyB,EAAC;AACjE,iC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACwB;;AAExB;AACA;AACA;AAC4I;AACnF;AACpB;AAC2B;AACC;AACJ;AACM;AACkB;;AAErF;AACA;AACA;AACmE;AACc;AACd;AACM;AAC/B;AACY;AACN;AACU;AACR;AAClD;AACA;AACA;AACA;AACA,CAAC;AACD,sBAAsB,uDAAI,CAAC,uDAAI;AAC/B,+BAA+B,MAAM;AACrC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,wBAAwB,qEAAgB;AACxC,2BAA2B,qEAAgB;AAC3C;AACA;AACA;AACA;AACA,6BAA6B,gEAAW;AACxC,2BAA2B,gEAAW;AACtC,uBAAuB,4DAAQ,GAAG;AAClC,EAAE,6DAAS;AACX,eAAe;AACf,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAI,CAAC,uDAAI;AAC/B,+BAA+B,MAAM;AACrC,2BAA2B,uDAAI,CAAC,4EAAe;AAC/C;AACA,+DAA+D,uDAAI,CAAC,mEAAM;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uDAAI;AACnC;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,6BAA6B,0DAAM;AACnC,oCAAoC,0DAAM;AAC1C;AACA;AACA;AACA,IAAI,EAAE,4DAAW,CAAC,0CAAc;AAChC,EAAE,6DAAS;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,eAAe,mDAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,gCAAgC,4DAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE,0DAAS;AACf;AACA;AACA;AACA;AACA,MAAM,SAAS,0CAAc;AAC7B;AACA;AACA,MAAM,SAAS,yDAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAa;AACnC,sBAAsB,sDAAa;AACnC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE,4DAAW,CAAC,0CAAc;AAChC,EAAE,6DAAS;AACX;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,sBAAsB,wDAAK,CAAC,wDAAS;AACrC,0CAA0C,uDAAI,CAAC,sDAAW;AAC1D;AACA,yCAAyC,uDAAI,CAAC,mEAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAK;AACpC;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK,sCAAsC,uDAAI,CAAC,2EAA6B;AAC7E;AACA;AACA;AACA;AACA,KAAK,gBAAgB,wDAAK;AAC1B;AACA;AACA,iBAAiB,gDAAI;AACrB;AACA;AACA,8BAA8B,uDAAI,CAAC,mEAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,yCAAyC,wDAAK,CAAC,wDAAS;AACxD,kCAAkC,uDAAI;AACtC;AACA;AACA,WAAW,8BAA8B,uDAAI,CAAC,yDAAM;AACpD;AACA,6BAA6B,wDAAU,GAAG,wDAAS;AACnD,8BAA8B,mDAAE,yBAAyB,mDAAE;AAC3D;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO,gBAAgB,uDAAI,CAAC,wDAAK;AACjC;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA,iCAAiC,wEAA4B;AAC7D;AACA,iEAAe,wBAAwB,EAAC;AACxC,iC;;;;;;;;;;;;;;;;AC5QA;AACA;AACA;AAC+C;AAC/C;AACA;AACA,CAAC;AACD,EAAE,6DAAS;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE,6DAAS;AACX;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,iEAAe,cAAc,EAAC;AAC9B,iC;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtCoE;AAC2B;AACjC;AACM;AACZ;AACF;AACU;AAChE,iC;;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACwB;;AAExB;AACA;AACA;AAC2D;AAC0G;AAC5H;AACgE;;AAEzG;AACA;AACA;AACkD;AACF;AACE;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,6DAAS;AACX,oEAAoE,UAAU;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,iEAAiE,qEAAiB;AAClF,2BAA2B,oEAAgB;AAC3C,wBAAwB,oEAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,+BAA+B,mFAAkB;AACjD;AACA;AACA;AACA,YAAY,mDAAE;AACd;AACA,UAAU,mDAAE;AACZ;AACA,sBAAsB,mDAAE;AACxB;AACA,aAAa,mDAAE;AACf;AACA,aAAa,mDAAE;AACf;AACA,YAAY,mDAAE;AACd;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAK;AAC3B,0DAA0D;AAC1D,SAAS,gEAAY;AACrB,eAAe,gDAAI;AACnB,4BAA4B,uDAAK;AACjC;AACA,8BAA8B,sDAAI,CAAC,4EAAe;AAClD;AACA,2CAA2C,sDAAI,CAAC,yDAAe;AAC/D,cAAc,mEAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO,qCAAqC,sDAAI;AAChD;AACA;AACA,OAAO,gBAAgB,uDAAK;AAC5B;AACA,gCAAgC,sDAAI,CAAC,4EAAe;AACpD;AACA,uDAAuD,sDAAI,CAAC,yDAAe;AAC3E;AACA;AACA,gBAAgB,mEAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA,mCAAmC,uDAAK,CAAC,mEAAM;AAC/C;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS,gBAAgB,sDAAI,CAAC,yDAAe;AAC7C;AACA;AACA;AACA,SAAS,6BAA6B,sDAAI,CAAC,yDAAe;AAC1D;AACA;AACA;AACA,SAAS,6BAA6B,sDAAI,CAAC,yDAAe;AAC1D;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK,4BAA4B,sDAAI,CAAC,yDAAe;AACrD;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,iEAAe,8DAAU,mBAAmB,EAAC;AAC7C,iC;;;;;;;;;;;;;;;;;ACrMA;AACA;AACA;AACwB;AACwB;AACjC;AACf;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,sBAAsB,sDAAI;AAC1B,eAAe,gDAAI;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,iC;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACwB;;AAExB;AACA;AACA;AACmD;AACH;AAChD;AACA;AACA;AACA,CAAC;AACD,sBAAsB,sDAAI,CAAC,uDAAI;AAC/B,yBAAyB,MAAM;AAC/B;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,sBAAsB,sDAAI,CAAC,uDAAI;AAC/B,yBAAyB,MAAM;AAC/B;AACA,yDAAyD,sDAAI;AAC7D,iBAAiB,gDAAI;AACrB;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,iEAAe,WAAW,EAAC;AAC3B,iC;;;;;;;;;;;;;;;;;;;;;;;ACnC6B;AACG;AAChC,iC;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AAC+C;AACoB;;AAEnE;AACA;AACA;AAC+F;;AAE/F;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,QAAQ;AACpB;AACO;AACP,UAAU,4EAA+B;AACzC,SAAS,2EAA8B;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,UAAU,4EAA+B;AACzC,SAAS,2EAA8B;AACvC,qDAAqD,yDAAgB;AACrE;AACA,sBAAsB,yDAAgB;AACtC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACO;AACP;AACA,CAAC;AACD,UAAU,4EAA+B;AACzC,qDAAqD,yDAAgB;AACrE;AACA,sBAAsB,yDAAgB;AACtC;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,QAAQ;AACpB;AACO;AACP;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,UAAU,4EAA+B;AACzC,SAAS,2EAA8B;AACvC,sCAAsC,yDAAgB;;AAEtD;AACA;AACA;AACA;AACA,oBAAoB,yDAAgB;AACpC;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;AACP;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,UAAU,4EAA+B;AACzC,SAAS,2EAA8B;AACvC,sCAAsC,yDAAgB;AACtD,oBAAoB,yDAAgB;AACpC;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA,GAAG;AACH,IAAI,4DAAU;AACd;AACA;AACA,KAAK;AACL,sBAAsB,yDAAgB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA,GAAG;AACH,IAAI,4DAAU;AACd;AACA;AACA,KAAK;AACL,sBAAsB,yDAAgB;AACtC;AACA;;AAEA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC,WAAW,yBAAyB;AACpC;AACA,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA,GAAG;AACH,IAAI,4DAAU;AACd;AACA;AACA,KAAK;AACL,sBAAsB,yDAAgB;AACtC;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;;;AC9MA;AACA;AACA;AACA,UAAU;AACV;AACO;AACP,qC;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AAC+C;AACxC;AACP;AACA,IAAI,4DAAU,IAAI,OAAO;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA,IAAI,4DAAU;AACd;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI,4DAAU;AACd;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AAC6D;;AAE7D;AACA;AACA;AACqC;AACI;AACT;AACS;;AAEzC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACO,cAAc,iEAAgB,CAAC,kDAAU;AAChD,SAAS;AACT,SAAS;AACT,WAAW;AACX,CAAC;;AAED;AACA;AACA,yDAAQ;AACR,iC;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACkD;AAC3C,sCAAsC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,gEAAe;AAC9B;AACA;AACA,CAAC,CAAC,EAAC;AACH,mC;;;;;;;;;;;;;;;;;;;;;;;;;AC1DA;AACA;AACA;AACyD;AACV;AACoB;;AAEnE;AACA;AACA;AAC+F;;AAE/F;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,2BAA2B;AACvC;AACO,mCAAmC,uEAAsB;AAChE,UAAU,4EAA+B;AACzC,4CAA4C,yDAAgB;;AAE5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,mCAAmC,uEAAsB;AAChE,UAAU,4EAA+B;AACzC,2BAA2B,yDAAgB;AAC3C;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,SAAS;AACrB;AACO,qBAAqB,uEAAsB;AAClD;AACA,UAAU,4EAA+B;AACzC,SAAS,2EAA8B;AACvC,6BAA6B,yDAAgB;AAC7C;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,SAAS;AACrB;AACO,wBAAwB,uEAAsB;AACrD,EAAE,4DAAU;AACZ;AACA;AACA,GAAG;AACH,kBAAkB,yDAAgB;AAClC,CAAC;;AAED;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,SAAS;AACrB;AACO;AACP;AACA;AACA,qC;;;;;;;;;;;;;;;AC1FA,cAAc,aAAa,+CAA+C,gDAAgD,eAAe,QAAQ,IAAI,0CAA0C,yCAAyC,SAAgB,gBAAgB,wCAAwC,IAAI,mDAAmD,SAAS,iEAAe,IAAI,E;;;;;;;;;;;;;;ACAnY;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE,UAAU;AACZ;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,aAAa;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,eAAe;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,eAAe;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,eAAe;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,EAAE,iBAAiB,EAAE,MAAM;AACzD;AACA,8BAA8B,aAAa;AAC3C,wDAAwD;AACxD,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,gBAAgB,sBAAsB;AACtC,gBAAgB,sBAAsB;AACtC,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,kDAAkD;AAClD,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E,0EAA0E;AAC1E,sFAAsF;AACtF;AACA;AACA,gFAAgF;AAChF,wEAAwE,gDAAgD;AACxH,wEAAwE,gDAAgD;AACxH;AACA,qDAAqD;AACrD,qDAAqD;AACrD,oEAAoE;AACpE,uEAAuE;AACvE,0DAA0D;AAC1D,+CAA+C;AAC/C,kDAAkD;AAClD,0CAA0C;AAC1C,4DAA4D;AAC5D,4DAA4D;AAC5D,0CAA0C;AAC1C,+CAA+C;AAC/C,8DAA8D;AAC9D,+CAA+C;AAC/C,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,oFAAoF,6DAA6D,8HAA8H;AAC/Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qTAAqT;AACrT;AACA;AACA;AACA,MAAM,wCAAwC,oFAAoF,oKAAoK,iHAAiH;AACvZ;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6B;AAC7B;;;;;;;;;;;;;;;;ACn2CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,YAAY;AACzF;AACA,UAAU,4DAA4D;AACtE;AACA;AACA,0HAA0H,eAAe,EAAE,MAAM;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,KAAK,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,MAAM;AAC5D;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,8BAA8B,uBAAuB,mBAAmB,gBAAgB;AACxF,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B;AAC7B;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS,4BAA4B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AAIE;AACF;;;;;;;;;;;;;;;;;ACzG0C;AACF;AACxC;AACA,gBAAgB,8BAA8B,IAAI;AAClD;AACA;AACA;AACA,iBAAiB,uDAAY;AAC7B;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AAIE;AACF;;;;;;;;;;;AC5Ba;;AAEb;;;;AAIA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,UAAU;AAC/B;;AAEA,qBAAqB,UAAU;AAC/B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;AC7CY;;AAEZ,QAAQ,4GAA4G,EAAE,mBAAO,CAAC,yDAAa;AAC3I,QAAQ,4BAA4B,EAAE,mBAAO,CAAC,6DAAe;;AAE7D;AACA,cAAc,6CAA6C;AAC3D,WAAW,GAAG;AACd,WAAW,iCAAiC;AAC5C,aAAa;AACb;AACA;AACA;AACA,qBAAqB,GAAG;AACxB,IAAI;AACJ,qBAAqB,GAAG;AACxB;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,iCAAiC;AAC5C,aAAa;AACb;AACA;AACA,sDAAsD,gBAAgB,eAAe;AACrF;AACA;AACA;AACA;;AAEA;AACA,WAAW,uCAAuC;AAClD,WAAW,uCAAuC;AAClD,WAAW,iCAAiC;AAC5C,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA,aAAa,sCAAsC;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,WAAW,8CAA8C;AACzD,WAAW,8CAA8C;AACzD,WAAW,kCAAkC;AAC7C,aAAa;AACb;AACA;AACA;AACA;AACA,+EAA+E,8BAA8B;AAC7G,IAAI;AACJ,+DAA+D,8BAA8B;AAC7F;;AAEA;AACA;AACA,+EAA+E,8BAA8B;AAC7G,IAAI;AACJ,+DAA+D,8BAA8B;AAC7F;;AAEA;AACA;;AAEA;AACA,WAAW,gDAAgD;AAC3D,WAAW,iCAAiC;AAC5C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,iCAAiC;AAC5C;AACA;AACA;AACA,kCAAkC;AAClC,aAAa,sCAAsC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAsB;AACtB,sBAAsB;;;;;;;;;;;ACnVV;;AAEZ,QAAQ,SAAS,EAAE,mBAAO,CAAC,qDAAS;AACpC,mCAAmC,KAAK,sBAAsB,aAAa,EAAE;;AAE7E,wCAAwC,OAAO;AAC/C;;AAEA,cAAc,8BAA8B;;AAE5C;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,iDAAiD,GAAG;AACpD;;AAEA;AACA;AACA,WAAW,uCAAuC;AAClD,WAAW,kCAAkC;AAC7C,aAAa;AACb;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,YAAY;AAC1B,cAAc,SAAS;AACvB,cAAc,UAAU;AACxB,cAAc,UAAU;AACxB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB;;AAEA;AACA,WAAW,uCAAuC;AAClD,aAAa;AACb;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,WAAW,UAAU;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,WAAW,UAAU;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,WAAW,UAAU;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,GAAG,gCAAgC;AACnE;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO,GAAG,mBAAmB;AACpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,mBAAmB,GAAG,IAAI;;AAEnD;AACA;AACA;;AAEA,WAAW,UAAU;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA,CAAC;;AAED,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA,CAAC;;AAED,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA,CAAC;;AAED,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA,CAAC;;AAED,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA,CAAC;;AAED,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA,CAAC;;AAED,2BAA2B,mCAAmC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACA;AACA;AACA;AACA,yBAAyB,YAAY;AACrC,yBAAyB,YAAY;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1QY;;AAEZ,WAAW,4BAA4B;AACvC,oDAAoD,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,GAAG;;AAEnG,WAAW,4BAA4B;AACvC,uEAAuE,EAAE,gBAAgB,EAAE,wBAAwB,EAAE;;AAErH;AACA,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA,oEAAoE,QAAQ;;AAE5E;AACA,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,mBAAmB;AACnB,aAAa,eAAe;AAC5B;AACA,aAAa,eAAe;AAC5B;AACA;AACA;;AAEA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,+CAA+C;AAC/C;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,kCAAkC,SAAS;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,IAAI;AACJ,aAAa;AACb;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,uCAAuC;AAClD,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,uCAAuC;AAClD,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/UA;AACA;AACA;AACA;AACA;AACA;;AAEkD;AACK;AACF;;AAErD,aAAa,iDAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,WAAW,oDAAa;AACxB;AACA;AACA;AACA,WAAW,6DAAiB;AAC5B;AACA;AACA;AACA;AACA,mBAAmB,kEAAY;AAC/B;AACA,OAAO;AACP;AACA,0CAA0C,oDAAa;AACvD;AACA;AACA;AACA;AACA;;AAE2B;AAC3B;;;;;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;;AAEkD;AACgB;AACrC;;AAE7B;AACA,oBAAoB,iDAAU;AAC9B,OAAO,qBAAqB,UAAU,oDAAa,CAAC,gDAAI;AACxD;AACA;AACA,iBAAiB,kEAAY,WAAW,iEAAW,WAAW;AAC9D;AACA,KAAK;AACL;AACA,6BAA6B,SAAS;AACtC;AACA;;AAEuC;AACvC;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;AACxC;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;;AAEsD;;AAEtD,gBAAgB,gEAAgB;AAChC,aAAa,mCAAmC;AAChD,aAAa,8BAA8B;AAC3C;;AAE8B;AAC9B;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;;AAEsD;;AAEtD,eAAe,gEAAgB;AAC/B,eAAe,2CAA2C;AAC1D,aAAa,8DAA8D;AAC3E;;AAE6B;AAC7B;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;;AAEsD;;AAEtD,cAAc,gEAAgB,sBAAsB,qCAAqC;;AAE7D;AAC5B;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;;AAEsD;;AAEtD,mBAAmB,gEAAgB;AACnC,eAAe,4CAA4C;AAC3D,aAAa,iEAAiE;AAC9E;;AAEiC;AACjC;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;;AAEsD;;AAEtD,gBAAgB,gEAAgB;AAChC,eAAe,4CAA4C;AAC3D,aAAa,+BAA+B;AAC5C,aAAa,8BAA8B;AAC3C;;AAE8B;AAC9B;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;;AAEsD;;AAEtD,iBAAiB,gEAAgB;AACjC,aAAa,gFAAgF;AAC7F,aAAa,6CAA6C;AAC1D,aAAa,6BAA6B;AAC1C,aAAa,+BAA+B;AAC5C;;AAE+B;AAC/B;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;;AAEsD;;AAEtD,eAAe,gEAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6B;AAC7B;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;;AAEsD;;AAEtD,gBAAgB,gEAAgB;AAChC,eAAe,qEAAqE;AACpF,eAAe,sEAAsE;AACrF,eAAe,oEAAoE;AACnF,eAAe,qEAAqE;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8B;AAC9B;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;;AAEsD;;AAEtD,gBAAgB,gEAAgB;AAChC,aAAa,8BAA8B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8B;AAC9B;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;;AAEsD;;AAEtD,aAAa,gEAAgB;AAC7B,aAAa,8BAA8B;AAC3C,aAAa,8BAA8B;AAC3C;;AAE2B;AAC3B;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;;AAEsD;;AAEtD,iBAAiB,gEAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6BAA6B;AAC1C,aAAa,8BAA8B;AAC3C,aAAa,6BAA6B;AAC1C,aAAa,6BAA6B;AAC1C;;AAE+B;AAC/B;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;;AAEsD;;AAEtD,UAAU,gEAAgB;AAC1B,aAAa,gCAAgC;AAC7C,aAAa,gCAAgC;AAC7C;;AAEwB;AACxB;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAEoC;AACrC;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACwC;AACW;AAC5C;AACP,OAAO,+CAAU,EAAE,mDAAc,CAAC,iEAAe,MAAM,YAAY;AACnE;AAC+B;;AAE/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACVO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,aAAa;AACzD;AACA,2DAA2D,WAAW;AACtE;AACA;AACA,wDAAwD,WAAW,mCAAmC,KAAK;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;ACpCoD;AAC7C,sBAAsB,mBAAmB,IAAI;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,cAAc,IAAI,eAAe;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qHAAqH,eAAe;AACpI;AACA,SAAS;AACT;AACA;AACA,iHAAiH,eAAe;AAChI;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iHAAiH,eAAe;AAChI;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uHAAuH,eAAe;AACtI;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sBAAsB,6DAAa;AACnC,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wC;;;;;;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ,gEAAgE,aAAa;AAChG;AACA,YAAY,aAAa;AACzB,YAAY,eAAe;AAC3B;AACA;AACA;AACA,kDAAkD,kBAAkB;AACpE;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,KAAK,cAAc,MAAM;AAC1D;AACA;AACA,mCAAmC,KAAK,cAAc,MAAM;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,sDAAsD,6DAA6D;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACpD,mC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChPA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACwC;AACC;AAC8E;AACjC;AACtF;AACA,sDAAI;AACwD;AAC+C;AAC3G;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB;AAClB,wCAAwC;AACxC;AACA;AACA;AACA;AACA,wCAAwC,mDAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDAAU;AAC3C;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA,2CAA2C,8BAA8B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB,IAAI;AACtD,0BAA0B;AAC1B,gBAAgB,6CAA6C;AAC7D;AACA;AACA,cAAc,6DAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,iEAAe;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,6CAA6C;AAC5F;AACA;AACA,0BAA0B,YAAY;AACtC;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,mBAAmB,8CAA8C;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAAe,kBAAkB,kDAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA,eAAe,gDAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB,+BAA+B,2CAA2C;AAC9G,yCAAyC,cAAc;AACvD;AACA;AACA,sBAAsB,yDAAiB;AACvC;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA,0BAA0B,iEAAyB;AACnD;AACA,sBAAsB,0DAAkB,GAAG,iBAAiB;AAC5D;AACA;AACA;AACA;AACA,kDAAkD,kBAAkB;AACpE,wCAAwC,EAAE,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA,6DAA6D,kCAAkC;AAC/F,oCAAoC,EAAE,aAAa;AACnD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wBAAwB,GAAG,0BAA0B;AAC/E;AACA;AACA,0BAA0B,wBAAwB;AAClD;AACA,sBAAsB,mDAAW,0BAA0B,eAAe,6HAA6H,SAAS,4CAA4C;AAC5P,SAAS;AACT;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB,MAAM,iDAAO,CAAC;AACtD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAW,yBAAyB;AAC1D;AACA,8BAA8B;AAC9B;AACA,kCAAkC;AAClC;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iDAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iDAAO;AAClD;AACA,yCAAyC,YAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iDAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iDAAO;AAClD;AACA;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iDAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,8DAA8D;AACxE,UAAU,4DAA4D;AACtE,UAAU,kEAAkE;AAC5E,UAAU,kEAAkE;AAC5E,UAAU,oEAAoE;AAC9E,UAAU,6FAA6F;AACvG;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B,MAAM,GAAG,MAAM,GAAG,MAAM;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kBAAkB,mDAAW,IAAI,MAAM;AACvC;AACA;AACA,kBAAkB,mDAAW,IAAI,MAAM;AACvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,mDAAW,8CAA8C,OAAO;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,cAAc,mDAAW,qBAAqB,OAAO,SAAS,aAAa;AAC3E;AACO;AACP;AACA;AACA;AACA;AACA,cAAc,mDAAW,qBAAqB,OAAO,SAAS,aAAa;AAC3E;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA,SAAS;AACT,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc,kBAAkB,QAAQ;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mDAAW,8BAA8B;AACvD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC57BA;AACyC;AAClC;AACP;AACO;AACP;AACA,iBAAiB,6CAA6C;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ,EAAE,IAAI;AACpC;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gBAAgB,sDAAW,iBAAiB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,UAAU,IAAI;AAChC;AACA;AACA;AACO;AACP,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,UAAU,IAAI;AAChC,gBAAgB,0CAA0C;AAC1D;AACA;AACO;AACP;AACO;AACP;AACO;AACP;AACO;AACP;AACO;AACP;AACO;AACP;AACO;AACP;AACO;AACP;AACO;AACP;AACA;AACA;AACA;AACO;A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AsB,mDAAkB;AACxC;AACA;AACA,sBAAsB,mDAAkB,4EAA4E;AACpH;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAkB;AAC5C;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA,0BAA0B,mDAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,0BAA0B,IAAI;AACxF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,iBAAiB,4CAAU;AAC3B;AACA;AACA;AACA;AACA,+CAA+C,MAAM,EAAE,aAAa;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAkB,gFAAgF,MAAM;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,sDAAsD,MAAM;AAC5D;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AAC4N;AACjR,iEAAe,MAAM,EAAC;AACtB,kC;;;;;;;;;;;;;;;;AChRA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AAC8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAW,yCAAyC,uBAAuB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAW,qDAAqD,uBAAuB;AAC7G;AACA,kBAAkB,mDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,0BAA0B;AAC1B,2BAA2B;AAC3B,kCAAkC,mBAAmB;AACrD;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,0BAA0B;AAC1B,2BAA2B;AAC3B,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;AChJO;AACA;AACP;AACA;AACA;AACO;AACA;AACP,oC;;;;;;;;;;;;;;;;ACP2D;AACA;AAC3D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8CAAM;AACnB;AACA,YAAY,wDAAc;AAC1B,eAAe,oDAAU,CAAC,wDAAc;AACxC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qDAAS;AACvB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qDAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qDAAS;AAC3B;AACA,sBAAsB,gEAAgE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wDAAc;AAC/B;AACA,sBAAsB,oDAAU;AAChC;AACA;AACA;AACA;AACA,sBAAsB,oDAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oCAAoC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;;;;;;;ACnRwC;AACxC;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACO,2CAA2C;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,iDAAiD,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,EAAE;AACpD;AACA,SAAS;AACT;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,qBAAqB,OAAO,UAAU,aAAa;AACnD;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;;;ACxNA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,yC;;;;;;;;;;;;;;;;;;;AClCA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AAC2C;AAC2B;AAC2B;AACjD;AAC4B;AAC5E;AACO,2CAA2C,yDAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2EAAiB,aAAa,uEAAa;AAC5D,4CAA4C,0BAA0B;AACtE;AACA;AACA,qBAAqB,4EAAkB;AACvC;AACA;AACA,qBAAqB,4EAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,0BAA0B,IAAI,4CAA4C;AAChJ;AACA,uCAAuC,oEAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAgD;AAChE;AACA,gBAAgB,oDAAoD;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,0BAA0B,mDAAW;AACrC;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA,0DAA0D,qBAAqB,2BAA2B;AAC1G;AACA,gCAAgC;AAChC,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA,0DAA0D,qBAAqB,IAAI,sCAAsC;AACzH,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA,yBAAyB,kFAA2B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAA8C;AAC9D;AACA,gBAAgB,oDAAoD;AACpE;AACA;AACA,gBAAgB,mEAAkB;AAClC;AACA,8BAA8B,mDAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,0BAA0B,mDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA,0DAA0D,qBAAqB,2BAA2B;AAC1G;AACA,oCAAoC;AACpC,uCAAuC,6BAA6B;AACpE;AACA;AACA;AACA,0DAA0D,qBAAqB,IAAI,sCAAsC;AACzH,uCAAuC,6BAA6B;AACpE;AACA;AACA;AACA;AACA,6BAA6B,kFAA2B;AACxD;AACA;AACA;AACA,uCAAuC,6BAA6B;AACpE;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,YAAY,4EAAkB;AAC9B,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mDAAW;AACzB,CAAC;AACD,2CAA2C,QAAQ;AACnD;AACA,YAAY,4EAAkB;AAC9B;AACA;AACA,YAAY,4EAAkB;AAC9B;AACA;AACA;AACA;AACA,CAAC;AACD,2CAA2C,QAAQ;AACnD;AACA,YAAY,2EAAiB;AAC7B;AACA;AACA,YAAY,uEAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,mDAAW;AAC7B;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,yD;;;;;;;;;;;;;;;;;;AC/WA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACoC;AACM;AACoB;AACd;AACzC,8BAA8B,yDAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,6EAA6E,iBAAiB,8BAA8B,4BAA4B,IAAI,8BAA8B;AAC1L;AACA;AACA,yBAAyB;AACzB,aAAa;AACb;AACA;AACA,yBAAyB;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAM;AAC7B;AACA;AACA;AACA;AACA,sBAAsB,yDAAiB;AACvC;AACA;AACA;AACA;AACA,2BAA2B,kDAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4DAA4D;AACnF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4DAA4D;AACnF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4DAA4D;AACnF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,yDAAyD,4CAA4C;AACrG;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,0DAA0D,4CAA4C;AACtG;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4CAAU,cAAc,4CAAU;AACvD;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,yBAAyB,4CAAU;AACnC,+FAA+F,WAAW;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gHAAgH,MAAM;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,IAAI,gBAAgB,WAAW,cAAc,SAAS;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,mDAAW;AAC7B;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;;;;;AC7iBmF;AACpB;AACxD,mCAAmC,2FAA4B;AACtE;AACA;AACA;AACA;AACA;AACA,uBAAuB,kEAAkE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8DAA8D;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4EAAkB;AAC9B;AACA;AACA;AACA;AACA,iD;;;;;;;;;;;;;;;;;;;AC7BA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACwH;AACrC;AACzC;AACkH;AACnF;AAClE,mCAAmC,2FAA4B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,yBAAyB,IAAI,uBAAuB,8DAA8D;AAChL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,yBAAyB,IAAI,4CAA4C;AACvI;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mEAAkB;AACpD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,yCAAyC,yCAAyC;AAClF;AACA;AACA;AACA,kDAAkD,0CAA0C;AAC5F;AACA;AACA;AACA,kDAAkD,0CAA0C;AAC5F;AACA,KAAK;AACL;AACA,sBAAsB,mDAAW;AACjC;AACA;AACA;AACA,sBAAsB,mDAAW;AACjC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,6EAA4B;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,qBAAqB,yDAAyD;AAC9E;AACA;AACA,qDAAqD,iCAAiC;AACtF;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,sEAAqB;AAC5G;AACA,kCAAkC,+DAAuB;AACzD;AACA;AACA,kCAAkC,sEAA8B;AAChE;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,oBAAoB,6DAA6D;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oFAAY;AACxD;AACA;AACA;AACA;AACA;AACA,6BAA6B,yCAAyC;AACtE,iGAAiG;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,oCAAoC;AAC1G;AACA;AACA;AACA;AACA,4BAA4B,oEAAmB;AAC/C,kEAAkE,oFAAY;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,6EAA6E,iBAAiB,8BAA8B,4BAA4B,IAAI,8BAA8B;AAC1L;AACA;AACA,yBAAyB;AACzB,aAAa;AACb;AACA;AACA,yBAAyB;AACzB,aAAa;AACb;AACA;AACA;AACA,2BAA2B,kDAAM;AACjC;AACA;AACA;AACA;AACA,YAAY,2DAA2D;AACvE;AACA;AACA;AACA,gCAAgC,wDAAwD;AACxF;AACA,0BAA0B,mDAAW,qCAAqC,MAAM;AAChF;AACA,oBAAoB,4DAA4D;AAChF,uCAAuC,2BAA2B;AAClE;AACA,0BAA0B,mDAAW,4BAA4B,MAAM;AACvE;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA,8BAA8B,mDAAW,+CAA+C,MAAM;AAC9F;AACA;AACA,8BAA8B,mDAAW,0CAA0C,MAAM;AACzF;AACA;AACA;AACA;AACA;AACA,yCAAyC,uBAAuB;AAChE;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sCAAsC;AAC1E,oCAAoC,mCAAmC;AACvE;AACA,0CAA0C,mDAAW,oBAAoB,MAAM,eAAe,EAAE,QAAQ,cAAc;AACtH;AACA;AACA,0CAA0C,mDAAW,oBAAoB,MAAM,eAAe,EAAE,UAAU,cAAc;AACxH;AACA;AACA,0CAA0C,mDAAW,oBAAoB,MAAM,eAAe,EAAE,mBAAmB,cAAc;AACjI;AACA;AACA,0CAA0C,mDAAW,oBAAoB,MAAM,eAAe,EAAE,wBAAwB,cAAc;AACtI;AACA,qCAAqC,mCAAmC;AACxE,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA,2BAA2B,iEAAiE;AAC5F;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC,qBAAqB,IAAI;AAC5D;AACA,WAAW,yEAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iD;;;;;;;;;;;;;;;AClfkE;AAC3D,4CAA4C,2EAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kEAAkE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8DAA8D;AACrF;AACA;AACA;AACA;AACA;AACA,0D;;;;;;;;;;;;;;;AC7BA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AAC8D;AACvD;AACP;AACA;AACA;AACA;AACA,gEAAgE;AAChE,+DAA+D;AAC/D;AACA,0DAA0D;AAC1D,yDAAyD;AACzD,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wFAAwF;AACxF,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAiB;AACrC;AACA,yBAAyB,yDAAiB;AAC1C;AACA;AACA;AACA,yBAAyB,mDAAW;AACpC;AACA;AACA;AACA,gCAAgC,mDAAW;AAC3C;AACA;AACA;AACA;AACA,mCAAmC,mDAAW;AAC9C;AACA,wC;;;;;;;;;;;;;;;;;;;;;;;ACnM2C;AACsB;AAC1D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mCAAmC,cAAc,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,6EAA4B;AACpC;AACA;AACA;AACA;AACO,2CAA2C,mBAAmB;AACrE,kBAAkB;AAClB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,sBAAsB,mDAAW,+DAA+D,aAAa,UAAU;AACvH;AACA;AACA,sBAAsB,mDAAW,UAAU,mBAAmB;AAC9D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;;;;;AC/JO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;ACrBO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA,gD;;;;;;;;;;;;;;;;;;;;;;;;ACZoG;AAC7F;AACP,kBAAkB;AAClB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACO;AACP,kBAAkB;AAClB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACO;AACP;AACA;AACO,mCAAmC,mBAAmB;AAC7D,kBAAkB;AAClB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACO;AACP;AACA;AACA,sBAAsB,+DAAuB;AAC7C;AACA;AACA,sBAAsB,sEAA8B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,sBAAsB,mDAAW,+DAA+D,aAAa,UAAU;AACvH;AACA;AACA,sBAAsB,mDAAW,UAAU,mBAAmB;AAC9D;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;AClJA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACiE;AAChB;AACW;AACrD,6BAA6B,yDAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4DAA4D;AACnF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,cAAc,IAAI,0DAA0D;AACvJ;AACA;AACA;AACA,qDAAqD,yBAAyB,IAAI,4CAA4C;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAW,4BAA4B,mBAAmB;AACxF;AACA;AACA;AACA;AACA,kCAAkC,mDAAW,6BAA6B,oBAAoB;AAC9F;AACA;AACA,kCAAkC,mDAAW,8CAA8C,aAAa;AACxG;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAW,4BAA4B,mBAAmB;AACxF;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,sBAAsB,mDAAW;AACjC;AACA;AACA;AACA,sBAAsB,mDAAW;AACjC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0BAA0B,mDAAW,8EAA8E,WAAW;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAW,4BAA4B,mBAAmB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAW,4BAA4B,mBAAmB;AACxF;AACA;AACA;AACA;AACA,kCAAkC,mDAAW,6BAA6B,oBAAoB;AAC9F;AACA;AACA,kCAAkC,mDAAW,8CAA8C,aAAa;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAW,4BAA4B,mBAAmB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,6EAA6E,iBAAiB,8BAA8B,4BAA4B,IAAI,8BAA8B;AAC1L;AACA;AACA,yBAAyB;AACzB,aAAa;AACb;AACA;AACA,yBAAyB;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAW;AACjC;AACA;AACA;AACA;AACA,WAAW,wEAAkB;AAC7B;AACA,2C;;;;;;;;;;;;;;;;ACrPA;AAC0C;AAC1C;AACA;AACA;AACO,mBAAmB,mDAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,mDAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA,uC;;;;;;;;;;;;;;ACjEA;AACO;AACP;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;;;ACNA;AACiD;AACP;AACJ;AACoB;AACH;AACD;AACH;AAC5C,oBAAoB,sDAAW;AACtC;AACA;AACA,kCAAkC,+DAAgC;AAClE,gCAAgC,2DAA4B;AAC5D,0BAA0B,+CAAgB;AAC1C;AACA;AACA,uBAAuB,+DAAc;AACrC,qBAAqB,2DAAY;AACjC,eAAe,+CAAM;AACrB,kC;;;;;;;;;;;;;;;ACnBA;AACiD;AAC1C,qBAAqB,sDAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAyD;AAChF;AACA,SAAS;AACT;AACA;AACA,mC;;;;;;;;;;;;;;;;AC3BA;AACiD;AACV;AAChC,6BAA6B,sDAAW;AAC/C;AACA,0DAA0D,kEAAgC;AAC1F;AACA;AACA;AACA,0BAA0B,mBAAmB;AAC7C,SAAS;AACT;AACA;AACA,2C;;;;;;;;;;;;;;;;ACbA;AACiD;AACV;AAChC,2BAA2B,sDAAW;AAC7C;AACA,wDAAwD,kEAAgC,GAAG,gCAAgC,qBAAqB;AAChJ;AACA;AACA,yC;;;;;;;;;;;;;;;;;;ACRA;AAC8C;AACC;AACA;AACxC,sBAAsB,sDAAW;AACxC;AACA;AACA;AACA;AACA,+CAA+C,kBAAkB;AACjE;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA,mBAAmB;AACnB,YAAY,2DAAgB;AAC5B,+BAA+B;AAC/B;AACA,kEAAkE,mBAAmB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACO,0BAA0B,uDAAU;AAC3C;AACA;AACA,oC;;;;;;;;;;;;;;;;;;ACnCA;AACiD;AACC;AACA;AACc;AACzD,yBAAyB,sDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,YAAY;AAC3D;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,YAAY;AAC5D;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA,mBAAmB;AACnB,YAAY,2DAAgB;AAC5B,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACO,6BAA6B,uDAAU;AAC9C;AACA;AACA,uC;;;;;;;;;;;;;;;;;;;ACtFA;AACiD;AACC;AACP;AACoB;AACR;AACH;AACA;AACH;AACV;AAChC,mBAAmB,sDAAW;AACrC;AACA;AACA,4BAA4B,4DAAoB;AAChD,wBAAwB,gDAAY;AACpC,8BAA8B,uDAAwB;AACtD,2BAA2B,yDAAkB;AAC7C;AACA;AACA,gBAAgB,4DAAQ;AACxB,kBAAkB,uDAAU;AAC5B,sBAAsB,2DAAc;AACpC,eAAe,yDAAO;AACtB,iC;;;;;;;;;;;;;;;;ACvBA;AACoD;AACA;AAC7C,mBAAmB,sDAAW;AACrC;AACA;AACA,+BAA+B,yDAA0B;AACzD;AACA;AACA;AACA,uBAAuB,yDAA0B;AACjD,CAAC,oBAAoB;AACrB,iC;;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACoD;AACyB;AACmB;AACnB;AACK;AACc;AACN;AACb;AACC;AACvE,0BAA0B,sDAAW;AAC5C;AACA,QAAQ,mEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,yCAAyC,oEAAmB;AAC5D;AACA;AACA;AACA,mBAAmB,iGAA6B;AAChD;AACA,eAAe,+EAAoB;AACnC;AACA;AACA;AACA,mBAAmB,iGAA6B;AAChD;AACA,eAAe,+EAAoB;AACnC;AACA;AACA;AACA;AACA;AACA,eAAe,+EAAoB;AACnC;AACA;AACA,wC;;;;;;;;;;;;;;;;;AC1CA;AACoD;AACN;AACH;AAC8B;AACH;AAC/D,uBAAuB,sDAAW;AACzC;AACA;AACA,4BAA4B,mDAAoB;AAChD,yCAAyC,8EAA8C;AACvF;AACA;AACA,oBAAoB,mDAAQ;AAC5B,iCAAiC,8EAAqB;AACtD,qC;;;;;;;;;;;;;;;ACfA;AACoD;AAC7C,uBAAuB,sDAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA,qC;;;;;;;;;;;;;;;AC1BA;AACoD;AAC7C,oCAAoC,sDAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA,mD;;;;;;;;;;;;;;;;;;AC1BA;AACoD;AACC;AACA;AACrD;AACA;AACA;AACO,uBAAuB,sDAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS,YAAY,UAAU;AAC3E;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS,YAAY,UAAU;AAC5E;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA,6BAA6B;AAC7B,YAAY,2DAAgB;AAC5B,yCAAyC;AACzC;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS,YAAY,UAAU;AAC9E;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACO,2BAA2B,uDAAU;AAC5C;AACA;AACA,qC;;;;;;;;;;;;;;;;;;;;ACpEA;AACuD;AACC;AACc;AACzB;AACL;AACW;AACK;AACxD;AACA;AACA;AACO,mBAAmB,sDAAW;AACrC;AACA;AACA,yBAAyB,6CAAc;AACvC;AACA;AACA,gBAAgB,mBAAmB;AACnC,6CAA6C,SAAS;AACtD,qBAAqB,SAAS;AAC9B;AACA;AACA,uBAAuB,qDAAqD;AAC5E;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS,QAAQ,MAAM;AACnE;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS,QAAQ,MAAM;AACpE;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA,6BAA6B;AAC7B,YAAY,2DAAgB;AAC5B,yCAAyC;AACzC;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS,QAAQ,MAAM;AACpE;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA,2BAA2B,iCAAiC;AAC5D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAe;AAC9B;AACA;AACA,6CAA6C,SAAS,QAAQ,MAAM;AACpE;AACA;AACA,uBAAuB,qDAAqD;AAC5E;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAe;AAC9B;AACA;AACO,uBAAuB,uDAAU;AACxC;AACA;AACA,aAAa,6CAAK;AAClB,oBAAoB,oDAAY;AAChC,iC;;;;;;;;;;;;;;;;;;AC1KA;AACuD;AACC;AACA;AACxD;AACA;AACA;AACO,oBAAoB,sDAAW;AACtC,gDAAgD;AAChD,YAAY,2DAAgB;AAC5B,4DAA4D;AAC5D;AACA,4CAA4C,SAAS,QAAQ,MAAM,SAAS,OAAO;AACnF;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA,oCAAoC;AACpC,YAAY,2DAAgB;AAC5B,gDAAgD;AAChD;AACA,mDAAmD,SAAS,QAAQ,MAAM;AAC1E;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACO,2BAA2B,uDAAU;AAC5C;AACA;AACA,kC;;;;;;;;;;;;;;;;;;;AChCA;AACoD;AACC;AACc;AACrB;AACW;AACd;AACO;AAClD;AACA;AACA;AACO,sBAAsB,sDAAW;AACxC;AACA;AACA,wBAAwB,gDAAY;AACpC,4BAA4B,mDAAoB;AAChD;AACA,oBAAoB;AACpB,YAAY,2DAAgB;AAC5B,iCAAiC;AACjC;AACA;AACA;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAqD;AAC5E;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAe;AAC9B;AACA;AACA,eAAe,gDAAI;AACnB,mBAAmB,oDAAQ;AAC3B,mBAAmB,mDAAQ;AAC3B,uBAAuB,uDAAY;AACnC,oC;;;;;;;;;;;;;;;;ACzFA;AACiD;AACe;AACkB;AAC3E,mBAAmB,sDAAW;AACrC;AACA;AACA,+BAA+B,qEAA0B;AACzD;AACA;AACA,mBAAmB,qEAAW;AAC9B,2BAA2B,6EAAmB;AAC9C,iC;;;;;;;;;;;;;;;;;;;;ACZA;AACoD;AACC;AACP;AACJ;AACW;AAC9C,0BAA0B,sDAAW;AAC5C;AACA;AACA,4BAA4B,mDAAoB;AAChD;AACA;AACA,wDAAwD,gDAAgD;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY,iBAAiB;AACxC;AACA;AACA;AACA;AACA,sDAAsD,aAAa,KAAK,kBAAkB;AAC1F;AACA,mBAAmB;AACnB,YAAY,2DAAgB;AAC5B,+BAA+B;AAC/B;AACA,mFAAmF,mBAAmB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,aAAa;AACrE;AACA;AACO,kCAAkC,uDAAU;AACnD;AACO,8CAA8C,uDAAU;AAC/D;AACA;AACA,uBAAuB,mDAAQ;AAC/B,wC;;;;;;;;;;;;;;;;;;ACrEA;AACoD;AACC;AACe;AAC7D,uBAAuB,sDAAW;AACzC,iCAAiC;AACjC,YAAY,2DAAgB;AAC5B,6CAA6C;AAC7C;AACA,4DAA4D,aAAa,YAAY,6EAA+B,IAAI,mBAAmB;AAC3I;AACA;AAC2C;AAC3C,qC;;;;;;;;;;;;;;;ACbA;AAC8C;AACvC,0BAA0B,sDAAW;AAC5C;AACA,mDAAmD,gDAAgD;AACnG;AACA;AACA,wC;;;;;;;;;;;;;;;;;;;ACPA;AACiD;AACC;AACJ;AACoB;AAChB;AAC3C,yBAAyB,sDAAW;AAC3C;AACA;AACA,yBAAyB,mDAAc;AACvC;AACA;AACA;AACA;AACA;AACA,kDAAkD,kBAAkB;AACpE;AACA;AACA;AACA;AACA;AACA,+CAA+C,YAAY;AAC3D;AACA,mBAAmB;AACnB,YAAY,2DAAgB;AAC5B,+BAA+B;AAC/B;AACA,oFAAoF,mBAAmB;AACvG;AACA;AACA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA,uBAAuB,oCAAoC;AAC3D,SAAS;AACT;AACA;AACO,yCAAyC,uDAAU;AAC1D;AACA;AACA,mBAAmB,mDAAK;AACxB,mCAAmC,mEAAqB;AACxD,uC;;;;;;;;;;;;;;;AC5CA;AACoD;AAC7C,sBAAsB,sDAAW;AACxC;AACA;AACA;AACA;AACA,+CAA+C,YAAY,SAAS,OAAO;AAC3E;AACA,uBAAuB,mDAAmD;AAC1E;AACA,SAAS;AACT;AACA;AACA,oC;;;;;;;;;;;;;;;;;;;;ACdA;AACoD;AACC;AACX;AACE;AACJ;AACa;AAC9C,oBAAoB,sDAAW;AACtC;AACA;AACA,2BAA2B,iDAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,YAAY,SAAS,kEAAgC,GAAG,kBAAkB;AAC1H;AACA;AACA;AACA;AACA;AACA,+CAA+C,YAAY,SAAS,OAAO;AAC3E;AACA,gCAAgC;AAChC,YAAY,2DAAgB;AAC5B,4CAA4C;AAC5C;AACA,sDAAsD,YAAY;AAClE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kDAAkD,YAAY,SAAS,OAAO;AAC9E;AACA,uBAAuB,oCAAoC;AAC3D,SAAS;AACT;AACA;AACO,oCAAoC,uDAAU;AACrD;AACA;AACA,gBAAgB,iDAAO;AACvB,kC;;;;;;;;;;;;;;;;AClDA;AAC8C;AACV;AAC7B,yBAAyB,sDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAU;AACtB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAU;AAClB;AACA;AACA;AACA;AACA,mDAAmD,qDAAmB;AACtE,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA,uC;;;;;;;;;;;;;;;;;;;ACnDA;AACiD;AACC;AACP;AACmB;AACZ;AAC3C,oBAAoB,sDAAW;AACtC;AACA;AACA,wBAAwB,gDAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kBAAkB;AAC/D;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO,KAAK,kBAAkB;AACzE;AACA,mBAAmB;AACnB,YAAY,2DAAgB;AAC5B,+BAA+B;AAC/B;AACA,0EAA0E,mBAAmB;AAC7F;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACO,oCAAoC,uDAAU;AACrD;AACA;AACA,aAAa,gDAAI;AACjB,6BAA6B,gEAAoB;AACjD,kC;;;;;;;;;;;;;;;;;;ACpDA;AACoD;AACC;AACA;AAC9C,0BAA0B,sDAAW;AAC5C;AACA;AACA;AACA;AACA,0CAA0C,OAAO,QAAQ,MAAM,gBAAgB,aAAa;AAC5F;AACA,kCAAkC;AAClC,YAAY,2DAAgB;AAC5B,8CAA8C;AAC9C;AACA,iDAAiD,OAAO,QAAQ,MAAM,+CAA+C,mBAAmB;AACxI;AACA;AACO,0CAA0C,uDAAU;AAC3D;AACA;AACA,yC;;;;;;;;;;;;;;;;;;;ACrBA;AACoD;AACC;AACA;AAC0B;AAC1B;AAC9C,mBAAmB,sDAAW;AACrC;AACA;AACA,+BAA+B,0DAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO,UAAU,kBAAkB;AAC9E;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO,QAAQ,MAAM;AAC/D;AACA,2BAA2B;AAC3B,YAAY,2DAAgB;AAC5B,uCAAuC;AACvC;AACA,iDAAiD,OAAO,gCAAgC,mBAAmB;AAC3G;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO,QAAQ,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO,QAAQ,MAAM;AAChE;AACA;AACO,mCAAmC,uDAAU;AACpD;AACA;AACA,mBAAmB,0DAAW;AAC9B,mCAAmC,0EAA2B;AAC9D,iC;;;;;;;;;;;;;;;;;;;;ACjDA;AAC8C;AACC;AACX;AACqB;AACrB;AACW;AACxC,oBAAoB,sDAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kEAAgC,GAAG,kBAAkB;AAChG;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA,mBAAmB;AACnB,YAAY,2DAAgB;AAC5B,+BAA+B;AAC/B;AACA,oEAAoE,mBAAmB;AACvF;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA,uBAAuB,mDAAmD;AAC1E;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA,kCAAkC,gDAAgD,IAAI;AACtF;AACA;AACA;AACA;AACA,kBAAkB,gDAAK;AACvB;AACA;AACA,0BAA0B,iEAAyB;AACnD,8DAA8D,IAAI,6BAA6B,SAAS;AACxG,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACO,8BAA8B,uDAAU;AAC/C;AACA;AACA,kC;;;;;;;;;;;;;;;;AC5FA;AACoD;AACR;AACH;AAClC,oBAAoB,sDAAW;AACtC;AACA;AACA,2BAA2B,iDAAkB;AAC7C;AACA;AACA,gBAAgB,iDAAO;AACvB,kC;;;;;;;;;;;;;;;ACXA;AACoD;AAC7C,sBAAsB,sDAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,qEAAqE,kBAAkB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,UAAU;AACV;AACA;AACA;AACA,0EAA0E,kBAAkB;AAC5F;AACA;AACA,oC;;;;;;;;;;;;;;;;AC7CA;AACoD;AACA;AAC4B;AACzE,0BAA0B,sDAAW;AAC5C;AACA;AACA,+BAA+B,yDAA0B;AACzD;AACA;AACA,0BAA0B,yDAAW;AACrC,4CAA4C,2EAA6B;AACzE,wC;;;;;;;;;;;;;;;;;;ACZA;AACoD;AACC;AACN;AACxC,0BAA0B,sDAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,yBAAyB,gDAAgD,kCAAkC;AAC9K;AACA,iDAAiD;AACjD,YAAY,2DAAgB;AAC5B,6DAA6D;AAC7D;AACA,4DAA4D,yBAAyB;AACrF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,yBAAyB,eAAe,aAAa;AACpH;AACA;AACA;AACA;AACA;AACO,4CAA4C,iDAAI;AACvD;AACA;AACA,wC;;;;;;;;;;;;;;;;;;;AC3DA;AACiD;AACL;AACH;AACK;AACJ;AACsB;AACJ;AACjB;AAC0C;AAC9E,yBAAyB,sDAAW;AAC3C;AACA;AACA,2BAA2B,iDAAkB;AAC7C,wBAAwB,gDAAY;AACpC,+BAA+B,qEAA0B;AACzD,yBAAyB,mDAAc;AACvC;AACA;AACA,qBAAqB,iDAAO;AAC5B,kBAAkB,gDAAI;AACtB,gCAAgC,8DAAkB;AAClD,qCAAqC,mEAAuB;AAC5D,yBAAyB,qEAAW;AACpC,mBAAmB,mDAAK;AACxB,wC;;;;;;;;;;;;;;;;;;ACzBA;AACoD;AACC;AACA;AAC9C,0BAA0B,sDAAW;AAC5C,oCAAoC;AACpC,YAAY,2DAAgB;AAC5B,gDAAgD;AAChD;AACA,4DAA4D,gBAAgB,+CAA+C,mBAAmB;AAC9I;AACA;AACO,2CAA2C,uDAAU;AAC5D;AACA;AACA,wC;;;;;;;;;;;;;;;;;;;;ACfA;AACoD;AACC;AACD;AAC2B;AAC1B;AAC9C,mBAAmB,sDAAW;AACrC;AACA;AACA,+BAA+B,yDAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,wDAAwD,kBAAkB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA,mBAAmB;AACnB,YAAY,2DAAgB;AAC5B,+BAA+B;AAC/B;AACA,kFAAkF,mBAAmB;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gBAAgB;AACtE;AACA,0CAA0C;AAC1C,YAAY,2DAAgB;AAC5B,sDAAsD;AACtD;AACA,4DAA4D,gBAAgB;AAC5E;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gBAAgB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gBAAgB;AACtE;AACA;AACO,iCAAiC,uDAAU;AAClD;AACO,sCAAsC,uDAAU;AACvD;AACA;AACA;AACA,mBAAmB,yDAAW;AAC9B,oCAAoC,0EAA4B;AAChE,iC;;;;;;;;;;;;;;;AC7GA;AACiD;AAC1C,sBAAsB,sDAAW;AACxC;AACA,oC;;;;;;;;;;;;;;;ACJA;AACiD;AAC1C,2BAA2B,sDAAW;AAC7C;AACA,0C;;;;;;;;;;;;;;;;ACJA;AACiD;AACM;AACH;AAC7C,sBAAsB,sDAAW;AACxC;AACA;AACA,gCAAgC,4DAA4B;AAC5D;AACA;AACA,uBAAuB,4DAAY;AACnC,oC;;;;;;;;;;;;;;;;ACXA;AAC8C;AACV;AAC7B,qBAAqB,sDAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,uDAAuD,kEAAgC,GAAG,kBAAkB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,kDAAkD,kEAAgC,GAAG,kBAAkB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,0DAA0D,kBAAkB;AAC5E;AACA;AACA,mC;;;;;;;;;;;;;;;;;AC/CA;AAC8C;AACL;AAClC,qBAAqB,sDAAW;AACvC;AACA;AACA;AACA;AACA;AACA,2CAA2C,MAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,MAAM;AACpD;AACA;AACA;AACA;AACA;AACO,yBAAyB,iDAAI;AACpC;AACA;AACA,mC;;;;;;;;;;;;;;;AChCA;AAC8C;AACvC,0BAA0B,sDAAW;AAC5C;AACA;AACA;AACA;AACA;AACA,mDAAmD,kBAAkB;AACrE;AACA;AACA,wC;;;;;;;;;;;;;;;;;;ACXA;AACiD;AACC;AACE;AAC7C,yBAAyB,sDAAW;AAC3C,+BAA+B;AAC/B,YAAY,2DAAgB;AAC5B,2CAA2C;AAC3C;AACA,qDAAqD,WAAW,eAAe,6DAAiB;AAChG;AACA;AACA,SAAS;AACT;AACA;AAC6B;AAC7B,wC;;;;;;;;;;;;;;;;;;;;AChBA;AAC8E;AAC7B;AACE;AACJ;AACyB;AACtB;AAC3C,wBAAwB,sDAAW;AAC1C;AACA;AACA,8BAA8B,wDAAwB;AACtD;AACA;AACA,iDAAiD,gDAAgD;AACjG;AACA,gBAAgB,uEAAa;AAC7B;AACA;AACA,SAAS;AACT;AACA,mCAAmC;AACnC,8CAA8C,WAAW;AACzD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA,uBAAuB,oCAAoC;AAC3D,SAAS;AACT;AACA;AACA;AACA;AACA,uCAAuC,uEAAa;AACpD;AACA;AACA;AACA;AACA;AACA,eAAe,6EAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,WAAW;AAC1D;AACA,uBAAuB,oCAAoC;AAC3D,SAAS;AACT;AACA;AACO,gCAAgC,uDAAU;AACjD;AACA,uBAAuB,wDAAU;AACjC,sC;;;;;;;;;;;;;;;;AC5EA;AACiD;AACV;AAChC,oBAAoB,sDAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS,SAAS,kEAAgC,GAAG,kBAAkB;AACpH;AACA;AACA,kC;;;;;;;;;;;;;;;;ACrBA;AACiD;AACT;AACJ;AAC7B,sBAAsB,sDAAW;AACxC;AACA;AACA,yBAAyB,6CAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,kBAAkB;AACjE;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS,cAAc,kBAAkB;AACtF;AACA;AACA,gBAAgB,6CAAK;AACrB,oC;;;;;;;;;;;;;;;;;;;AC3DA;AACiD;AACC;AACX;AACkB;AACN;AAC5C,0BAA0B,sDAAW;AAC5C;AACA;AACA;AACA;AACA,mDAAmD,cAAc;AACjE;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kDAAkD,cAAc,gBAAgB,QAAQ;AACxF;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,cAAc,gBAAgB,QAAQ;AACzF;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,YAAY,2DAAgB;AAC5B,4DAA4D;AAC5D;AACA,yDAAyD,cAAc,gBAAgB,QAAQ,SAAS,4DAAoB,IAAI,8BAA8B,uDAAuD;AACrN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,mCAAmC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kEAAmB;AACjC;AACA;AACA,SAAS;AACT;AACA;AACgC;AAChC,yC;;;;;;;;;;;;;;;;;;;AC1HA;AACiD;AACQ;AACD;AACjD,oBAAoB,sDAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,cAAc;AACjE;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kDAAkD,cAAc,SAAS,OAAO;AAChF;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mDAAmD,cAAc,SAAS,OAAO;AACjF;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA,kCAAkC;AAClC,YAAY,2DAAgB;AAC5B,8CAA8C;AAC9C;AACA,yDAAyD,cAAc;AACvE;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,cAAc,SAAS,OAAO;AACnF;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,mCAAmC;AAC9F,4CAA4C,sBAAsB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,cAAc,SAAS,OAAO,uCAAuC,uBAAuB,uDAAuD;AAC5M;AACA;AACO,mCAAmC,uDAAU;AACpD;AACA;AACA;AACA;AACO,uCAAuC,iDAAI;AAClD;AACA;AACA;AACA,kC;;;;;;;;;;;;;;;;;;;;;AC1IA;AACiD;AACC;AACG;AACH;AACV;AAC6C;AAC7B;AACjD,2BAA2B,sDAAW;AAC7C;AACA;AACA,yBAAyB,6CAAc;AACvC,+BAA+B,0DAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kDAAkD,cAAc;AAChE;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mDAAmD,cAAc;AACjE;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA,mBAAmB;AACnB,YAAY,2DAAgB;AAC5B,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qDAAqD,cAAc;AACnE;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA,uBAAuB,qDAAqD;AAC5E,SAAS;AACT;AACA;AACO,+BAA+B,uDAAU;AAChD;AACA;AACA;AACA;AACO,6CAA6C,iDAAI;AACxD;AACA;AACA;AACA,qBAAqB,6CAAK;AAC1B,oCAAoC,4DAAoB;AACxD,wCAAwC,gEAAwB;AAChE,2BAA2B,0DAAW;AACtC,0C;;;;;;;;;;;;;;;;;;;;ACxFoD;AACV;AACyC;AACP;AACzB;AACZ;AAChC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gDAAQ,mCAAmC,gEAAqB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gDAAQ;AAC9C;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oEAAW;AAC/C,yBAAyB,yFAA6B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAAc;AACjC;AACA;AACA,aAAa;AACb;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACO;AACP;AACA;AACA,kBAAkB,mDAAW;AAC7B;AACA;AACA,4BAA4B,oEAAW;AACvC,iBAAiB,yFAA6B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mFAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;;;;;;;;ACvRiG;AAC/C;AAC3C;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yDAAyD,gEAAc;AACvE;AACA;AACA,0BAA0B,YAAY;AACtC,yDAAyD,iBAAiB,GAAG,mBAAmB,MAAM,qBAAqB,IAAI,mBAAmB;AAClJ,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,eAAe,YAAY;AAC3B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,eAAe,kDAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,iDAAiD,eAAe,eAAe;AAC/E,qBAAqB,SAAS,qBAAqB;AACnD;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB,EAAE,eAAe;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,WAAW,4EAA0B;AACrC;AACO;AACP;AACA,WAAW,4EAA0B;AACrC;AACO;AACP,qBAAqB,sDAAQ;AAC7B,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,IAAI,GAAG;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,IAAI,GAAG,KAAK;AACxG;AACA;AACA,oIAAoI,OAAO;AAC3I;AACA;AACA,oC;;;;;;;;;;;;;;AC7JO,2BAA2B;AAClC,oC;;;;;;;;;;;;;;;;ACDA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","sources":["webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/dist/esm/client/auth.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/dist/esm/client/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/dist/esm/client/streamableHttp.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/client.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/helpers.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/interfaces.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/dist/esm/server/auth/errors.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-compat.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-json-schema-compat.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/dist/esm/shared/auth-utils.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/dist/esm/shared/auth.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/dist/esm/shared/transport.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/dist/esm/types.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/dist/esm/validation/ajv-provider.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv-formats/dist/formats.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv-formats/dist/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv-formats/dist/limit.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/ajv.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/codegen/code.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/codegen/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/codegen/scope.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/errors.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/names.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/ref_error.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/resolve.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/rules.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/util.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/applicability.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/boolSchema.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/dataType.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/defaults.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/keyword.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/subschema.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/core.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/runtime/equal.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/runtime/ucs2length.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/runtime/uri.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/runtime/validation_error.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/allOf.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/anyOf.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/contains.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/dependencies.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/if.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/items.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/items2020.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/not.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/oneOf.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/properties.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/thenElse.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/code.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/core/id.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/core/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/core/ref.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/discriminator/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/discriminator/types.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/draft7.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/format/format.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/format/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/metadata.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/const.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/enum.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/limitItems.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/limitLength.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/limitNumber.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/limitProperties.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/multipleOf.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/pattern.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/required.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/json-schema-traverse/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/Options.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/Refs.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/errorMessages.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/getRelativePath.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parseDef.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parseTypes.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/any.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/array.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/branded.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/catch.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/date.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/default.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/effects.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/enum.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/literal.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/map.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/never.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/null.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/number.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/object.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/optional.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/promise.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/record.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/set.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/string.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/union.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/selectParser.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v3/ZodError.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v3/errors.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v3/external.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v3/helpers/errorUtil.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v3/helpers/parseUtil.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v3/helpers/typeAliases.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v3/helpers/util.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v3/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v3/locales/en.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v3/types.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4-mini/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/classic/checks.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/classic/coerce.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/classic/compat.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/classic/errors.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/classic/external.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/classic/from-json-schema.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/classic/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/classic/iso.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/classic/parse.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/classic/schemas.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/api.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/checks.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/core.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/doc.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/errors.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/json-schema-generator.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/json-schema-processors.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/json-schema.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/parse.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/regexes.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/registries.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/schemas.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/to-json-schema.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/util.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/versions.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/ar.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/az.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/be.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/bg.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/ca.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/cs.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/da.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/de.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/en.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/eo.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/es.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/fa.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/fi.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/fr-CA.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/fr.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/he.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/hu.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/hy.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/id.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/is.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/it.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/ja.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/ka.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/kh.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/km.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/ko.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/lt.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/mk.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/ms.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/nl.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/no.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/ota.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/pl.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/ps.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/pt.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/ru.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/sl.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/sv.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/ta.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/th.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/tr.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/ua.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/uk.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/ur.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/uz.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/vi.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/yo.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/zh-CN.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/zh-TW.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/mini/checks.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/mini/coerce.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/mini/external.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/mini/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/mini/iso.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/mini/parse.js","webpack://newfold.wordpress.editor.chat/./node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/mini/schemas.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/icons/build-module/library/check.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/icons/build-module/library/close-small.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/icons/build-module/library/star-empty.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/icons/build-module/library/star-filled.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/interface/build-module/components/action-item/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/interface/build-module/components/complementary-area-context/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/interface/build-module/components/complementary-area-header/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/interface/build-module/components/complementary-area-more-menu-item/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/interface/build-module/components/complementary-area-toggle/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/interface/build-module/components/complementary-area/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/interface/build-module/components/fullscreen-mode/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/interface/build-module/components/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/interface/build-module/components/interface-skeleton/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/interface/build-module/components/navigable-region/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/interface/build-module/components/pinned-items/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/interface/build-module/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/interface/build-module/store/actions.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/interface/build-module/store/constants.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/interface/build-module/store/deprecated.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/interface/build-module/store/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/interface/build-module/store/reducer.js","webpack://newfold.wordpress.editor.chat/./node_modules/@wordpress/interface/build-module/store/selectors.js","webpack://newfold.wordpress.editor.chat/./node_modules/clsx/dist/clsx.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/dompurify/dist/purify.es.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/eventsource-parser/dist/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/eventsource-parser/dist/stream.js","webpack://newfold.wordpress.editor.chat/./node_modules/fast-deep-equal/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/fast-uri/index.js","webpack://newfold.wordpress.editor.chat/./node_modules/fast-uri/lib/schemes.js","webpack://newfold.wordpress.editor.chat/./node_modules/fast-uri/lib/utils.js","webpack://newfold.wordpress.editor.chat/./node_modules/lucide-react/dist/esm/Icon.js","webpack://newfold.wordpress.editor.chat/./node_modules/lucide-react/dist/esm/createLucideIcon.js","webpack://newfold.wordpress.editor.chat/./node_modules/lucide-react/dist/esm/defaultAttributes.js","webpack://newfold.wordpress.editor.chat/./node_modules/lucide-react/dist/esm/icons/arrow-up.js","webpack://newfold.wordpress.editor.chat/./node_modules/lucide-react/dist/esm/icons/at-sign.js","webpack://newfold.wordpress.editor.chat/./node_modules/lucide-react/dist/esm/icons/check.js","webpack://newfold.wordpress.editor.chat/./node_modules/lucide-react/dist/esm/icons/circle-stop.js","webpack://newfold.wordpress.editor.chat/./node_modules/lucide-react/dist/esm/icons/circle-x.js","webpack://newfold.wordpress.editor.chat/./node_modules/lucide-react/dist/esm/icons/file-plus.js","webpack://newfold.wordpress.editor.chat/./node_modules/lucide-react/dist/esm/icons/layers.js","webpack://newfold.wordpress.editor.chat/./node_modules/lucide-react/dist/esm/icons/palette.js","webpack://newfold.wordpress.editor.chat/./node_modules/lucide-react/dist/esm/icons/pen-line.js","webpack://newfold.wordpress.editor.chat/./node_modules/lucide-react/dist/esm/icons/plus.js","webpack://newfold.wordpress.editor.chat/./node_modules/lucide-react/dist/esm/icons/sparkles.js","webpack://newfold.wordpress.editor.chat/./node_modules/lucide-react/dist/esm/icons/x.js","webpack://newfold.wordpress.editor.chat/./node_modules/lucide-react/dist/esm/shared/src/utils.js","webpack://newfold.wordpress.editor.chat/./node_modules/openai/_shims/MultipartBody.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/_shims/index.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/_shims/registry.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/_shims/web-runtime.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/_vendor/partial-json-parser/parser.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/core.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/error.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/index.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/internal/decoders/line.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/internal/qs/formats.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/internal/qs/stringify.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/internal/qs/utils.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/internal/stream-utils.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/lib/AbstractChatCompletionRunner.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/lib/AssistantStream.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/lib/ChatCompletionRunner.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/lib/ChatCompletionStream.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/lib/ChatCompletionStreamingRunner.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/lib/EventStream.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/lib/ResponsesParser.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/lib/RunnableFunction.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/lib/Util.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/lib/chatCompletionUtils.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/lib/parser.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/lib/responses/ResponseStream.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/pagination.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resource.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/audio/audio.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/audio/speech.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/audio/transcriptions.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/audio/translations.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/batches.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/beta/assistants.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/beta/beta.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/beta/chat/chat.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/beta/chat/completions.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/beta/realtime/realtime.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/beta/realtime/sessions.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/beta/realtime/transcription-sessions.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/beta/threads/messages.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/beta/threads/runs/runs.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/beta/threads/runs/steps.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/beta/threads/threads.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/chat/chat.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/chat/completions/completions.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/chat/completions/messages.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/completions.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/containers/containers.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/containers/files/content.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/containers/files/files.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/embeddings.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/evals/evals.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/evals/runs/output-items.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/evals/runs/runs.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/files.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/fine-tuning/alpha/alpha.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/fine-tuning/alpha/graders.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/fine-tuning/checkpoints/permissions.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/fine-tuning/fine-tuning.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/fine-tuning/jobs/jobs.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/fine-tuning/methods.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/graders/grader-models.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/graders/graders.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/images.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/models.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/moderations.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/responses/input-items.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/responses/responses.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/uploads/parts.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/uploads/uploads.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/vector-stores/file-batches.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/vector-stores/files.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/resources/vector-stores/vector-stores.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/streaming.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/uploads.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/openai/version.mjs","webpack://newfold.wordpress.editor.chat/./node_modules/pkce-challenge/dist/index.browser.js","webpack://newfold.wordpress.editor.chat/./src/components/ChatEditor.jsx","webpack://newfold.wordpress.editor.chat/./src/components/chat/ActionButtons.jsx","webpack://newfold.wordpress.editor.chat/./src/components/chat/ChatInput.jsx","webpack://newfold.wordpress.editor.chat/./src/components/chat/ChatMessage.jsx","webpack://newfold.wordpress.editor.chat/./src/components/chat/ChatMessages.jsx","webpack://newfold.wordpress.editor.chat/./src/components/chat/WelcomeScreen.jsx","webpack://newfold.wordpress.editor.chat/./src/components/sidebar/SidebarHeader.jsx","webpack://newfold.wordpress.editor.chat/./src/components/ui/AILogo.jsx","webpack://newfold.wordpress.editor.chat/./src/components/ui/ContextTag.jsx","webpack://newfold.wordpress.editor.chat/./src/components/ui/ErrorAlert.jsx","webpack://newfold.wordpress.editor.chat/./src/components/ui/SuggestionButton.jsx","webpack://newfold.wordpress.editor.chat/./src/components/ui/TypingIndicator.jsx","webpack://newfold.wordpress.editor.chat/./src/hooks/useChat.js","webpack://newfold.wordpress.editor.chat/./src/hooks/useSelectedBlock.js","webpack://newfold.wordpress.editor.chat/./src/services/actionExecutor.js","webpack://newfold.wordpress.editor.chat/./src/services/globalStylesService.js","webpack://newfold.wordpress.editor.chat/./src/services/mcpClient.js","webpack://newfold.wordpress.editor.chat/./src/services/openaiClient.js","webpack://newfold.wordpress.editor.chat/./src/styles/app.scss","webpack://newfold.wordpress.editor.chat/./src/svg/sparks.svg","webpack://newfold.wordpress.editor.chat/./src/utils/editorHelpers.js","webpack://newfold.wordpress.editor.chat/./src/utils/helpers.js","webpack://newfold.wordpress.editor.chat/./src/utils/markdownParser.js","webpack://newfold.wordpress.editor.chat/./src/utils/sanitizeHtml.js","webpack://newfold.wordpress.editor.chat/external window [\"wp\",\"blocks\"]","webpack://newfold.wordpress.editor.chat/external window [\"wp\",\"components\"]","webpack://newfold.wordpress.editor.chat/external window [\"wp\",\"compose\"]","webpack://newfold.wordpress.editor.chat/external window [\"wp\",\"coreData\"]","webpack://newfold.wordpress.editor.chat/external window [\"wp\",\"data\"]","webpack://newfold.wordpress.editor.chat/external window [\"wp\",\"deprecated\"]","webpack://newfold.wordpress.editor.chat/external window [\"wp\",\"domReady\"]","webpack://newfold.wordpress.editor.chat/external window [\"wp\",\"editor\"]","webpack://newfold.wordpress.editor.chat/external window [\"wp\",\"element\"]","webpack://newfold.wordpress.editor.chat/external window [\"wp\",\"i18n\"]","webpack://newfold.wordpress.editor.chat/external window [\"wp\",\"plugins\"]","webpack://newfold.wordpress.editor.chat/external window [\"wp\",\"preferences\"]","webpack://newfold.wordpress.editor.chat/external window [\"wp\",\"primitives\"]","webpack://newfold.wordpress.editor.chat/external window [\"wp\",\"viewport\"]","webpack://newfold.wordpress.editor.chat/external window \"React\"","webpack://newfold.wordpress.editor.chat/external window \"ReactJSXRuntime\"","webpack://newfold.wordpress.editor.chat/webpack/bootstrap","webpack://newfold.wordpress.editor.chat/webpack/runtime/compat get default export","webpack://newfold.wordpress.editor.chat/webpack/runtime/define property getters","webpack://newfold.wordpress.editor.chat/webpack/runtime/hasOwnProperty shorthand","webpack://newfold.wordpress.editor.chat/webpack/runtime/make namespace object","webpack://newfold.wordpress.editor.chat/./src/chat-editor.js"],"sourcesContent":["import pkceChallenge from 'pkce-challenge';\nimport { LATEST_PROTOCOL_VERSION } from '../types.js';\nimport { OAuthErrorResponseSchema, OpenIdProviderDiscoveryMetadataSchema } from '../shared/auth.js';\nimport { OAuthClientInformationFullSchema, OAuthMetadataSchema, OAuthProtectedResourceMetadataSchema, OAuthTokensSchema } from '../shared/auth.js';\nimport { checkResourceAllowed, resourceUrlFromServerUrl } from '../shared/auth-utils.js';\nimport { InvalidClientError, InvalidClientMetadataError, InvalidGrantError, OAUTH_ERRORS, OAuthError, ServerError, UnauthorizedClientError } from '../server/auth/errors.js';\nexport class UnauthorizedError extends Error {\n    constructor(message) {\n        super(message ?? 'Unauthorized');\n    }\n}\nfunction isClientAuthMethod(method) {\n    return ['client_secret_basic', 'client_secret_post', 'none'].includes(method);\n}\nconst AUTHORIZATION_CODE_RESPONSE_TYPE = 'code';\nconst AUTHORIZATION_CODE_CHALLENGE_METHOD = 'S256';\n/**\n * Determines the best client authentication method to use based on server support and client configuration.\n *\n * Priority order (highest to lowest):\n * 1. client_secret_basic (if client secret is available)\n * 2. client_secret_post (if client secret is available)\n * 3. none (for public clients)\n *\n * @param clientInformation - OAuth client information containing credentials\n * @param supportedMethods - Authentication methods supported by the authorization server\n * @returns The selected authentication method\n */\nexport function selectClientAuthMethod(clientInformation, supportedMethods) {\n    const hasClientSecret = clientInformation.client_secret !== undefined;\n    // If server doesn't specify supported methods, use RFC 6749 defaults\n    if (supportedMethods.length === 0) {\n        return hasClientSecret ? 'client_secret_post' : 'none';\n    }\n    // Prefer the method returned by the server during client registration if valid and supported\n    if ('token_endpoint_auth_method' in clientInformation &&\n        clientInformation.token_endpoint_auth_method &&\n        isClientAuthMethod(clientInformation.token_endpoint_auth_method) &&\n        supportedMethods.includes(clientInformation.token_endpoint_auth_method)) {\n        return clientInformation.token_endpoint_auth_method;\n    }\n    // Try methods in priority order (most secure first)\n    if (hasClientSecret && supportedMethods.includes('client_secret_basic')) {\n        return 'client_secret_basic';\n    }\n    if (hasClientSecret && supportedMethods.includes('client_secret_post')) {\n        return 'client_secret_post';\n    }\n    if (supportedMethods.includes('none')) {\n        return 'none';\n    }\n    // Fallback: use what we have\n    return hasClientSecret ? 'client_secret_post' : 'none';\n}\n/**\n * Applies client authentication to the request based on the specified method.\n *\n * Implements OAuth 2.1 client authentication methods:\n * - client_secret_basic: HTTP Basic authentication (RFC 6749 Section 2.3.1)\n * - client_secret_post: Credentials in request body (RFC 6749 Section 2.3.1)\n * - none: Public client authentication (RFC 6749 Section 2.1)\n *\n * @param method - The authentication method to use\n * @param clientInformation - OAuth client information containing credentials\n * @param headers - HTTP headers object to modify\n * @param params - URL search parameters to modify\n * @throws {Error} When required credentials are missing\n */\nfunction applyClientAuthentication(method, clientInformation, headers, params) {\n    const { client_id, client_secret } = clientInformation;\n    switch (method) {\n        case 'client_secret_basic':\n            applyBasicAuth(client_id, client_secret, headers);\n            return;\n        case 'client_secret_post':\n            applyPostAuth(client_id, client_secret, params);\n            return;\n        case 'none':\n            applyPublicAuth(client_id, params);\n            return;\n        default:\n            throw new Error(`Unsupported client authentication method: ${method}`);\n    }\n}\n/**\n * Applies HTTP Basic authentication (RFC 6749 Section 2.3.1)\n */\nfunction applyBasicAuth(clientId, clientSecret, headers) {\n    if (!clientSecret) {\n        throw new Error('client_secret_basic authentication requires a client_secret');\n    }\n    const credentials = btoa(`${clientId}:${clientSecret}`);\n    headers.set('Authorization', `Basic ${credentials}`);\n}\n/**\n * Applies POST body authentication (RFC 6749 Section 2.3.1)\n */\nfunction applyPostAuth(clientId, clientSecret, params) {\n    params.set('client_id', clientId);\n    if (clientSecret) {\n        params.set('client_secret', clientSecret);\n    }\n}\n/**\n * Applies public client authentication (RFC 6749 Section 2.1)\n */\nfunction applyPublicAuth(clientId, params) {\n    params.set('client_id', clientId);\n}\n/**\n * Parses an OAuth error response from a string or Response object.\n *\n * If the input is a standard OAuth2.0 error response, it will be parsed according to the spec\n * and an instance of the appropriate OAuthError subclass will be returned.\n * If parsing fails, it falls back to a generic ServerError that includes\n * the response status (if available) and original content.\n *\n * @param input - A Response object or string containing the error response\n * @returns A Promise that resolves to an OAuthError instance\n */\nexport async function parseErrorResponse(input) {\n    const statusCode = input instanceof Response ? input.status : undefined;\n    const body = input instanceof Response ? await input.text() : input;\n    try {\n        const result = OAuthErrorResponseSchema.parse(JSON.parse(body));\n        const { error, error_description, error_uri } = result;\n        const errorClass = OAUTH_ERRORS[error] || ServerError;\n        return new errorClass(error_description || '', error_uri);\n    }\n    catch (error) {\n        // Not a valid OAuth error response, but try to inform the user of the raw data anyway\n        const errorMessage = `${statusCode ? `HTTP ${statusCode}: ` : ''}Invalid OAuth error response: ${error}. Raw body: ${body}`;\n        return new ServerError(errorMessage);\n    }\n}\n/**\n * Orchestrates the full auth flow with a server.\n *\n * This can be used as a single entry point for all authorization functionality,\n * instead of linking together the other lower-level functions in this module.\n */\nexport async function auth(provider, options) {\n    try {\n        return await authInternal(provider, options);\n    }\n    catch (error) {\n        // Handle recoverable error types by invalidating credentials and retrying\n        if (error instanceof InvalidClientError || error instanceof UnauthorizedClientError) {\n            await provider.invalidateCredentials?.('all');\n            return await authInternal(provider, options);\n        }\n        else if (error instanceof InvalidGrantError) {\n            await provider.invalidateCredentials?.('tokens');\n            return await authInternal(provider, options);\n        }\n        // Throw otherwise\n        throw error;\n    }\n}\nasync function authInternal(provider, { serverUrl, authorizationCode, scope, resourceMetadataUrl, fetchFn }) {\n    let resourceMetadata;\n    let authorizationServerUrl;\n    try {\n        resourceMetadata = await discoverOAuthProtectedResourceMetadata(serverUrl, { resourceMetadataUrl }, fetchFn);\n        if (resourceMetadata.authorization_servers && resourceMetadata.authorization_servers.length > 0) {\n            authorizationServerUrl = resourceMetadata.authorization_servers[0];\n        }\n    }\n    catch {\n        // Ignore errors and fall back to /.well-known/oauth-authorization-server\n    }\n    /**\n     * If we don't get a valid authorization server metadata from protected resource metadata,\n     * fallback to the legacy MCP spec's implementation (version 2025-03-26): MCP server base URL acts as the Authorization server.\n     */\n    if (!authorizationServerUrl) {\n        authorizationServerUrl = new URL('/', serverUrl);\n    }\n    const resource = await selectResourceURL(serverUrl, provider, resourceMetadata);\n    const metadata = await discoverAuthorizationServerMetadata(authorizationServerUrl, {\n        fetchFn\n    });\n    // Handle client registration if needed\n    let clientInformation = await Promise.resolve(provider.clientInformation());\n    if (!clientInformation) {\n        if (authorizationCode !== undefined) {\n            throw new Error('Existing OAuth client information is required when exchanging an authorization code');\n        }\n        const supportsUrlBasedClientId = metadata?.client_id_metadata_document_supported === true;\n        const clientMetadataUrl = provider.clientMetadataUrl;\n        if (clientMetadataUrl && !isHttpsUrl(clientMetadataUrl)) {\n            throw new InvalidClientMetadataError(`clientMetadataUrl must be a valid HTTPS URL with a non-root pathname, got: ${clientMetadataUrl}`);\n        }\n        const shouldUseUrlBasedClientId = supportsUrlBasedClientId && clientMetadataUrl;\n        if (shouldUseUrlBasedClientId) {\n            // SEP-991: URL-based Client IDs\n            clientInformation = {\n                client_id: clientMetadataUrl\n            };\n            await provider.saveClientInformation?.(clientInformation);\n        }\n        else {\n            // Fallback to dynamic registration\n            if (!provider.saveClientInformation) {\n                throw new Error('OAuth client information must be saveable for dynamic registration');\n            }\n            const fullInformation = await registerClient(authorizationServerUrl, {\n                metadata,\n                clientMetadata: provider.clientMetadata,\n                fetchFn\n            });\n            await provider.saveClientInformation(fullInformation);\n            clientInformation = fullInformation;\n        }\n    }\n    // Non-interactive flows (e.g., client_credentials, jwt-bearer) don't need a redirect URL\n    const nonInteractiveFlow = !provider.redirectUrl;\n    // Exchange authorization code for tokens, or fetch tokens directly for non-interactive flows\n    if (authorizationCode !== undefined || nonInteractiveFlow) {\n        const tokens = await fetchToken(provider, authorizationServerUrl, {\n            metadata,\n            resource,\n            authorizationCode,\n            fetchFn\n        });\n        await provider.saveTokens(tokens);\n        return 'AUTHORIZED';\n    }\n    const tokens = await provider.tokens();\n    // Handle token refresh or new authorization\n    if (tokens?.refresh_token) {\n        try {\n            // Attempt to refresh the token\n            const newTokens = await refreshAuthorization(authorizationServerUrl, {\n                metadata,\n                clientInformation,\n                refreshToken: tokens.refresh_token,\n                resource,\n                addClientAuthentication: provider.addClientAuthentication,\n                fetchFn\n            });\n            await provider.saveTokens(newTokens);\n            return 'AUTHORIZED';\n        }\n        catch (error) {\n            // If this is a ServerError, or an unknown type, log it out and try to continue. Otherwise, escalate so we can fix things and retry.\n            if (!(error instanceof OAuthError) || error instanceof ServerError) {\n                // Could not refresh OAuth tokens\n            }\n            else {\n                // Refresh failed for another reason, re-throw\n                throw error;\n            }\n        }\n    }\n    const state = provider.state ? await provider.state() : undefined;\n    // Start new authorization flow\n    const { authorizationUrl, codeVerifier } = await startAuthorization(authorizationServerUrl, {\n        metadata,\n        clientInformation,\n        state,\n        redirectUrl: provider.redirectUrl,\n        scope: scope || resourceMetadata?.scopes_supported?.join(' ') || provider.clientMetadata.scope,\n        resource\n    });\n    await provider.saveCodeVerifier(codeVerifier);\n    await provider.redirectToAuthorization(authorizationUrl);\n    return 'REDIRECT';\n}\n/**\n * SEP-991: URL-based Client IDs\n * Validate that the client_id is a valid URL with https scheme\n */\nexport function isHttpsUrl(value) {\n    if (!value)\n        return false;\n    try {\n        const url = new URL(value);\n        return url.protocol === 'https:' && url.pathname !== '/';\n    }\n    catch {\n        return false;\n    }\n}\nexport async function selectResourceURL(serverUrl, provider, resourceMetadata) {\n    const defaultResource = resourceUrlFromServerUrl(serverUrl);\n    // If provider has custom validation, delegate to it\n    if (provider.validateResourceURL) {\n        return await provider.validateResourceURL(defaultResource, resourceMetadata?.resource);\n    }\n    // Only include resource parameter when Protected Resource Metadata is present\n    if (!resourceMetadata) {\n        return undefined;\n    }\n    // Validate that the metadata's resource is compatible with our request\n    if (!checkResourceAllowed({ requestedResource: defaultResource, configuredResource: resourceMetadata.resource })) {\n        throw new Error(`Protected resource ${resourceMetadata.resource} does not match expected ${defaultResource} (or origin)`);\n    }\n    // Prefer the resource from metadata since it's what the server is telling us to request\n    return new URL(resourceMetadata.resource);\n}\n/**\n * Extract resource_metadata, scope, and error from WWW-Authenticate header.\n */\nexport function extractWWWAuthenticateParams(res) {\n    const authenticateHeader = res.headers.get('WWW-Authenticate');\n    if (!authenticateHeader) {\n        return {};\n    }\n    const [type, scheme] = authenticateHeader.split(' ');\n    if (type.toLowerCase() !== 'bearer' || !scheme) {\n        return {};\n    }\n    const resourceMetadataMatch = extractFieldFromWwwAuth(res, 'resource_metadata') || undefined;\n    let resourceMetadataUrl;\n    if (resourceMetadataMatch) {\n        try {\n            resourceMetadataUrl = new URL(resourceMetadataMatch);\n        }\n        catch {\n            // Ignore invalid URL\n        }\n    }\n    const scope = extractFieldFromWwwAuth(res, 'scope') || undefined;\n    const error = extractFieldFromWwwAuth(res, 'error') || undefined;\n    return {\n        resourceMetadataUrl,\n        scope,\n        error\n    };\n}\n/**\n * Extracts a specific field's value from the WWW-Authenticate header string.\n *\n * @param response The HTTP response object containing the headers.\n * @param fieldName The name of the field to extract (e.g., \"realm\", \"nonce\").\n * @returns The field value\n */\nfunction extractFieldFromWwwAuth(response, fieldName) {\n    const wwwAuthHeader = response.headers.get('WWW-Authenticate');\n    if (!wwwAuthHeader) {\n        return null;\n    }\n    const pattern = new RegExp(`${fieldName}=(?:\"([^\"]+)\"|([^\\\\s,]+))`);\n    const match = wwwAuthHeader.match(pattern);\n    if (match) {\n        // Pattern matches: field_name=\"value\" or field_name=value (unquoted)\n        return match[1] || match[2];\n    }\n    return null;\n}\n/**\n * Extract resource_metadata from response header.\n * @deprecated Use `extractWWWAuthenticateParams` instead.\n */\nexport function extractResourceMetadataUrl(res) {\n    const authenticateHeader = res.headers.get('WWW-Authenticate');\n    if (!authenticateHeader) {\n        return undefined;\n    }\n    const [type, scheme] = authenticateHeader.split(' ');\n    if (type.toLowerCase() !== 'bearer' || !scheme) {\n        return undefined;\n    }\n    const regex = /resource_metadata=\"([^\"]*)\"/;\n    const match = regex.exec(authenticateHeader);\n    if (!match) {\n        return undefined;\n    }\n    try {\n        return new URL(match[1]);\n    }\n    catch {\n        return undefined;\n    }\n}\n/**\n * Looks up RFC 9728 OAuth 2.0 Protected Resource Metadata.\n *\n * If the server returns a 404 for the well-known endpoint, this function will\n * return `undefined`. Any other errors will be thrown as exceptions.\n */\nexport async function discoverOAuthProtectedResourceMetadata(serverUrl, opts, fetchFn = fetch) {\n    const response = await discoverMetadataWithFallback(serverUrl, 'oauth-protected-resource', fetchFn, {\n        protocolVersion: opts?.protocolVersion,\n        metadataUrl: opts?.resourceMetadataUrl\n    });\n    if (!response || response.status === 404) {\n        await response?.body?.cancel();\n        throw new Error(`Resource server does not implement OAuth 2.0 Protected Resource Metadata.`);\n    }\n    if (!response.ok) {\n        await response.body?.cancel();\n        throw new Error(`HTTP ${response.status} trying to load well-known OAuth protected resource metadata.`);\n    }\n    return OAuthProtectedResourceMetadataSchema.parse(await response.json());\n}\n/**\n * Helper function to handle fetch with CORS retry logic\n */\nasync function fetchWithCorsRetry(url, headers, fetchFn = fetch) {\n    try {\n        return await fetchFn(url, { headers });\n    }\n    catch (error) {\n        if (error instanceof TypeError) {\n            if (headers) {\n                // CORS errors come back as TypeError, retry without headers\n                return fetchWithCorsRetry(url, undefined, fetchFn);\n            }\n            else {\n                // We're getting CORS errors on retry too, return undefined\n                return undefined;\n            }\n        }\n        throw error;\n    }\n}\n/**\n * Constructs the well-known path for auth-related metadata discovery\n */\nfunction buildWellKnownPath(wellKnownPrefix, pathname = '', options = {}) {\n    // Strip trailing slash from pathname to avoid double slashes\n    if (pathname.endsWith('/')) {\n        pathname = pathname.slice(0, -1);\n    }\n    return options.prependPathname ? `${pathname}/.well-known/${wellKnownPrefix}` : `/.well-known/${wellKnownPrefix}${pathname}`;\n}\n/**\n * Tries to discover OAuth metadata at a specific URL\n */\nasync function tryMetadataDiscovery(url, protocolVersion, fetchFn = fetch) {\n    const headers = {\n        'MCP-Protocol-Version': protocolVersion\n    };\n    return await fetchWithCorsRetry(url, headers, fetchFn);\n}\n/**\n * Determines if fallback to root discovery should be attempted\n */\nfunction shouldAttemptFallback(response, pathname) {\n    return !response || (response.status >= 400 && response.status < 500 && pathname !== '/');\n}\n/**\n * Generic function for discovering OAuth metadata with fallback support\n */\nasync function discoverMetadataWithFallback(serverUrl, wellKnownType, fetchFn, opts) {\n    const issuer = new URL(serverUrl);\n    const protocolVersion = opts?.protocolVersion ?? LATEST_PROTOCOL_VERSION;\n    let url;\n    if (opts?.metadataUrl) {\n        url = new URL(opts.metadataUrl);\n    }\n    else {\n        // Try path-aware discovery first\n        const wellKnownPath = buildWellKnownPath(wellKnownType, issuer.pathname);\n        url = new URL(wellKnownPath, opts?.metadataServerUrl ?? issuer);\n        url.search = issuer.search;\n    }\n    let response = await tryMetadataDiscovery(url, protocolVersion, fetchFn);\n    // If path-aware discovery fails with 404 and we're not already at root, try fallback to root discovery\n    if (!opts?.metadataUrl && shouldAttemptFallback(response, issuer.pathname)) {\n        const rootUrl = new URL(`/.well-known/${wellKnownType}`, issuer);\n        response = await tryMetadataDiscovery(rootUrl, protocolVersion, fetchFn);\n    }\n    return response;\n}\n/**\n * Looks up RFC 8414 OAuth 2.0 Authorization Server Metadata.\n *\n * If the server returns a 404 for the well-known endpoint, this function will\n * return `undefined`. Any other errors will be thrown as exceptions.\n *\n * @deprecated This function is deprecated in favor of `discoverAuthorizationServerMetadata`.\n */\nexport async function discoverOAuthMetadata(issuer, { authorizationServerUrl, protocolVersion } = {}, fetchFn = fetch) {\n    if (typeof issuer === 'string') {\n        issuer = new URL(issuer);\n    }\n    if (!authorizationServerUrl) {\n        authorizationServerUrl = issuer;\n    }\n    if (typeof authorizationServerUrl === 'string') {\n        authorizationServerUrl = new URL(authorizationServerUrl);\n    }\n    protocolVersion ?? (protocolVersion = LATEST_PROTOCOL_VERSION);\n    const response = await discoverMetadataWithFallback(authorizationServerUrl, 'oauth-authorization-server', fetchFn, {\n        protocolVersion,\n        metadataServerUrl: authorizationServerUrl\n    });\n    if (!response || response.status === 404) {\n        await response?.body?.cancel();\n        return undefined;\n    }\n    if (!response.ok) {\n        await response.body?.cancel();\n        throw new Error(`HTTP ${response.status} trying to load well-known OAuth metadata`);\n    }\n    return OAuthMetadataSchema.parse(await response.json());\n}\n/**\n * Builds a list of discovery URLs to try for authorization server metadata.\n * URLs are returned in priority order:\n * 1. OAuth metadata at the given URL\n * 2. OIDC metadata endpoints at the given URL\n */\nexport function buildDiscoveryUrls(authorizationServerUrl) {\n    const url = typeof authorizationServerUrl === 'string' ? new URL(authorizationServerUrl) : authorizationServerUrl;\n    const hasPath = url.pathname !== '/';\n    const urlsToTry = [];\n    if (!hasPath) {\n        // Root path: https://example.com/.well-known/oauth-authorization-server\n        urlsToTry.push({\n            url: new URL('/.well-known/oauth-authorization-server', url.origin),\n            type: 'oauth'\n        });\n        // OIDC: https://example.com/.well-known/openid-configuration\n        urlsToTry.push({\n            url: new URL(`/.well-known/openid-configuration`, url.origin),\n            type: 'oidc'\n        });\n        return urlsToTry;\n    }\n    // Strip trailing slash from pathname to avoid double slashes\n    let pathname = url.pathname;\n    if (pathname.endsWith('/')) {\n        pathname = pathname.slice(0, -1);\n    }\n    // 1. OAuth metadata at the given URL\n    // Insert well-known before the path: https://example.com/.well-known/oauth-authorization-server/tenant1\n    urlsToTry.push({\n        url: new URL(`/.well-known/oauth-authorization-server${pathname}`, url.origin),\n        type: 'oauth'\n    });\n    // 2. OIDC metadata endpoints\n    // RFC 8414 style: Insert /.well-known/openid-configuration before the path\n    urlsToTry.push({\n        url: new URL(`/.well-known/openid-configuration${pathname}`, url.origin),\n        type: 'oidc'\n    });\n    // OIDC Discovery 1.0 style: Append /.well-known/openid-configuration after the path\n    urlsToTry.push({\n        url: new URL(`${pathname}/.well-known/openid-configuration`, url.origin),\n        type: 'oidc'\n    });\n    return urlsToTry;\n}\n/**\n * Discovers authorization server metadata with support for RFC 8414 OAuth 2.0 Authorization Server Metadata\n * and OpenID Connect Discovery 1.0 specifications.\n *\n * This function implements a fallback strategy for authorization server discovery:\n * 1. Attempts RFC 8414 OAuth metadata discovery first\n * 2. If OAuth discovery fails, falls back to OpenID Connect Discovery\n *\n * @param authorizationServerUrl - The authorization server URL obtained from the MCP Server's\n *                                 protected resource metadata, or the MCP server's URL if the\n *                                 metadata was not found.\n * @param options - Configuration options\n * @param options.fetchFn - Optional fetch function for making HTTP requests, defaults to global fetch\n * @param options.protocolVersion - MCP protocol version to use, defaults to LATEST_PROTOCOL_VERSION\n * @returns Promise resolving to authorization server metadata, or undefined if discovery fails\n */\nexport async function discoverAuthorizationServerMetadata(authorizationServerUrl, { fetchFn = fetch, protocolVersion = LATEST_PROTOCOL_VERSION } = {}) {\n    const headers = {\n        'MCP-Protocol-Version': protocolVersion,\n        Accept: 'application/json'\n    };\n    // Get the list of URLs to try\n    const urlsToTry = buildDiscoveryUrls(authorizationServerUrl);\n    // Try each URL in order\n    for (const { url: endpointUrl, type } of urlsToTry) {\n        const response = await fetchWithCorsRetry(endpointUrl, headers, fetchFn);\n        if (!response) {\n            /**\n             * CORS error occurred - don't throw as the endpoint may not allow CORS,\n             * continue trying other possible endpoints\n             */\n            continue;\n        }\n        if (!response.ok) {\n            await response.body?.cancel();\n            // Continue looking for any 4xx response code.\n            if (response.status >= 400 && response.status < 500) {\n                continue; // Try next URL\n            }\n            throw new Error(`HTTP ${response.status} trying to load ${type === 'oauth' ? 'OAuth' : 'OpenID provider'} metadata from ${endpointUrl}`);\n        }\n        // Parse and validate based on type\n        if (type === 'oauth') {\n            return OAuthMetadataSchema.parse(await response.json());\n        }\n        else {\n            return OpenIdProviderDiscoveryMetadataSchema.parse(await response.json());\n        }\n    }\n    return undefined;\n}\n/**\n * Begins the authorization flow with the given server, by generating a PKCE challenge and constructing the authorization URL.\n */\nexport async function startAuthorization(authorizationServerUrl, { metadata, clientInformation, redirectUrl, scope, state, resource }) {\n    let authorizationUrl;\n    if (metadata) {\n        authorizationUrl = new URL(metadata.authorization_endpoint);\n        if (!metadata.response_types_supported.includes(AUTHORIZATION_CODE_RESPONSE_TYPE)) {\n            throw new Error(`Incompatible auth server: does not support response type ${AUTHORIZATION_CODE_RESPONSE_TYPE}`);\n        }\n        if (metadata.code_challenge_methods_supported &&\n            !metadata.code_challenge_methods_supported.includes(AUTHORIZATION_CODE_CHALLENGE_METHOD)) {\n            throw new Error(`Incompatible auth server: does not support code challenge method ${AUTHORIZATION_CODE_CHALLENGE_METHOD}`);\n        }\n    }\n    else {\n        authorizationUrl = new URL('/authorize', authorizationServerUrl);\n    }\n    // Generate PKCE challenge\n    const challenge = await pkceChallenge();\n    const codeVerifier = challenge.code_verifier;\n    const codeChallenge = challenge.code_challenge;\n    authorizationUrl.searchParams.set('response_type', AUTHORIZATION_CODE_RESPONSE_TYPE);\n    authorizationUrl.searchParams.set('client_id', clientInformation.client_id);\n    authorizationUrl.searchParams.set('code_challenge', codeChallenge);\n    authorizationUrl.searchParams.set('code_challenge_method', AUTHORIZATION_CODE_CHALLENGE_METHOD);\n    authorizationUrl.searchParams.set('redirect_uri', String(redirectUrl));\n    if (state) {\n        authorizationUrl.searchParams.set('state', state);\n    }\n    if (scope) {\n        authorizationUrl.searchParams.set('scope', scope);\n    }\n    if (scope?.includes('offline_access')) {\n        // if the request includes the OIDC-only \"offline_access\" scope,\n        // we need to set the prompt to \"consent\" to ensure the user is prompted to grant offline access\n        // https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess\n        authorizationUrl.searchParams.append('prompt', 'consent');\n    }\n    if (resource) {\n        authorizationUrl.searchParams.set('resource', resource.href);\n    }\n    return { authorizationUrl, codeVerifier };\n}\n/**\n * Prepares token request parameters for an authorization code exchange.\n *\n * This is the default implementation used by fetchToken when the provider\n * doesn't implement prepareTokenRequest.\n *\n * @param authorizationCode - The authorization code received from the authorization endpoint\n * @param codeVerifier - The PKCE code verifier\n * @param redirectUri - The redirect URI used in the authorization request\n * @returns URLSearchParams for the authorization_code grant\n */\nexport function prepareAuthorizationCodeRequest(authorizationCode, codeVerifier, redirectUri) {\n    return new URLSearchParams({\n        grant_type: 'authorization_code',\n        code: authorizationCode,\n        code_verifier: codeVerifier,\n        redirect_uri: String(redirectUri)\n    });\n}\n/**\n * Internal helper to execute a token request with the given parameters.\n * Used by exchangeAuthorization, refreshAuthorization, and fetchToken.\n */\nasync function executeTokenRequest(authorizationServerUrl, { metadata, tokenRequestParams, clientInformation, addClientAuthentication, resource, fetchFn }) {\n    const tokenUrl = metadata?.token_endpoint ? new URL(metadata.token_endpoint) : new URL('/token', authorizationServerUrl);\n    const headers = new Headers({\n        'Content-Type': 'application/x-www-form-urlencoded',\n        Accept: 'application/json'\n    });\n    if (resource) {\n        tokenRequestParams.set('resource', resource.href);\n    }\n    if (addClientAuthentication) {\n        await addClientAuthentication(headers, tokenRequestParams, tokenUrl, metadata);\n    }\n    else if (clientInformation) {\n        const supportedMethods = metadata?.token_endpoint_auth_methods_supported ?? [];\n        const authMethod = selectClientAuthMethod(clientInformation, supportedMethods);\n        applyClientAuthentication(authMethod, clientInformation, headers, tokenRequestParams);\n    }\n    const response = await (fetchFn ?? fetch)(tokenUrl, {\n        method: 'POST',\n        headers,\n        body: tokenRequestParams\n    });\n    if (!response.ok) {\n        throw await parseErrorResponse(response);\n    }\n    return OAuthTokensSchema.parse(await response.json());\n}\n/**\n * Exchanges an authorization code for an access token with the given server.\n *\n * Supports multiple client authentication methods as specified in OAuth 2.1:\n * - Automatically selects the best authentication method based on server support\n * - Falls back to appropriate defaults when server metadata is unavailable\n *\n * @param authorizationServerUrl - The authorization server's base URL\n * @param options - Configuration object containing client info, auth code, etc.\n * @returns Promise resolving to OAuth tokens\n * @throws {Error} When token exchange fails or authentication is invalid\n */\nexport async function exchangeAuthorization(authorizationServerUrl, { metadata, clientInformation, authorizationCode, codeVerifier, redirectUri, resource, addClientAuthentication, fetchFn }) {\n    const tokenRequestParams = prepareAuthorizationCodeRequest(authorizationCode, codeVerifier, redirectUri);\n    return executeTokenRequest(authorizationServerUrl, {\n        metadata,\n        tokenRequestParams,\n        clientInformation,\n        addClientAuthentication,\n        resource,\n        fetchFn\n    });\n}\n/**\n * Exchange a refresh token for an updated access token.\n *\n * Supports multiple client authentication methods as specified in OAuth 2.1:\n * - Automatically selects the best authentication method based on server support\n * - Preserves the original refresh token if a new one is not returned\n *\n * @param authorizationServerUrl - The authorization server's base URL\n * @param options - Configuration object containing client info, refresh token, etc.\n * @returns Promise resolving to OAuth tokens (preserves original refresh_token if not replaced)\n * @throws {Error} When token refresh fails or authentication is invalid\n */\nexport async function refreshAuthorization(authorizationServerUrl, { metadata, clientInformation, refreshToken, resource, addClientAuthentication, fetchFn }) {\n    const tokenRequestParams = new URLSearchParams({\n        grant_type: 'refresh_token',\n        refresh_token: refreshToken\n    });\n    const tokens = await executeTokenRequest(authorizationServerUrl, {\n        metadata,\n        tokenRequestParams,\n        clientInformation,\n        addClientAuthentication,\n        resource,\n        fetchFn\n    });\n    // Preserve original refresh token if server didn't return a new one\n    return { refresh_token: refreshToken, ...tokens };\n}\n/**\n * Unified token fetching that works with any grant type via provider.prepareTokenRequest().\n *\n * This function provides a single entry point for obtaining tokens regardless of the\n * OAuth grant type. The provider's prepareTokenRequest() method determines which grant\n * to use and supplies the grant-specific parameters.\n *\n * @param provider - OAuth client provider that implements prepareTokenRequest()\n * @param authorizationServerUrl - The authorization server's base URL\n * @param options - Configuration for the token request\n * @returns Promise resolving to OAuth tokens\n * @throws {Error} When provider doesn't implement prepareTokenRequest or token fetch fails\n *\n * @example\n * // Provider for client_credentials:\n * class MyProvider implements OAuthClientProvider {\n *   prepareTokenRequest(scope) {\n *     const params = new URLSearchParams({ grant_type: 'client_credentials' });\n *     if (scope) params.set('scope', scope);\n *     return params;\n *   }\n *   // ... other methods\n * }\n *\n * const tokens = await fetchToken(provider, authServerUrl, { metadata });\n */\nexport async function fetchToken(provider, authorizationServerUrl, { metadata, resource, authorizationCode, fetchFn } = {}) {\n    const scope = provider.clientMetadata.scope;\n    // Use provider's prepareTokenRequest if available, otherwise fall back to authorization_code\n    let tokenRequestParams;\n    if (provider.prepareTokenRequest) {\n        tokenRequestParams = await provider.prepareTokenRequest(scope);\n    }\n    // Default to authorization_code grant if no custom prepareTokenRequest\n    if (!tokenRequestParams) {\n        if (!authorizationCode) {\n            throw new Error('Either provider.prepareTokenRequest() or authorizationCode is required');\n        }\n        if (!provider.redirectUrl) {\n            throw new Error('redirectUrl is required for authorization_code flow');\n        }\n        const codeVerifier = await provider.codeVerifier();\n        tokenRequestParams = prepareAuthorizationCodeRequest(authorizationCode, codeVerifier, provider.redirectUrl);\n    }\n    const clientInformation = await provider.clientInformation();\n    return executeTokenRequest(authorizationServerUrl, {\n        metadata,\n        tokenRequestParams,\n        clientInformation: clientInformation ?? undefined,\n        addClientAuthentication: provider.addClientAuthentication,\n        resource,\n        fetchFn\n    });\n}\n/**\n * Performs OAuth 2.0 Dynamic Client Registration according to RFC 7591.\n */\nexport async function registerClient(authorizationServerUrl, { metadata, clientMetadata, fetchFn }) {\n    let registrationUrl;\n    if (metadata) {\n        if (!metadata.registration_endpoint) {\n            throw new Error('Incompatible auth server: does not support dynamic client registration');\n        }\n        registrationUrl = new URL(metadata.registration_endpoint);\n    }\n    else {\n        registrationUrl = new URL('/register', authorizationServerUrl);\n    }\n    const response = await (fetchFn ?? fetch)(registrationUrl, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(clientMetadata)\n    });\n    if (!response.ok) {\n        throw await parseErrorResponse(response);\n    }\n    return OAuthClientInformationFullSchema.parse(await response.json());\n}\n//# sourceMappingURL=auth.js.map","import { mergeCapabilities, Protocol } from '../shared/protocol.js';\nimport { CallToolResultSchema, CompleteResultSchema, EmptyResultSchema, ErrorCode, GetPromptResultSchema, InitializeResultSchema, LATEST_PROTOCOL_VERSION, ListPromptsResultSchema, ListResourcesResultSchema, ListResourceTemplatesResultSchema, ListToolsResultSchema, McpError, ReadResourceResultSchema, SUPPORTED_PROTOCOL_VERSIONS, ElicitResultSchema, ElicitRequestSchema, CreateTaskResultSchema, CreateMessageRequestSchema, CreateMessageResultSchema, ToolListChangedNotificationSchema, PromptListChangedNotificationSchema, ResourceListChangedNotificationSchema, ListChangedOptionsBaseSchema } from '../types.js';\nimport { AjvJsonSchemaValidator } from '../validation/ajv-provider.js';\nimport { getObjectShape, isZ4Schema, safeParse } from '../server/zod-compat.js';\nimport { ExperimentalClientTasks } from '../experimental/tasks/client.js';\nimport { assertToolsCallTaskCapability, assertClientRequestTaskCapability } from '../experimental/tasks/helpers.js';\n/**\n * Elicitation default application helper. Applies defaults to the data based on the schema.\n *\n * @param schema - The schema to apply defaults to.\n * @param data - The data to apply defaults to.\n */\nfunction applyElicitationDefaults(schema, data) {\n    if (!schema || data === null || typeof data !== 'object')\n        return;\n    // Handle object properties\n    if (schema.type === 'object' && schema.properties && typeof schema.properties === 'object') {\n        const obj = data;\n        const props = schema.properties;\n        for (const key of Object.keys(props)) {\n            const propSchema = props[key];\n            // If missing or explicitly undefined, apply default if present\n            if (obj[key] === undefined && Object.prototype.hasOwnProperty.call(propSchema, 'default')) {\n                obj[key] = propSchema.default;\n            }\n            // Recurse into existing nested objects/arrays\n            if (obj[key] !== undefined) {\n                applyElicitationDefaults(propSchema, obj[key]);\n            }\n        }\n    }\n    if (Array.isArray(schema.anyOf)) {\n        for (const sub of schema.anyOf) {\n            // Skip boolean schemas (true/false are valid JSON Schemas but have no defaults)\n            if (typeof sub !== 'boolean') {\n                applyElicitationDefaults(sub, data);\n            }\n        }\n    }\n    // Combine schemas\n    if (Array.isArray(schema.oneOf)) {\n        for (const sub of schema.oneOf) {\n            // Skip boolean schemas (true/false are valid JSON Schemas but have no defaults)\n            if (typeof sub !== 'boolean') {\n                applyElicitationDefaults(sub, data);\n            }\n        }\n    }\n}\n/**\n * Determines which elicitation modes are supported based on declared client capabilities.\n *\n * According to the spec:\n * - An empty elicitation capability object defaults to form mode support (backwards compatibility)\n * - URL mode is only supported if explicitly declared\n *\n * @param capabilities - The client's elicitation capabilities\n * @returns An object indicating which modes are supported\n */\nexport function getSupportedElicitationModes(capabilities) {\n    if (!capabilities) {\n        return { supportsFormMode: false, supportsUrlMode: false };\n    }\n    const hasFormCapability = capabilities.form !== undefined;\n    const hasUrlCapability = capabilities.url !== undefined;\n    // If neither form nor url are explicitly declared, form mode is supported (backwards compatibility)\n    const supportsFormMode = hasFormCapability || (!hasFormCapability && !hasUrlCapability);\n    const supportsUrlMode = hasUrlCapability;\n    return { supportsFormMode, supportsUrlMode };\n}\n/**\n * An MCP client on top of a pluggable transport.\n *\n * The client will automatically begin the initialization flow with the server when connect() is called.\n *\n * To use with custom types, extend the base Request/Notification/Result types and pass them as type parameters:\n *\n * ```typescript\n * // Custom schemas\n * const CustomRequestSchema = RequestSchema.extend({...})\n * const CustomNotificationSchema = NotificationSchema.extend({...})\n * const CustomResultSchema = ResultSchema.extend({...})\n *\n * // Type aliases\n * type CustomRequest = z.infer<typeof CustomRequestSchema>\n * type CustomNotification = z.infer<typeof CustomNotificationSchema>\n * type CustomResult = z.infer<typeof CustomResultSchema>\n *\n * // Create typed client\n * const client = new Client<CustomRequest, CustomNotification, CustomResult>({\n *   name: \"CustomClient\",\n *   version: \"1.0.0\"\n * })\n * ```\n */\nexport class Client extends Protocol {\n    /**\n     * Initializes this client with the given name and version information.\n     */\n    constructor(_clientInfo, options) {\n        super(options);\n        this._clientInfo = _clientInfo;\n        this._cachedToolOutputValidators = new Map();\n        this._cachedKnownTaskTools = new Set();\n        this._cachedRequiredTaskTools = new Set();\n        this._listChangedDebounceTimers = new Map();\n        this._capabilities = options?.capabilities ?? {};\n        this._jsonSchemaValidator = options?.jsonSchemaValidator ?? new AjvJsonSchemaValidator();\n        // Store list changed config for setup after connection (when we know server capabilities)\n        if (options?.listChanged) {\n            this._pendingListChangedConfig = options.listChanged;\n        }\n    }\n    /**\n     * Set up handlers for list changed notifications based on config and server capabilities.\n     * This should only be called after initialization when server capabilities are known.\n     * Handlers are silently skipped if the server doesn't advertise the corresponding listChanged capability.\n     * @internal\n     */\n    _setupListChangedHandlers(config) {\n        if (config.tools && this._serverCapabilities?.tools?.listChanged) {\n            this._setupListChangedHandler('tools', ToolListChangedNotificationSchema, config.tools, async () => {\n                const result = await this.listTools();\n                return result.tools;\n            });\n        }\n        if (config.prompts && this._serverCapabilities?.prompts?.listChanged) {\n            this._setupListChangedHandler('prompts', PromptListChangedNotificationSchema, config.prompts, async () => {\n                const result = await this.listPrompts();\n                return result.prompts;\n            });\n        }\n        if (config.resources && this._serverCapabilities?.resources?.listChanged) {\n            this._setupListChangedHandler('resources', ResourceListChangedNotificationSchema, config.resources, async () => {\n                const result = await this.listResources();\n                return result.resources;\n            });\n        }\n    }\n    /**\n     * Access experimental features.\n     *\n     * WARNING: These APIs are experimental and may change without notice.\n     *\n     * @experimental\n     */\n    get experimental() {\n        if (!this._experimental) {\n            this._experimental = {\n                tasks: new ExperimentalClientTasks(this)\n            };\n        }\n        return this._experimental;\n    }\n    /**\n     * Registers new capabilities. This can only be called before connecting to a transport.\n     *\n     * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).\n     */\n    registerCapabilities(capabilities) {\n        if (this.transport) {\n            throw new Error('Cannot register capabilities after connecting to transport');\n        }\n        this._capabilities = mergeCapabilities(this._capabilities, capabilities);\n    }\n    /**\n     * Override request handler registration to enforce client-side validation for elicitation.\n     */\n    setRequestHandler(requestSchema, handler) {\n        const shape = getObjectShape(requestSchema);\n        const methodSchema = shape?.method;\n        if (!methodSchema) {\n            throw new Error('Schema is missing a method literal');\n        }\n        // Extract literal value using type-safe property access\n        let methodValue;\n        if (isZ4Schema(methodSchema)) {\n            const v4Schema = methodSchema;\n            const v4Def = v4Schema._zod?.def;\n            methodValue = v4Def?.value ?? v4Schema.value;\n        }\n        else {\n            const v3Schema = methodSchema;\n            const legacyDef = v3Schema._def;\n            methodValue = legacyDef?.value ?? v3Schema.value;\n        }\n        if (typeof methodValue !== 'string') {\n            throw new Error('Schema method literal must be a string');\n        }\n        const method = methodValue;\n        if (method === 'elicitation/create') {\n            const wrappedHandler = async (request, extra) => {\n                const validatedRequest = safeParse(ElicitRequestSchema, request);\n                if (!validatedRequest.success) {\n                    // Type guard: if success is false, error is guaranteed to exist\n                    const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);\n                    throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation request: ${errorMessage}`);\n                }\n                const { params } = validatedRequest.data;\n                params.mode = params.mode ?? 'form';\n                const { supportsFormMode, supportsUrlMode } = getSupportedElicitationModes(this._capabilities.elicitation);\n                if (params.mode === 'form' && !supportsFormMode) {\n                    throw new McpError(ErrorCode.InvalidParams, 'Client does not support form-mode elicitation requests');\n                }\n                if (params.mode === 'url' && !supportsUrlMode) {\n                    throw new McpError(ErrorCode.InvalidParams, 'Client does not support URL-mode elicitation requests');\n                }\n                const result = await Promise.resolve(handler(request, extra));\n                // When task creation is requested, validate and return CreateTaskResult\n                if (params.task) {\n                    const taskValidationResult = safeParse(CreateTaskResultSchema, result);\n                    if (!taskValidationResult.success) {\n                        const errorMessage = taskValidationResult.error instanceof Error\n                            ? taskValidationResult.error.message\n                            : String(taskValidationResult.error);\n                        throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);\n                    }\n                    return taskValidationResult.data;\n                }\n                // For non-task requests, validate against ElicitResultSchema\n                const validationResult = safeParse(ElicitResultSchema, result);\n                if (!validationResult.success) {\n                    // Type guard: if success is false, error is guaranteed to exist\n                    const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);\n                    throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation result: ${errorMessage}`);\n                }\n                const validatedResult = validationResult.data;\n                const requestedSchema = params.mode === 'form' ? params.requestedSchema : undefined;\n                if (params.mode === 'form' && validatedResult.action === 'accept' && validatedResult.content && requestedSchema) {\n                    if (this._capabilities.elicitation?.form?.applyDefaults) {\n                        try {\n                            applyElicitationDefaults(requestedSchema, validatedResult.content);\n                        }\n                        catch {\n                            // gracefully ignore errors in default application\n                        }\n                    }\n                }\n                return validatedResult;\n            };\n            // Install the wrapped handler\n            return super.setRequestHandler(requestSchema, wrappedHandler);\n        }\n        if (method === 'sampling/createMessage') {\n            const wrappedHandler = async (request, extra) => {\n                const validatedRequest = safeParse(CreateMessageRequestSchema, request);\n                if (!validatedRequest.success) {\n                    const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);\n                    throw new McpError(ErrorCode.InvalidParams, `Invalid sampling request: ${errorMessage}`);\n                }\n                const { params } = validatedRequest.data;\n                const result = await Promise.resolve(handler(request, extra));\n                // When task creation is requested, validate and return CreateTaskResult\n                if (params.task) {\n                    const taskValidationResult = safeParse(CreateTaskResultSchema, result);\n                    if (!taskValidationResult.success) {\n                        const errorMessage = taskValidationResult.error instanceof Error\n                            ? taskValidationResult.error.message\n                            : String(taskValidationResult.error);\n                        throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);\n                    }\n                    return taskValidationResult.data;\n                }\n                // For non-task requests, validate against CreateMessageResultSchema\n                const validationResult = safeParse(CreateMessageResultSchema, result);\n                if (!validationResult.success) {\n                    const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);\n                    throw new McpError(ErrorCode.InvalidParams, `Invalid sampling result: ${errorMessage}`);\n                }\n                return validationResult.data;\n            };\n            // Install the wrapped handler\n            return super.setRequestHandler(requestSchema, wrappedHandler);\n        }\n        // Other handlers use default behavior\n        return super.setRequestHandler(requestSchema, handler);\n    }\n    assertCapability(capability, method) {\n        if (!this._serverCapabilities?.[capability]) {\n            throw new Error(`Server does not support ${capability} (required for ${method})`);\n        }\n    }\n    async connect(transport, options) {\n        await super.connect(transport);\n        // When transport sessionId is already set this means we are trying to reconnect.\n        // In this case we don't need to initialize again.\n        if (transport.sessionId !== undefined) {\n            return;\n        }\n        try {\n            const result = await this.request({\n                method: 'initialize',\n                params: {\n                    protocolVersion: LATEST_PROTOCOL_VERSION,\n                    capabilities: this._capabilities,\n                    clientInfo: this._clientInfo\n                }\n            }, InitializeResultSchema, options);\n            if (result === undefined) {\n                throw new Error(`Server sent invalid initialize result: ${result}`);\n            }\n            if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {\n                throw new Error(`Server's protocol version is not supported: ${result.protocolVersion}`);\n            }\n            this._serverCapabilities = result.capabilities;\n            this._serverVersion = result.serverInfo;\n            // HTTP transports must set the protocol version in each header after initialization.\n            if (transport.setProtocolVersion) {\n                transport.setProtocolVersion(result.protocolVersion);\n            }\n            this._instructions = result.instructions;\n            await this.notification({\n                method: 'notifications/initialized'\n            });\n            // Set up list changed handlers now that we know server capabilities\n            if (this._pendingListChangedConfig) {\n                this._setupListChangedHandlers(this._pendingListChangedConfig);\n                this._pendingListChangedConfig = undefined;\n            }\n        }\n        catch (error) {\n            // Disconnect if initialization fails.\n            void this.close();\n            throw error;\n        }\n    }\n    /**\n     * After initialization has completed, this will be populated with the server's reported capabilities.\n     */\n    getServerCapabilities() {\n        return this._serverCapabilities;\n    }\n    /**\n     * After initialization has completed, this will be populated with information about the server's name and version.\n     */\n    getServerVersion() {\n        return this._serverVersion;\n    }\n    /**\n     * After initialization has completed, this may be populated with information about the server's instructions.\n     */\n    getInstructions() {\n        return this._instructions;\n    }\n    assertCapabilityForMethod(method) {\n        switch (method) {\n            case 'logging/setLevel':\n                if (!this._serverCapabilities?.logging) {\n                    throw new Error(`Server does not support logging (required for ${method})`);\n                }\n                break;\n            case 'prompts/get':\n            case 'prompts/list':\n                if (!this._serverCapabilities?.prompts) {\n                    throw new Error(`Server does not support prompts (required for ${method})`);\n                }\n                break;\n            case 'resources/list':\n            case 'resources/templates/list':\n            case 'resources/read':\n            case 'resources/subscribe':\n            case 'resources/unsubscribe':\n                if (!this._serverCapabilities?.resources) {\n                    throw new Error(`Server does not support resources (required for ${method})`);\n                }\n                if (method === 'resources/subscribe' && !this._serverCapabilities.resources.subscribe) {\n                    throw new Error(`Server does not support resource subscriptions (required for ${method})`);\n                }\n                break;\n            case 'tools/call':\n            case 'tools/list':\n                if (!this._serverCapabilities?.tools) {\n                    throw new Error(`Server does not support tools (required for ${method})`);\n                }\n                break;\n            case 'completion/complete':\n                if (!this._serverCapabilities?.completions) {\n                    throw new Error(`Server does not support completions (required for ${method})`);\n                }\n                break;\n            case 'initialize':\n                // No specific capability required for initialize\n                break;\n            case 'ping':\n                // No specific capability required for ping\n                break;\n        }\n    }\n    assertNotificationCapability(method) {\n        switch (method) {\n            case 'notifications/roots/list_changed':\n                if (!this._capabilities.roots?.listChanged) {\n                    throw new Error(`Client does not support roots list changed notifications (required for ${method})`);\n                }\n                break;\n            case 'notifications/initialized':\n                // No specific capability required for initialized\n                break;\n            case 'notifications/cancelled':\n                // Cancellation notifications are always allowed\n                break;\n            case 'notifications/progress':\n                // Progress notifications are always allowed\n                break;\n        }\n    }\n    assertRequestHandlerCapability(method) {\n        // Task handlers are registered in Protocol constructor before _capabilities is initialized\n        // Skip capability check for task methods during initialization\n        if (!this._capabilities) {\n            return;\n        }\n        switch (method) {\n            case 'sampling/createMessage':\n                if (!this._capabilities.sampling) {\n                    throw new Error(`Client does not support sampling capability (required for ${method})`);\n                }\n                break;\n            case 'elicitation/create':\n                if (!this._capabilities.elicitation) {\n                    throw new Error(`Client does not support elicitation capability (required for ${method})`);\n                }\n                break;\n            case 'roots/list':\n                if (!this._capabilities.roots) {\n                    throw new Error(`Client does not support roots capability (required for ${method})`);\n                }\n                break;\n            case 'tasks/get':\n            case 'tasks/list':\n            case 'tasks/result':\n            case 'tasks/cancel':\n                if (!this._capabilities.tasks) {\n                    throw new Error(`Client does not support tasks capability (required for ${method})`);\n                }\n                break;\n            case 'ping':\n                // No specific capability required for ping\n                break;\n        }\n    }\n    assertTaskCapability(method) {\n        assertToolsCallTaskCapability(this._serverCapabilities?.tasks?.requests, method, 'Server');\n    }\n    assertTaskHandlerCapability(method) {\n        // Task handlers are registered in Protocol constructor before _capabilities is initialized\n        // Skip capability check for task methods during initialization\n        if (!this._capabilities) {\n            return;\n        }\n        assertClientRequestTaskCapability(this._capabilities.tasks?.requests, method, 'Client');\n    }\n    async ping(options) {\n        return this.request({ method: 'ping' }, EmptyResultSchema, options);\n    }\n    async complete(params, options) {\n        return this.request({ method: 'completion/complete', params }, CompleteResultSchema, options);\n    }\n    async setLoggingLevel(level, options) {\n        return this.request({ method: 'logging/setLevel', params: { level } }, EmptyResultSchema, options);\n    }\n    async getPrompt(params, options) {\n        return this.request({ method: 'prompts/get', params }, GetPromptResultSchema, options);\n    }\n    async listPrompts(params, options) {\n        return this.request({ method: 'prompts/list', params }, ListPromptsResultSchema, options);\n    }\n    async listResources(params, options) {\n        return this.request({ method: 'resources/list', params }, ListResourcesResultSchema, options);\n    }\n    async listResourceTemplates(params, options) {\n        return this.request({ method: 'resources/templates/list', params }, ListResourceTemplatesResultSchema, options);\n    }\n    async readResource(params, options) {\n        return this.request({ method: 'resources/read', params }, ReadResourceResultSchema, options);\n    }\n    async subscribeResource(params, options) {\n        return this.request({ method: 'resources/subscribe', params }, EmptyResultSchema, options);\n    }\n    async unsubscribeResource(params, options) {\n        return this.request({ method: 'resources/unsubscribe', params }, EmptyResultSchema, options);\n    }\n    /**\n     * Calls a tool and waits for the result. Automatically validates structured output if the tool has an outputSchema.\n     *\n     * For task-based execution with streaming behavior, use client.experimental.tasks.callToolStream() instead.\n     */\n    async callTool(params, resultSchema = CallToolResultSchema, options) {\n        // Guard: required-task tools need experimental API\n        if (this.isToolTaskRequired(params.name)) {\n            throw new McpError(ErrorCode.InvalidRequest, `Tool \"${params.name}\" requires task-based execution. Use client.experimental.tasks.callToolStream() instead.`);\n        }\n        const result = await this.request({ method: 'tools/call', params }, resultSchema, options);\n        // Check if the tool has an outputSchema\n        const validator = this.getToolOutputValidator(params.name);\n        if (validator) {\n            // If tool has outputSchema, it MUST return structuredContent (unless it's an error)\n            if (!result.structuredContent && !result.isError) {\n                throw new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`);\n            }\n            // Only validate structured content if present (not when there's an error)\n            if (result.structuredContent) {\n                try {\n                    // Validate the structured content against the schema\n                    const validationResult = validator(result.structuredContent);\n                    if (!validationResult.valid) {\n                        throw new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`);\n                    }\n                }\n                catch (error) {\n                    if (error instanceof McpError) {\n                        throw error;\n                    }\n                    throw new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error instanceof Error ? error.message : String(error)}`);\n                }\n            }\n        }\n        return result;\n    }\n    isToolTask(toolName) {\n        if (!this._serverCapabilities?.tasks?.requests?.tools?.call) {\n            return false;\n        }\n        return this._cachedKnownTaskTools.has(toolName);\n    }\n    /**\n     * Check if a tool requires task-based execution.\n     * Unlike isToolTask which includes 'optional' tools, this only checks for 'required'.\n     */\n    isToolTaskRequired(toolName) {\n        return this._cachedRequiredTaskTools.has(toolName);\n    }\n    /**\n     * Cache validators for tool output schemas.\n     * Called after listTools() to pre-compile validators for better performance.\n     */\n    cacheToolMetadata(tools) {\n        this._cachedToolOutputValidators.clear();\n        this._cachedKnownTaskTools.clear();\n        this._cachedRequiredTaskTools.clear();\n        for (const tool of tools) {\n            // If the tool has an outputSchema, create and cache the validator\n            if (tool.outputSchema) {\n                const toolValidator = this._jsonSchemaValidator.getValidator(tool.outputSchema);\n                this._cachedToolOutputValidators.set(tool.name, toolValidator);\n            }\n            // If the tool supports task-based execution, cache that information\n            const taskSupport = tool.execution?.taskSupport;\n            if (taskSupport === 'required' || taskSupport === 'optional') {\n                this._cachedKnownTaskTools.add(tool.name);\n            }\n            if (taskSupport === 'required') {\n                this._cachedRequiredTaskTools.add(tool.name);\n            }\n        }\n    }\n    /**\n     * Get cached validator for a tool\n     */\n    getToolOutputValidator(toolName) {\n        return this._cachedToolOutputValidators.get(toolName);\n    }\n    async listTools(params, options) {\n        const result = await this.request({ method: 'tools/list', params }, ListToolsResultSchema, options);\n        // Cache the tools and their output schemas for future validation\n        this.cacheToolMetadata(result.tools);\n        return result;\n    }\n    /**\n     * Set up a single list changed handler.\n     * @internal\n     */\n    _setupListChangedHandler(listType, notificationSchema, options, fetcher) {\n        // Validate options using Zod schema (validates autoRefresh and debounceMs)\n        const parseResult = ListChangedOptionsBaseSchema.safeParse(options);\n        if (!parseResult.success) {\n            throw new Error(`Invalid ${listType} listChanged options: ${parseResult.error.message}`);\n        }\n        // Validate callback\n        if (typeof options.onChanged !== 'function') {\n            throw new Error(`Invalid ${listType} listChanged options: onChanged must be a function`);\n        }\n        const { autoRefresh, debounceMs } = parseResult.data;\n        const { onChanged } = options;\n        const refresh = async () => {\n            if (!autoRefresh) {\n                onChanged(null, null);\n                return;\n            }\n            try {\n                const items = await fetcher();\n                onChanged(null, items);\n            }\n            catch (e) {\n                const error = e instanceof Error ? e : new Error(String(e));\n                onChanged(error, null);\n            }\n        };\n        const handler = () => {\n            if (debounceMs) {\n                // Clear any pending debounce timer for this list type\n                const existingTimer = this._listChangedDebounceTimers.get(listType);\n                if (existingTimer) {\n                    clearTimeout(existingTimer);\n                }\n                // Set up debounced refresh\n                const timer = setTimeout(refresh, debounceMs);\n                this._listChangedDebounceTimers.set(listType, timer);\n            }\n            else {\n                // No debounce, refresh immediately\n                refresh();\n            }\n        };\n        // Register notification handler\n        this.setNotificationHandler(notificationSchema, handler);\n    }\n    async sendRootsListChanged() {\n        return this.notification({ method: 'notifications/roots/list_changed' });\n    }\n}\n//# sourceMappingURL=index.js.map","import { createFetchWithInit, normalizeHeaders } from '../shared/transport.js';\nimport { isInitializedNotification, isJSONRPCRequest, isJSONRPCResultResponse, JSONRPCMessageSchema } from '../types.js';\nimport { auth, extractWWWAuthenticateParams, UnauthorizedError } from './auth.js';\nimport { EventSourceParserStream } from 'eventsource-parser/stream';\n// Default reconnection options for StreamableHTTP connections\nconst DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS = {\n    initialReconnectionDelay: 1000,\n    maxReconnectionDelay: 30000,\n    reconnectionDelayGrowFactor: 1.5,\n    maxRetries: 2\n};\nexport class StreamableHTTPError extends Error {\n    constructor(code, message) {\n        super(`Streamable HTTP error: ${message}`);\n        this.code = code;\n    }\n}\n/**\n * Client transport for Streamable HTTP: this implements the MCP Streamable HTTP transport specification.\n * It will connect to a server using HTTP POST for sending messages and HTTP GET with Server-Sent Events\n * for receiving messages.\n */\nexport class StreamableHTTPClientTransport {\n    constructor(url, opts) {\n        this._hasCompletedAuthFlow = false; // Circuit breaker: detect auth success followed by immediate 401\n        this._url = url;\n        this._resourceMetadataUrl = undefined;\n        this._scope = undefined;\n        this._requestInit = opts?.requestInit;\n        this._authProvider = opts?.authProvider;\n        this._fetch = opts?.fetch;\n        this._fetchWithInit = createFetchWithInit(opts?.fetch, opts?.requestInit);\n        this._sessionId = opts?.sessionId;\n        this._reconnectionOptions = opts?.reconnectionOptions ?? DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS;\n    }\n    async _authThenStart() {\n        if (!this._authProvider) {\n            throw new UnauthorizedError('No auth provider');\n        }\n        let result;\n        try {\n            result = await auth(this._authProvider, {\n                serverUrl: this._url,\n                resourceMetadataUrl: this._resourceMetadataUrl,\n                scope: this._scope,\n                fetchFn: this._fetchWithInit\n            });\n        }\n        catch (error) {\n            this.onerror?.(error);\n            throw error;\n        }\n        if (result !== 'AUTHORIZED') {\n            throw new UnauthorizedError();\n        }\n        return await this._startOrAuthSse({ resumptionToken: undefined });\n    }\n    async _commonHeaders() {\n        const headers = {};\n        if (this._authProvider) {\n            const tokens = await this._authProvider.tokens();\n            if (tokens) {\n                headers['Authorization'] = `Bearer ${tokens.access_token}`;\n            }\n        }\n        if (this._sessionId) {\n            headers['mcp-session-id'] = this._sessionId;\n        }\n        if (this._protocolVersion) {\n            headers['mcp-protocol-version'] = this._protocolVersion;\n        }\n        const extraHeaders = normalizeHeaders(this._requestInit?.headers);\n        return new Headers({\n            ...headers,\n            ...extraHeaders\n        });\n    }\n    async _startOrAuthSse(options) {\n        const { resumptionToken } = options;\n        try {\n            // Try to open an initial SSE stream with GET to listen for server messages\n            // This is optional according to the spec - server may not support it\n            const headers = await this._commonHeaders();\n            headers.set('Accept', 'text/event-stream');\n            // Include Last-Event-ID header for resumable streams if provided\n            if (resumptionToken) {\n                headers.set('last-event-id', resumptionToken);\n            }\n            const response = await (this._fetch ?? fetch)(this._url, {\n                method: 'GET',\n                headers,\n                signal: this._abortController?.signal\n            });\n            if (!response.ok) {\n                await response.body?.cancel();\n                if (response.status === 401 && this._authProvider) {\n                    // Need to authenticate\n                    return await this._authThenStart();\n                }\n                // 405 indicates that the server does not offer an SSE stream at GET endpoint\n                // This is an expected case that should not trigger an error\n                if (response.status === 405) {\n                    return;\n                }\n                throw new StreamableHTTPError(response.status, `Failed to open SSE stream: ${response.statusText}`);\n            }\n            this._handleSseStream(response.body, options, true);\n        }\n        catch (error) {\n            this.onerror?.(error);\n            throw error;\n        }\n    }\n    /**\n     * Calculates the next reconnection delay using  backoff algorithm\n     *\n     * @param attempt Current reconnection attempt count for the specific stream\n     * @returns Time to wait in milliseconds before next reconnection attempt\n     */\n    _getNextReconnectionDelay(attempt) {\n        // Use server-provided retry value if available\n        if (this._serverRetryMs !== undefined) {\n            return this._serverRetryMs;\n        }\n        // Fall back to exponential backoff\n        const initialDelay = this._reconnectionOptions.initialReconnectionDelay;\n        const growFactor = this._reconnectionOptions.reconnectionDelayGrowFactor;\n        const maxDelay = this._reconnectionOptions.maxReconnectionDelay;\n        // Cap at maximum delay\n        return Math.min(initialDelay * Math.pow(growFactor, attempt), maxDelay);\n    }\n    /**\n     * Schedule a reconnection attempt using server-provided retry interval or backoff\n     *\n     * @param lastEventId The ID of the last received event for resumability\n     * @param attemptCount Current reconnection attempt count for this specific stream\n     */\n    _scheduleReconnection(options, attemptCount = 0) {\n        // Use provided options or default options\n        const maxRetries = this._reconnectionOptions.maxRetries;\n        // Check if we've exceeded maximum retry attempts\n        if (attemptCount >= maxRetries) {\n            this.onerror?.(new Error(`Maximum reconnection attempts (${maxRetries}) exceeded.`));\n            return;\n        }\n        // Calculate next delay based on current attempt count\n        const delay = this._getNextReconnectionDelay(attemptCount);\n        // Schedule the reconnection\n        this._reconnectionTimeout = setTimeout(() => {\n            // Use the last event ID to resume where we left off\n            this._startOrAuthSse(options).catch(error => {\n                this.onerror?.(new Error(`Failed to reconnect SSE stream: ${error instanceof Error ? error.message : String(error)}`));\n                // Schedule another attempt if this one failed, incrementing the attempt counter\n                this._scheduleReconnection(options, attemptCount + 1);\n            });\n        }, delay);\n    }\n    _handleSseStream(stream, options, isReconnectable) {\n        if (!stream) {\n            return;\n        }\n        const { onresumptiontoken, replayMessageId } = options;\n        let lastEventId;\n        // Track whether we've received a priming event (event with ID)\n        // Per spec, server SHOULD send a priming event with ID before closing\n        let hasPrimingEvent = false;\n        // Track whether we've received a response - if so, no need to reconnect\n        // Reconnection is for when server disconnects BEFORE sending response\n        let receivedResponse = false;\n        const processStream = async () => {\n            // this is the closest we can get to trying to catch network errors\n            // if something happens reader will throw\n            try {\n                // Create a pipeline: binary stream -> text decoder -> SSE parser\n                const reader = stream\n                    .pipeThrough(new TextDecoderStream())\n                    .pipeThrough(new EventSourceParserStream({\n                    onRetry: (retryMs) => {\n                        // Capture server-provided retry value for reconnection timing\n                        this._serverRetryMs = retryMs;\n                    }\n                }))\n                    .getReader();\n                while (true) {\n                    const { value: event, done } = await reader.read();\n                    if (done) {\n                        break;\n                    }\n                    // Update last event ID if provided\n                    if (event.id) {\n                        lastEventId = event.id;\n                        // Mark that we've received a priming event - stream is now resumable\n                        hasPrimingEvent = true;\n                        onresumptiontoken?.(event.id);\n                    }\n                    // Skip events with no data (priming events, keep-alives)\n                    if (!event.data) {\n                        continue;\n                    }\n                    if (!event.event || event.event === 'message') {\n                        try {\n                            const message = JSONRPCMessageSchema.parse(JSON.parse(event.data));\n                            if (isJSONRPCResultResponse(message)) {\n                                // Mark that we received a response - no need to reconnect for this request\n                                receivedResponse = true;\n                                if (replayMessageId !== undefined) {\n                                    message.id = replayMessageId;\n                                }\n                            }\n                            this.onmessage?.(message);\n                        }\n                        catch (error) {\n                            this.onerror?.(error);\n                        }\n                    }\n                }\n                // Handle graceful server-side disconnect\n                // Server may close connection after sending event ID and retry field\n                // Reconnect if: already reconnectable (GET stream) OR received a priming event (POST stream with event ID)\n                // BUT don't reconnect if we already received a response - the request is complete\n                const canResume = isReconnectable || hasPrimingEvent;\n                const needsReconnect = canResume && !receivedResponse;\n                if (needsReconnect && this._abortController && !this._abortController.signal.aborted) {\n                    this._scheduleReconnection({\n                        resumptionToken: lastEventId,\n                        onresumptiontoken,\n                        replayMessageId\n                    }, 0);\n                }\n            }\n            catch (error) {\n                // Handle stream errors - likely a network disconnect\n                this.onerror?.(new Error(`SSE stream disconnected: ${error}`));\n                // Attempt to reconnect if the stream disconnects unexpectedly and we aren't closing\n                // Reconnect if: already reconnectable (GET stream) OR received a priming event (POST stream with event ID)\n                // BUT don't reconnect if we already received a response - the request is complete\n                const canResume = isReconnectable || hasPrimingEvent;\n                const needsReconnect = canResume && !receivedResponse;\n                if (needsReconnect && this._abortController && !this._abortController.signal.aborted) {\n                    // Use the exponential backoff reconnection strategy\n                    try {\n                        this._scheduleReconnection({\n                            resumptionToken: lastEventId,\n                            onresumptiontoken,\n                            replayMessageId\n                        }, 0);\n                    }\n                    catch (error) {\n                        this.onerror?.(new Error(`Failed to reconnect: ${error instanceof Error ? error.message : String(error)}`));\n                    }\n                }\n            }\n        };\n        processStream();\n    }\n    async start() {\n        if (this._abortController) {\n            throw new Error('StreamableHTTPClientTransport already started! If using Client class, note that connect() calls start() automatically.');\n        }\n        this._abortController = new AbortController();\n    }\n    /**\n     * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.\n     */\n    async finishAuth(authorizationCode) {\n        if (!this._authProvider) {\n            throw new UnauthorizedError('No auth provider');\n        }\n        const result = await auth(this._authProvider, {\n            serverUrl: this._url,\n            authorizationCode,\n            resourceMetadataUrl: this._resourceMetadataUrl,\n            scope: this._scope,\n            fetchFn: this._fetchWithInit\n        });\n        if (result !== 'AUTHORIZED') {\n            throw new UnauthorizedError('Failed to authorize');\n        }\n    }\n    async close() {\n        if (this._reconnectionTimeout) {\n            clearTimeout(this._reconnectionTimeout);\n            this._reconnectionTimeout = undefined;\n        }\n        this._abortController?.abort();\n        this.onclose?.();\n    }\n    async send(message, options) {\n        try {\n            const { resumptionToken, onresumptiontoken } = options || {};\n            if (resumptionToken) {\n                // If we have at last event ID, we need to reconnect the SSE stream\n                this._startOrAuthSse({ resumptionToken, replayMessageId: isJSONRPCRequest(message) ? message.id : undefined }).catch(err => this.onerror?.(err));\n                return;\n            }\n            const headers = await this._commonHeaders();\n            headers.set('content-type', 'application/json');\n            headers.set('accept', 'application/json, text/event-stream');\n            const init = {\n                ...this._requestInit,\n                method: 'POST',\n                headers,\n                body: JSON.stringify(message),\n                signal: this._abortController?.signal\n            };\n            const response = await (this._fetch ?? fetch)(this._url, init);\n            // Handle session ID received during initialization\n            const sessionId = response.headers.get('mcp-session-id');\n            if (sessionId) {\n                this._sessionId = sessionId;\n            }\n            if (!response.ok) {\n                const text = await response.text().catch(() => null);\n                if (response.status === 401 && this._authProvider) {\n                    // Prevent infinite recursion when server returns 401 after successful auth\n                    if (this._hasCompletedAuthFlow) {\n                        throw new StreamableHTTPError(401, 'Server returned 401 after successful authentication');\n                    }\n                    const { resourceMetadataUrl, scope } = extractWWWAuthenticateParams(response);\n                    this._resourceMetadataUrl = resourceMetadataUrl;\n                    this._scope = scope;\n                    const result = await auth(this._authProvider, {\n                        serverUrl: this._url,\n                        resourceMetadataUrl: this._resourceMetadataUrl,\n                        scope: this._scope,\n                        fetchFn: this._fetchWithInit\n                    });\n                    if (result !== 'AUTHORIZED') {\n                        throw new UnauthorizedError();\n                    }\n                    // Mark that we completed auth flow\n                    this._hasCompletedAuthFlow = true;\n                    // Purposely _not_ awaited, so we don't call onerror twice\n                    return this.send(message);\n                }\n                if (response.status === 403 && this._authProvider) {\n                    const { resourceMetadataUrl, scope, error } = extractWWWAuthenticateParams(response);\n                    if (error === 'insufficient_scope') {\n                        const wwwAuthHeader = response.headers.get('WWW-Authenticate');\n                        // Check if we've already tried upscoping with this header to prevent infinite loops.\n                        if (this._lastUpscopingHeader === wwwAuthHeader) {\n                            throw new StreamableHTTPError(403, 'Server returned 403 after trying upscoping');\n                        }\n                        if (scope) {\n                            this._scope = scope;\n                        }\n                        if (resourceMetadataUrl) {\n                            this._resourceMetadataUrl = resourceMetadataUrl;\n                        }\n                        // Mark that upscoping was tried.\n                        this._lastUpscopingHeader = wwwAuthHeader ?? undefined;\n                        const result = await auth(this._authProvider, {\n                            serverUrl: this._url,\n                            resourceMetadataUrl: this._resourceMetadataUrl,\n                            scope: this._scope,\n                            fetchFn: this._fetch\n                        });\n                        if (result !== 'AUTHORIZED') {\n                            throw new UnauthorizedError();\n                        }\n                        return this.send(message);\n                    }\n                }\n                throw new StreamableHTTPError(response.status, `Error POSTing to endpoint: ${text}`);\n            }\n            // Reset auth loop flag on successful response\n            this._hasCompletedAuthFlow = false;\n            this._lastUpscopingHeader = undefined;\n            // If the response is 202 Accepted, there's no body to process\n            if (response.status === 202) {\n                await response.body?.cancel();\n                // if the accepted notification is initialized, we start the SSE stream\n                // if it's supported by the server\n                if (isInitializedNotification(message)) {\n                    // Start without a lastEventId since this is a fresh connection\n                    this._startOrAuthSse({ resumptionToken: undefined }).catch(err => this.onerror?.(err));\n                }\n                return;\n            }\n            // Get original message(s) for detecting request IDs\n            const messages = Array.isArray(message) ? message : [message];\n            const hasRequests = messages.filter(msg => 'method' in msg && 'id' in msg && msg.id !== undefined).length > 0;\n            // Check the response type\n            const contentType = response.headers.get('content-type');\n            if (hasRequests) {\n                if (contentType?.includes('text/event-stream')) {\n                    // Handle SSE stream responses for requests\n                    // We use the same handler as standalone streams, which now supports\n                    // reconnection with the last event ID\n                    this._handleSseStream(response.body, { onresumptiontoken }, false);\n                }\n                else if (contentType?.includes('application/json')) {\n                    // For non-streaming servers, we might get direct JSON responses\n                    const data = await response.json();\n                    const responseMessages = Array.isArray(data)\n                        ? data.map(msg => JSONRPCMessageSchema.parse(msg))\n                        : [JSONRPCMessageSchema.parse(data)];\n                    for (const msg of responseMessages) {\n                        this.onmessage?.(msg);\n                    }\n                }\n                else {\n                    await response.body?.cancel();\n                    throw new StreamableHTTPError(-1, `Unexpected content type: ${contentType}`);\n                }\n            }\n            else {\n                // No requests in message but got 200 OK - still need to release connection\n                await response.body?.cancel();\n            }\n        }\n        catch (error) {\n            this.onerror?.(error);\n            throw error;\n        }\n    }\n    get sessionId() {\n        return this._sessionId;\n    }\n    /**\n     * Terminates the current session by sending a DELETE request to the server.\n     *\n     * Clients that no longer need a particular session\n     * (e.g., because the user is leaving the client application) SHOULD send an\n     * HTTP DELETE to the MCP endpoint with the Mcp-Session-Id header to explicitly\n     * terminate the session.\n     *\n     * The server MAY respond with HTTP 405 Method Not Allowed, indicating that\n     * the server does not allow clients to terminate sessions.\n     */\n    async terminateSession() {\n        if (!this._sessionId) {\n            return; // No session to terminate\n        }\n        try {\n            const headers = await this._commonHeaders();\n            const init = {\n                ...this._requestInit,\n                method: 'DELETE',\n                headers,\n                signal: this._abortController?.signal\n            };\n            const response = await (this._fetch ?? fetch)(this._url, init);\n            await response.body?.cancel();\n            // We specifically handle 405 as a valid response according to the spec,\n            // meaning the server does not support explicit session termination\n            if (!response.ok && response.status !== 405) {\n                throw new StreamableHTTPError(response.status, `Failed to terminate session: ${response.statusText}`);\n            }\n            this._sessionId = undefined;\n        }\n        catch (error) {\n            this.onerror?.(error);\n            throw error;\n        }\n    }\n    setProtocolVersion(version) {\n        this._protocolVersion = version;\n    }\n    get protocolVersion() {\n        return this._protocolVersion;\n    }\n    /**\n     * Resume an SSE stream from a previous event ID.\n     * Opens a GET SSE connection with Last-Event-ID header to replay missed events.\n     *\n     * @param lastEventId The event ID to resume from\n     * @param options Optional callback to receive new resumption tokens\n     */\n    async resumeStream(lastEventId, options) {\n        await this._startOrAuthSse({\n            resumptionToken: lastEventId,\n            onresumptiontoken: options?.onresumptiontoken\n        });\n    }\n}\n//# sourceMappingURL=streamableHttp.js.map","/**\n * Experimental client task features for MCP SDK.\n * WARNING: These APIs are experimental and may change without notice.\n *\n * @experimental\n */\nimport { CallToolResultSchema, McpError, ErrorCode } from '../../types.js';\n/**\n * Experimental task features for MCP clients.\n *\n * Access via `client.experimental.tasks`:\n * ```typescript\n * const stream = client.experimental.tasks.callToolStream({ name: 'tool', arguments: {} });\n * const task = await client.experimental.tasks.getTask(taskId);\n * ```\n *\n * @experimental\n */\nexport class ExperimentalClientTasks {\n    constructor(_client) {\n        this._client = _client;\n    }\n    /**\n     * Calls a tool and returns an AsyncGenerator that yields response messages.\n     * The generator is guaranteed to end with either a 'result' or 'error' message.\n     *\n     * This method provides streaming access to tool execution, allowing you to\n     * observe intermediate task status updates for long-running tool calls.\n     * Automatically validates structured output if the tool has an outputSchema.\n     *\n     * @example\n     * ```typescript\n     * const stream = client.experimental.tasks.callToolStream({ name: 'myTool', arguments: {} });\n     * for await (const message of stream) {\n     *   switch (message.type) {\n     *     case 'taskCreated':\n     *       console.log('Tool execution started:', message.task.taskId);\n     *       break;\n     *     case 'taskStatus':\n     *       console.log('Tool status:', message.task.status);\n     *       break;\n     *     case 'result':\n     *       console.log('Tool result:', message.result);\n     *       break;\n     *     case 'error':\n     *       console.error('Tool error:', message.error);\n     *       break;\n     *   }\n     * }\n     * ```\n     *\n     * @param params - Tool call parameters (name and arguments)\n     * @param resultSchema - Zod schema for validating the result (defaults to CallToolResultSchema)\n     * @param options - Optional request options (timeout, signal, task creation params, etc.)\n     * @returns AsyncGenerator that yields ResponseMessage objects\n     *\n     * @experimental\n     */\n    async *callToolStream(params, resultSchema = CallToolResultSchema, options) {\n        // Access Client's internal methods\n        const clientInternal = this._client;\n        // Add task creation parameters if server supports it and not explicitly provided\n        const optionsWithTask = {\n            ...options,\n            // We check if the tool is known to be a task during auto-configuration, but assume\n            // the caller knows what they're doing if they pass this explicitly\n            task: options?.task ?? (clientInternal.isToolTask(params.name) ? {} : undefined)\n        };\n        const stream = clientInternal.requestStream({ method: 'tools/call', params }, resultSchema, optionsWithTask);\n        // Get the validator for this tool (if it has an output schema)\n        const validator = clientInternal.getToolOutputValidator(params.name);\n        // Iterate through the stream and validate the final result if needed\n        for await (const message of stream) {\n            // If this is a result message and the tool has an output schema, validate it\n            if (message.type === 'result' && validator) {\n                const result = message.result;\n                // If tool has outputSchema, it MUST return structuredContent (unless it's an error)\n                if (!result.structuredContent && !result.isError) {\n                    yield {\n                        type: 'error',\n                        error: new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`)\n                    };\n                    return;\n                }\n                // Only validate structured content if present (not when there's an error)\n                if (result.structuredContent) {\n                    try {\n                        // Validate the structured content against the schema\n                        const validationResult = validator(result.structuredContent);\n                        if (!validationResult.valid) {\n                            yield {\n                                type: 'error',\n                                error: new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`)\n                            };\n                            return;\n                        }\n                    }\n                    catch (error) {\n                        if (error instanceof McpError) {\n                            yield { type: 'error', error };\n                            return;\n                        }\n                        yield {\n                            type: 'error',\n                            error: new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error instanceof Error ? error.message : String(error)}`)\n                        };\n                        return;\n                    }\n                }\n            }\n            // Yield the message (either validated result or any other message type)\n            yield message;\n        }\n    }\n    /**\n     * Gets the current status of a task.\n     *\n     * @param taskId - The task identifier\n     * @param options - Optional request options\n     * @returns The task status\n     *\n     * @experimental\n     */\n    async getTask(taskId, options) {\n        return this._client.getTask({ taskId }, options);\n    }\n    /**\n     * Retrieves the result of a completed task.\n     *\n     * @param taskId - The task identifier\n     * @param resultSchema - Zod schema for validating the result\n     * @param options - Optional request options\n     * @returns The task result\n     *\n     * @experimental\n     */\n    async getTaskResult(taskId, resultSchema, options) {\n        // Delegate to the client's underlying Protocol method\n        return this._client.getTaskResult({ taskId }, resultSchema, options);\n    }\n    /**\n     * Lists tasks with optional pagination.\n     *\n     * @param cursor - Optional pagination cursor\n     * @param options - Optional request options\n     * @returns List of tasks with optional next cursor\n     *\n     * @experimental\n     */\n    async listTasks(cursor, options) {\n        // Delegate to the client's underlying Protocol method\n        return this._client.listTasks(cursor ? { cursor } : undefined, options);\n    }\n    /**\n     * Cancels a running task.\n     *\n     * @param taskId - The task identifier\n     * @param options - Optional request options\n     *\n     * @experimental\n     */\n    async cancelTask(taskId, options) {\n        // Delegate to the client's underlying Protocol method\n        return this._client.cancelTask({ taskId }, options);\n    }\n    /**\n     * Sends a request and returns an AsyncGenerator that yields response messages.\n     * The generator is guaranteed to end with either a 'result' or 'error' message.\n     *\n     * This method provides streaming access to request processing, allowing you to\n     * observe intermediate task status updates for task-augmented requests.\n     *\n     * @param request - The request to send\n     * @param resultSchema - Zod schema for validating the result\n     * @param options - Optional request options (timeout, signal, task creation params, etc.)\n     * @returns AsyncGenerator that yields ResponseMessage objects\n     *\n     * @experimental\n     */\n    requestStream(request, resultSchema, options) {\n        return this._client.requestStream(request, resultSchema, options);\n    }\n}\n//# sourceMappingURL=client.js.map","/**\n * Experimental task capability assertion helpers.\n * WARNING: These APIs are experimental and may change without notice.\n *\n * @experimental\n */\n/**\n * Asserts that task creation is supported for tools/call.\n * Used by Client.assertTaskCapability and Server.assertTaskHandlerCapability.\n *\n * @param requests - The task requests capability object\n * @param method - The method being checked\n * @param entityName - 'Server' or 'Client' for error messages\n * @throws Error if the capability is not supported\n *\n * @experimental\n */\nexport function assertToolsCallTaskCapability(requests, method, entityName) {\n    if (!requests) {\n        throw new Error(`${entityName} does not support task creation (required for ${method})`);\n    }\n    switch (method) {\n        case 'tools/call':\n            if (!requests.tools?.call) {\n                throw new Error(`${entityName} does not support task creation for tools/call (required for ${method})`);\n            }\n            break;\n        default:\n            // Method doesn't support tasks, which is fine - no error\n            break;\n    }\n}\n/**\n * Asserts that task creation is supported for sampling/createMessage or elicitation/create.\n * Used by Server.assertTaskCapability and Client.assertTaskHandlerCapability.\n *\n * @param requests - The task requests capability object\n * @param method - The method being checked\n * @param entityName - 'Server' or 'Client' for error messages\n * @throws Error if the capability is not supported\n *\n * @experimental\n */\nexport function assertClientRequestTaskCapability(requests, method, entityName) {\n    if (!requests) {\n        throw new Error(`${entityName} does not support task creation (required for ${method})`);\n    }\n    switch (method) {\n        case 'sampling/createMessage':\n            if (!requests.sampling?.createMessage) {\n                throw new Error(`${entityName} does not support task creation for sampling/createMessage (required for ${method})`);\n            }\n            break;\n        case 'elicitation/create':\n            if (!requests.elicitation?.create) {\n                throw new Error(`${entityName} does not support task creation for elicitation/create (required for ${method})`);\n            }\n            break;\n        default:\n            // Method doesn't support tasks, which is fine - no error\n            break;\n    }\n}\n//# sourceMappingURL=helpers.js.map","/**\n * Experimental task interfaces for MCP SDK.\n * WARNING: These APIs are experimental and may change without notice.\n */\n/**\n * Checks if a task status represents a terminal state.\n * Terminal states are those where the task has finished and will not change.\n *\n * @param status - The task status to check\n * @returns True if the status is terminal (completed, failed, or cancelled)\n * @experimental\n */\nexport function isTerminal(status) {\n    return status === 'completed' || status === 'failed' || status === 'cancelled';\n}\n//# sourceMappingURL=interfaces.js.map","/**\n * Base class for all OAuth errors\n */\nexport class OAuthError extends Error {\n    constructor(message, errorUri) {\n        super(message);\n        this.errorUri = errorUri;\n        this.name = this.constructor.name;\n    }\n    /**\n     * Converts the error to a standard OAuth error response object\n     */\n    toResponseObject() {\n        const response = {\n            error: this.errorCode,\n            error_description: this.message\n        };\n        if (this.errorUri) {\n            response.error_uri = this.errorUri;\n        }\n        return response;\n    }\n    get errorCode() {\n        return this.constructor.errorCode;\n    }\n}\n/**\n * Invalid request error - The request is missing a required parameter,\n * includes an invalid parameter value, includes a parameter more than once,\n * or is otherwise malformed.\n */\nexport class InvalidRequestError extends OAuthError {\n}\nInvalidRequestError.errorCode = 'invalid_request';\n/**\n * Invalid client error - Client authentication failed (e.g., unknown client, no client\n * authentication included, or unsupported authentication method).\n */\nexport class InvalidClientError extends OAuthError {\n}\nInvalidClientError.errorCode = 'invalid_client';\n/**\n * Invalid grant error - The provided authorization grant or refresh token is\n * invalid, expired, revoked, does not match the redirection URI used in the\n * authorization request, or was issued to another client.\n */\nexport class InvalidGrantError extends OAuthError {\n}\nInvalidGrantError.errorCode = 'invalid_grant';\n/**\n * Unauthorized client error - The authenticated client is not authorized to use\n * this authorization grant type.\n */\nexport class UnauthorizedClientError extends OAuthError {\n}\nUnauthorizedClientError.errorCode = 'unauthorized_client';\n/**\n * Unsupported grant type error - The authorization grant type is not supported\n * by the authorization server.\n */\nexport class UnsupportedGrantTypeError extends OAuthError {\n}\nUnsupportedGrantTypeError.errorCode = 'unsupported_grant_type';\n/**\n * Invalid scope error - The requested scope is invalid, unknown, malformed, or\n * exceeds the scope granted by the resource owner.\n */\nexport class InvalidScopeError extends OAuthError {\n}\nInvalidScopeError.errorCode = 'invalid_scope';\n/**\n * Access denied error - The resource owner or authorization server denied the request.\n */\nexport class AccessDeniedError extends OAuthError {\n}\nAccessDeniedError.errorCode = 'access_denied';\n/**\n * Server error - The authorization server encountered an unexpected condition\n * that prevented it from fulfilling the request.\n */\nexport class ServerError extends OAuthError {\n}\nServerError.errorCode = 'server_error';\n/**\n * Temporarily unavailable error - The authorization server is currently unable to\n * handle the request due to a temporary overloading or maintenance of the server.\n */\nexport class TemporarilyUnavailableError extends OAuthError {\n}\nTemporarilyUnavailableError.errorCode = 'temporarily_unavailable';\n/**\n * Unsupported response type error - The authorization server does not support\n * obtaining an authorization code using this method.\n */\nexport class UnsupportedResponseTypeError extends OAuthError {\n}\nUnsupportedResponseTypeError.errorCode = 'unsupported_response_type';\n/**\n * Unsupported token type error - The authorization server does not support\n * the requested token type.\n */\nexport class UnsupportedTokenTypeError extends OAuthError {\n}\nUnsupportedTokenTypeError.errorCode = 'unsupported_token_type';\n/**\n * Invalid token error - The access token provided is expired, revoked, malformed,\n * or invalid for other reasons.\n */\nexport class InvalidTokenError extends OAuthError {\n}\nInvalidTokenError.errorCode = 'invalid_token';\n/**\n * Method not allowed error - The HTTP method used is not allowed for this endpoint.\n * (Custom, non-standard error)\n */\nexport class MethodNotAllowedError extends OAuthError {\n}\nMethodNotAllowedError.errorCode = 'method_not_allowed';\n/**\n * Too many requests error - Rate limit exceeded.\n * (Custom, non-standard error based on RFC 6585)\n */\nexport class TooManyRequestsError extends OAuthError {\n}\nTooManyRequestsError.errorCode = 'too_many_requests';\n/**\n * Invalid client metadata error - The client metadata is invalid.\n * (Custom error for dynamic client registration - RFC 7591)\n */\nexport class InvalidClientMetadataError extends OAuthError {\n}\nInvalidClientMetadataError.errorCode = 'invalid_client_metadata';\n/**\n * Insufficient scope error - The request requires higher privileges than provided by the access token.\n */\nexport class InsufficientScopeError extends OAuthError {\n}\nInsufficientScopeError.errorCode = 'insufficient_scope';\n/**\n * Invalid target error - The requested resource is invalid, missing, unknown, or malformed.\n * (Custom error for resource indicators - RFC 8707)\n */\nexport class InvalidTargetError extends OAuthError {\n}\nInvalidTargetError.errorCode = 'invalid_target';\n/**\n * A utility class for defining one-off error codes\n */\nexport class CustomOAuthError extends OAuthError {\n    constructor(customErrorCode, message, errorUri) {\n        super(message, errorUri);\n        this.customErrorCode = customErrorCode;\n    }\n    get errorCode() {\n        return this.customErrorCode;\n    }\n}\n/**\n * A full list of all OAuthErrors, enabling parsing from error responses\n */\nexport const OAUTH_ERRORS = {\n    [InvalidRequestError.errorCode]: InvalidRequestError,\n    [InvalidClientError.errorCode]: InvalidClientError,\n    [InvalidGrantError.errorCode]: InvalidGrantError,\n    [UnauthorizedClientError.errorCode]: UnauthorizedClientError,\n    [UnsupportedGrantTypeError.errorCode]: UnsupportedGrantTypeError,\n    [InvalidScopeError.errorCode]: InvalidScopeError,\n    [AccessDeniedError.errorCode]: AccessDeniedError,\n    [ServerError.errorCode]: ServerError,\n    [TemporarilyUnavailableError.errorCode]: TemporarilyUnavailableError,\n    [UnsupportedResponseTypeError.errorCode]: UnsupportedResponseTypeError,\n    [UnsupportedTokenTypeError.errorCode]: UnsupportedTokenTypeError,\n    [InvalidTokenError.errorCode]: InvalidTokenError,\n    [MethodNotAllowedError.errorCode]: MethodNotAllowedError,\n    [TooManyRequestsError.errorCode]: TooManyRequestsError,\n    [InvalidClientMetadataError.errorCode]: InvalidClientMetadataError,\n    [InsufficientScopeError.errorCode]: InsufficientScopeError,\n    [InvalidTargetError.errorCode]: InvalidTargetError\n};\n//# sourceMappingURL=errors.js.map","// zod-compat.ts\n// ----------------------------------------------------\n// Unified types + helpers to accept Zod v3 and v4 (Mini)\n// ----------------------------------------------------\nimport * as z3rt from 'zod/v3';\nimport * as z4mini from 'zod/v4-mini';\n// --- Runtime detection ---\nexport function isZ4Schema(s) {\n    // Present on Zod 4 (Classic & Mini) schemas; absent on Zod 3\n    const schema = s;\n    return !!schema._zod;\n}\n// --- Schema construction ---\nexport function objectFromShape(shape) {\n    const values = Object.values(shape);\n    if (values.length === 0)\n        return z4mini.object({}); // default to v4 Mini\n    const allV4 = values.every(isZ4Schema);\n    const allV3 = values.every(s => !isZ4Schema(s));\n    if (allV4)\n        return z4mini.object(shape);\n    if (allV3)\n        return z3rt.object(shape);\n    throw new Error('Mixed Zod versions detected in object shape.');\n}\n// --- Unified parsing ---\nexport function safeParse(schema, data) {\n    if (isZ4Schema(schema)) {\n        // Mini exposes top-level safeParse\n        const result = z4mini.safeParse(schema, data);\n        return result;\n    }\n    const v3Schema = schema;\n    const result = v3Schema.safeParse(data);\n    return result;\n}\nexport async function safeParseAsync(schema, data) {\n    if (isZ4Schema(schema)) {\n        // Mini exposes top-level safeParseAsync\n        const result = await z4mini.safeParseAsync(schema, data);\n        return result;\n    }\n    const v3Schema = schema;\n    const result = await v3Schema.safeParseAsync(data);\n    return result;\n}\n// --- Shape extraction ---\nexport function getObjectShape(schema) {\n    if (!schema)\n        return undefined;\n    // Zod v3 exposes `.shape`; Zod v4 keeps the shape on `_zod.def.shape`\n    let rawShape;\n    if (isZ4Schema(schema)) {\n        const v4Schema = schema;\n        rawShape = v4Schema._zod?.def?.shape;\n    }\n    else {\n        const v3Schema = schema;\n        rawShape = v3Schema.shape;\n    }\n    if (!rawShape)\n        return undefined;\n    if (typeof rawShape === 'function') {\n        try {\n            return rawShape();\n        }\n        catch {\n            return undefined;\n        }\n    }\n    return rawShape;\n}\n// --- Schema normalization ---\n/**\n * Normalizes a schema to an object schema. Handles both:\n * - Already-constructed object schemas (v3 or v4)\n * - Raw shapes that need to be wrapped into object schemas\n */\nexport function normalizeObjectSchema(schema) {\n    if (!schema)\n        return undefined;\n    // First check if it's a raw shape (Record<string, AnySchema>)\n    // Raw shapes don't have _def or _zod properties and aren't schemas themselves\n    if (typeof schema === 'object') {\n        // Check if it's actually a ZodRawShapeCompat (not a schema instance)\n        // by checking if it lacks schema-like internal properties\n        const asV3 = schema;\n        const asV4 = schema;\n        // If it's not a schema instance (no _def or _zod), it might be a raw shape\n        if (!asV3._def && !asV4._zod) {\n            // Check if all values are schemas (heuristic to confirm it's a raw shape)\n            const values = Object.values(schema);\n            if (values.length > 0 &&\n                values.every(v => typeof v === 'object' &&\n                    v !== null &&\n                    (v._def !== undefined ||\n                        v._zod !== undefined ||\n                        typeof v.parse === 'function'))) {\n                return objectFromShape(schema);\n            }\n        }\n    }\n    // If we get here, it should be an AnySchema (not a raw shape)\n    // Check if it's already an object schema\n    if (isZ4Schema(schema)) {\n        // Check if it's a v4 object\n        const v4Schema = schema;\n        const def = v4Schema._zod?.def;\n        if (def && (def.type === 'object' || def.shape !== undefined)) {\n            return schema;\n        }\n    }\n    else {\n        // Check if it's a v3 object\n        const v3Schema = schema;\n        if (v3Schema.shape !== undefined) {\n            return schema;\n        }\n    }\n    return undefined;\n}\n// --- Error message extraction ---\n/**\n * Safely extracts an error message from a parse result error.\n * Zod errors can have different structures, so we handle various cases.\n */\nexport function getParseErrorMessage(error) {\n    if (error && typeof error === 'object') {\n        // Try common error structures\n        if ('message' in error && typeof error.message === 'string') {\n            return error.message;\n        }\n        if ('issues' in error && Array.isArray(error.issues) && error.issues.length > 0) {\n            const firstIssue = error.issues[0];\n            if (firstIssue && typeof firstIssue === 'object' && 'message' in firstIssue) {\n                return String(firstIssue.message);\n            }\n        }\n        // Fallback: try to stringify the error\n        try {\n            return JSON.stringify(error);\n        }\n        catch {\n            return String(error);\n        }\n    }\n    return String(error);\n}\n// --- Schema metadata access ---\n/**\n * Gets the description from a schema, if available.\n * Works with both Zod v3 and v4.\n *\n * Both versions expose a `.description` getter that returns the description\n * from their respective internal storage (v3: _def, v4: globalRegistry).\n */\nexport function getSchemaDescription(schema) {\n    return schema.description;\n}\n/**\n * Checks if a schema is optional.\n * Works with both Zod v3 and v4.\n */\nexport function isSchemaOptional(schema) {\n    if (isZ4Schema(schema)) {\n        const v4Schema = schema;\n        return v4Schema._zod?.def?.type === 'optional';\n    }\n    const v3Schema = schema;\n    // v3 has isOptional() method\n    if (typeof schema.isOptional === 'function') {\n        return schema.isOptional();\n    }\n    return v3Schema._def?.typeName === 'ZodOptional';\n}\n/**\n * Gets the literal value from a schema, if it's a literal schema.\n * Works with both Zod v3 and v4.\n * Returns undefined if the schema is not a literal or the value cannot be determined.\n */\nexport function getLiteralValue(schema) {\n    if (isZ4Schema(schema)) {\n        const v4Schema = schema;\n        const def = v4Schema._zod?.def;\n        if (def) {\n            // Try various ways to get the literal value\n            if (def.value !== undefined)\n                return def.value;\n            if (Array.isArray(def.values) && def.values.length > 0) {\n                return def.values[0];\n            }\n        }\n    }\n    const v3Schema = schema;\n    const def = v3Schema._def;\n    if (def) {\n        if (def.value !== undefined)\n            return def.value;\n        if (Array.isArray(def.values) && def.values.length > 0) {\n            return def.values[0];\n        }\n    }\n    // Fallback: check for direct value property (some Zod versions)\n    const directValue = schema.value;\n    if (directValue !== undefined)\n        return directValue;\n    return undefined;\n}\n//# sourceMappingURL=zod-compat.js.map","// zod-json-schema-compat.ts\n// ----------------------------------------------------\n// JSON Schema conversion for both Zod v3 and Zod v4 (Mini)\n// v3 uses your vendored converter; v4 uses Mini's toJSONSchema\n// ----------------------------------------------------\nimport * as z4mini from 'zod/v4-mini';\nimport { getObjectShape, safeParse, isZ4Schema, getLiteralValue } from './zod-compat.js';\nimport { zodToJsonSchema } from 'zod-to-json-schema';\nfunction mapMiniTarget(t) {\n    if (!t)\n        return 'draft-7';\n    if (t === 'jsonSchema7' || t === 'draft-7')\n        return 'draft-7';\n    if (t === 'jsonSchema2019-09' || t === 'draft-2020-12')\n        return 'draft-2020-12';\n    return 'draft-7'; // fallback\n}\nexport function toJsonSchemaCompat(schema, opts) {\n    if (isZ4Schema(schema)) {\n        // v4 branch  use Mini's built-in toJSONSchema\n        return z4mini.toJSONSchema(schema, {\n            target: mapMiniTarget(opts?.target),\n            io: opts?.pipeStrategy ?? 'input'\n        });\n    }\n    // v3 branch  use vendored converter\n    return zodToJsonSchema(schema, {\n        strictUnions: opts?.strictUnions ?? true,\n        pipeStrategy: opts?.pipeStrategy ?? 'input'\n    });\n}\nexport function getMethodLiteral(schema) {\n    const shape = getObjectShape(schema);\n    const methodSchema = shape?.method;\n    if (!methodSchema) {\n        throw new Error('Schema is missing a method literal');\n    }\n    const value = getLiteralValue(methodSchema);\n    if (typeof value !== 'string') {\n        throw new Error('Schema method literal must be a string');\n    }\n    return value;\n}\nexport function parseWithCompat(schema, data) {\n    const result = safeParse(schema, data);\n    if (!result.success) {\n        throw result.error;\n    }\n    return result.data;\n}\n//# sourceMappingURL=zod-json-schema-compat.js.map","/**\n * Utilities for handling OAuth resource URIs.\n */\n/**\n * Converts a server URL to a resource URL by removing the fragment.\n * RFC 8707 section 2 states that resource URIs \"MUST NOT include a fragment component\".\n * Keeps everything else unchanged (scheme, domain, port, path, query).\n */\nexport function resourceUrlFromServerUrl(url) {\n    const resourceURL = typeof url === 'string' ? new URL(url) : new URL(url.href);\n    resourceURL.hash = ''; // Remove fragment\n    return resourceURL;\n}\n/**\n * Checks if a requested resource URL matches a configured resource URL.\n * A requested resource matches if it has the same scheme, domain, port,\n * and its path starts with the configured resource's path.\n *\n * @param requestedResource The resource URL being requested\n * @param configuredResource The resource URL that has been configured\n * @returns true if the requested resource matches the configured resource, false otherwise\n */\nexport function checkResourceAllowed({ requestedResource, configuredResource }) {\n    const requested = typeof requestedResource === 'string' ? new URL(requestedResource) : new URL(requestedResource.href);\n    const configured = typeof configuredResource === 'string' ? new URL(configuredResource) : new URL(configuredResource.href);\n    // Compare the origin (scheme, domain, and port)\n    if (requested.origin !== configured.origin) {\n        return false;\n    }\n    // Handle cases like requested=/foo and configured=/foo/\n    if (requested.pathname.length < configured.pathname.length) {\n        return false;\n    }\n    // Check if the requested path starts with the configured path\n    // Ensure both paths end with / for proper comparison\n    // This ensures that if we have paths like \"/api\" and \"/api/users\",\n    // we properly detect that \"/api/users\" is a subpath of \"/api\"\n    // By adding a trailing slash if missing, we avoid false positives\n    // where paths like \"/api123\" would incorrectly match \"/api\"\n    const requestedPath = requested.pathname.endsWith('/') ? requested.pathname : requested.pathname + '/';\n    const configuredPath = configured.pathname.endsWith('/') ? configured.pathname : configured.pathname + '/';\n    return requestedPath.startsWith(configuredPath);\n}\n//# sourceMappingURL=auth-utils.js.map","import * as z from 'zod/v4';\n/**\n * Reusable URL validation that disallows javascript: scheme\n */\nexport const SafeUrlSchema = z\n    .url()\n    .superRefine((val, ctx) => {\n    if (!URL.canParse(val)) {\n        ctx.addIssue({\n            code: z.ZodIssueCode.custom,\n            message: 'URL must be parseable',\n            fatal: true\n        });\n        return z.NEVER;\n    }\n})\n    .refine(url => {\n    const u = new URL(url);\n    return u.protocol !== 'javascript:' && u.protocol !== 'data:' && u.protocol !== 'vbscript:';\n}, { message: 'URL cannot use javascript:, data:, or vbscript: scheme' });\n/**\n * RFC 9728 OAuth Protected Resource Metadata\n */\nexport const OAuthProtectedResourceMetadataSchema = z.looseObject({\n    resource: z.string().url(),\n    authorization_servers: z.array(SafeUrlSchema).optional(),\n    jwks_uri: z.string().url().optional(),\n    scopes_supported: z.array(z.string()).optional(),\n    bearer_methods_supported: z.array(z.string()).optional(),\n    resource_signing_alg_values_supported: z.array(z.string()).optional(),\n    resource_name: z.string().optional(),\n    resource_documentation: z.string().optional(),\n    resource_policy_uri: z.string().url().optional(),\n    resource_tos_uri: z.string().url().optional(),\n    tls_client_certificate_bound_access_tokens: z.boolean().optional(),\n    authorization_details_types_supported: z.array(z.string()).optional(),\n    dpop_signing_alg_values_supported: z.array(z.string()).optional(),\n    dpop_bound_access_tokens_required: z.boolean().optional()\n});\n/**\n * RFC 8414 OAuth 2.0 Authorization Server Metadata\n */\nexport const OAuthMetadataSchema = z.looseObject({\n    issuer: z.string(),\n    authorization_endpoint: SafeUrlSchema,\n    token_endpoint: SafeUrlSchema,\n    registration_endpoint: SafeUrlSchema.optional(),\n    scopes_supported: z.array(z.string()).optional(),\n    response_types_supported: z.array(z.string()),\n    response_modes_supported: z.array(z.string()).optional(),\n    grant_types_supported: z.array(z.string()).optional(),\n    token_endpoint_auth_methods_supported: z.array(z.string()).optional(),\n    token_endpoint_auth_signing_alg_values_supported: z.array(z.string()).optional(),\n    service_documentation: SafeUrlSchema.optional(),\n    revocation_endpoint: SafeUrlSchema.optional(),\n    revocation_endpoint_auth_methods_supported: z.array(z.string()).optional(),\n    revocation_endpoint_auth_signing_alg_values_supported: z.array(z.string()).optional(),\n    introspection_endpoint: z.string().optional(),\n    introspection_endpoint_auth_methods_supported: z.array(z.string()).optional(),\n    introspection_endpoint_auth_signing_alg_values_supported: z.array(z.string()).optional(),\n    code_challenge_methods_supported: z.array(z.string()).optional(),\n    client_id_metadata_document_supported: z.boolean().optional()\n});\n/**\n * OpenID Connect Discovery 1.0 Provider Metadata\n * see: https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata\n */\nexport const OpenIdProviderMetadataSchema = z.looseObject({\n    issuer: z.string(),\n    authorization_endpoint: SafeUrlSchema,\n    token_endpoint: SafeUrlSchema,\n    userinfo_endpoint: SafeUrlSchema.optional(),\n    jwks_uri: SafeUrlSchema,\n    registration_endpoint: SafeUrlSchema.optional(),\n    scopes_supported: z.array(z.string()).optional(),\n    response_types_supported: z.array(z.string()),\n    response_modes_supported: z.array(z.string()).optional(),\n    grant_types_supported: z.array(z.string()).optional(),\n    acr_values_supported: z.array(z.string()).optional(),\n    subject_types_supported: z.array(z.string()),\n    id_token_signing_alg_values_supported: z.array(z.string()),\n    id_token_encryption_alg_values_supported: z.array(z.string()).optional(),\n    id_token_encryption_enc_values_supported: z.array(z.string()).optional(),\n    userinfo_signing_alg_values_supported: z.array(z.string()).optional(),\n    userinfo_encryption_alg_values_supported: z.array(z.string()).optional(),\n    userinfo_encryption_enc_values_supported: z.array(z.string()).optional(),\n    request_object_signing_alg_values_supported: z.array(z.string()).optional(),\n    request_object_encryption_alg_values_supported: z.array(z.string()).optional(),\n    request_object_encryption_enc_values_supported: z.array(z.string()).optional(),\n    token_endpoint_auth_methods_supported: z.array(z.string()).optional(),\n    token_endpoint_auth_signing_alg_values_supported: z.array(z.string()).optional(),\n    display_values_supported: z.array(z.string()).optional(),\n    claim_types_supported: z.array(z.string()).optional(),\n    claims_supported: z.array(z.string()).optional(),\n    service_documentation: z.string().optional(),\n    claims_locales_supported: z.array(z.string()).optional(),\n    ui_locales_supported: z.array(z.string()).optional(),\n    claims_parameter_supported: z.boolean().optional(),\n    request_parameter_supported: z.boolean().optional(),\n    request_uri_parameter_supported: z.boolean().optional(),\n    require_request_uri_registration: z.boolean().optional(),\n    op_policy_uri: SafeUrlSchema.optional(),\n    op_tos_uri: SafeUrlSchema.optional(),\n    client_id_metadata_document_supported: z.boolean().optional()\n});\n/**\n * OpenID Connect Discovery metadata that may include OAuth 2.0 fields\n * This schema represents the real-world scenario where OIDC providers\n * return a mix of OpenID Connect and OAuth 2.0 metadata fields\n */\nexport const OpenIdProviderDiscoveryMetadataSchema = z.object({\n    ...OpenIdProviderMetadataSchema.shape,\n    ...OAuthMetadataSchema.pick({\n        code_challenge_methods_supported: true\n    }).shape\n});\n/**\n * OAuth 2.1 token response\n */\nexport const OAuthTokensSchema = z\n    .object({\n    access_token: z.string(),\n    id_token: z.string().optional(), // Optional for OAuth 2.1, but necessary in OpenID Connect\n    token_type: z.string(),\n    expires_in: z.coerce.number().optional(),\n    scope: z.string().optional(),\n    refresh_token: z.string().optional()\n})\n    .strip();\n/**\n * OAuth 2.1 error response\n */\nexport const OAuthErrorResponseSchema = z.object({\n    error: z.string(),\n    error_description: z.string().optional(),\n    error_uri: z.string().optional()\n});\n/**\n * Optional version of SafeUrlSchema that allows empty string for retrocompatibility on tos_uri and logo_uri\n */\nexport const OptionalSafeUrlSchema = SafeUrlSchema.optional().or(z.literal('').transform(() => undefined));\n/**\n * RFC 7591 OAuth 2.0 Dynamic Client Registration metadata\n */\nexport const OAuthClientMetadataSchema = z\n    .object({\n    redirect_uris: z.array(SafeUrlSchema),\n    token_endpoint_auth_method: z.string().optional(),\n    grant_types: z.array(z.string()).optional(),\n    response_types: z.array(z.string()).optional(),\n    client_name: z.string().optional(),\n    client_uri: SafeUrlSchema.optional(),\n    logo_uri: OptionalSafeUrlSchema,\n    scope: z.string().optional(),\n    contacts: z.array(z.string()).optional(),\n    tos_uri: OptionalSafeUrlSchema,\n    policy_uri: z.string().optional(),\n    jwks_uri: SafeUrlSchema.optional(),\n    jwks: z.any().optional(),\n    software_id: z.string().optional(),\n    software_version: z.string().optional(),\n    software_statement: z.string().optional()\n})\n    .strip();\n/**\n * RFC 7591 OAuth 2.0 Dynamic Client Registration client information\n */\nexport const OAuthClientInformationSchema = z\n    .object({\n    client_id: z.string(),\n    client_secret: z.string().optional(),\n    client_id_issued_at: z.number().optional(),\n    client_secret_expires_at: z.number().optional()\n})\n    .strip();\n/**\n * RFC 7591 OAuth 2.0 Dynamic Client Registration full response (client information plus metadata)\n */\nexport const OAuthClientInformationFullSchema = OAuthClientMetadataSchema.merge(OAuthClientInformationSchema);\n/**\n * RFC 7591 OAuth 2.0 Dynamic Client Registration error response\n */\nexport const OAuthClientRegistrationErrorSchema = z\n    .object({\n    error: z.string(),\n    error_description: z.string().optional()\n})\n    .strip();\n/**\n * RFC 7009 OAuth 2.0 Token Revocation request\n */\nexport const OAuthTokenRevocationRequestSchema = z\n    .object({\n    token: z.string(),\n    token_type_hint: z.string().optional()\n})\n    .strip();\n//# sourceMappingURL=auth.js.map","import { safeParse } from '../server/zod-compat.js';\nimport { CancelledNotificationSchema, CreateTaskResultSchema, ErrorCode, GetTaskRequestSchema, GetTaskResultSchema, GetTaskPayloadRequestSchema, ListTasksRequestSchema, ListTasksResultSchema, CancelTaskRequestSchema, CancelTaskResultSchema, isJSONRPCErrorResponse, isJSONRPCRequest, isJSONRPCResultResponse, isJSONRPCNotification, McpError, PingRequestSchema, ProgressNotificationSchema, RELATED_TASK_META_KEY, TaskStatusNotificationSchema, isTaskAugmentedRequestParams } from '../types.js';\nimport { isTerminal } from '../experimental/tasks/interfaces.js';\nimport { getMethodLiteral, parseWithCompat } from '../server/zod-json-schema-compat.js';\n/**\n * The default request timeout, in miliseconds.\n */\nexport const DEFAULT_REQUEST_TIMEOUT_MSEC = 60000;\n/**\n * Implements MCP protocol framing on top of a pluggable transport, including\n * features like request/response linking, notifications, and progress.\n */\nexport class Protocol {\n    constructor(_options) {\n        this._options = _options;\n        this._requestMessageId = 0;\n        this._requestHandlers = new Map();\n        this._requestHandlerAbortControllers = new Map();\n        this._notificationHandlers = new Map();\n        this._responseHandlers = new Map();\n        this._progressHandlers = new Map();\n        this._timeoutInfo = new Map();\n        this._pendingDebouncedNotifications = new Set();\n        // Maps task IDs to progress tokens to keep handlers alive after CreateTaskResult\n        this._taskProgressTokens = new Map();\n        this._requestResolvers = new Map();\n        this.setNotificationHandler(CancelledNotificationSchema, notification => {\n            this._oncancel(notification);\n        });\n        this.setNotificationHandler(ProgressNotificationSchema, notification => {\n            this._onprogress(notification);\n        });\n        this.setRequestHandler(PingRequestSchema, \n        // Automatic pong by default.\n        _request => ({}));\n        // Install task handlers if TaskStore is provided\n        this._taskStore = _options?.taskStore;\n        this._taskMessageQueue = _options?.taskMessageQueue;\n        if (this._taskStore) {\n            this.setRequestHandler(GetTaskRequestSchema, async (request, extra) => {\n                const task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);\n                if (!task) {\n                    throw new McpError(ErrorCode.InvalidParams, 'Failed to retrieve task: Task not found');\n                }\n                // Per spec: tasks/get responses SHALL NOT include related-task metadata\n                // as the taskId parameter is the source of truth\n                // @ts-expect-error SendResultT cannot contain GetTaskResult, but we include it in our derived types everywhere else\n                return {\n                    ...task\n                };\n            });\n            this.setRequestHandler(GetTaskPayloadRequestSchema, async (request, extra) => {\n                const handleTaskResult = async () => {\n                    const taskId = request.params.taskId;\n                    // Deliver queued messages\n                    if (this._taskMessageQueue) {\n                        let queuedMessage;\n                        while ((queuedMessage = await this._taskMessageQueue.dequeue(taskId, extra.sessionId))) {\n                            // Handle response and error messages by routing them to the appropriate resolver\n                            if (queuedMessage.type === 'response' || queuedMessage.type === 'error') {\n                                const message = queuedMessage.message;\n                                const requestId = message.id;\n                                // Lookup resolver in _requestResolvers map\n                                const resolver = this._requestResolvers.get(requestId);\n                                if (resolver) {\n                                    // Remove resolver from map after invocation\n                                    this._requestResolvers.delete(requestId);\n                                    // Invoke resolver with response or error\n                                    if (queuedMessage.type === 'response') {\n                                        resolver(message);\n                                    }\n                                    else {\n                                        // Convert JSONRPCError to McpError\n                                        const errorMessage = message;\n                                        const error = new McpError(errorMessage.error.code, errorMessage.error.message, errorMessage.error.data);\n                                        resolver(error);\n                                    }\n                                }\n                                else {\n                                    // Handle missing resolver gracefully with error logging\n                                    const messageType = queuedMessage.type === 'response' ? 'Response' : 'Error';\n                                    this._onerror(new Error(`${messageType} handler missing for request ${requestId}`));\n                                }\n                                // Continue to next message\n                                continue;\n                            }\n                            // Send the message on the response stream by passing the relatedRequestId\n                            // This tells the transport to write the message to the tasks/result response stream\n                            await this._transport?.send(queuedMessage.message, { relatedRequestId: extra.requestId });\n                        }\n                    }\n                    // Now check task status\n                    const task = await this._taskStore.getTask(taskId, extra.sessionId);\n                    if (!task) {\n                        throw new McpError(ErrorCode.InvalidParams, `Task not found: ${taskId}`);\n                    }\n                    // Block if task is not terminal (we've already delivered all queued messages above)\n                    if (!isTerminal(task.status)) {\n                        // Wait for status change or new messages\n                        await this._waitForTaskUpdate(taskId, extra.signal);\n                        // After waking up, recursively call to deliver any new messages or result\n                        return await handleTaskResult();\n                    }\n                    // If task is terminal, return the result\n                    if (isTerminal(task.status)) {\n                        const result = await this._taskStore.getTaskResult(taskId, extra.sessionId);\n                        this._clearTaskQueue(taskId);\n                        return {\n                            ...result,\n                            _meta: {\n                                ...result._meta,\n                                [RELATED_TASK_META_KEY]: {\n                                    taskId: taskId\n                                }\n                            }\n                        };\n                    }\n                    return await handleTaskResult();\n                };\n                return await handleTaskResult();\n            });\n            this.setRequestHandler(ListTasksRequestSchema, async (request, extra) => {\n                try {\n                    const { tasks, nextCursor } = await this._taskStore.listTasks(request.params?.cursor, extra.sessionId);\n                    // @ts-expect-error SendResultT cannot contain ListTasksResult, but we include it in our derived types everywhere else\n                    return {\n                        tasks,\n                        nextCursor,\n                        _meta: {}\n                    };\n                }\n                catch (error) {\n                    throw new McpError(ErrorCode.InvalidParams, `Failed to list tasks: ${error instanceof Error ? error.message : String(error)}`);\n                }\n            });\n            this.setRequestHandler(CancelTaskRequestSchema, async (request, extra) => {\n                try {\n                    // Get the current task to check if it's in a terminal state, in case the implementation is not atomic\n                    const task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);\n                    if (!task) {\n                        throw new McpError(ErrorCode.InvalidParams, `Task not found: ${request.params.taskId}`);\n                    }\n                    // Reject cancellation of terminal tasks\n                    if (isTerminal(task.status)) {\n                        throw new McpError(ErrorCode.InvalidParams, `Cannot cancel task in terminal status: ${task.status}`);\n                    }\n                    await this._taskStore.updateTaskStatus(request.params.taskId, 'cancelled', 'Client cancelled task execution.', extra.sessionId);\n                    this._clearTaskQueue(request.params.taskId);\n                    const cancelledTask = await this._taskStore.getTask(request.params.taskId, extra.sessionId);\n                    if (!cancelledTask) {\n                        // Task was deleted during cancellation (e.g., cleanup happened)\n                        throw new McpError(ErrorCode.InvalidParams, `Task not found after cancellation: ${request.params.taskId}`);\n                    }\n                    return {\n                        _meta: {},\n                        ...cancelledTask\n                    };\n                }\n                catch (error) {\n                    // Re-throw McpError as-is\n                    if (error instanceof McpError) {\n                        throw error;\n                    }\n                    throw new McpError(ErrorCode.InvalidRequest, `Failed to cancel task: ${error instanceof Error ? error.message : String(error)}`);\n                }\n            });\n        }\n    }\n    async _oncancel(notification) {\n        if (!notification.params.requestId) {\n            return;\n        }\n        // Handle request cancellation\n        const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);\n        controller?.abort(notification.params.reason);\n    }\n    _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {\n        this._timeoutInfo.set(messageId, {\n            timeoutId: setTimeout(onTimeout, timeout),\n            startTime: Date.now(),\n            timeout,\n            maxTotalTimeout,\n            resetTimeoutOnProgress,\n            onTimeout\n        });\n    }\n    _resetTimeout(messageId) {\n        const info = this._timeoutInfo.get(messageId);\n        if (!info)\n            return false;\n        const totalElapsed = Date.now() - info.startTime;\n        if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {\n            this._timeoutInfo.delete(messageId);\n            throw McpError.fromError(ErrorCode.RequestTimeout, 'Maximum total timeout exceeded', {\n                maxTotalTimeout: info.maxTotalTimeout,\n                totalElapsed\n            });\n        }\n        clearTimeout(info.timeoutId);\n        info.timeoutId = setTimeout(info.onTimeout, info.timeout);\n        return true;\n    }\n    _cleanupTimeout(messageId) {\n        const info = this._timeoutInfo.get(messageId);\n        if (info) {\n            clearTimeout(info.timeoutId);\n            this._timeoutInfo.delete(messageId);\n        }\n    }\n    /**\n     * Attaches to the given transport, starts it, and starts listening for messages.\n     *\n     * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.\n     */\n    async connect(transport) {\n        this._transport = transport;\n        const _onclose = this.transport?.onclose;\n        this._transport.onclose = () => {\n            _onclose?.();\n            this._onclose();\n        };\n        const _onerror = this.transport?.onerror;\n        this._transport.onerror = (error) => {\n            _onerror?.(error);\n            this._onerror(error);\n        };\n        const _onmessage = this._transport?.onmessage;\n        this._transport.onmessage = (message, extra) => {\n            _onmessage?.(message, extra);\n            if (isJSONRPCResultResponse(message) || isJSONRPCErrorResponse(message)) {\n                this._onresponse(message);\n            }\n            else if (isJSONRPCRequest(message)) {\n                this._onrequest(message, extra);\n            }\n            else if (isJSONRPCNotification(message)) {\n                this._onnotification(message);\n            }\n            else {\n                this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));\n            }\n        };\n        await this._transport.start();\n    }\n    _onclose() {\n        const responseHandlers = this._responseHandlers;\n        this._responseHandlers = new Map();\n        this._progressHandlers.clear();\n        this._taskProgressTokens.clear();\n        this._pendingDebouncedNotifications.clear();\n        const error = McpError.fromError(ErrorCode.ConnectionClosed, 'Connection closed');\n        this._transport = undefined;\n        this.onclose?.();\n        for (const handler of responseHandlers.values()) {\n            handler(error);\n        }\n    }\n    _onerror(error) {\n        this.onerror?.(error);\n    }\n    _onnotification(notification) {\n        const handler = this._notificationHandlers.get(notification.method) ?? this.fallbackNotificationHandler;\n        // Ignore notifications not being subscribed to.\n        if (handler === undefined) {\n            return;\n        }\n        // Starting with Promise.resolve() puts any synchronous errors into the monad as well.\n        Promise.resolve()\n            .then(() => handler(notification))\n            .catch(error => this._onerror(new Error(`Uncaught error in notification handler: ${error}`)));\n    }\n    _onrequest(request, extra) {\n        const handler = this._requestHandlers.get(request.method) ?? this.fallbackRequestHandler;\n        // Capture the current transport at request time to ensure responses go to the correct client\n        const capturedTransport = this._transport;\n        // Extract taskId from request metadata if present (needed early for method not found case)\n        const relatedTaskId = request.params?._meta?.[RELATED_TASK_META_KEY]?.taskId;\n        if (handler === undefined) {\n            const errorResponse = {\n                jsonrpc: '2.0',\n                id: request.id,\n                error: {\n                    code: ErrorCode.MethodNotFound,\n                    message: 'Method not found'\n                }\n            };\n            // Queue or send the error response based on whether this is a task-related request\n            if (relatedTaskId && this._taskMessageQueue) {\n                this._enqueueTaskMessage(relatedTaskId, {\n                    type: 'error',\n                    message: errorResponse,\n                    timestamp: Date.now()\n                }, capturedTransport?.sessionId).catch(error => this._onerror(new Error(`Failed to enqueue error response: ${error}`)));\n            }\n            else {\n                capturedTransport\n                    ?.send(errorResponse)\n                    .catch(error => this._onerror(new Error(`Failed to send an error response: ${error}`)));\n            }\n            return;\n        }\n        const abortController = new AbortController();\n        this._requestHandlerAbortControllers.set(request.id, abortController);\n        const taskCreationParams = isTaskAugmentedRequestParams(request.params) ? request.params.task : undefined;\n        const taskStore = this._taskStore ? this.requestTaskStore(request, capturedTransport?.sessionId) : undefined;\n        const fullExtra = {\n            signal: abortController.signal,\n            sessionId: capturedTransport?.sessionId,\n            _meta: request.params?._meta,\n            sendNotification: async (notification) => {\n                // Include related-task metadata if this request is part of a task\n                const notificationOptions = { relatedRequestId: request.id };\n                if (relatedTaskId) {\n                    notificationOptions.relatedTask = { taskId: relatedTaskId };\n                }\n                await this.notification(notification, notificationOptions);\n            },\n            sendRequest: async (r, resultSchema, options) => {\n                // Include related-task metadata if this request is part of a task\n                const requestOptions = { ...options, relatedRequestId: request.id };\n                if (relatedTaskId && !requestOptions.relatedTask) {\n                    requestOptions.relatedTask = { taskId: relatedTaskId };\n                }\n                // Set task status to input_required when sending a request within a task context\n                // Use the taskId from options (explicit) or fall back to relatedTaskId (inherited)\n                const effectiveTaskId = requestOptions.relatedTask?.taskId ?? relatedTaskId;\n                if (effectiveTaskId && taskStore) {\n                    await taskStore.updateTaskStatus(effectiveTaskId, 'input_required');\n                }\n                return await this.request(r, resultSchema, requestOptions);\n            },\n            authInfo: extra?.authInfo,\n            requestId: request.id,\n            requestInfo: extra?.requestInfo,\n            taskId: relatedTaskId,\n            taskStore: taskStore,\n            taskRequestedTtl: taskCreationParams?.ttl,\n            closeSSEStream: extra?.closeSSEStream,\n            closeStandaloneSSEStream: extra?.closeStandaloneSSEStream\n        };\n        // Starting with Promise.resolve() puts any synchronous errors into the monad as well.\n        Promise.resolve()\n            .then(() => {\n            // If this request asked for task creation, check capability first\n            if (taskCreationParams) {\n                // Check if the request method supports task creation\n                this.assertTaskHandlerCapability(request.method);\n            }\n        })\n            .then(() => handler(request, fullExtra))\n            .then(async (result) => {\n            if (abortController.signal.aborted) {\n                // Request was cancelled\n                return;\n            }\n            const response = {\n                result,\n                jsonrpc: '2.0',\n                id: request.id\n            };\n            // Queue or send the response based on whether this is a task-related request\n            if (relatedTaskId && this._taskMessageQueue) {\n                await this._enqueueTaskMessage(relatedTaskId, {\n                    type: 'response',\n                    message: response,\n                    timestamp: Date.now()\n                }, capturedTransport?.sessionId);\n            }\n            else {\n                await capturedTransport?.send(response);\n            }\n        }, async (error) => {\n            if (abortController.signal.aborted) {\n                // Request was cancelled\n                return;\n            }\n            const errorResponse = {\n                jsonrpc: '2.0',\n                id: request.id,\n                error: {\n                    code: Number.isSafeInteger(error['code']) ? error['code'] : ErrorCode.InternalError,\n                    message: error.message ?? 'Internal error',\n                    ...(error['data'] !== undefined && { data: error['data'] })\n                }\n            };\n            // Queue or send the error response based on whether this is a task-related request\n            if (relatedTaskId && this._taskMessageQueue) {\n                await this._enqueueTaskMessage(relatedTaskId, {\n                    type: 'error',\n                    message: errorResponse,\n                    timestamp: Date.now()\n                }, capturedTransport?.sessionId);\n            }\n            else {\n                await capturedTransport?.send(errorResponse);\n            }\n        })\n            .catch(error => this._onerror(new Error(`Failed to send response: ${error}`)))\n            .finally(() => {\n            this._requestHandlerAbortControllers.delete(request.id);\n        });\n    }\n    _onprogress(notification) {\n        const { progressToken, ...params } = notification.params;\n        const messageId = Number(progressToken);\n        const handler = this._progressHandlers.get(messageId);\n        if (!handler) {\n            this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));\n            return;\n        }\n        const responseHandler = this._responseHandlers.get(messageId);\n        const timeoutInfo = this._timeoutInfo.get(messageId);\n        if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {\n            try {\n                this._resetTimeout(messageId);\n            }\n            catch (error) {\n                // Clean up if maxTotalTimeout was exceeded\n                this._responseHandlers.delete(messageId);\n                this._progressHandlers.delete(messageId);\n                this._cleanupTimeout(messageId);\n                responseHandler(error);\n                return;\n            }\n        }\n        handler(params);\n    }\n    _onresponse(response) {\n        const messageId = Number(response.id);\n        // Check if this is a response to a queued request\n        const resolver = this._requestResolvers.get(messageId);\n        if (resolver) {\n            this._requestResolvers.delete(messageId);\n            if (isJSONRPCResultResponse(response)) {\n                resolver(response);\n            }\n            else {\n                const error = new McpError(response.error.code, response.error.message, response.error.data);\n                resolver(error);\n            }\n            return;\n        }\n        const handler = this._responseHandlers.get(messageId);\n        if (handler === undefined) {\n            this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));\n            return;\n        }\n        this._responseHandlers.delete(messageId);\n        this._cleanupTimeout(messageId);\n        // Keep progress handler alive for CreateTaskResult responses\n        let isTaskResponse = false;\n        if (isJSONRPCResultResponse(response) && response.result && typeof response.result === 'object') {\n            const result = response.result;\n            if (result.task && typeof result.task === 'object') {\n                const task = result.task;\n                if (typeof task.taskId === 'string') {\n                    isTaskResponse = true;\n                    this._taskProgressTokens.set(task.taskId, messageId);\n                }\n            }\n        }\n        if (!isTaskResponse) {\n            this._progressHandlers.delete(messageId);\n        }\n        if (isJSONRPCResultResponse(response)) {\n            handler(response);\n        }\n        else {\n            const error = McpError.fromError(response.error.code, response.error.message, response.error.data);\n            handler(error);\n        }\n    }\n    get transport() {\n        return this._transport;\n    }\n    /**\n     * Closes the connection.\n     */\n    async close() {\n        await this._transport?.close();\n    }\n    /**\n     * Sends a request and returns an AsyncGenerator that yields response messages.\n     * The generator is guaranteed to end with either a 'result' or 'error' message.\n     *\n     * @example\n     * ```typescript\n     * const stream = protocol.requestStream(request, resultSchema, options);\n     * for await (const message of stream) {\n     *   switch (message.type) {\n     *     case 'taskCreated':\n     *       console.log('Task created:', message.task.taskId);\n     *       break;\n     *     case 'taskStatus':\n     *       console.log('Task status:', message.task.status);\n     *       break;\n     *     case 'result':\n     *       console.log('Final result:', message.result);\n     *       break;\n     *     case 'error':\n     *       console.error('Error:', message.error);\n     *       break;\n     *   }\n     * }\n     * ```\n     *\n     * @experimental Use `client.experimental.tasks.requestStream()` to access this method.\n     */\n    async *requestStream(request, resultSchema, options) {\n        const { task } = options ?? {};\n        // For non-task requests, just yield the result\n        if (!task) {\n            try {\n                const result = await this.request(request, resultSchema, options);\n                yield { type: 'result', result };\n            }\n            catch (error) {\n                yield {\n                    type: 'error',\n                    error: error instanceof McpError ? error : new McpError(ErrorCode.InternalError, String(error))\n                };\n            }\n            return;\n        }\n        // For task-augmented requests, we need to poll for status\n        // First, make the request to create the task\n        let taskId;\n        try {\n            // Send the request and get the CreateTaskResult\n            const createResult = await this.request(request, CreateTaskResultSchema, options);\n            // Extract taskId from the result\n            if (createResult.task) {\n                taskId = createResult.task.taskId;\n                yield { type: 'taskCreated', task: createResult.task };\n            }\n            else {\n                throw new McpError(ErrorCode.InternalError, 'Task creation did not return a task');\n            }\n            // Poll for task completion\n            while (true) {\n                // Get current task status\n                const task = await this.getTask({ taskId }, options);\n                yield { type: 'taskStatus', task };\n                // Check if task is terminal\n                if (isTerminal(task.status)) {\n                    if (task.status === 'completed') {\n                        // Get the final result\n                        const result = await this.getTaskResult({ taskId }, resultSchema, options);\n                        yield { type: 'result', result };\n                    }\n                    else if (task.status === 'failed') {\n                        yield {\n                            type: 'error',\n                            error: new McpError(ErrorCode.InternalError, `Task ${taskId} failed`)\n                        };\n                    }\n                    else if (task.status === 'cancelled') {\n                        yield {\n                            type: 'error',\n                            error: new McpError(ErrorCode.InternalError, `Task ${taskId} was cancelled`)\n                        };\n                    }\n                    return;\n                }\n                // When input_required, call tasks/result to deliver queued messages\n                // (elicitation, sampling) via SSE and block until terminal\n                if (task.status === 'input_required') {\n                    const result = await this.getTaskResult({ taskId }, resultSchema, options);\n                    yield { type: 'result', result };\n                    return;\n                }\n                // Wait before polling again\n                const pollInterval = task.pollInterval ?? this._options?.defaultTaskPollInterval ?? 1000;\n                await new Promise(resolve => setTimeout(resolve, pollInterval));\n                // Check if cancelled\n                options?.signal?.throwIfAborted();\n            }\n        }\n        catch (error) {\n            yield {\n                type: 'error',\n                error: error instanceof McpError ? error : new McpError(ErrorCode.InternalError, String(error))\n            };\n        }\n    }\n    /**\n     * Sends a request and waits for a response.\n     *\n     * Do not use this method to emit notifications! Use notification() instead.\n     */\n    request(request, resultSchema, options) {\n        const { relatedRequestId, resumptionToken, onresumptiontoken, task, relatedTask } = options ?? {};\n        // Send the request\n        return new Promise((resolve, reject) => {\n            const earlyReject = (error) => {\n                reject(error);\n            };\n            if (!this._transport) {\n                earlyReject(new Error('Not connected'));\n                return;\n            }\n            if (this._options?.enforceStrictCapabilities === true) {\n                try {\n                    this.assertCapabilityForMethod(request.method);\n                    // If task creation is requested, also check task capabilities\n                    if (task) {\n                        this.assertTaskCapability(request.method);\n                    }\n                }\n                catch (e) {\n                    earlyReject(e);\n                    return;\n                }\n            }\n            options?.signal?.throwIfAborted();\n            const messageId = this._requestMessageId++;\n            const jsonrpcRequest = {\n                ...request,\n                jsonrpc: '2.0',\n                id: messageId\n            };\n            if (options?.onprogress) {\n                this._progressHandlers.set(messageId, options.onprogress);\n                jsonrpcRequest.params = {\n                    ...request.params,\n                    _meta: {\n                        ...(request.params?._meta || {}),\n                        progressToken: messageId\n                    }\n                };\n            }\n            // Augment with task creation parameters if provided\n            if (task) {\n                jsonrpcRequest.params = {\n                    ...jsonrpcRequest.params,\n                    task: task\n                };\n            }\n            // Augment with related task metadata if relatedTask is provided\n            if (relatedTask) {\n                jsonrpcRequest.params = {\n                    ...jsonrpcRequest.params,\n                    _meta: {\n                        ...(jsonrpcRequest.params?._meta || {}),\n                        [RELATED_TASK_META_KEY]: relatedTask\n                    }\n                };\n            }\n            const cancel = (reason) => {\n                this._responseHandlers.delete(messageId);\n                this._progressHandlers.delete(messageId);\n                this._cleanupTimeout(messageId);\n                this._transport\n                    ?.send({\n                    jsonrpc: '2.0',\n                    method: 'notifications/cancelled',\n                    params: {\n                        requestId: messageId,\n                        reason: String(reason)\n                    }\n                }, { relatedRequestId, resumptionToken, onresumptiontoken })\n                    .catch(error => this._onerror(new Error(`Failed to send cancellation: ${error}`)));\n                // Wrap the reason in an McpError if it isn't already\n                const error = reason instanceof McpError ? reason : new McpError(ErrorCode.RequestTimeout, String(reason));\n                reject(error);\n            };\n            this._responseHandlers.set(messageId, response => {\n                if (options?.signal?.aborted) {\n                    return;\n                }\n                if (response instanceof Error) {\n                    return reject(response);\n                }\n                try {\n                    const parseResult = safeParse(resultSchema, response.result);\n                    if (!parseResult.success) {\n                        // Type guard: if success is false, error is guaranteed to exist\n                        reject(parseResult.error);\n                    }\n                    else {\n                        resolve(parseResult.data);\n                    }\n                }\n                catch (error) {\n                    reject(error);\n                }\n            });\n            options?.signal?.addEventListener('abort', () => {\n                cancel(options?.signal?.reason);\n            });\n            const timeout = options?.timeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC;\n            const timeoutHandler = () => cancel(McpError.fromError(ErrorCode.RequestTimeout, 'Request timed out', { timeout }));\n            this._setupTimeout(messageId, timeout, options?.maxTotalTimeout, timeoutHandler, options?.resetTimeoutOnProgress ?? false);\n            // Queue request if related to a task\n            const relatedTaskId = relatedTask?.taskId;\n            if (relatedTaskId) {\n                // Store the response resolver for this request so responses can be routed back\n                const responseResolver = (response) => {\n                    const handler = this._responseHandlers.get(messageId);\n                    if (handler) {\n                        handler(response);\n                    }\n                    else {\n                        // Log error when resolver is missing, but don't fail\n                        this._onerror(new Error(`Response handler missing for side-channeled request ${messageId}`));\n                    }\n                };\n                this._requestResolvers.set(messageId, responseResolver);\n                this._enqueueTaskMessage(relatedTaskId, {\n                    type: 'request',\n                    message: jsonrpcRequest,\n                    timestamp: Date.now()\n                }).catch(error => {\n                    this._cleanupTimeout(messageId);\n                    reject(error);\n                });\n                // Don't send through transport - queued messages are delivered via tasks/result only\n                // This prevents duplicate delivery for bidirectional transports\n            }\n            else {\n                // No related task - send through transport normally\n                this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch(error => {\n                    this._cleanupTimeout(messageId);\n                    reject(error);\n                });\n            }\n        });\n    }\n    /**\n     * Gets the current status of a task.\n     *\n     * @experimental Use `client.experimental.tasks.getTask()` to access this method.\n     */\n    async getTask(params, options) {\n        // @ts-expect-error SendRequestT cannot directly contain GetTaskRequest, but we ensure all type instantiations contain it anyways\n        return this.request({ method: 'tasks/get', params }, GetTaskResultSchema, options);\n    }\n    /**\n     * Retrieves the result of a completed task.\n     *\n     * @experimental Use `client.experimental.tasks.getTaskResult()` to access this method.\n     */\n    async getTaskResult(params, resultSchema, options) {\n        // @ts-expect-error SendRequestT cannot directly contain GetTaskPayloadRequest, but we ensure all type instantiations contain it anyways\n        return this.request({ method: 'tasks/result', params }, resultSchema, options);\n    }\n    /**\n     * Lists tasks, optionally starting from a pagination cursor.\n     *\n     * @experimental Use `client.experimental.tasks.listTasks()` to access this method.\n     */\n    async listTasks(params, options) {\n        // @ts-expect-error SendRequestT cannot directly contain ListTasksRequest, but we ensure all type instantiations contain it anyways\n        return this.request({ method: 'tasks/list', params }, ListTasksResultSchema, options);\n    }\n    /**\n     * Cancels a specific task.\n     *\n     * @experimental Use `client.experimental.tasks.cancelTask()` to access this method.\n     */\n    async cancelTask(params, options) {\n        // @ts-expect-error SendRequestT cannot directly contain CancelTaskRequest, but we ensure all type instantiations contain it anyways\n        return this.request({ method: 'tasks/cancel', params }, CancelTaskResultSchema, options);\n    }\n    /**\n     * Emits a notification, which is a one-way message that does not expect a response.\n     */\n    async notification(notification, options) {\n        if (!this._transport) {\n            throw new Error('Not connected');\n        }\n        this.assertNotificationCapability(notification.method);\n        // Queue notification if related to a task\n        const relatedTaskId = options?.relatedTask?.taskId;\n        if (relatedTaskId) {\n            // Build the JSONRPC notification with metadata\n            const jsonrpcNotification = {\n                ...notification,\n                jsonrpc: '2.0',\n                params: {\n                    ...notification.params,\n                    _meta: {\n                        ...(notification.params?._meta || {}),\n                        [RELATED_TASK_META_KEY]: options.relatedTask\n                    }\n                }\n            };\n            await this._enqueueTaskMessage(relatedTaskId, {\n                type: 'notification',\n                message: jsonrpcNotification,\n                timestamp: Date.now()\n            });\n            // Don't send through transport - queued messages are delivered via tasks/result only\n            // This prevents duplicate delivery for bidirectional transports\n            return;\n        }\n        const debouncedMethods = this._options?.debouncedNotificationMethods ?? [];\n        // A notification can only be debounced if it's in the list AND it's \"simple\"\n        // (i.e., has no parameters and no related request ID or related task that could be lost).\n        const canDebounce = debouncedMethods.includes(notification.method) && !notification.params && !options?.relatedRequestId && !options?.relatedTask;\n        if (canDebounce) {\n            // If a notification of this type is already scheduled, do nothing.\n            if (this._pendingDebouncedNotifications.has(notification.method)) {\n                return;\n            }\n            // Mark this notification type as pending.\n            this._pendingDebouncedNotifications.add(notification.method);\n            // Schedule the actual send to happen in the next microtask.\n            // This allows all synchronous calls in the current event loop tick to be coalesced.\n            Promise.resolve().then(() => {\n                // Un-mark the notification so the next one can be scheduled.\n                this._pendingDebouncedNotifications.delete(notification.method);\n                // SAFETY CHECK: If the connection was closed while this was pending, abort.\n                if (!this._transport) {\n                    return;\n                }\n                let jsonrpcNotification = {\n                    ...notification,\n                    jsonrpc: '2.0'\n                };\n                // Augment with related task metadata if relatedTask is provided\n                if (options?.relatedTask) {\n                    jsonrpcNotification = {\n                        ...jsonrpcNotification,\n                        params: {\n                            ...jsonrpcNotification.params,\n                            _meta: {\n                                ...(jsonrpcNotification.params?._meta || {}),\n                                [RELATED_TASK_META_KEY]: options.relatedTask\n                            }\n                        }\n                    };\n                }\n                // Send the notification, but don't await it here to avoid blocking.\n                // Handle potential errors with a .catch().\n                this._transport?.send(jsonrpcNotification, options).catch(error => this._onerror(error));\n            });\n            // Return immediately.\n            return;\n        }\n        let jsonrpcNotification = {\n            ...notification,\n            jsonrpc: '2.0'\n        };\n        // Augment with related task metadata if relatedTask is provided\n        if (options?.relatedTask) {\n            jsonrpcNotification = {\n                ...jsonrpcNotification,\n                params: {\n                    ...jsonrpcNotification.params,\n                    _meta: {\n                        ...(jsonrpcNotification.params?._meta || {}),\n                        [RELATED_TASK_META_KEY]: options.relatedTask\n                    }\n                }\n            };\n        }\n        await this._transport.send(jsonrpcNotification, options);\n    }\n    /**\n     * Registers a handler to invoke when this protocol object receives a request with the given method.\n     *\n     * Note that this will replace any previous request handler for the same method.\n     */\n    setRequestHandler(requestSchema, handler) {\n        const method = getMethodLiteral(requestSchema);\n        this.assertRequestHandlerCapability(method);\n        this._requestHandlers.set(method, (request, extra) => {\n            const parsed = parseWithCompat(requestSchema, request);\n            return Promise.resolve(handler(parsed, extra));\n        });\n    }\n    /**\n     * Removes the request handler for the given method.\n     */\n    removeRequestHandler(method) {\n        this._requestHandlers.delete(method);\n    }\n    /**\n     * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.\n     */\n    assertCanSetRequestHandler(method) {\n        if (this._requestHandlers.has(method)) {\n            throw new Error(`A request handler for ${method} already exists, which would be overridden`);\n        }\n    }\n    /**\n     * Registers a handler to invoke when this protocol object receives a notification with the given method.\n     *\n     * Note that this will replace any previous notification handler for the same method.\n     */\n    setNotificationHandler(notificationSchema, handler) {\n        const method = getMethodLiteral(notificationSchema);\n        this._notificationHandlers.set(method, notification => {\n            const parsed = parseWithCompat(notificationSchema, notification);\n            return Promise.resolve(handler(parsed));\n        });\n    }\n    /**\n     * Removes the notification handler for the given method.\n     */\n    removeNotificationHandler(method) {\n        this._notificationHandlers.delete(method);\n    }\n    /**\n     * Cleans up the progress handler associated with a task.\n     * This should be called when a task reaches a terminal status.\n     */\n    _cleanupTaskProgressHandler(taskId) {\n        const progressToken = this._taskProgressTokens.get(taskId);\n        if (progressToken !== undefined) {\n            this._progressHandlers.delete(progressToken);\n            this._taskProgressTokens.delete(taskId);\n        }\n    }\n    /**\n     * Enqueues a task-related message for side-channel delivery via tasks/result.\n     * @param taskId The task ID to associate the message with\n     * @param message The message to enqueue\n     * @param sessionId Optional session ID for binding the operation to a specific session\n     * @throws Error if taskStore is not configured or if enqueue fails (e.g., queue overflow)\n     *\n     * Note: If enqueue fails, it's the TaskMessageQueue implementation's responsibility to handle\n     * the error appropriately (e.g., by failing the task, logging, etc.). The Protocol layer\n     * simply propagates the error.\n     */\n    async _enqueueTaskMessage(taskId, message, sessionId) {\n        // Task message queues are only used when taskStore is configured\n        if (!this._taskStore || !this._taskMessageQueue) {\n            throw new Error('Cannot enqueue task message: taskStore and taskMessageQueue are not configured');\n        }\n        const maxQueueSize = this._options?.maxTaskQueueSize;\n        await this._taskMessageQueue.enqueue(taskId, message, sessionId, maxQueueSize);\n    }\n    /**\n     * Clears the message queue for a task and rejects any pending request resolvers.\n     * @param taskId The task ID whose queue should be cleared\n     * @param sessionId Optional session ID for binding the operation to a specific session\n     */\n    async _clearTaskQueue(taskId, sessionId) {\n        if (this._taskMessageQueue) {\n            // Reject any pending request resolvers\n            const messages = await this._taskMessageQueue.dequeueAll(taskId, sessionId);\n            for (const message of messages) {\n                if (message.type === 'request' && isJSONRPCRequest(message.message)) {\n                    // Extract request ID from the message\n                    const requestId = message.message.id;\n                    const resolver = this._requestResolvers.get(requestId);\n                    if (resolver) {\n                        resolver(new McpError(ErrorCode.InternalError, 'Task cancelled or completed'));\n                        this._requestResolvers.delete(requestId);\n                    }\n                    else {\n                        // Log error when resolver is missing during cleanup for better observability\n                        this._onerror(new Error(`Resolver missing for request ${requestId} during task ${taskId} cleanup`));\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Waits for a task update (new messages or status change) with abort signal support.\n     * Uses polling to check for updates at the task's configured poll interval.\n     * @param taskId The task ID to wait for\n     * @param signal Abort signal to cancel the wait\n     * @returns Promise that resolves when an update occurs or rejects if aborted\n     */\n    async _waitForTaskUpdate(taskId, signal) {\n        // Get the task's poll interval, falling back to default\n        let interval = this._options?.defaultTaskPollInterval ?? 1000;\n        try {\n            const task = await this._taskStore?.getTask(taskId);\n            if (task?.pollInterval) {\n                interval = task.pollInterval;\n            }\n        }\n        catch {\n            // Use default interval if task lookup fails\n        }\n        return new Promise((resolve, reject) => {\n            if (signal.aborted) {\n                reject(new McpError(ErrorCode.InvalidRequest, 'Request cancelled'));\n                return;\n            }\n            // Wait for the poll interval, then resolve so caller can check for updates\n            const timeoutId = setTimeout(resolve, interval);\n            // Clean up timeout and reject if aborted\n            signal.addEventListener('abort', () => {\n                clearTimeout(timeoutId);\n                reject(new McpError(ErrorCode.InvalidRequest, 'Request cancelled'));\n            }, { once: true });\n        });\n    }\n    requestTaskStore(request, sessionId) {\n        const taskStore = this._taskStore;\n        if (!taskStore) {\n            throw new Error('No task store configured');\n        }\n        return {\n            createTask: async (taskParams) => {\n                if (!request) {\n                    throw new Error('No request provided');\n                }\n                return await taskStore.createTask(taskParams, request.id, {\n                    method: request.method,\n                    params: request.params\n                }, sessionId);\n            },\n            getTask: async (taskId) => {\n                const task = await taskStore.getTask(taskId, sessionId);\n                if (!task) {\n                    throw new McpError(ErrorCode.InvalidParams, 'Failed to retrieve task: Task not found');\n                }\n                return task;\n            },\n            storeTaskResult: async (taskId, status, result) => {\n                await taskStore.storeTaskResult(taskId, status, result, sessionId);\n                // Get updated task state and send notification\n                const task = await taskStore.getTask(taskId, sessionId);\n                if (task) {\n                    const notification = TaskStatusNotificationSchema.parse({\n                        method: 'notifications/tasks/status',\n                        params: task\n                    });\n                    await this.notification(notification);\n                    if (isTerminal(task.status)) {\n                        this._cleanupTaskProgressHandler(taskId);\n                        // Don't clear queue here - it will be cleared after delivery via tasks/result\n                    }\n                }\n            },\n            getTaskResult: taskId => {\n                return taskStore.getTaskResult(taskId, sessionId);\n            },\n            updateTaskStatus: async (taskId, status, statusMessage) => {\n                // Check if task exists\n                const task = await taskStore.getTask(taskId, sessionId);\n                if (!task) {\n                    throw new McpError(ErrorCode.InvalidParams, `Task \"${taskId}\" not found - it may have been cleaned up`);\n                }\n                // Don't allow transitions from terminal states\n                if (isTerminal(task.status)) {\n                    throw new McpError(ErrorCode.InvalidParams, `Cannot update task \"${taskId}\" from terminal status \"${task.status}\" to \"${status}\". Terminal states (completed, failed, cancelled) cannot transition to other states.`);\n                }\n                await taskStore.updateTaskStatus(taskId, status, statusMessage, sessionId);\n                // Get updated task state and send notification\n                const updatedTask = await taskStore.getTask(taskId, sessionId);\n                if (updatedTask) {\n                    const notification = TaskStatusNotificationSchema.parse({\n                        method: 'notifications/tasks/status',\n                        params: updatedTask\n                    });\n                    await this.notification(notification);\n                    if (isTerminal(updatedTask.status)) {\n                        this._cleanupTaskProgressHandler(taskId);\n                        // Don't clear queue here - it will be cleared after delivery via tasks/result\n                    }\n                }\n            },\n            listTasks: cursor => {\n                return taskStore.listTasks(cursor, sessionId);\n            }\n        };\n    }\n}\nfunction isPlainObject(value) {\n    return value !== null && typeof value === 'object' && !Array.isArray(value);\n}\nexport function mergeCapabilities(base, additional) {\n    const result = { ...base };\n    for (const key in additional) {\n        const k = key;\n        const addValue = additional[k];\n        if (addValue === undefined)\n            continue;\n        const baseValue = result[k];\n        if (isPlainObject(baseValue) && isPlainObject(addValue)) {\n            result[k] = { ...baseValue, ...addValue };\n        }\n        else {\n            result[k] = addValue;\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=protocol.js.map","/**\n * Normalizes HeadersInit to a plain Record<string, string> for manipulation.\n * Handles Headers objects, arrays of tuples, and plain objects.\n */\nexport function normalizeHeaders(headers) {\n    if (!headers)\n        return {};\n    if (headers instanceof Headers) {\n        return Object.fromEntries(headers.entries());\n    }\n    if (Array.isArray(headers)) {\n        return Object.fromEntries(headers);\n    }\n    return { ...headers };\n}\n/**\n * Creates a fetch function that includes base RequestInit options.\n * This ensures requests inherit settings like credentials, mode, headers, etc. from the base init.\n *\n * @param baseFetch - The base fetch function to wrap (defaults to global fetch)\n * @param baseInit - The base RequestInit to merge with each request\n * @returns A wrapped fetch function that merges base options with call-specific options\n */\nexport function createFetchWithInit(baseFetch = fetch, baseInit) {\n    if (!baseInit) {\n        return baseFetch;\n    }\n    // Return a wrapped fetch that merges base RequestInit with call-specific init\n    return async (url, init) => {\n        const mergedInit = {\n            ...baseInit,\n            ...init,\n            // Headers need special handling - merge instead of replace\n            headers: init?.headers ? { ...normalizeHeaders(baseInit.headers), ...normalizeHeaders(init.headers) } : baseInit.headers\n        };\n        return baseFetch(url, mergedInit);\n    };\n}\n//# sourceMappingURL=transport.js.map","import * as z from 'zod/v4';\nexport const LATEST_PROTOCOL_VERSION = '2025-11-25';\nexport const DEFAULT_NEGOTIATED_PROTOCOL_VERSION = '2025-03-26';\nexport const SUPPORTED_PROTOCOL_VERSIONS = [LATEST_PROTOCOL_VERSION, '2025-06-18', '2025-03-26', '2024-11-05', '2024-10-07'];\nexport const RELATED_TASK_META_KEY = 'io.modelcontextprotocol/related-task';\n/* JSON-RPC types */\nexport const JSONRPC_VERSION = '2.0';\n/**\n * Assert 'object' type schema.\n *\n * @internal\n */\nconst AssertObjectSchema = z.custom((v) => v !== null && (typeof v === 'object' || typeof v === 'function'));\n/**\n * A progress token, used to associate progress notifications with the original request.\n */\nexport const ProgressTokenSchema = z.union([z.string(), z.number().int()]);\n/**\n * An opaque token used to represent a cursor for pagination.\n */\nexport const CursorSchema = z.string();\n/**\n * Task creation parameters, used to ask that the server create a task to represent a request.\n */\nexport const TaskCreationParamsSchema = z.looseObject({\n    /**\n     * Time in milliseconds to keep task results available after completion.\n     * If null, the task has unlimited lifetime until manually cleaned up.\n     */\n    ttl: z.union([z.number(), z.null()]).optional(),\n    /**\n     * Time in milliseconds to wait between task status requests.\n     */\n    pollInterval: z.number().optional()\n});\nexport const TaskMetadataSchema = z.object({\n    ttl: z.number().optional()\n});\n/**\n * Metadata for associating messages with a task.\n * Include this in the `_meta` field under the key `io.modelcontextprotocol/related-task`.\n */\nexport const RelatedTaskMetadataSchema = z.object({\n    taskId: z.string()\n});\nconst RequestMetaSchema = z.looseObject({\n    /**\n     * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\n     */\n    progressToken: ProgressTokenSchema.optional(),\n    /**\n     * If specified, this request is related to the provided task.\n     */\n    [RELATED_TASK_META_KEY]: RelatedTaskMetadataSchema.optional()\n});\n/**\n * Common params for any request.\n */\nconst BaseRequestParamsSchema = z.object({\n    /**\n     * See [General fields: `_meta`](/specification/draft/basic/index#meta) for notes on `_meta` usage.\n     */\n    _meta: RequestMetaSchema.optional()\n});\n/**\n * Common params for any task-augmented request.\n */\nexport const TaskAugmentedRequestParamsSchema = BaseRequestParamsSchema.extend({\n    /**\n     * If specified, the caller is requesting task-augmented execution for this request.\n     * The request will return a CreateTaskResult immediately, and the actual result can be\n     * retrieved later via tasks/result.\n     *\n     * Task augmentation is subject to capability negotiation - receivers MUST declare support\n     * for task augmentation of specific request types in their capabilities.\n     */\n    task: TaskMetadataSchema.optional()\n});\n/**\n * Checks if a value is a valid TaskAugmentedRequestParams.\n * @param value - The value to check.\n *\n * @returns True if the value is a valid TaskAugmentedRequestParams, false otherwise.\n */\nexport const isTaskAugmentedRequestParams = (value) => TaskAugmentedRequestParamsSchema.safeParse(value).success;\nexport const RequestSchema = z.object({\n    method: z.string(),\n    params: BaseRequestParamsSchema.loose().optional()\n});\nconst NotificationsParamsSchema = z.object({\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: RequestMetaSchema.optional()\n});\nexport const NotificationSchema = z.object({\n    method: z.string(),\n    params: NotificationsParamsSchema.loose().optional()\n});\nexport const ResultSchema = z.looseObject({\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: RequestMetaSchema.optional()\n});\n/**\n * A uniquely identifying ID for a request in JSON-RPC.\n */\nexport const RequestIdSchema = z.union([z.string(), z.number().int()]);\n/**\n * A request that expects a response.\n */\nexport const JSONRPCRequestSchema = z\n    .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: RequestIdSchema,\n    ...RequestSchema.shape\n})\n    .strict();\nexport const isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success;\n/**\n * A notification which does not expect a response.\n */\nexport const JSONRPCNotificationSchema = z\n    .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    ...NotificationSchema.shape\n})\n    .strict();\nexport const isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success;\n/**\n * A successful (non-error) response to a request.\n */\nexport const JSONRPCResultResponseSchema = z\n    .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: RequestIdSchema,\n    result: ResultSchema\n})\n    .strict();\n/**\n * Checks if a value is a valid JSONRPCResultResponse.\n * @param value - The value to check.\n *\n * @returns True if the value is a valid JSONRPCResultResponse, false otherwise.\n */\nexport const isJSONRPCResultResponse = (value) => JSONRPCResultResponseSchema.safeParse(value).success;\n/**\n * @deprecated Use {@link isJSONRPCResultResponse} instead.\n *\n * Please note that {@link JSONRPCResponse} is a union of {@link JSONRPCResultResponse} and {@link JSONRPCErrorResponse} as per the updated JSON-RPC specification. (was previously just {@link JSONRPCResultResponse})\n */\nexport const isJSONRPCResponse = isJSONRPCResultResponse;\n/**\n * Error codes defined by the JSON-RPC specification.\n */\nexport var ErrorCode;\n(function (ErrorCode) {\n    // SDK error codes\n    ErrorCode[ErrorCode[\"ConnectionClosed\"] = -32000] = \"ConnectionClosed\";\n    ErrorCode[ErrorCode[\"RequestTimeout\"] = -32001] = \"RequestTimeout\";\n    // Standard JSON-RPC error codes\n    ErrorCode[ErrorCode[\"ParseError\"] = -32700] = \"ParseError\";\n    ErrorCode[ErrorCode[\"InvalidRequest\"] = -32600] = \"InvalidRequest\";\n    ErrorCode[ErrorCode[\"MethodNotFound\"] = -32601] = \"MethodNotFound\";\n    ErrorCode[ErrorCode[\"InvalidParams\"] = -32602] = \"InvalidParams\";\n    ErrorCode[ErrorCode[\"InternalError\"] = -32603] = \"InternalError\";\n    // MCP-specific error codes\n    ErrorCode[ErrorCode[\"UrlElicitationRequired\"] = -32042] = \"UrlElicitationRequired\";\n})(ErrorCode || (ErrorCode = {}));\n/**\n * A response to a request that indicates an error occurred.\n */\nexport const JSONRPCErrorResponseSchema = z\n    .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: RequestIdSchema.optional(),\n    error: z.object({\n        /**\n         * The error type that occurred.\n         */\n        code: z.number().int(),\n        /**\n         * A short description of the error. The message SHOULD be limited to a concise single sentence.\n         */\n        message: z.string(),\n        /**\n         * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).\n         */\n        data: z.unknown().optional()\n    })\n})\n    .strict();\n/**\n * @deprecated Use {@link JSONRPCErrorResponseSchema} instead.\n */\nexport const JSONRPCErrorSchema = JSONRPCErrorResponseSchema;\n/**\n * Checks if a value is a valid JSONRPCErrorResponse.\n * @param value - The value to check.\n *\n * @returns True if the value is a valid JSONRPCErrorResponse, false otherwise.\n */\nexport const isJSONRPCErrorResponse = (value) => JSONRPCErrorResponseSchema.safeParse(value).success;\n/**\n * @deprecated Use {@link isJSONRPCErrorResponse} instead.\n */\nexport const isJSONRPCError = isJSONRPCErrorResponse;\nexport const JSONRPCMessageSchema = z.union([\n    JSONRPCRequestSchema,\n    JSONRPCNotificationSchema,\n    JSONRPCResultResponseSchema,\n    JSONRPCErrorResponseSchema\n]);\nexport const JSONRPCResponseSchema = z.union([JSONRPCResultResponseSchema, JSONRPCErrorResponseSchema]);\n/* Empty result */\n/**\n * A response that indicates success but carries no data.\n */\nexport const EmptyResultSchema = ResultSchema.strict();\nexport const CancelledNotificationParamsSchema = NotificationsParamsSchema.extend({\n    /**\n     * The ID of the request to cancel.\n     *\n     * This MUST correspond to the ID of a request previously issued in the same direction.\n     */\n    requestId: RequestIdSchema.optional(),\n    /**\n     * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.\n     */\n    reason: z.string().optional()\n});\n/* Cancellation */\n/**\n * This notification can be sent by either side to indicate that it is cancelling a previously-issued request.\n *\n * The request SHOULD still be in-flight, but due to communication latency, it is always possible that this notification MAY arrive after the request has already finished.\n *\n * This notification indicates that the result will be unused, so any associated processing SHOULD cease.\n *\n * A client MUST NOT attempt to cancel its `initialize` request.\n */\nexport const CancelledNotificationSchema = NotificationSchema.extend({\n    method: z.literal('notifications/cancelled'),\n    params: CancelledNotificationParamsSchema\n});\n/* Base Metadata */\n/**\n * Icon schema for use in tools, prompts, resources, and implementations.\n */\nexport const IconSchema = z.object({\n    /**\n     * URL or data URI for the icon.\n     */\n    src: z.string(),\n    /**\n     * Optional MIME type for the icon.\n     */\n    mimeType: z.string().optional(),\n    /**\n     * Optional array of strings that specify sizes at which the icon can be used.\n     * Each string should be in WxH format (e.g., `\"48x48\"`, `\"96x96\"`) or `\"any\"` for scalable formats like SVG.\n     *\n     * If not provided, the client should assume that the icon can be used at any size.\n     */\n    sizes: z.array(z.string()).optional(),\n    /**\n     * Optional specifier for the theme this icon is designed for. `light` indicates\n     * the icon is designed to be used with a light background, and `dark` indicates\n     * the icon is designed to be used with a dark background.\n     *\n     * If not provided, the client should assume the icon can be used with any theme.\n     */\n    theme: z.enum(['light', 'dark']).optional()\n});\n/**\n * Base schema to add `icons` property.\n *\n */\nexport const IconsSchema = z.object({\n    /**\n     * Optional set of sized icons that the client can display in a user interface.\n     *\n     * Clients that support rendering icons MUST support at least the following MIME types:\n     * - `image/png` - PNG images (safe, universal compatibility)\n     * - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)\n     *\n     * Clients that support rendering icons SHOULD also support:\n     * - `image/svg+xml` - SVG images (scalable but requires security precautions)\n     * - `image/webp` - WebP images (modern, efficient format)\n     */\n    icons: z.array(IconSchema).optional()\n});\n/**\n * Base metadata interface for common properties across resources, tools, prompts, and implementations.\n */\nexport const BaseMetadataSchema = z.object({\n    /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */\n    name: z.string(),\n    /**\n     * Intended for UI and end-user contexts  optimized to be human-readable and easily understood,\n     * even by those unfamiliar with domain-specific terminology.\n     *\n     * If not provided, the name should be used for display (except for Tool,\n     * where `annotations.title` should be given precedence over using `name`,\n     * if present).\n     */\n    title: z.string().optional()\n});\n/* Initialization */\n/**\n * Describes the name and version of an MCP implementation.\n */\nexport const ImplementationSchema = BaseMetadataSchema.extend({\n    ...BaseMetadataSchema.shape,\n    ...IconsSchema.shape,\n    version: z.string(),\n    /**\n     * An optional URL of the website for this implementation.\n     */\n    websiteUrl: z.string().optional(),\n    /**\n     * An optional human-readable description of what this implementation does.\n     *\n     * This can be used by clients or servers to provide context about their purpose\n     * and capabilities. For example, a server might describe the types of resources\n     * or tools it provides, while a client might describe its intended use case.\n     */\n    description: z.string().optional()\n});\nconst FormElicitationCapabilitySchema = z.intersection(z.object({\n    applyDefaults: z.boolean().optional()\n}), z.record(z.string(), z.unknown()));\nconst ElicitationCapabilitySchema = z.preprocess(value => {\n    if (value && typeof value === 'object' && !Array.isArray(value)) {\n        if (Object.keys(value).length === 0) {\n            return { form: {} };\n        }\n    }\n    return value;\n}, z.intersection(z.object({\n    form: FormElicitationCapabilitySchema.optional(),\n    url: AssertObjectSchema.optional()\n}), z.record(z.string(), z.unknown()).optional()));\n/**\n * Task capabilities for clients, indicating which request types support task creation.\n */\nexport const ClientTasksCapabilitySchema = z.looseObject({\n    /**\n     * Present if the client supports listing tasks.\n     */\n    list: AssertObjectSchema.optional(),\n    /**\n     * Present if the client supports cancelling tasks.\n     */\n    cancel: AssertObjectSchema.optional(),\n    /**\n     * Capabilities for task creation on specific request types.\n     */\n    requests: z\n        .looseObject({\n        /**\n         * Task support for sampling requests.\n         */\n        sampling: z\n            .looseObject({\n            createMessage: AssertObjectSchema.optional()\n        })\n            .optional(),\n        /**\n         * Task support for elicitation requests.\n         */\n        elicitation: z\n            .looseObject({\n            create: AssertObjectSchema.optional()\n        })\n            .optional()\n    })\n        .optional()\n});\n/**\n * Task capabilities for servers, indicating which request types support task creation.\n */\nexport const ServerTasksCapabilitySchema = z.looseObject({\n    /**\n     * Present if the server supports listing tasks.\n     */\n    list: AssertObjectSchema.optional(),\n    /**\n     * Present if the server supports cancelling tasks.\n     */\n    cancel: AssertObjectSchema.optional(),\n    /**\n     * Capabilities for task creation on specific request types.\n     */\n    requests: z\n        .looseObject({\n        /**\n         * Task support for tool requests.\n         */\n        tools: z\n            .looseObject({\n            call: AssertObjectSchema.optional()\n        })\n            .optional()\n    })\n        .optional()\n});\n/**\n * Capabilities a client may support. Known capabilities are defined here, in this schema, but this is not a closed set: any client can define its own, additional capabilities.\n */\nexport const ClientCapabilitiesSchema = z.object({\n    /**\n     * Experimental, non-standard capabilities that the client supports.\n     */\n    experimental: z.record(z.string(), AssertObjectSchema).optional(),\n    /**\n     * Present if the client supports sampling from an LLM.\n     */\n    sampling: z\n        .object({\n        /**\n         * Present if the client supports context inclusion via includeContext parameter.\n         * If not declared, servers SHOULD only use `includeContext: \"none\"` (or omit it).\n         */\n        context: AssertObjectSchema.optional(),\n        /**\n         * Present if the client supports tool use via tools and toolChoice parameters.\n         */\n        tools: AssertObjectSchema.optional()\n    })\n        .optional(),\n    /**\n     * Present if the client supports eliciting user input.\n     */\n    elicitation: ElicitationCapabilitySchema.optional(),\n    /**\n     * Present if the client supports listing roots.\n     */\n    roots: z\n        .object({\n        /**\n         * Whether the client supports issuing notifications for changes to the roots list.\n         */\n        listChanged: z.boolean().optional()\n    })\n        .optional(),\n    /**\n     * Present if the client supports task creation.\n     */\n    tasks: ClientTasksCapabilitySchema.optional()\n});\nexport const InitializeRequestParamsSchema = BaseRequestParamsSchema.extend({\n    /**\n     * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.\n     */\n    protocolVersion: z.string(),\n    capabilities: ClientCapabilitiesSchema,\n    clientInfo: ImplementationSchema\n});\n/**\n * This request is sent from the client to the server when it first connects, asking it to begin initialization.\n */\nexport const InitializeRequestSchema = RequestSchema.extend({\n    method: z.literal('initialize'),\n    params: InitializeRequestParamsSchema\n});\nexport const isInitializeRequest = (value) => InitializeRequestSchema.safeParse(value).success;\n/**\n * Capabilities that a server may support. Known capabilities are defined here, in this schema, but this is not a closed set: any server can define its own, additional capabilities.\n */\nexport const ServerCapabilitiesSchema = z.object({\n    /**\n     * Experimental, non-standard capabilities that the server supports.\n     */\n    experimental: z.record(z.string(), AssertObjectSchema).optional(),\n    /**\n     * Present if the server supports sending log messages to the client.\n     */\n    logging: AssertObjectSchema.optional(),\n    /**\n     * Present if the server supports sending completions to the client.\n     */\n    completions: AssertObjectSchema.optional(),\n    /**\n     * Present if the server offers any prompt templates.\n     */\n    prompts: z\n        .object({\n        /**\n         * Whether this server supports issuing notifications for changes to the prompt list.\n         */\n        listChanged: z.boolean().optional()\n    })\n        .optional(),\n    /**\n     * Present if the server offers any resources to read.\n     */\n    resources: z\n        .object({\n        /**\n         * Whether this server supports clients subscribing to resource updates.\n         */\n        subscribe: z.boolean().optional(),\n        /**\n         * Whether this server supports issuing notifications for changes to the resource list.\n         */\n        listChanged: z.boolean().optional()\n    })\n        .optional(),\n    /**\n     * Present if the server offers any tools to call.\n     */\n    tools: z\n        .object({\n        /**\n         * Whether this server supports issuing notifications for changes to the tool list.\n         */\n        listChanged: z.boolean().optional()\n    })\n        .optional(),\n    /**\n     * Present if the server supports task creation.\n     */\n    tasks: ServerTasksCapabilitySchema.optional()\n});\n/**\n * After receiving an initialize request from the client, the server sends this response.\n */\nexport const InitializeResultSchema = ResultSchema.extend({\n    /**\n     * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.\n     */\n    protocolVersion: z.string(),\n    capabilities: ServerCapabilitiesSchema,\n    serverInfo: ImplementationSchema,\n    /**\n     * Instructions describing how to use the server and its features.\n     *\n     * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a \"hint\" to the model. For example, this information MAY be added to the system prompt.\n     */\n    instructions: z.string().optional()\n});\n/**\n * This notification is sent from the client to the server after initialization has finished.\n */\nexport const InitializedNotificationSchema = NotificationSchema.extend({\n    method: z.literal('notifications/initialized'),\n    params: NotificationsParamsSchema.optional()\n});\nexport const isInitializedNotification = (value) => InitializedNotificationSchema.safeParse(value).success;\n/* Ping */\n/**\n * A ping, issued by either the server or the client, to check that the other party is still alive. The receiver must promptly respond, or else may be disconnected.\n */\nexport const PingRequestSchema = RequestSchema.extend({\n    method: z.literal('ping'),\n    params: BaseRequestParamsSchema.optional()\n});\n/* Progress notifications */\nexport const ProgressSchema = z.object({\n    /**\n     * The progress thus far. This should increase every time progress is made, even if the total is unknown.\n     */\n    progress: z.number(),\n    /**\n     * Total number of items to process (or total progress required), if known.\n     */\n    total: z.optional(z.number()),\n    /**\n     * An optional message describing the current progress.\n     */\n    message: z.optional(z.string())\n});\nexport const ProgressNotificationParamsSchema = z.object({\n    ...NotificationsParamsSchema.shape,\n    ...ProgressSchema.shape,\n    /**\n     * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.\n     */\n    progressToken: ProgressTokenSchema\n});\n/**\n * An out-of-band notification used to inform the receiver of a progress update for a long-running request.\n *\n * @category notifications/progress\n */\nexport const ProgressNotificationSchema = NotificationSchema.extend({\n    method: z.literal('notifications/progress'),\n    params: ProgressNotificationParamsSchema\n});\nexport const PaginatedRequestParamsSchema = BaseRequestParamsSchema.extend({\n    /**\n     * An opaque token representing the current pagination position.\n     * If provided, the server should return results starting after this cursor.\n     */\n    cursor: CursorSchema.optional()\n});\n/* Pagination */\nexport const PaginatedRequestSchema = RequestSchema.extend({\n    params: PaginatedRequestParamsSchema.optional()\n});\nexport const PaginatedResultSchema = ResultSchema.extend({\n    /**\n     * An opaque token representing the pagination position after the last returned result.\n     * If present, there may be more results available.\n     */\n    nextCursor: CursorSchema.optional()\n});\n/**\n * The status of a task.\n * */\nexport const TaskStatusSchema = z.enum(['working', 'input_required', 'completed', 'failed', 'cancelled']);\n/* Tasks */\n/**\n * A pollable state object associated with a request.\n */\nexport const TaskSchema = z.object({\n    taskId: z.string(),\n    status: TaskStatusSchema,\n    /**\n     * Time in milliseconds to keep task results available after completion.\n     * If null, the task has unlimited lifetime until manually cleaned up.\n     */\n    ttl: z.union([z.number(), z.null()]),\n    /**\n     * ISO 8601 timestamp when the task was created.\n     */\n    createdAt: z.string(),\n    /**\n     * ISO 8601 timestamp when the task was last updated.\n     */\n    lastUpdatedAt: z.string(),\n    pollInterval: z.optional(z.number()),\n    /**\n     * Optional diagnostic message for failed tasks or other status information.\n     */\n    statusMessage: z.optional(z.string())\n});\n/**\n * Result returned when a task is created, containing the task data wrapped in a task field.\n */\nexport const CreateTaskResultSchema = ResultSchema.extend({\n    task: TaskSchema\n});\n/**\n * Parameters for task status notification.\n */\nexport const TaskStatusNotificationParamsSchema = NotificationsParamsSchema.merge(TaskSchema);\n/**\n * A notification sent when a task's status changes.\n */\nexport const TaskStatusNotificationSchema = NotificationSchema.extend({\n    method: z.literal('notifications/tasks/status'),\n    params: TaskStatusNotificationParamsSchema\n});\n/**\n * A request to get the state of a specific task.\n */\nexport const GetTaskRequestSchema = RequestSchema.extend({\n    method: z.literal('tasks/get'),\n    params: BaseRequestParamsSchema.extend({\n        taskId: z.string()\n    })\n});\n/**\n * The response to a tasks/get request.\n */\nexport const GetTaskResultSchema = ResultSchema.merge(TaskSchema);\n/**\n * A request to get the result of a specific task.\n */\nexport const GetTaskPayloadRequestSchema = RequestSchema.extend({\n    method: z.literal('tasks/result'),\n    params: BaseRequestParamsSchema.extend({\n        taskId: z.string()\n    })\n});\n/**\n * The response to a tasks/result request.\n * The structure matches the result type of the original request.\n * For example, a tools/call task would return the CallToolResult structure.\n *\n */\nexport const GetTaskPayloadResultSchema = ResultSchema.loose();\n/**\n * A request to list tasks.\n */\nexport const ListTasksRequestSchema = PaginatedRequestSchema.extend({\n    method: z.literal('tasks/list')\n});\n/**\n * The response to a tasks/list request.\n */\nexport const ListTasksResultSchema = PaginatedResultSchema.extend({\n    tasks: z.array(TaskSchema)\n});\n/**\n * A request to cancel a specific task.\n */\nexport const CancelTaskRequestSchema = RequestSchema.extend({\n    method: z.literal('tasks/cancel'),\n    params: BaseRequestParamsSchema.extend({\n        taskId: z.string()\n    })\n});\n/**\n * The response to a tasks/cancel request.\n */\nexport const CancelTaskResultSchema = ResultSchema.merge(TaskSchema);\n/* Resources */\n/**\n * The contents of a specific resource or sub-resource.\n */\nexport const ResourceContentsSchema = z.object({\n    /**\n     * The URI of this resource.\n     */\n    uri: z.string(),\n    /**\n     * The MIME type of this resource, if known.\n     */\n    mimeType: z.optional(z.string()),\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.record(z.string(), z.unknown()).optional()\n});\nexport const TextResourceContentsSchema = ResourceContentsSchema.extend({\n    /**\n     * The text of the item. This must only be set if the item can actually be represented as text (not binary data).\n     */\n    text: z.string()\n});\n/**\n * A Zod schema for validating Base64 strings that is more performant and\n * robust for very large inputs than the default regex-based check. It avoids\n * stack overflows by using the native `atob` function for validation.\n */\nconst Base64Schema = z.string().refine(val => {\n    try {\n        // atob throws a DOMException if the string contains characters\n        // that are not part of the Base64 character set.\n        atob(val);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}, { message: 'Invalid Base64 string' });\nexport const BlobResourceContentsSchema = ResourceContentsSchema.extend({\n    /**\n     * A base64-encoded string representing the binary data of the item.\n     */\n    blob: Base64Schema\n});\n/**\n * The sender or recipient of messages and data in a conversation.\n */\nexport const RoleSchema = z.enum(['user', 'assistant']);\n/**\n * Optional annotations providing clients additional context about a resource.\n */\nexport const AnnotationsSchema = z.object({\n    /**\n     * Intended audience(s) for the resource.\n     */\n    audience: z.array(RoleSchema).optional(),\n    /**\n     * Importance hint for the resource, from 0 (least) to 1 (most).\n     */\n    priority: z.number().min(0).max(1).optional(),\n    /**\n     * ISO 8601 timestamp for the most recent modification.\n     */\n    lastModified: z.iso.datetime({ offset: true }).optional()\n});\n/**\n * A known resource that the server is capable of reading.\n */\nexport const ResourceSchema = z.object({\n    ...BaseMetadataSchema.shape,\n    ...IconsSchema.shape,\n    /**\n     * The URI of this resource.\n     */\n    uri: z.string(),\n    /**\n     * A description of what this resource represents.\n     *\n     * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a \"hint\" to the model.\n     */\n    description: z.optional(z.string()),\n    /**\n     * The MIME type of this resource, if known.\n     */\n    mimeType: z.optional(z.string()),\n    /**\n     * Optional annotations for the client.\n     */\n    annotations: AnnotationsSchema.optional(),\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.optional(z.looseObject({}))\n});\n/**\n * A template description for resources available on the server.\n */\nexport const ResourceTemplateSchema = z.object({\n    ...BaseMetadataSchema.shape,\n    ...IconsSchema.shape,\n    /**\n     * A URI template (according to RFC 6570) that can be used to construct resource URIs.\n     */\n    uriTemplate: z.string(),\n    /**\n     * A description of what this template is for.\n     *\n     * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a \"hint\" to the model.\n     */\n    description: z.optional(z.string()),\n    /**\n     * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.\n     */\n    mimeType: z.optional(z.string()),\n    /**\n     * Optional annotations for the client.\n     */\n    annotations: AnnotationsSchema.optional(),\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.optional(z.looseObject({}))\n});\n/**\n * Sent from the client to request a list of resources the server has.\n */\nexport const ListResourcesRequestSchema = PaginatedRequestSchema.extend({\n    method: z.literal('resources/list')\n});\n/**\n * The server's response to a resources/list request from the client.\n */\nexport const ListResourcesResultSchema = PaginatedResultSchema.extend({\n    resources: z.array(ResourceSchema)\n});\n/**\n * Sent from the client to request a list of resource templates the server has.\n */\nexport const ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({\n    method: z.literal('resources/templates/list')\n});\n/**\n * The server's response to a resources/templates/list request from the client.\n */\nexport const ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({\n    resourceTemplates: z.array(ResourceTemplateSchema)\n});\nexport const ResourceRequestParamsSchema = BaseRequestParamsSchema.extend({\n    /**\n     * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.\n     *\n     * @format uri\n     */\n    uri: z.string()\n});\n/**\n * Parameters for a `resources/read` request.\n */\nexport const ReadResourceRequestParamsSchema = ResourceRequestParamsSchema;\n/**\n * Sent from the client to the server, to read a specific resource URI.\n */\nexport const ReadResourceRequestSchema = RequestSchema.extend({\n    method: z.literal('resources/read'),\n    params: ReadResourceRequestParamsSchema\n});\n/**\n * The server's response to a resources/read request from the client.\n */\nexport const ReadResourceResultSchema = ResultSchema.extend({\n    contents: z.array(z.union([TextResourceContentsSchema, BlobResourceContentsSchema]))\n});\n/**\n * An optional notification from the server to the client, informing it that the list of resources it can read from has changed. This may be issued by servers without any previous subscription from the client.\n */\nexport const ResourceListChangedNotificationSchema = NotificationSchema.extend({\n    method: z.literal('notifications/resources/list_changed'),\n    params: NotificationsParamsSchema.optional()\n});\nexport const SubscribeRequestParamsSchema = ResourceRequestParamsSchema;\n/**\n * Sent from the client to request resources/updated notifications from the server whenever a particular resource changes.\n */\nexport const SubscribeRequestSchema = RequestSchema.extend({\n    method: z.literal('resources/subscribe'),\n    params: SubscribeRequestParamsSchema\n});\nexport const UnsubscribeRequestParamsSchema = ResourceRequestParamsSchema;\n/**\n * Sent from the client to request cancellation of resources/updated notifications from the server. This should follow a previous resources/subscribe request.\n */\nexport const UnsubscribeRequestSchema = RequestSchema.extend({\n    method: z.literal('resources/unsubscribe'),\n    params: UnsubscribeRequestParamsSchema\n});\n/**\n * Parameters for a `notifications/resources/updated` notification.\n */\nexport const ResourceUpdatedNotificationParamsSchema = NotificationsParamsSchema.extend({\n    /**\n     * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.\n     */\n    uri: z.string()\n});\n/**\n * A notification from the server to the client, informing it that a resource has changed and may need to be read again. This should only be sent if the client previously sent a resources/subscribe request.\n */\nexport const ResourceUpdatedNotificationSchema = NotificationSchema.extend({\n    method: z.literal('notifications/resources/updated'),\n    params: ResourceUpdatedNotificationParamsSchema\n});\n/* Prompts */\n/**\n * Describes an argument that a prompt can accept.\n */\nexport const PromptArgumentSchema = z.object({\n    /**\n     * The name of the argument.\n     */\n    name: z.string(),\n    /**\n     * A human-readable description of the argument.\n     */\n    description: z.optional(z.string()),\n    /**\n     * Whether this argument must be provided.\n     */\n    required: z.optional(z.boolean())\n});\n/**\n * A prompt or prompt template that the server offers.\n */\nexport const PromptSchema = z.object({\n    ...BaseMetadataSchema.shape,\n    ...IconsSchema.shape,\n    /**\n     * An optional description of what this prompt provides\n     */\n    description: z.optional(z.string()),\n    /**\n     * A list of arguments to use for templating the prompt.\n     */\n    arguments: z.optional(z.array(PromptArgumentSchema)),\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.optional(z.looseObject({}))\n});\n/**\n * Sent from the client to request a list of prompts and prompt templates the server has.\n */\nexport const ListPromptsRequestSchema = PaginatedRequestSchema.extend({\n    method: z.literal('prompts/list')\n});\n/**\n * The server's response to a prompts/list request from the client.\n */\nexport const ListPromptsResultSchema = PaginatedResultSchema.extend({\n    prompts: z.array(PromptSchema)\n});\n/**\n * Parameters for a `prompts/get` request.\n */\nexport const GetPromptRequestParamsSchema = BaseRequestParamsSchema.extend({\n    /**\n     * The name of the prompt or prompt template.\n     */\n    name: z.string(),\n    /**\n     * Arguments to use for templating the prompt.\n     */\n    arguments: z.record(z.string(), z.string()).optional()\n});\n/**\n * Used by the client to get a prompt provided by the server.\n */\nexport const GetPromptRequestSchema = RequestSchema.extend({\n    method: z.literal('prompts/get'),\n    params: GetPromptRequestParamsSchema\n});\n/**\n * Text provided to or from an LLM.\n */\nexport const TextContentSchema = z.object({\n    type: z.literal('text'),\n    /**\n     * The text content of the message.\n     */\n    text: z.string(),\n    /**\n     * Optional annotations for the client.\n     */\n    annotations: AnnotationsSchema.optional(),\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.record(z.string(), z.unknown()).optional()\n});\n/**\n * An image provided to or from an LLM.\n */\nexport const ImageContentSchema = z.object({\n    type: z.literal('image'),\n    /**\n     * The base64-encoded image data.\n     */\n    data: Base64Schema,\n    /**\n     * The MIME type of the image. Different providers may support different image types.\n     */\n    mimeType: z.string(),\n    /**\n     * Optional annotations for the client.\n     */\n    annotations: AnnotationsSchema.optional(),\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.record(z.string(), z.unknown()).optional()\n});\n/**\n * An Audio provided to or from an LLM.\n */\nexport const AudioContentSchema = z.object({\n    type: z.literal('audio'),\n    /**\n     * The base64-encoded audio data.\n     */\n    data: Base64Schema,\n    /**\n     * The MIME type of the audio. Different providers may support different audio types.\n     */\n    mimeType: z.string(),\n    /**\n     * Optional annotations for the client.\n     */\n    annotations: AnnotationsSchema.optional(),\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.record(z.string(), z.unknown()).optional()\n});\n/**\n * A tool call request from an assistant (LLM).\n * Represents the assistant's request to use a tool.\n */\nexport const ToolUseContentSchema = z.object({\n    type: z.literal('tool_use'),\n    /**\n     * The name of the tool to invoke.\n     * Must match a tool name from the request's tools array.\n     */\n    name: z.string(),\n    /**\n     * Unique identifier for this tool call.\n     * Used to correlate with ToolResultContent in subsequent messages.\n     */\n    id: z.string(),\n    /**\n     * Arguments to pass to the tool.\n     * Must conform to the tool's inputSchema.\n     */\n    input: z.record(z.string(), z.unknown()),\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.record(z.string(), z.unknown()).optional()\n});\n/**\n * The contents of a resource, embedded into a prompt or tool call result.\n */\nexport const EmbeddedResourceSchema = z.object({\n    type: z.literal('resource'),\n    resource: z.union([TextResourceContentsSchema, BlobResourceContentsSchema]),\n    /**\n     * Optional annotations for the client.\n     */\n    annotations: AnnotationsSchema.optional(),\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.record(z.string(), z.unknown()).optional()\n});\n/**\n * A resource that the server is capable of reading, included in a prompt or tool call result.\n *\n * Note: resource links returned by tools are not guaranteed to appear in the results of `resources/list` requests.\n */\nexport const ResourceLinkSchema = ResourceSchema.extend({\n    type: z.literal('resource_link')\n});\n/**\n * A content block that can be used in prompts and tool results.\n */\nexport const ContentBlockSchema = z.union([\n    TextContentSchema,\n    ImageContentSchema,\n    AudioContentSchema,\n    ResourceLinkSchema,\n    EmbeddedResourceSchema\n]);\n/**\n * Describes a message returned as part of a prompt.\n */\nexport const PromptMessageSchema = z.object({\n    role: RoleSchema,\n    content: ContentBlockSchema\n});\n/**\n * The server's response to a prompts/get request from the client.\n */\nexport const GetPromptResultSchema = ResultSchema.extend({\n    /**\n     * An optional description for the prompt.\n     */\n    description: z.string().optional(),\n    messages: z.array(PromptMessageSchema)\n});\n/**\n * An optional notification from the server to the client, informing it that the list of prompts it offers has changed. This may be issued by servers without any previous subscription from the client.\n */\nexport const PromptListChangedNotificationSchema = NotificationSchema.extend({\n    method: z.literal('notifications/prompts/list_changed'),\n    params: NotificationsParamsSchema.optional()\n});\n/* Tools */\n/**\n * Additional properties describing a Tool to clients.\n *\n * NOTE: all properties in ToolAnnotations are **hints**.\n * They are not guaranteed to provide a faithful description of\n * tool behavior (including descriptive properties like `title`).\n *\n * Clients should never make tool use decisions based on ToolAnnotations\n * received from untrusted servers.\n */\nexport const ToolAnnotationsSchema = z.object({\n    /**\n     * A human-readable title for the tool.\n     */\n    title: z.string().optional(),\n    /**\n     * If true, the tool does not modify its environment.\n     *\n     * Default: false\n     */\n    readOnlyHint: z.boolean().optional(),\n    /**\n     * If true, the tool may perform destructive updates to its environment.\n     * If false, the tool performs only additive updates.\n     *\n     * (This property is meaningful only when `readOnlyHint == false`)\n     *\n     * Default: true\n     */\n    destructiveHint: z.boolean().optional(),\n    /**\n     * If true, calling the tool repeatedly with the same arguments\n     * will have no additional effect on the its environment.\n     *\n     * (This property is meaningful only when `readOnlyHint == false`)\n     *\n     * Default: false\n     */\n    idempotentHint: z.boolean().optional(),\n    /**\n     * If true, this tool may interact with an \"open world\" of external\n     * entities. If false, the tool's domain of interaction is closed.\n     * For example, the world of a web search tool is open, whereas that\n     * of a memory tool is not.\n     *\n     * Default: true\n     */\n    openWorldHint: z.boolean().optional()\n});\n/**\n * Execution-related properties for a tool.\n */\nexport const ToolExecutionSchema = z.object({\n    /**\n     * Indicates the tool's preference for task-augmented execution.\n     * - \"required\": Clients MUST invoke the tool as a task\n     * - \"optional\": Clients MAY invoke the tool as a task or normal request\n     * - \"forbidden\": Clients MUST NOT attempt to invoke the tool as a task\n     *\n     * If not present, defaults to \"forbidden\".\n     */\n    taskSupport: z.enum(['required', 'optional', 'forbidden']).optional()\n});\n/**\n * Definition for a tool the client can call.\n */\nexport const ToolSchema = z.object({\n    ...BaseMetadataSchema.shape,\n    ...IconsSchema.shape,\n    /**\n     * A human-readable description of the tool.\n     */\n    description: z.string().optional(),\n    /**\n     * A JSON Schema 2020-12 object defining the expected parameters for the tool.\n     * Must have type: 'object' at the root level per MCP spec.\n     */\n    inputSchema: z\n        .object({\n        type: z.literal('object'),\n        properties: z.record(z.string(), AssertObjectSchema).optional(),\n        required: z.array(z.string()).optional()\n    })\n        .catchall(z.unknown()),\n    /**\n     * An optional JSON Schema 2020-12 object defining the structure of the tool's output\n     * returned in the structuredContent field of a CallToolResult.\n     * Must have type: 'object' at the root level per MCP spec.\n     */\n    outputSchema: z\n        .object({\n        type: z.literal('object'),\n        properties: z.record(z.string(), AssertObjectSchema).optional(),\n        required: z.array(z.string()).optional()\n    })\n        .catchall(z.unknown())\n        .optional(),\n    /**\n     * Optional additional tool information.\n     */\n    annotations: ToolAnnotationsSchema.optional(),\n    /**\n     * Execution-related properties for this tool.\n     */\n    execution: ToolExecutionSchema.optional(),\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.record(z.string(), z.unknown()).optional()\n});\n/**\n * Sent from the client to request a list of tools the server has.\n */\nexport const ListToolsRequestSchema = PaginatedRequestSchema.extend({\n    method: z.literal('tools/list')\n});\n/**\n * The server's response to a tools/list request from the client.\n */\nexport const ListToolsResultSchema = PaginatedResultSchema.extend({\n    tools: z.array(ToolSchema)\n});\n/**\n * The server's response to a tool call.\n */\nexport const CallToolResultSchema = ResultSchema.extend({\n    /**\n     * A list of content objects that represent the result of the tool call.\n     *\n     * If the Tool does not define an outputSchema, this field MUST be present in the result.\n     * For backwards compatibility, this field is always present, but it may be empty.\n     */\n    content: z.array(ContentBlockSchema).default([]),\n    /**\n     * An object containing structured tool output.\n     *\n     * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.\n     */\n    structuredContent: z.record(z.string(), z.unknown()).optional(),\n    /**\n     * Whether the tool call ended in an error.\n     *\n     * If not set, this is assumed to be false (the call was successful).\n     *\n     * Any errors that originate from the tool SHOULD be reported inside the result\n     * object, with `isError` set to true, _not_ as an MCP protocol-level error\n     * response. Otherwise, the LLM would not be able to see that an error occurred\n     * and self-correct.\n     *\n     * However, any errors in _finding_ the tool, an error indicating that the\n     * server does not support tool calls, or any other exceptional conditions,\n     * should be reported as an MCP error response.\n     */\n    isError: z.boolean().optional()\n});\n/**\n * CallToolResultSchema extended with backwards compatibility to protocol version 2024-10-07.\n */\nexport const CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({\n    toolResult: z.unknown()\n}));\n/**\n * Parameters for a `tools/call` request.\n */\nexport const CallToolRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({\n    /**\n     * The name of the tool to call.\n     */\n    name: z.string(),\n    /**\n     * Arguments to pass to the tool.\n     */\n    arguments: z.record(z.string(), z.unknown()).optional()\n});\n/**\n * Used by the client to invoke a tool provided by the server.\n */\nexport const CallToolRequestSchema = RequestSchema.extend({\n    method: z.literal('tools/call'),\n    params: CallToolRequestParamsSchema\n});\n/**\n * An optional notification from the server to the client, informing it that the list of tools it offers has changed. This may be issued by servers without any previous subscription from the client.\n */\nexport const ToolListChangedNotificationSchema = NotificationSchema.extend({\n    method: z.literal('notifications/tools/list_changed'),\n    params: NotificationsParamsSchema.optional()\n});\n/**\n * Base schema for list changed subscription options (without callback).\n * Used internally for Zod validation of autoRefresh and debounceMs.\n */\nexport const ListChangedOptionsBaseSchema = z.object({\n    /**\n     * If true, the list will be refreshed automatically when a list changed notification is received.\n     * The callback will be called with the updated list.\n     *\n     * If false, the callback will be called with null items, allowing manual refresh.\n     *\n     * @default true\n     */\n    autoRefresh: z.boolean().default(true),\n    /**\n     * Debounce time in milliseconds for list changed notification processing.\n     *\n     * Multiple notifications received within this timeframe will only trigger one refresh.\n     * Set to 0 to disable debouncing.\n     *\n     * @default 300\n     */\n    debounceMs: z.number().int().nonnegative().default(300)\n});\n/* Logging */\n/**\n * The severity of a log message.\n */\nexport const LoggingLevelSchema = z.enum(['debug', 'info', 'notice', 'warning', 'error', 'critical', 'alert', 'emergency']);\n/**\n * Parameters for a `logging/setLevel` request.\n */\nexport const SetLevelRequestParamsSchema = BaseRequestParamsSchema.extend({\n    /**\n     * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.\n     */\n    level: LoggingLevelSchema\n});\n/**\n * A request from the client to the server, to enable or adjust logging.\n */\nexport const SetLevelRequestSchema = RequestSchema.extend({\n    method: z.literal('logging/setLevel'),\n    params: SetLevelRequestParamsSchema\n});\n/**\n * Parameters for a `notifications/message` notification.\n */\nexport const LoggingMessageNotificationParamsSchema = NotificationsParamsSchema.extend({\n    /**\n     * The severity of this log message.\n     */\n    level: LoggingLevelSchema,\n    /**\n     * An optional name of the logger issuing this message.\n     */\n    logger: z.string().optional(),\n    /**\n     * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.\n     */\n    data: z.unknown()\n});\n/**\n * Notification of a log message passed from server to client. If no logging/setLevel request has been sent from the client, the server MAY decide which messages to send automatically.\n */\nexport const LoggingMessageNotificationSchema = NotificationSchema.extend({\n    method: z.literal('notifications/message'),\n    params: LoggingMessageNotificationParamsSchema\n});\n/* Sampling */\n/**\n * Hints to use for model selection.\n */\nexport const ModelHintSchema = z.object({\n    /**\n     * A hint for a model name.\n     */\n    name: z.string().optional()\n});\n/**\n * The server's preferences for model selection, requested of the client during sampling.\n */\nexport const ModelPreferencesSchema = z.object({\n    /**\n     * Optional hints to use for model selection.\n     */\n    hints: z.array(ModelHintSchema).optional(),\n    /**\n     * How much to prioritize cost when selecting a model.\n     */\n    costPriority: z.number().min(0).max(1).optional(),\n    /**\n     * How much to prioritize sampling speed (latency) when selecting a model.\n     */\n    speedPriority: z.number().min(0).max(1).optional(),\n    /**\n     * How much to prioritize intelligence and capabilities when selecting a model.\n     */\n    intelligencePriority: z.number().min(0).max(1).optional()\n});\n/**\n * Controls tool usage behavior in sampling requests.\n */\nexport const ToolChoiceSchema = z.object({\n    /**\n     * Controls when tools are used:\n     * - \"auto\": Model decides whether to use tools (default)\n     * - \"required\": Model MUST use at least one tool before completing\n     * - \"none\": Model MUST NOT use any tools\n     */\n    mode: z.enum(['auto', 'required', 'none']).optional()\n});\n/**\n * The result of a tool execution, provided by the user (server).\n * Represents the outcome of invoking a tool requested via ToolUseContent.\n */\nexport const ToolResultContentSchema = z.object({\n    type: z.literal('tool_result'),\n    toolUseId: z.string().describe('The unique identifier for the corresponding tool call.'),\n    content: z.array(ContentBlockSchema).default([]),\n    structuredContent: z.object({}).loose().optional(),\n    isError: z.boolean().optional(),\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.record(z.string(), z.unknown()).optional()\n});\n/**\n * Basic content types for sampling responses (without tool use).\n * Used for backwards-compatible CreateMessageResult when tools are not used.\n */\nexport const SamplingContentSchema = z.discriminatedUnion('type', [TextContentSchema, ImageContentSchema, AudioContentSchema]);\n/**\n * Content block types allowed in sampling messages.\n * This includes text, image, audio, tool use requests, and tool results.\n */\nexport const SamplingMessageContentBlockSchema = z.discriminatedUnion('type', [\n    TextContentSchema,\n    ImageContentSchema,\n    AudioContentSchema,\n    ToolUseContentSchema,\n    ToolResultContentSchema\n]);\n/**\n * Describes a message issued to or received from an LLM API.\n */\nexport const SamplingMessageSchema = z.object({\n    role: RoleSchema,\n    content: z.union([SamplingMessageContentBlockSchema, z.array(SamplingMessageContentBlockSchema)]),\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.record(z.string(), z.unknown()).optional()\n});\n/**\n * Parameters for a `sampling/createMessage` request.\n */\nexport const CreateMessageRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({\n    messages: z.array(SamplingMessageSchema),\n    /**\n     * The server's preferences for which model to select. The client MAY modify or omit this request.\n     */\n    modelPreferences: ModelPreferencesSchema.optional(),\n    /**\n     * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.\n     */\n    systemPrompt: z.string().optional(),\n    /**\n     * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt.\n     * The client MAY ignore this request.\n     *\n     * Default is \"none\". Values \"thisServer\" and \"allServers\" are soft-deprecated. Servers SHOULD only use these values if the client\n     * declares ClientCapabilities.sampling.context. These values may be removed in future spec releases.\n     */\n    includeContext: z.enum(['none', 'thisServer', 'allServers']).optional(),\n    temperature: z.number().optional(),\n    /**\n     * The requested maximum number of tokens to sample (to prevent runaway completions).\n     *\n     * The client MAY choose to sample fewer tokens than the requested maximum.\n     */\n    maxTokens: z.number().int(),\n    stopSequences: z.array(z.string()).optional(),\n    /**\n     * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.\n     */\n    metadata: AssertObjectSchema.optional(),\n    /**\n     * Tools that the model may use during generation.\n     * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.\n     */\n    tools: z.array(ToolSchema).optional(),\n    /**\n     * Controls how the model uses tools.\n     * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.\n     * Default is `{ mode: \"auto\" }`.\n     */\n    toolChoice: ToolChoiceSchema.optional()\n});\n/**\n * A request from the server to sample an LLM via the client. The client has full discretion over which model to select. The client should also inform the user before beginning sampling, to allow them to inspect the request (human in the loop) and decide whether to approve it.\n */\nexport const CreateMessageRequestSchema = RequestSchema.extend({\n    method: z.literal('sampling/createMessage'),\n    params: CreateMessageRequestParamsSchema\n});\n/**\n * The client's response to a sampling/create_message request from the server.\n * This is the backwards-compatible version that returns single content (no arrays).\n * Used when the request does not include tools.\n */\nexport const CreateMessageResultSchema = ResultSchema.extend({\n    /**\n     * The name of the model that generated the message.\n     */\n    model: z.string(),\n    /**\n     * The reason why sampling stopped, if known.\n     *\n     * Standard values:\n     * - \"endTurn\": Natural end of the assistant's turn\n     * - \"stopSequence\": A stop sequence was encountered\n     * - \"maxTokens\": Maximum token limit was reached\n     *\n     * This field is an open string to allow for provider-specific stop reasons.\n     */\n    stopReason: z.optional(z.enum(['endTurn', 'stopSequence', 'maxTokens']).or(z.string())),\n    role: RoleSchema,\n    /**\n     * Response content. Single content block (text, image, or audio).\n     */\n    content: SamplingContentSchema\n});\n/**\n * The client's response to a sampling/create_message request when tools were provided.\n * This version supports array content for tool use flows.\n */\nexport const CreateMessageResultWithToolsSchema = ResultSchema.extend({\n    /**\n     * The name of the model that generated the message.\n     */\n    model: z.string(),\n    /**\n     * The reason why sampling stopped, if known.\n     *\n     * Standard values:\n     * - \"endTurn\": Natural end of the assistant's turn\n     * - \"stopSequence\": A stop sequence was encountered\n     * - \"maxTokens\": Maximum token limit was reached\n     * - \"toolUse\": The model wants to use one or more tools\n     *\n     * This field is an open string to allow for provider-specific stop reasons.\n     */\n    stopReason: z.optional(z.enum(['endTurn', 'stopSequence', 'maxTokens', 'toolUse']).or(z.string())),\n    role: RoleSchema,\n    /**\n     * Response content. May be a single block or array. May include ToolUseContent if stopReason is \"toolUse\".\n     */\n    content: z.union([SamplingMessageContentBlockSchema, z.array(SamplingMessageContentBlockSchema)])\n});\n/* Elicitation */\n/**\n * Primitive schema definition for boolean fields.\n */\nexport const BooleanSchemaSchema = z.object({\n    type: z.literal('boolean'),\n    title: z.string().optional(),\n    description: z.string().optional(),\n    default: z.boolean().optional()\n});\n/**\n * Primitive schema definition for string fields.\n */\nexport const StringSchemaSchema = z.object({\n    type: z.literal('string'),\n    title: z.string().optional(),\n    description: z.string().optional(),\n    minLength: z.number().optional(),\n    maxLength: z.number().optional(),\n    format: z.enum(['email', 'uri', 'date', 'date-time']).optional(),\n    default: z.string().optional()\n});\n/**\n * Primitive schema definition for number fields.\n */\nexport const NumberSchemaSchema = z.object({\n    type: z.enum(['number', 'integer']),\n    title: z.string().optional(),\n    description: z.string().optional(),\n    minimum: z.number().optional(),\n    maximum: z.number().optional(),\n    default: z.number().optional()\n});\n/**\n * Schema for single-selection enumeration without display titles for options.\n */\nexport const UntitledSingleSelectEnumSchemaSchema = z.object({\n    type: z.literal('string'),\n    title: z.string().optional(),\n    description: z.string().optional(),\n    enum: z.array(z.string()),\n    default: z.string().optional()\n});\n/**\n * Schema for single-selection enumeration with display titles for each option.\n */\nexport const TitledSingleSelectEnumSchemaSchema = z.object({\n    type: z.literal('string'),\n    title: z.string().optional(),\n    description: z.string().optional(),\n    oneOf: z.array(z.object({\n        const: z.string(),\n        title: z.string()\n    })),\n    default: z.string().optional()\n});\n/**\n * Use TitledSingleSelectEnumSchema instead.\n * This interface will be removed in a future version.\n */\nexport const LegacyTitledEnumSchemaSchema = z.object({\n    type: z.literal('string'),\n    title: z.string().optional(),\n    description: z.string().optional(),\n    enum: z.array(z.string()),\n    enumNames: z.array(z.string()).optional(),\n    default: z.string().optional()\n});\n// Combined single selection enumeration\nexport const SingleSelectEnumSchemaSchema = z.union([UntitledSingleSelectEnumSchemaSchema, TitledSingleSelectEnumSchemaSchema]);\n/**\n * Schema for multiple-selection enumeration without display titles for options.\n */\nexport const UntitledMultiSelectEnumSchemaSchema = z.object({\n    type: z.literal('array'),\n    title: z.string().optional(),\n    description: z.string().optional(),\n    minItems: z.number().optional(),\n    maxItems: z.number().optional(),\n    items: z.object({\n        type: z.literal('string'),\n        enum: z.array(z.string())\n    }),\n    default: z.array(z.string()).optional()\n});\n/**\n * Schema for multiple-selection enumeration with display titles for each option.\n */\nexport const TitledMultiSelectEnumSchemaSchema = z.object({\n    type: z.literal('array'),\n    title: z.string().optional(),\n    description: z.string().optional(),\n    minItems: z.number().optional(),\n    maxItems: z.number().optional(),\n    items: z.object({\n        anyOf: z.array(z.object({\n            const: z.string(),\n            title: z.string()\n        }))\n    }),\n    default: z.array(z.string()).optional()\n});\n/**\n * Combined schema for multiple-selection enumeration\n */\nexport const MultiSelectEnumSchemaSchema = z.union([UntitledMultiSelectEnumSchemaSchema, TitledMultiSelectEnumSchemaSchema]);\n/**\n * Primitive schema definition for enum fields.\n */\nexport const EnumSchemaSchema = z.union([LegacyTitledEnumSchemaSchema, SingleSelectEnumSchemaSchema, MultiSelectEnumSchemaSchema]);\n/**\n * Union of all primitive schema definitions.\n */\nexport const PrimitiveSchemaDefinitionSchema = z.union([EnumSchemaSchema, BooleanSchemaSchema, StringSchemaSchema, NumberSchemaSchema]);\n/**\n * Parameters for an `elicitation/create` request for form-based elicitation.\n */\nexport const ElicitRequestFormParamsSchema = TaskAugmentedRequestParamsSchema.extend({\n    /**\n     * The elicitation mode.\n     *\n     * Optional for backward compatibility. Clients MUST treat missing mode as \"form\".\n     */\n    mode: z.literal('form').optional(),\n    /**\n     * The message to present to the user describing what information is being requested.\n     */\n    message: z.string(),\n    /**\n     * A restricted subset of JSON Schema.\n     * Only top-level properties are allowed, without nesting.\n     */\n    requestedSchema: z.object({\n        type: z.literal('object'),\n        properties: z.record(z.string(), PrimitiveSchemaDefinitionSchema),\n        required: z.array(z.string()).optional()\n    })\n});\n/**\n * Parameters for an `elicitation/create` request for URL-based elicitation.\n */\nexport const ElicitRequestURLParamsSchema = TaskAugmentedRequestParamsSchema.extend({\n    /**\n     * The elicitation mode.\n     */\n    mode: z.literal('url'),\n    /**\n     * The message to present to the user explaining why the interaction is needed.\n     */\n    message: z.string(),\n    /**\n     * The ID of the elicitation, which must be unique within the context of the server.\n     * The client MUST treat this ID as an opaque value.\n     */\n    elicitationId: z.string(),\n    /**\n     * The URL that the user should navigate to.\n     */\n    url: z.string().url()\n});\n/**\n * The parameters for a request to elicit additional information from the user via the client.\n */\nexport const ElicitRequestParamsSchema = z.union([ElicitRequestFormParamsSchema, ElicitRequestURLParamsSchema]);\n/**\n * A request from the server to elicit user input via the client.\n * The client should present the message and form fields to the user (form mode)\n * or navigate to a URL (URL mode).\n */\nexport const ElicitRequestSchema = RequestSchema.extend({\n    method: z.literal('elicitation/create'),\n    params: ElicitRequestParamsSchema\n});\n/**\n * Parameters for a `notifications/elicitation/complete` notification.\n *\n * @category notifications/elicitation/complete\n */\nexport const ElicitationCompleteNotificationParamsSchema = NotificationsParamsSchema.extend({\n    /**\n     * The ID of the elicitation that completed.\n     */\n    elicitationId: z.string()\n});\n/**\n * A notification from the server to the client, informing it of a completion of an out-of-band elicitation request.\n *\n * @category notifications/elicitation/complete\n */\nexport const ElicitationCompleteNotificationSchema = NotificationSchema.extend({\n    method: z.literal('notifications/elicitation/complete'),\n    params: ElicitationCompleteNotificationParamsSchema\n});\n/**\n * The client's response to an elicitation/create request from the server.\n */\nexport const ElicitResultSchema = ResultSchema.extend({\n    /**\n     * The user action in response to the elicitation.\n     * - \"accept\": User submitted the form/confirmed the action\n     * - \"decline\": User explicitly decline the action\n     * - \"cancel\": User dismissed without making an explicit choice\n     */\n    action: z.enum(['accept', 'decline', 'cancel']),\n    /**\n     * The submitted form data, only present when action is \"accept\".\n     * Contains values matching the requested schema.\n     * Per MCP spec, content is \"typically omitted\" for decline/cancel actions.\n     * We normalize null to undefined for leniency while maintaining type compatibility.\n     */\n    content: z.preprocess(val => (val === null ? undefined : val), z.record(z.string(), z.union([z.string(), z.number(), z.boolean(), z.array(z.string())])).optional())\n});\n/* Autocomplete */\n/**\n * A reference to a resource or resource template definition.\n */\nexport const ResourceTemplateReferenceSchema = z.object({\n    type: z.literal('ref/resource'),\n    /**\n     * The URI or URI template of the resource.\n     */\n    uri: z.string()\n});\n/**\n * @deprecated Use ResourceTemplateReferenceSchema instead\n */\nexport const ResourceReferenceSchema = ResourceTemplateReferenceSchema;\n/**\n * Identifies a prompt.\n */\nexport const PromptReferenceSchema = z.object({\n    type: z.literal('ref/prompt'),\n    /**\n     * The name of the prompt or prompt template\n     */\n    name: z.string()\n});\n/**\n * Parameters for a `completion/complete` request.\n */\nexport const CompleteRequestParamsSchema = BaseRequestParamsSchema.extend({\n    ref: z.union([PromptReferenceSchema, ResourceTemplateReferenceSchema]),\n    /**\n     * The argument's information\n     */\n    argument: z.object({\n        /**\n         * The name of the argument\n         */\n        name: z.string(),\n        /**\n         * The value of the argument to use for completion matching.\n         */\n        value: z.string()\n    }),\n    context: z\n        .object({\n        /**\n         * Previously-resolved variables in a URI template or prompt.\n         */\n        arguments: z.record(z.string(), z.string()).optional()\n    })\n        .optional()\n});\n/**\n * A request from the client to the server, to ask for completion options.\n */\nexport const CompleteRequestSchema = RequestSchema.extend({\n    method: z.literal('completion/complete'),\n    params: CompleteRequestParamsSchema\n});\nexport function assertCompleteRequestPrompt(request) {\n    if (request.params.ref.type !== 'ref/prompt') {\n        throw new TypeError(`Expected CompleteRequestPrompt, but got ${request.params.ref.type}`);\n    }\n    void request;\n}\nexport function assertCompleteRequestResourceTemplate(request) {\n    if (request.params.ref.type !== 'ref/resource') {\n        throw new TypeError(`Expected CompleteRequestResourceTemplate, but got ${request.params.ref.type}`);\n    }\n    void request;\n}\n/**\n * The server's response to a completion/complete request\n */\nexport const CompleteResultSchema = ResultSchema.extend({\n    completion: z.looseObject({\n        /**\n         * An array of completion values. Must not exceed 100 items.\n         */\n        values: z.array(z.string()).max(100),\n        /**\n         * The total number of completion options available. This can exceed the number of values actually sent in the response.\n         */\n        total: z.optional(z.number().int()),\n        /**\n         * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.\n         */\n        hasMore: z.optional(z.boolean())\n    })\n});\n/* Roots */\n/**\n * Represents a root directory or file that the server can operate on.\n */\nexport const RootSchema = z.object({\n    /**\n     * The URI identifying the root. This *must* start with file:// for now.\n     */\n    uri: z.string().startsWith('file://'),\n    /**\n     * An optional name for the root.\n     */\n    name: z.string().optional(),\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.record(z.string(), z.unknown()).optional()\n});\n/**\n * Sent from the server to request a list of root URIs from the client.\n */\nexport const ListRootsRequestSchema = RequestSchema.extend({\n    method: z.literal('roots/list'),\n    params: BaseRequestParamsSchema.optional()\n});\n/**\n * The client's response to a roots/list request from the server.\n */\nexport const ListRootsResultSchema = ResultSchema.extend({\n    roots: z.array(RootSchema)\n});\n/**\n * A notification from the client to the server, informing it that the list of roots has changed.\n */\nexport const RootsListChangedNotificationSchema = NotificationSchema.extend({\n    method: z.literal('notifications/roots/list_changed'),\n    params: NotificationsParamsSchema.optional()\n});\n/* Client messages */\nexport const ClientRequestSchema = z.union([\n    PingRequestSchema,\n    InitializeRequestSchema,\n    CompleteRequestSchema,\n    SetLevelRequestSchema,\n    GetPromptRequestSchema,\n    ListPromptsRequestSchema,\n    ListResourcesRequestSchema,\n    ListResourceTemplatesRequestSchema,\n    ReadResourceRequestSchema,\n    SubscribeRequestSchema,\n    UnsubscribeRequestSchema,\n    CallToolRequestSchema,\n    ListToolsRequestSchema,\n    GetTaskRequestSchema,\n    GetTaskPayloadRequestSchema,\n    ListTasksRequestSchema,\n    CancelTaskRequestSchema\n]);\nexport const ClientNotificationSchema = z.union([\n    CancelledNotificationSchema,\n    ProgressNotificationSchema,\n    InitializedNotificationSchema,\n    RootsListChangedNotificationSchema,\n    TaskStatusNotificationSchema\n]);\nexport const ClientResultSchema = z.union([\n    EmptyResultSchema,\n    CreateMessageResultSchema,\n    CreateMessageResultWithToolsSchema,\n    ElicitResultSchema,\n    ListRootsResultSchema,\n    GetTaskResultSchema,\n    ListTasksResultSchema,\n    CreateTaskResultSchema\n]);\n/* Server messages */\nexport const ServerRequestSchema = z.union([\n    PingRequestSchema,\n    CreateMessageRequestSchema,\n    ElicitRequestSchema,\n    ListRootsRequestSchema,\n    GetTaskRequestSchema,\n    GetTaskPayloadRequestSchema,\n    ListTasksRequestSchema,\n    CancelTaskRequestSchema\n]);\nexport const ServerNotificationSchema = z.union([\n    CancelledNotificationSchema,\n    ProgressNotificationSchema,\n    LoggingMessageNotificationSchema,\n    ResourceUpdatedNotificationSchema,\n    ResourceListChangedNotificationSchema,\n    ToolListChangedNotificationSchema,\n    PromptListChangedNotificationSchema,\n    TaskStatusNotificationSchema,\n    ElicitationCompleteNotificationSchema\n]);\nexport const ServerResultSchema = z.union([\n    EmptyResultSchema,\n    InitializeResultSchema,\n    CompleteResultSchema,\n    GetPromptResultSchema,\n    ListPromptsResultSchema,\n    ListResourcesResultSchema,\n    ListResourceTemplatesResultSchema,\n    ReadResourceResultSchema,\n    CallToolResultSchema,\n    ListToolsResultSchema,\n    GetTaskResultSchema,\n    ListTasksResultSchema,\n    CreateTaskResultSchema\n]);\nexport class McpError extends Error {\n    constructor(code, message, data) {\n        super(`MCP error ${code}: ${message}`);\n        this.code = code;\n        this.data = data;\n        this.name = 'McpError';\n    }\n    /**\n     * Factory method to create the appropriate error type based on the error code and data\n     */\n    static fromError(code, message, data) {\n        // Check for specific error types\n        if (code === ErrorCode.UrlElicitationRequired && data) {\n            const errorData = data;\n            if (errorData.elicitations) {\n                return new UrlElicitationRequiredError(errorData.elicitations, message);\n            }\n        }\n        // Default to generic McpError\n        return new McpError(code, message, data);\n    }\n}\n/**\n * Specialized error type when a tool requires a URL mode elicitation.\n * This makes it nicer for the client to handle since there is specific data to work with instead of just a code to check against.\n */\nexport class UrlElicitationRequiredError extends McpError {\n    constructor(elicitations, message = `URL elicitation${elicitations.length > 1 ? 's' : ''} required`) {\n        super(ErrorCode.UrlElicitationRequired, message, {\n            elicitations: elicitations\n        });\n    }\n    get elicitations() {\n        return this.data?.elicitations ?? [];\n    }\n}\n//# sourceMappingURL=types.js.map","/**\n * AJV-based JSON Schema validator provider\n */\nimport Ajv from 'ajv';\nimport _addFormats from 'ajv-formats';\nfunction createDefaultAjvInstance() {\n    const ajv = new Ajv({\n        strict: false,\n        validateFormats: true,\n        validateSchema: false,\n        allErrors: true\n    });\n    const addFormats = _addFormats;\n    addFormats(ajv);\n    return ajv;\n}\n/**\n * @example\n * ```typescript\n * // Use with default AJV instance (recommended)\n * import { AjvJsonSchemaValidator } from '@modelcontextprotocol/sdk/validation/ajv';\n * const validator = new AjvJsonSchemaValidator();\n *\n * // Use with custom AJV instance\n * import { Ajv } from 'ajv';\n * const ajv = new Ajv({ strict: true, allErrors: true });\n * const validator = new AjvJsonSchemaValidator(ajv);\n * ```\n */\nexport class AjvJsonSchemaValidator {\n    /**\n     * Create an AJV validator\n     *\n     * @param ajv - Optional pre-configured AJV instance. If not provided, a default instance will be created.\n     *\n     * @example\n     * ```typescript\n     * // Use default configuration (recommended for most cases)\n     * import { AjvJsonSchemaValidator } from '@modelcontextprotocol/sdk/validation/ajv';\n     * const validator = new AjvJsonSchemaValidator();\n     *\n     * // Or provide custom AJV instance for advanced configuration\n     * import { Ajv } from 'ajv';\n     * import addFormats from 'ajv-formats';\n     *\n     * const ajv = new Ajv({ validateFormats: true });\n     * addFormats(ajv);\n     * const validator = new AjvJsonSchemaValidator(ajv);\n     * ```\n     */\n    constructor(ajv) {\n        this._ajv = ajv ?? createDefaultAjvInstance();\n    }\n    /**\n     * Create a validator for the given JSON Schema\n     *\n     * The validator is compiled once and can be reused multiple times.\n     * If the schema has an $id, it will be cached by AJV automatically.\n     *\n     * @param schema - Standard JSON Schema object\n     * @returns A validator function that validates input data\n     */\n    getValidator(schema) {\n        // Check if schema has $id and is already compiled/cached\n        const ajvValidator = '$id' in schema && typeof schema.$id === 'string'\n            ? (this._ajv.getSchema(schema.$id) ?? this._ajv.compile(schema))\n            : this._ajv.compile(schema);\n        return (input) => {\n            const valid = ajvValidator(input);\n            if (valid) {\n                return {\n                    valid: true,\n                    data: input,\n                    errorMessage: undefined\n                };\n            }\n            else {\n                return {\n                    valid: false,\n                    data: undefined,\n                    errorMessage: this._ajv.errorsText(ajvValidator.errors)\n                };\n            }\n        };\n    }\n}\n//# sourceMappingURL=ajv-provider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.formatNames = exports.fastFormats = exports.fullFormats = void 0;\nfunction fmtDef(validate, compare) {\n    return { validate, compare };\n}\nexports.fullFormats = {\n    // date: http://tools.ietf.org/html/rfc3339#section-5.6\n    date: fmtDef(date, compareDate),\n    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n    time: fmtDef(getTime(true), compareTime),\n    \"date-time\": fmtDef(getDateTime(true), compareDateTime),\n    \"iso-time\": fmtDef(getTime(), compareIsoTime),\n    \"iso-date-time\": fmtDef(getDateTime(), compareIsoDateTime),\n    // duration: https://tools.ietf.org/html/rfc3339#appendix-A\n    duration: /^P(?!$)((\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?|(\\d+W)?)$/,\n    uri,\n    \"uri-reference\": /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,\n    // uri-template: https://tools.ietf.org/html/rfc6570\n    \"uri-template\": /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i,\n    // For the source: https://gist.github.com/dperini/729294\n    // For test cases: https://mathiasbynens.be/demo/url-regex\n    url: /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu,\n    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n    hostname: /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i,\n    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n    ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/,\n    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i,\n    regex,\n    // uuid: http://tools.ietf.org/html/rfc4122\n    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,\n    // JSON-pointer: https://tools.ietf.org/html/rfc6901\n    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n    \"json-pointer\": /^(?:\\/(?:[^~/]|~0|~1)*)*$/,\n    \"json-pointer-uri-fragment\": /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,\n    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00\n    \"relative-json-pointer\": /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/,\n    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types\n    // byte: https://github.com/miguelmota/is-base64\n    byte,\n    // signed 32 bit integer\n    int32: { type: \"number\", validate: validateInt32 },\n    // signed 64 bit integer\n    int64: { type: \"number\", validate: validateInt64 },\n    // C-type float\n    float: { type: \"number\", validate: validateNumber },\n    // C-type double\n    double: { type: \"number\", validate: validateNumber },\n    // hint to the UI to hide input strings\n    password: true,\n    // unchecked string payload\n    binary: true,\n};\nexports.fastFormats = {\n    ...exports.fullFormats,\n    date: fmtDef(/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/, compareDate),\n    time: fmtDef(/^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i, compareTime),\n    \"date-time\": fmtDef(/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\dt(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i, compareDateTime),\n    \"iso-time\": fmtDef(/^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i, compareIsoTime),\n    \"iso-date-time\": fmtDef(/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i, compareIsoDateTime),\n    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n    uri: /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/)?[^\\s]*$/i,\n    \"uri-reference\": /^(?:(?:[a-z][a-z0-9+\\-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i,\n    // email (sources from jsen validator):\n    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')\n    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n};\nexports.formatNames = Object.keys(exports.fullFormats);\nfunction isLeapYear(year) {\n    // https://tools.ietf.org/html/rfc3339#appendix-C\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\nconst DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nfunction date(str) {\n    // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n    const matches = DATE.exec(str);\n    if (!matches)\n        return false;\n    const year = +matches[1];\n    const month = +matches[2];\n    const day = +matches[3];\n    return (month >= 1 &&\n        month <= 12 &&\n        day >= 1 &&\n        day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]));\n}\nfunction compareDate(d1, d2) {\n    if (!(d1 && d2))\n        return undefined;\n    if (d1 > d2)\n        return 1;\n    if (d1 < d2)\n        return -1;\n    return 0;\n}\nconst TIME = /^(\\d\\d):(\\d\\d):(\\d\\d(?:\\.\\d+)?)(z|([+-])(\\d\\d)(?::?(\\d\\d))?)?$/i;\nfunction getTime(strictTimeZone) {\n    return function time(str) {\n        const matches = TIME.exec(str);\n        if (!matches)\n            return false;\n        const hr = +matches[1];\n        const min = +matches[2];\n        const sec = +matches[3];\n        const tz = matches[4];\n        const tzSign = matches[5] === \"-\" ? -1 : 1;\n        const tzH = +(matches[6] || 0);\n        const tzM = +(matches[7] || 0);\n        if (tzH > 23 || tzM > 59 || (strictTimeZone && !tz))\n            return false;\n        if (hr <= 23 && min <= 59 && sec < 60)\n            return true;\n        // leap second\n        const utcMin = min - tzM * tzSign;\n        const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);\n        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;\n    };\n}\nfunction compareTime(s1, s2) {\n    if (!(s1 && s2))\n        return undefined;\n    const t1 = new Date(\"2020-01-01T\" + s1).valueOf();\n    const t2 = new Date(\"2020-01-01T\" + s2).valueOf();\n    if (!(t1 && t2))\n        return undefined;\n    return t1 - t2;\n}\nfunction compareIsoTime(t1, t2) {\n    if (!(t1 && t2))\n        return undefined;\n    const a1 = TIME.exec(t1);\n    const a2 = TIME.exec(t2);\n    if (!(a1 && a2))\n        return undefined;\n    t1 = a1[1] + a1[2] + a1[3];\n    t2 = a2[1] + a2[2] + a2[3];\n    if (t1 > t2)\n        return 1;\n    if (t1 < t2)\n        return -1;\n    return 0;\n}\nconst DATE_TIME_SEPARATOR = /t|\\s/i;\nfunction getDateTime(strictTimeZone) {\n    const time = getTime(strictTimeZone);\n    return function date_time(str) {\n        // http://tools.ietf.org/html/rfc3339#section-5.6\n        const dateTime = str.split(DATE_TIME_SEPARATOR);\n        return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);\n    };\n}\nfunction compareDateTime(dt1, dt2) {\n    if (!(dt1 && dt2))\n        return undefined;\n    const d1 = new Date(dt1).valueOf();\n    const d2 = new Date(dt2).valueOf();\n    if (!(d1 && d2))\n        return undefined;\n    return d1 - d2;\n}\nfunction compareIsoDateTime(dt1, dt2) {\n    if (!(dt1 && dt2))\n        return undefined;\n    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);\n    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);\n    const res = compareDate(d1, d2);\n    if (res === undefined)\n        return undefined;\n    return res || compareTime(t1, t2);\n}\nconst NOT_URI_FRAGMENT = /\\/|:/;\nconst URI = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\nfunction uri(str) {\n    // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n    return NOT_URI_FRAGMENT.test(str) && URI.test(str);\n}\nconst BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;\nfunction byte(str) {\n    BYTE.lastIndex = 0;\n    return BYTE.test(str);\n}\nconst MIN_INT32 = -(2 ** 31);\nconst MAX_INT32 = 2 ** 31 - 1;\nfunction validateInt32(value) {\n    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;\n}\nfunction validateInt64(value) {\n    // JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64\n    return Number.isInteger(value);\n}\nfunction validateNumber() {\n    return true;\n}\nconst Z_ANCHOR = /[^\\\\]\\\\Z/;\nfunction regex(str) {\n    if (Z_ANCHOR.test(str))\n        return false;\n    try {\n        new RegExp(str);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n//# sourceMappingURL=formats.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst formats_1 = require(\"./formats\");\nconst limit_1 = require(\"./limit\");\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\nconst fullName = new codegen_1.Name(\"fullFormats\");\nconst fastName = new codegen_1.Name(\"fastFormats\");\nconst formatsPlugin = (ajv, opts = { keywords: true }) => {\n    if (Array.isArray(opts)) {\n        addFormats(ajv, opts, formats_1.fullFormats, fullName);\n        return ajv;\n    }\n    const [formats, exportName] = opts.mode === \"fast\" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];\n    const list = opts.formats || formats_1.formatNames;\n    addFormats(ajv, list, formats, exportName);\n    if (opts.keywords)\n        (0, limit_1.default)(ajv);\n    return ajv;\n};\nformatsPlugin.get = (name, mode = \"full\") => {\n    const formats = mode === \"fast\" ? formats_1.fastFormats : formats_1.fullFormats;\n    const f = formats[name];\n    if (!f)\n        throw new Error(`Unknown format \"${name}\"`);\n    return f;\n};\nfunction addFormats(ajv, list, fs, exportName) {\n    var _a;\n    var _b;\n    (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : (_b.formats = (0, codegen_1._) `require(\"ajv-formats/dist/formats\").${exportName}`);\n    for (const f of list)\n        ajv.addFormat(f, fs[f]);\n}\nmodule.exports = exports = formatsPlugin;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = formatsPlugin;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.formatLimitDefinition = void 0;\nconst ajv_1 = require(\"ajv\");\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n    formatMaximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n    formatMinimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n    formatExclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n    formatExclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE },\n};\nconst error = {\n    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `should be ${KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,\n};\nexports.formatLimitDefinition = {\n    keyword: Object.keys(KWDs),\n    type: \"string\",\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, schemaCode, keyword, it } = cxt;\n        const { opts, self } = it;\n        if (!opts.validateFormats)\n            return;\n        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, \"format\");\n        if (fCxt.$data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fmt = gen.const(\"fmt\", (0, codegen_1._) `${fmts}[${fCxt.schemaCode}]`);\n            cxt.fail$data((0, codegen_1.or)((0, codegen_1._) `typeof ${fmt} != \"object\"`, (0, codegen_1._) `${fmt} instanceof RegExp`, (0, codegen_1._) `typeof ${fmt}.compare != \"function\"`, compareCode(fmt)));\n        }\n        function validateFormat() {\n            const format = fCxt.schema;\n            const fmtDef = self.formats[format];\n            if (!fmtDef || fmtDef === true)\n                return;\n            if (typeof fmtDef != \"object\" ||\n                fmtDef instanceof RegExp ||\n                typeof fmtDef.compare != \"function\") {\n                throw new Error(`\"${keyword}\": format \"${format}\" does not define \"compare\" function`);\n            }\n            const fmt = gen.scopeValue(\"formats\", {\n                key: format,\n                ref: fmtDef,\n                code: opts.code.formats ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : undefined,\n            });\n            cxt.fail$data(compareCode(fmt));\n        }\n        function compareCode(fmt) {\n            return (0, codegen_1._) `${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;\n        }\n    },\n    dependencies: [\"format\"],\n};\nconst formatLimitPlugin = (ajv) => {\n    ajv.addKeyword(exports.formatLimitDefinition);\n    return ajv;\n};\nexports.default = formatLimitPlugin;\n//# sourceMappingURL=limit.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;\nconst core_1 = require(\"./core\");\nconst draft7_1 = require(\"./vocabularies/draft7\");\nconst discriminator_1 = require(\"./vocabularies/discriminator\");\nconst draft7MetaSchema = require(\"./refs/json-schema-draft-07.json\");\nconst META_SUPPORT_DATA = [\"/properties\"];\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\";\nclass Ajv extends core_1.default {\n    _addVocabularies() {\n        super._addVocabularies();\n        draft7_1.default.forEach((v) => this.addVocabulary(v));\n        if (this.opts.discriminator)\n            this.addKeyword(discriminator_1.default);\n    }\n    _addDefaultMetaSchema() {\n        super._addDefaultMetaSchema();\n        if (!this.opts.meta)\n            return;\n        const metaSchema = this.opts.$data\n            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n            : draft7MetaSchema;\n        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);\n        this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID;\n    }\n    defaultMeta() {\n        return (this.opts.defaultMeta =\n            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));\n    }\n}\nexports.Ajv = Ajv;\nmodule.exports = exports = Ajv;\nmodule.exports.Ajv = Ajv;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Ajv;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return codegen_1._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return codegen_1.str; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return codegen_1.stringify; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return codegen_1.nil; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return codegen_1.Name; } });\nObject.defineProperty(exports, \"CodeGen\", { enumerable: true, get: function () { return codegen_1.CodeGen; } });\nvar validation_error_1 = require(\"./runtime/validation_error\");\nObject.defineProperty(exports, \"ValidationError\", { enumerable: true, get: function () { return validation_error_1.default; } });\nvar ref_error_1 = require(\"./compile/ref_error\");\nObject.defineProperty(exports, \"MissingRefError\", { enumerable: true, get: function () { return ref_error_1.default; } });\n//# sourceMappingURL=ajv.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass _CodeOrName {\n}\nexports._CodeOrName = _CodeOrName;\nexports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nclass Name extends _CodeOrName {\n    constructor(s) {\n        super();\n        if (!exports.IDENTIFIER.test(s))\n            throw new Error(\"CodeGen: name must be a valid identifier\");\n        this.str = s;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        return false;\n    }\n    get names() {\n        return { [this.str]: 1 };\n    }\n}\nexports.Name = Name;\nclass _Code extends _CodeOrName {\n    constructor(code) {\n        super();\n        this._items = typeof code === \"string\" ? [code] : code;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        if (this._items.length > 1)\n            return false;\n        const item = this._items[0];\n        return item === \"\" || item === '\"\"';\n    }\n    get str() {\n        var _a;\n        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, \"\")));\n    }\n    get names() {\n        var _a;\n        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {\n            if (c instanceof Name)\n                names[c.str] = (names[c.str] || 0) + 1;\n            return names;\n        }, {})));\n    }\n}\nexports._Code = _Code;\nexports.nil = new _Code(\"\");\nfunction _(strs, ...args) {\n    const code = [strs[0]];\n    let i = 0;\n    while (i < args.length) {\n        addCodeArg(code, args[i]);\n        code.push(strs[++i]);\n    }\n    return new _Code(code);\n}\nexports._ = _;\nconst plus = new _Code(\"+\");\nfunction str(strs, ...args) {\n    const expr = [safeStringify(strs[0])];\n    let i = 0;\n    while (i < args.length) {\n        expr.push(plus);\n        addCodeArg(expr, args[i]);\n        expr.push(plus, safeStringify(strs[++i]));\n    }\n    optimize(expr);\n    return new _Code(expr);\n}\nexports.str = str;\nfunction addCodeArg(code, arg) {\n    if (arg instanceof _Code)\n        code.push(...arg._items);\n    else if (arg instanceof Name)\n        code.push(arg);\n    else\n        code.push(interpolate(arg));\n}\nexports.addCodeArg = addCodeArg;\nfunction optimize(expr) {\n    let i = 1;\n    while (i < expr.length - 1) {\n        if (expr[i] === plus) {\n            const res = mergeExprItems(expr[i - 1], expr[i + 1]);\n            if (res !== undefined) {\n                expr.splice(i - 1, 3, res);\n                continue;\n            }\n            expr[i++] = \"+\";\n        }\n        i++;\n    }\n}\nfunction mergeExprItems(a, b) {\n    if (b === '\"\"')\n        return a;\n    if (a === '\"\"')\n        return b;\n    if (typeof a == \"string\") {\n        if (b instanceof Name || a[a.length - 1] !== '\"')\n            return;\n        if (typeof b != \"string\")\n            return `${a.slice(0, -1)}${b}\"`;\n        if (b[0] === '\"')\n            return a.slice(0, -1) + b.slice(1);\n        return;\n    }\n    if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name))\n        return `\"${a}${b.slice(1)}`;\n    return;\n}\nfunction strConcat(c1, c2) {\n    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;\n}\nexports.strConcat = strConcat;\n// TODO do not allow arrays here\nfunction interpolate(x) {\n    return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n        ? x\n        : safeStringify(Array.isArray(x) ? x.join(\",\") : x);\n}\nfunction stringify(x) {\n    return new _Code(safeStringify(x));\n}\nexports.stringify = stringify;\nfunction safeStringify(x) {\n    return JSON.stringify(x)\n        .replace(/\\u2028/g, \"\\\\u2028\")\n        .replace(/\\u2029/g, \"\\\\u2029\");\n}\nexports.safeStringify = safeStringify;\nfunction getProperty(key) {\n    return typeof key == \"string\" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;\n}\nexports.getProperty = getProperty;\n//Does best effort to format the name properly\nfunction getEsmExportName(key) {\n    if (typeof key == \"string\" && exports.IDENTIFIER.test(key)) {\n        return new _Code(`${key}`);\n    }\n    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);\n}\nexports.getEsmExportName = getEsmExportName;\nfunction regexpCode(rx) {\n    return new _Code(rx.toString());\n}\nexports.regexpCode = regexpCode;\n//# sourceMappingURL=code.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;\nconst code_1 = require(\"./code\");\nconst scope_1 = require(\"./scope\");\nvar code_2 = require(\"./code\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return code_2._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return code_2.str; } });\nObject.defineProperty(exports, \"strConcat\", { enumerable: true, get: function () { return code_2.strConcat; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return code_2.nil; } });\nObject.defineProperty(exports, \"getProperty\", { enumerable: true, get: function () { return code_2.getProperty; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return code_2.stringify; } });\nObject.defineProperty(exports, \"regexpCode\", { enumerable: true, get: function () { return code_2.regexpCode; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return code_2.Name; } });\nvar scope_2 = require(\"./scope\");\nObject.defineProperty(exports, \"Scope\", { enumerable: true, get: function () { return scope_2.Scope; } });\nObject.defineProperty(exports, \"ValueScope\", { enumerable: true, get: function () { return scope_2.ValueScope; } });\nObject.defineProperty(exports, \"ValueScopeName\", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });\nObject.defineProperty(exports, \"varKinds\", { enumerable: true, get: function () { return scope_2.varKinds; } });\nexports.operators = {\n    GT: new code_1._Code(\">\"),\n    GTE: new code_1._Code(\">=\"),\n    LT: new code_1._Code(\"<\"),\n    LTE: new code_1._Code(\"<=\"),\n    EQ: new code_1._Code(\"===\"),\n    NEQ: new code_1._Code(\"!==\"),\n    NOT: new code_1._Code(\"!\"),\n    OR: new code_1._Code(\"||\"),\n    AND: new code_1._Code(\"&&\"),\n    ADD: new code_1._Code(\"+\"),\n};\nclass Node {\n    optimizeNodes() {\n        return this;\n    }\n    optimizeNames(_names, _constants) {\n        return this;\n    }\n}\nclass Def extends Node {\n    constructor(varKind, name, rhs) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.rhs = rhs;\n    }\n    render({ es5, _n }) {\n        const varKind = es5 ? scope_1.varKinds.var : this.varKind;\n        const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`;\n        return `${varKind} ${this.name}${rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (!names[this.name.str])\n            return;\n        if (this.rhs)\n            this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};\n    }\n}\nclass Assign extends Node {\n    constructor(lhs, rhs, sideEffects) {\n        super();\n        this.lhs = lhs;\n        this.rhs = rhs;\n        this.sideEffects = sideEffects;\n    }\n    render({ _n }) {\n        return `${this.lhs} = ${this.rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)\n            return;\n        this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };\n        return addExprNames(names, this.rhs);\n    }\n}\nclass AssignOp extends Assign {\n    constructor(lhs, op, rhs, sideEffects) {\n        super(lhs, rhs, sideEffects);\n        this.op = op;\n    }\n    render({ _n }) {\n        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;\n    }\n}\nclass Label extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        return `${this.label}:` + _n;\n    }\n}\nclass Break extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        const label = this.label ? ` ${this.label}` : \"\";\n        return `break${label};` + _n;\n    }\n}\nclass Throw extends Node {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render({ _n }) {\n        return `throw ${this.error};` + _n;\n    }\n    get names() {\n        return this.error.names;\n    }\n}\nclass AnyCode extends Node {\n    constructor(code) {\n        super();\n        this.code = code;\n    }\n    render({ _n }) {\n        return `${this.code};` + _n;\n    }\n    optimizeNodes() {\n        return `${this.code}` ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        this.code = optimizeExpr(this.code, names, constants);\n        return this;\n    }\n    get names() {\n        return this.code instanceof code_1._CodeOrName ? this.code.names : {};\n    }\n}\nclass ParentNode extends Node {\n    constructor(nodes = []) {\n        super();\n        this.nodes = nodes;\n    }\n    render(opts) {\n        return this.nodes.reduce((code, n) => code + n.render(opts), \"\");\n    }\n    optimizeNodes() {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            const n = nodes[i].optimizeNodes();\n            if (Array.isArray(n))\n                nodes.splice(i, 1, ...n);\n            else if (n)\n                nodes[i] = n;\n            else\n                nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            // iterating backwards improves 1-pass optimization\n            const n = nodes[i];\n            if (n.optimizeNames(names, constants))\n                continue;\n            subtractNames(names, n.names);\n            nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    get names() {\n        return this.nodes.reduce((names, n) => addNames(names, n.names), {});\n    }\n}\nclass BlockNode extends ParentNode {\n    render(opts) {\n        return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n;\n    }\n}\nclass Root extends ParentNode {\n}\nclass Else extends BlockNode {\n}\nElse.kind = \"else\";\nclass If extends BlockNode {\n    constructor(condition, nodes) {\n        super(nodes);\n        this.condition = condition;\n    }\n    render(opts) {\n        let code = `if(${this.condition})` + super.render(opts);\n        if (this.else)\n            code += \"else \" + this.else.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        super.optimizeNodes();\n        const cond = this.condition;\n        if (cond === true)\n            return this.nodes; // else is ignored here\n        let e = this.else;\n        if (e) {\n            const ns = e.optimizeNodes();\n            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;\n        }\n        if (e) {\n            if (cond === false)\n                return e instanceof If ? e : e.nodes;\n            if (this.nodes.length)\n                return this;\n            return new If(not(cond), e instanceof If ? [e] : e.nodes);\n        }\n        if (cond === false || !this.nodes.length)\n            return undefined;\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a;\n        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        if (!(super.optimizeNames(names, constants) || this.else))\n            return;\n        this.condition = optimizeExpr(this.condition, names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        addExprNames(names, this.condition);\n        if (this.else)\n            addNames(names, this.else.names);\n        return names;\n    }\n}\nIf.kind = \"if\";\nclass For extends BlockNode {\n}\nFor.kind = \"for\";\nclass ForLoop extends For {\n    constructor(iteration) {\n        super();\n        this.iteration = iteration;\n    }\n    render(opts) {\n        return `for(${this.iteration})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iteration = optimizeExpr(this.iteration, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iteration.names);\n    }\n}\nclass ForRange extends For {\n    constructor(varKind, name, from, to) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.from = from;\n        this.to = to;\n    }\n    render(opts) {\n        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;\n        const { name, from, to } = this;\n        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);\n    }\n    get names() {\n        const names = addExprNames(super.names, this.from);\n        return addExprNames(names, this.to);\n    }\n}\nclass ForIter extends For {\n    constructor(loop, varKind, name, iterable) {\n        super();\n        this.loop = loop;\n        this.varKind = varKind;\n        this.name = name;\n        this.iterable = iterable;\n    }\n    render(opts) {\n        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iterable = optimizeExpr(this.iterable, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iterable.names);\n    }\n}\nclass Func extends BlockNode {\n    constructor(name, args, async) {\n        super();\n        this.name = name;\n        this.args = args;\n        this.async = async;\n    }\n    render(opts) {\n        const _async = this.async ? \"async \" : \"\";\n        return `${_async}function ${this.name}(${this.args})` + super.render(opts);\n    }\n}\nFunc.kind = \"func\";\nclass Return extends ParentNode {\n    render(opts) {\n        return \"return \" + super.render(opts);\n    }\n}\nReturn.kind = \"return\";\nclass Try extends BlockNode {\n    render(opts) {\n        let code = \"try\" + super.render(opts);\n        if (this.catch)\n            code += this.catch.render(opts);\n        if (this.finally)\n            code += this.finally.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        var _a, _b;\n        super.optimizeNodes();\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a, _b;\n        super.optimizeNames(names, constants);\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        if (this.catch)\n            addNames(names, this.catch.names);\n        if (this.finally)\n            addNames(names, this.finally.names);\n        return names;\n    }\n}\nclass Catch extends BlockNode {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render(opts) {\n        return `catch(${this.error})` + super.render(opts);\n    }\n}\nCatch.kind = \"catch\";\nclass Finally extends BlockNode {\n    render(opts) {\n        return \"finally\" + super.render(opts);\n    }\n}\nFinally.kind = \"finally\";\nclass CodeGen {\n    constructor(extScope, opts = {}) {\n        this._values = {};\n        this._blockStarts = [];\n        this._constants = {};\n        this.opts = { ...opts, _n: opts.lines ? \"\\n\" : \"\" };\n        this._extScope = extScope;\n        this._scope = new scope_1.Scope({ parent: extScope });\n        this._nodes = [new Root()];\n    }\n    toString() {\n        return this._root.render(this.opts);\n    }\n    // returns unique name in the internal scope\n    name(prefix) {\n        return this._scope.name(prefix);\n    }\n    // reserves unique name in the external scope\n    scopeName(prefix) {\n        return this._extScope.name(prefix);\n    }\n    // reserves unique name in the external scope and assigns value to it\n    scopeValue(prefixOrName, value) {\n        const name = this._extScope.value(prefixOrName, value);\n        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());\n        vs.add(name);\n        return name;\n    }\n    getScopeValue(prefix, keyOrRef) {\n        return this._extScope.getValue(prefix, keyOrRef);\n    }\n    // return code that assigns values in the external scope to the names that are used internally\n    // (same names that were returned by gen.scopeName or gen.scopeValue)\n    scopeRefs(scopeName) {\n        return this._extScope.scopeRefs(scopeName, this._values);\n    }\n    scopeCode() {\n        return this._extScope.scopeCode(this._values);\n    }\n    _def(varKind, nameOrPrefix, rhs, constant) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (rhs !== undefined && constant)\n            this._constants[name.str] = rhs;\n        this._leafNode(new Def(varKind, name, rhs));\n        return name;\n    }\n    // `const` declaration (`var` in es5 mode)\n    const(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);\n    }\n    // `let` declaration with optional assignment (`var` in es5 mode)\n    let(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);\n    }\n    // `var` declaration with optional assignment\n    var(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);\n    }\n    // assignment code\n    assign(lhs, rhs, sideEffects) {\n        return this._leafNode(new Assign(lhs, rhs, sideEffects));\n    }\n    // `+=` code\n    add(lhs, rhs) {\n        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));\n    }\n    // appends passed SafeExpr to code or executes Block\n    code(c) {\n        if (typeof c == \"function\")\n            c();\n        else if (c !== code_1.nil)\n            this._leafNode(new AnyCode(c));\n        return this;\n    }\n    // returns code for object literal for the passed argument list of key-value pairs\n    object(...keyValues) {\n        const code = [\"{\"];\n        for (const [key, value] of keyValues) {\n            if (code.length > 1)\n                code.push(\",\");\n            code.push(key);\n            if (key !== value || this.opts.es5) {\n                code.push(\":\");\n                (0, code_1.addCodeArg)(code, value);\n            }\n        }\n        code.push(\"}\");\n        return new code_1._Code(code);\n    }\n    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n    if(condition, thenBody, elseBody) {\n        this._blockNode(new If(condition));\n        if (thenBody && elseBody) {\n            this.code(thenBody).else().code(elseBody).endIf();\n        }\n        else if (thenBody) {\n            this.code(thenBody).endIf();\n        }\n        else if (elseBody) {\n            throw new Error('CodeGen: \"else\" body without \"then\" body');\n        }\n        return this;\n    }\n    // `else if` clause - invalid without `if` or after `else` clauses\n    elseIf(condition) {\n        return this._elseNode(new If(condition));\n    }\n    // `else` clause - only valid after `if` or `else if` clauses\n    else() {\n        return this._elseNode(new Else());\n    }\n    // end `if` statement (needed if gen.if was used only with condition)\n    endIf() {\n        return this._endBlockNode(If, Else);\n    }\n    _for(node, forBody) {\n        this._blockNode(node);\n        if (forBody)\n            this.code(forBody).endFor();\n        return this;\n    }\n    // a generic `for` clause (or statement if `forBody` is passed)\n    for(iteration, forBody) {\n        return this._for(new ForLoop(iteration), forBody);\n    }\n    // `for` statement for a range of values\n    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));\n    }\n    // `for-of` statement (in es5 mode replace with a normal for loop)\n    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (this.opts.es5) {\n            const arr = iterable instanceof code_1.Name ? iterable : this.var(\"_arr\", iterable);\n            return this.forRange(\"_i\", 0, (0, code_1._) `${arr}.length`, (i) => {\n                this.var(name, (0, code_1._) `${arr}[${i}]`);\n                forBody(name);\n            });\n        }\n        return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name));\n    }\n    // `for-in` statement.\n    // With option `ownProperties` replaced with a `for-of` loop for object keys\n    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {\n        if (this.opts.ownProperties) {\n            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);\n        }\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name));\n    }\n    // end `for` loop\n    endFor() {\n        return this._endBlockNode(For);\n    }\n    // `label` statement\n    label(label) {\n        return this._leafNode(new Label(label));\n    }\n    // `break` statement\n    break(label) {\n        return this._leafNode(new Break(label));\n    }\n    // `return` statement\n    return(value) {\n        const node = new Return();\n        this._blockNode(node);\n        this.code(value);\n        if (node.nodes.length !== 1)\n            throw new Error('CodeGen: \"return\" should have one node');\n        return this._endBlockNode(Return);\n    }\n    // `try` statement\n    try(tryBody, catchCode, finallyCode) {\n        if (!catchCode && !finallyCode)\n            throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n        const node = new Try();\n        this._blockNode(node);\n        this.code(tryBody);\n        if (catchCode) {\n            const error = this.name(\"e\");\n            this._currNode = node.catch = new Catch(error);\n            catchCode(error);\n        }\n        if (finallyCode) {\n            this._currNode = node.finally = new Finally();\n            this.code(finallyCode);\n        }\n        return this._endBlockNode(Catch, Finally);\n    }\n    // `throw` statement\n    throw(error) {\n        return this._leafNode(new Throw(error));\n    }\n    // start self-balancing block\n    block(body, nodeCount) {\n        this._blockStarts.push(this._nodes.length);\n        if (body)\n            this.code(body).endBlock(nodeCount);\n        return this;\n    }\n    // end the current self-balancing block\n    endBlock(nodeCount) {\n        const len = this._blockStarts.pop();\n        if (len === undefined)\n            throw new Error(\"CodeGen: not in self-balancing block\");\n        const toClose = this._nodes.length - len;\n        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);\n        }\n        this._nodes.length = len;\n        return this;\n    }\n    // `function` heading (or definition if funcBody is passed)\n    func(name, args = code_1.nil, async, funcBody) {\n        this._blockNode(new Func(name, args, async));\n        if (funcBody)\n            this.code(funcBody).endFunc();\n        return this;\n    }\n    // end function definition\n    endFunc() {\n        return this._endBlockNode(Func);\n    }\n    optimize(n = 1) {\n        while (n-- > 0) {\n            this._root.optimizeNodes();\n            this._root.optimizeNames(this._root.names, this._constants);\n        }\n    }\n    _leafNode(node) {\n        this._currNode.nodes.push(node);\n        return this;\n    }\n    _blockNode(node) {\n        this._currNode.nodes.push(node);\n        this._nodes.push(node);\n    }\n    _endBlockNode(N1, N2) {\n        const n = this._currNode;\n        if (n instanceof N1 || (N2 && n instanceof N2)) {\n            this._nodes.pop();\n            return this;\n        }\n        throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`);\n    }\n    _elseNode(node) {\n        const n = this._currNode;\n        if (!(n instanceof If)) {\n            throw new Error('CodeGen: \"else\" without \"if\"');\n        }\n        this._currNode = n.else = node;\n        return this;\n    }\n    get _root() {\n        return this._nodes[0];\n    }\n    get _currNode() {\n        const ns = this._nodes;\n        return ns[ns.length - 1];\n    }\n    set _currNode(node) {\n        const ns = this._nodes;\n        ns[ns.length - 1] = node;\n    }\n}\nexports.CodeGen = CodeGen;\nfunction addNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) + (from[n] || 0);\n    return names;\n}\nfunction addExprNames(names, from) {\n    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;\n}\nfunction optimizeExpr(expr, names, constants) {\n    if (expr instanceof code_1.Name)\n        return replaceName(expr);\n    if (!canOptimize(expr))\n        return expr;\n    return new code_1._Code(expr._items.reduce((items, c) => {\n        if (c instanceof code_1.Name)\n            c = replaceName(c);\n        if (c instanceof code_1._Code)\n            items.push(...c._items);\n        else\n            items.push(c);\n        return items;\n    }, []));\n    function replaceName(n) {\n        const c = constants[n.str];\n        if (c === undefined || names[n.str] !== 1)\n            return n;\n        delete names[n.str];\n        return c;\n    }\n    function canOptimize(e) {\n        return (e instanceof code_1._Code &&\n            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));\n    }\n}\nfunction subtractNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) - (from[n] || 0);\n}\nfunction not(x) {\n    return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : (0, code_1._) `!${par(x)}`;\n}\nexports.not = not;\nconst andCode = mappend(exports.operators.AND);\n// boolean AND (&&) expression with the passed arguments\nfunction and(...args) {\n    return args.reduce(andCode);\n}\nexports.and = and;\nconst orCode = mappend(exports.operators.OR);\n// boolean OR (||) expression with the passed arguments\nfunction or(...args) {\n    return args.reduce(orCode);\n}\nexports.or = or;\nfunction mappend(op) {\n    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);\n}\nfunction par(x) {\n    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\nconst code_1 = require(\"./code\");\nclass ValueError extends Error {\n    constructor(name) {\n        super(`CodeGen: \"code\" for ${name} not defined`);\n        this.value = name.value;\n    }\n}\nvar UsedValueState;\n(function (UsedValueState) {\n    UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n    UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));\nexports.varKinds = {\n    const: new code_1.Name(\"const\"),\n    let: new code_1.Name(\"let\"),\n    var: new code_1.Name(\"var\"),\n};\nclass Scope {\n    constructor({ prefixes, parent } = {}) {\n        this._names = {};\n        this._prefixes = prefixes;\n        this._parent = parent;\n    }\n    toName(nameOrPrefix) {\n        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n    }\n    name(prefix) {\n        return new code_1.Name(this._newName(prefix));\n    }\n    _newName(prefix) {\n        const ng = this._names[prefix] || this._nameGroup(prefix);\n        return `${prefix}${ng.index++}`;\n    }\n    _nameGroup(prefix) {\n        var _a, _b;\n        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {\n            throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n        }\n        return (this._names[prefix] = { prefix, index: 0 });\n    }\n}\nexports.Scope = Scope;\nclass ValueScopeName extends code_1.Name {\n    constructor(prefix, nameStr) {\n        super(nameStr);\n        this.prefix = prefix;\n    }\n    setValue(value, { property, itemIndex }) {\n        this.value = value;\n        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;\n    }\n}\nexports.ValueScopeName = ValueScopeName;\nconst line = (0, code_1._) `\\n`;\nclass ValueScope extends Scope {\n    constructor(opts) {\n        super(opts);\n        this._values = {};\n        this._scope = opts.scope;\n        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };\n    }\n    get() {\n        return this._scope;\n    }\n    name(prefix) {\n        return new ValueScopeName(prefix, this._newName(prefix));\n    }\n    value(nameOrPrefix, value) {\n        var _a;\n        if (value.ref === undefined)\n            throw new Error(\"CodeGen: ref must be passed in value\");\n        const name = this.toName(nameOrPrefix);\n        const { prefix } = name;\n        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n        let vs = this._values[prefix];\n        if (vs) {\n            const _name = vs.get(valueKey);\n            if (_name)\n                return _name;\n        }\n        else {\n            vs = this._values[prefix] = new Map();\n        }\n        vs.set(valueKey, name);\n        const s = this._scope[prefix] || (this._scope[prefix] = []);\n        const itemIndex = s.length;\n        s[itemIndex] = value.ref;\n        name.setValue(value, { property: prefix, itemIndex });\n        return name;\n    }\n    getValue(prefix, keyOrRef) {\n        const vs = this._values[prefix];\n        if (!vs)\n            return;\n        return vs.get(keyOrRef);\n    }\n    scopeRefs(scopeName, values = this._values) {\n        return this._reduceValues(values, (name) => {\n            if (name.scopePath === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return (0, code_1._) `${scopeName}${name.scopePath}`;\n        });\n    }\n    scopeCode(values = this._values, usedValues, getCode) {\n        return this._reduceValues(values, (name) => {\n            if (name.value === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return name.value.code;\n        }, usedValues, getCode);\n    }\n    _reduceValues(values, valueCode, usedValues = {}, getCode) {\n        let code = code_1.nil;\n        for (const prefix in values) {\n            const vs = values[prefix];\n            if (!vs)\n                continue;\n            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());\n            vs.forEach((name) => {\n                if (nameSet.has(name))\n                    return;\n                nameSet.set(name, UsedValueState.Started);\n                let c = valueCode(name);\n                if (c) {\n                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;\n                }\n                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {\n                    code = (0, code_1._) `${code}${c}${this.opts._n}`;\n                }\n                else {\n                    throw new ValueError(name);\n                }\n                nameSet.set(name, UsedValueState.Completed);\n            });\n        }\n        return code;\n    }\n}\nexports.ValueScope = ValueScope;\n//# sourceMappingURL=scope.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst util_1 = require(\"./util\");\nconst names_1 = require(\"./names\");\nexports.keywordError = {\n    message: ({ keyword }) => (0, codegen_1.str) `must pass \"${keyword}\" keyword validation`,\n};\nexports.keyword$DataError = {\n    message: ({ keyword, schemaType }) => schemaType\n        ? (0, codegen_1.str) `\"${keyword}\" keyword must be ${schemaType} ($data)`\n        : (0, codegen_1.str) `\"${keyword}\" keyword is invalid ($data)`,\n};\nfunction reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {\n        addError(gen, errObj);\n    }\n    else {\n        returnErrors(it, (0, codegen_1._) `[${errObj}]`);\n    }\n}\nexports.reportError = reportError;\nfunction reportExtraError(cxt, error = exports.keywordError, errorPaths) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    addError(gen, errObj);\n    if (!(compositeRule || allErrors)) {\n        returnErrors(it, names_1.default.vErrors);\n    }\n}\nexports.reportExtraError = reportExtraError;\nfunction resetErrorsCount(gen, errsCount) {\n    gen.assign(names_1.default.errors, errsCount);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));\n}\nexports.resetErrorsCount = resetErrorsCount;\nfunction extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {\n    /* istanbul ignore if */\n    if (errsCount === undefined)\n        throw new Error(\"ajv implementation error\");\n    const err = gen.name(\"err\");\n    gen.forRange(\"i\", errsCount, names_1.default.errors, (i) => {\n        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);\n        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));\n        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);\n        if (it.opts.verbose) {\n            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);\n            gen.assign((0, codegen_1._) `${err}.data`, data);\n        }\n    });\n}\nexports.extendErrors = extendErrors;\nfunction addError(gen, errObj) {\n    const err = gen.const(\"err\", errObj);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);\n    gen.code((0, codegen_1._) `${names_1.default.errors}++`);\n}\nfunction returnErrors(it, errs) {\n    const { gen, validateName, schemaEnv } = it;\n    if (schemaEnv.$async) {\n        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);\n        gen.return(false);\n    }\n}\nconst E = {\n    keyword: new codegen_1.Name(\"keyword\"),\n    schemaPath: new codegen_1.Name(\"schemaPath\"), // also used in JTD errors\n    params: new codegen_1.Name(\"params\"),\n    propertyName: new codegen_1.Name(\"propertyName\"),\n    message: new codegen_1.Name(\"message\"),\n    schema: new codegen_1.Name(\"schema\"),\n    parentSchema: new codegen_1.Name(\"parentSchema\"),\n};\nfunction errorObjectCode(cxt, error, errorPaths) {\n    const { createErrors } = cxt.it;\n    if (createErrors === false)\n        return (0, codegen_1._) `{}`;\n    return errorObject(cxt, error, errorPaths);\n}\nfunction errorObject(cxt, error, errorPaths = {}) {\n    const { gen, it } = cxt;\n    const keyValues = [\n        errorInstancePath(it, errorPaths),\n        errorSchemaPath(cxt, errorPaths),\n    ];\n    extraErrorProps(cxt, error, keyValues);\n    return gen.object(...keyValues);\n}\nfunction errorInstancePath({ errorPath }, { instancePath }) {\n    const instPath = instancePath\n        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`\n        : errorPath;\n    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];\n}\nfunction errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {\n    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;\n    if (schemaPath) {\n        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;\n    }\n    return [E.schemaPath, schPath];\n}\nfunction extraErrorProps(cxt, { params, message }, keyValues) {\n    const { keyword, data, schemaValue, it } = cxt;\n    const { opts, propertyName, topSchemaRef, schemaPath } = it;\n    keyValues.push([E.keyword, keyword], [E.params, typeof params == \"function\" ? params(cxt) : params || (0, codegen_1._) `{}`]);\n    if (opts.messages) {\n        keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message]);\n    }\n    if (opts.verbose) {\n        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);\n    }\n    if (propertyName)\n        keyValues.push([E.propertyName, propertyName]);\n}\n//# sourceMappingURL=errors.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst validation_error_1 = require(\"../runtime/validation_error\");\nconst names_1 = require(\"./names\");\nconst resolve_1 = require(\"./resolve\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nclass SchemaEnv {\n    constructor(env) {\n        var _a;\n        this.refs = {};\n        this.dynamicAnchors = {};\n        let schema;\n        if (typeof env.schema == \"object\")\n            schema = env.schema;\n        this.schema = env.schema;\n        this.schemaId = env.schemaId;\n        this.root = env.root || this;\n        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n        this.schemaPath = env.schemaPath;\n        this.localRefs = env.localRefs;\n        this.meta = env.meta;\n        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n        this.refs = {};\n    }\n}\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n    // TODO refactor - remove compilations\n    const _sch = getCompilingSchema.call(this, sch);\n    if (_sch)\n        return _sch;\n    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n    const { es5, lines } = this.opts.code;\n    const { ownProperties } = this.opts;\n    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });\n    let _ValidationError;\n    if (sch.$async) {\n        _ValidationError = gen.scopeValue(\"Error\", {\n            ref: validation_error_1.default,\n            code: (0, codegen_1._) `require(\"ajv/dist/runtime/validation_error\").default`,\n        });\n    }\n    const validateName = gen.scopeName(\"validate\");\n    sch.validateName = validateName;\n    const schemaCxt = {\n        gen,\n        allErrors: this.opts.allErrors,\n        data: names_1.default.data,\n        parentData: names_1.default.parentData,\n        parentDataProperty: names_1.default.parentDataProperty,\n        dataNames: [names_1.default.data],\n        dataPathArr: [codegen_1.nil], // TODO can its length be used as dataLevel if nil is removed?\n        dataLevel: 0,\n        dataTypes: [],\n        definedProperties: new Set(),\n        topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true\n            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }\n            : { ref: sch.schema }),\n        validateName,\n        ValidationError: _ValidationError,\n        schema: sch.schema,\n        schemaEnv: sch,\n        rootId,\n        baseId: sch.baseId || rootId,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n        errorPath: (0, codegen_1._) `\"\"`,\n        opts: this.opts,\n        self: this,\n    };\n    let sourceCode;\n    try {\n        this._compilations.add(sch);\n        (0, validate_1.validateFunctionCode)(schemaCxt);\n        gen.optimize(this.opts.code.optimize);\n        // gen.optimize(1)\n        const validateCode = gen.toString();\n        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n        if (this.opts.code.process)\n            sourceCode = this.opts.code.process(sourceCode, sch);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n        const validate = makeValidate(this, this.scope.get());\n        this.scope.value(validateName, { ref: validate });\n        validate.errors = null;\n        validate.schema = sch.schema;\n        validate.schemaEnv = sch;\n        if (sch.$async)\n            validate.$async = true;\n        if (this.opts.code.source === true) {\n            validate.source = { validateName, validateCode, scopeValues: gen._values };\n        }\n        if (this.opts.unevaluated) {\n            const { props, items } = schemaCxt;\n            validate.evaluated = {\n                props: props instanceof codegen_1.Name ? undefined : props,\n                items: items instanceof codegen_1.Name ? undefined : items,\n                dynamicProps: props instanceof codegen_1.Name,\n                dynamicItems: items instanceof codegen_1.Name,\n            };\n            if (validate.source)\n                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n        }\n        sch.validate = validate;\n        return sch;\n    }\n    catch (e) {\n        delete sch.validate;\n        delete sch.validateName;\n        if (sourceCode)\n            this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n        throw e;\n    }\n    finally {\n        this._compilations.delete(sch);\n    }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n    var _a;\n    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n    const schOrFunc = root.refs[ref];\n    if (schOrFunc)\n        return schOrFunc;\n    let _sch = resolve.call(this, root, ref);\n    if (_sch === undefined) {\n        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n        const { schemaId } = this.opts;\n        if (schema)\n            _sch = new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    if (_sch === undefined)\n        return;\n    return (root.refs[ref] = inlineOrCompile.call(this, _sch));\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))\n        return sch.schema;\n    return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n    for (const sch of this._compilations) {\n        if (sameSchemaEnv(sch, schEnv))\n            return sch;\n    }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n    let sch;\n    while (typeof (sch = this.refs[ref]) == \"string\")\n        ref = sch;\n    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n    const p = this.opts.uriResolver.parse(ref);\n    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);\n    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n    if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n        return getJsonPointer.call(this, p, root);\n    }\n    const id = (0, resolve_1.normalizeId)(refPath);\n    const schOrRef = this.refs[id] || this.schemas[id];\n    if (typeof schOrRef == \"string\") {\n        const sch = resolveSchema.call(this, root, schOrRef);\n        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\")\n            return;\n        return getJsonPointer.call(this, p, sch);\n    }\n    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\")\n        return;\n    if (!schOrRef.validate)\n        compileSchema.call(this, schOrRef);\n    if (id === (0, resolve_1.normalizeId)(ref)) {\n        const { schema } = schOrRef;\n        const { schemaId } = this.opts;\n        const schId = schema[schemaId];\n        if (schId)\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        return new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\n    \"properties\",\n    \"patternProperties\",\n    \"enum\",\n    \"dependencies\",\n    \"definitions\",\n]);\nfunction getJsonPointer(parsedRef, { baseId, schema, root }) {\n    var _a;\n    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\")\n        return;\n    for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n        if (typeof schema === \"boolean\")\n            return;\n        const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n        if (partSchema === undefined)\n            return;\n        schema = partSchema;\n        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n        const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        }\n    }\n    let env;\n    if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n        env = resolveSchema.call(this, root, $ref);\n    }\n    // even though resolution failed we need to return SchemaEnv to throw exception\n    // so that compileAsync loads missing schema.\n    const { schemaId } = this.opts;\n    env = env || new SchemaEnv({ schema, schemaId, root, baseId });\n    if (env.schema !== env.root.schema)\n        return env;\n    return undefined;\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"./codegen\");\nconst names = {\n    // validation function arguments\n    data: new codegen_1.Name(\"data\"), // data passed to validation function\n    // args passed from referencing schema\n    valCxt: new codegen_1.Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n    instancePath: new codegen_1.Name(\"instancePath\"),\n    parentData: new codegen_1.Name(\"parentData\"),\n    parentDataProperty: new codegen_1.Name(\"parentDataProperty\"),\n    rootData: new codegen_1.Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n    dynamicAnchors: new codegen_1.Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n    // function scoped variables\n    vErrors: new codegen_1.Name(\"vErrors\"), // null or array of validation errors\n    errors: new codegen_1.Name(\"errors\"), // counter of validation errors\n    this: new codegen_1.Name(\"this\"),\n    // \"globals\"\n    self: new codegen_1.Name(\"self\"),\n    scope: new codegen_1.Name(\"scope\"),\n    // JTD serialize/parse name for JSON string and position\n    json: new codegen_1.Name(\"json\"),\n    jsonPos: new codegen_1.Name(\"jsonPos\"),\n    jsonLen: new codegen_1.Name(\"jsonLen\"),\n    jsonPart: new codegen_1.Name(\"jsonPart\"),\n};\nexports.default = names;\n//# sourceMappingURL=names.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst resolve_1 = require(\"./resolve\");\nclass MissingRefError extends Error {\n    constructor(resolver, baseId, ref, msg) {\n        super(msg || `can't resolve reference ${ref} from id ${baseId}`);\n        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);\n        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));\n    }\n}\nexports.default = MissingRefError;\n//# sourceMappingURL=ref_error.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\nconst util_1 = require(\"./util\");\nconst equal = require(\"fast-deep-equal\");\nconst traverse = require(\"json-schema-traverse\");\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n    \"type\",\n    \"format\",\n    \"pattern\",\n    \"maxLength\",\n    \"minLength\",\n    \"maxProperties\",\n    \"minProperties\",\n    \"maxItems\",\n    \"minItems\",\n    \"maximum\",\n    \"minimum\",\n    \"uniqueItems\",\n    \"multipleOf\",\n    \"required\",\n    \"enum\",\n    \"const\",\n]);\nfunction inlineRef(schema, limit = true) {\n    if (typeof schema == \"boolean\")\n        return true;\n    if (limit === true)\n        return !hasRef(schema);\n    if (!limit)\n        return false;\n    return countKeys(schema) <= limit;\n}\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\n    \"$ref\",\n    \"$recursiveRef\",\n    \"$recursiveAnchor\",\n    \"$dynamicRef\",\n    \"$dynamicAnchor\",\n]);\nfunction hasRef(schema) {\n    for (const key in schema) {\n        if (REF_KEYWORDS.has(key))\n            return true;\n        const sch = schema[key];\n        if (Array.isArray(sch) && sch.some(hasRef))\n            return true;\n        if (typeof sch == \"object\" && hasRef(sch))\n            return true;\n    }\n    return false;\n}\nfunction countKeys(schema) {\n    let count = 0;\n    for (const key in schema) {\n        if (key === \"$ref\")\n            return Infinity;\n        count++;\n        if (SIMPLE_INLINED.has(key))\n            continue;\n        if (typeof schema[key] == \"object\") {\n            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));\n        }\n        if (count === Infinity)\n            return Infinity;\n    }\n    return count;\n}\nfunction getFullPath(resolver, id = \"\", normalize) {\n    if (normalize !== false)\n        id = normalizeId(id);\n    const p = resolver.parse(id);\n    return _getFullPath(resolver, p);\n}\nexports.getFullPath = getFullPath;\nfunction _getFullPath(resolver, p) {\n    const serialized = resolver.serialize(p);\n    return serialized.split(\"#\")[0] + \"#\";\n}\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n    return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\nexports.normalizeId = normalizeId;\nfunction resolveUrl(resolver, baseId, id) {\n    id = normalizeId(id);\n    return resolver.resolve(baseId, id);\n}\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\nfunction getSchemaRefs(schema, baseId) {\n    if (typeof schema == \"boolean\")\n        return {};\n    const { schemaId, uriResolver } = this.opts;\n    const schId = normalizeId(schema[schemaId] || baseId);\n    const baseIds = { \"\": schId };\n    const pathPrefix = getFullPath(uriResolver, schId, false);\n    const localRefs = {};\n    const schemaRefs = new Set();\n    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {\n        if (parentJsonPtr === undefined)\n            return;\n        const fullPath = pathPrefix + jsonPtr;\n        let innerBaseId = baseIds[parentJsonPtr];\n        if (typeof sch[schemaId] == \"string\")\n            innerBaseId = addRef.call(this, sch[schemaId]);\n        addAnchor.call(this, sch.$anchor);\n        addAnchor.call(this, sch.$dynamicAnchor);\n        baseIds[jsonPtr] = innerBaseId;\n        function addRef(ref) {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            const _resolve = this.opts.uriResolver.resolve;\n            ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);\n            if (schemaRefs.has(ref))\n                throw ambiguos(ref);\n            schemaRefs.add(ref);\n            let schOrRef = this.refs[ref];\n            if (typeof schOrRef == \"string\")\n                schOrRef = this.refs[schOrRef];\n            if (typeof schOrRef == \"object\") {\n                checkAmbiguosRef(sch, schOrRef.schema, ref);\n            }\n            else if (ref !== normalizeId(fullPath)) {\n                if (ref[0] === \"#\") {\n                    checkAmbiguosRef(sch, localRefs[ref], ref);\n                    localRefs[ref] = sch;\n                }\n                else {\n                    this.refs[ref] = fullPath;\n                }\n            }\n            return ref;\n        }\n        function addAnchor(anchor) {\n            if (typeof anchor == \"string\") {\n                if (!ANCHOR.test(anchor))\n                    throw new Error(`invalid anchor \"${anchor}\"`);\n                addRef.call(this, `#${anchor}`);\n            }\n        }\n    });\n    return localRefs;\n    function checkAmbiguosRef(sch1, sch2, ref) {\n        if (sch2 !== undefined && !equal(sch1, sch2))\n            throw ambiguos(ref);\n    }\n    function ambiguos(ref) {\n        return new Error(`reference \"${ref}\" resolves to more than one schema`);\n    }\n}\nexports.getSchemaRefs = getSchemaRefs;\n//# sourceMappingURL=resolve.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getRules = exports.isJSONType = void 0;\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"];\nconst jsonTypes = new Set(_jsonTypes);\nfunction isJSONType(x) {\n    return typeof x == \"string\" && jsonTypes.has(x);\n}\nexports.isJSONType = isJSONType;\nfunction getRules() {\n    const groups = {\n        number: { type: \"number\", rules: [] },\n        string: { type: \"string\", rules: [] },\n        array: { type: \"array\", rules: [] },\n        object: { type: \"object\", rules: [] },\n    };\n    return {\n        types: { ...groups, integer: true, boolean: true, null: true },\n        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],\n        post: { rules: [] },\n        all: {},\n        keywords: {},\n    };\n}\nexports.getRules = getRules;\n//# sourceMappingURL=rules.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst code_1 = require(\"./codegen/code\");\n// TODO refactor to use Set\nfunction toHash(arr) {\n    const hash = {};\n    for (const item of arr)\n        hash[item] = true;\n    return hash;\n}\nexports.toHash = toHash;\nfunction alwaysValidSchema(it, schema) {\n    if (typeof schema == \"boolean\")\n        return schema;\n    if (Object.keys(schema).length === 0)\n        return true;\n    checkUnknownRules(it, schema);\n    return !schemaHasRules(schema, it.self.RULES.all);\n}\nexports.alwaysValidSchema = alwaysValidSchema;\nfunction checkUnknownRules(it, schema = it.schema) {\n    const { opts, self } = it;\n    if (!opts.strictSchema)\n        return;\n    if (typeof schema === \"boolean\")\n        return;\n    const rules = self.RULES.keywords;\n    for (const key in schema) {\n        if (!rules[key])\n            checkStrictMode(it, `unknown keyword: \"${key}\"`);\n    }\n}\nexports.checkUnknownRules = checkUnknownRules;\nfunction schemaHasRules(schema, rules) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (rules[key])\n            return true;\n    return false;\n}\nexports.schemaHasRules = schemaHasRules;\nfunction schemaHasRulesButRef(schema, RULES) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (key !== \"$ref\" && RULES.all[key])\n            return true;\n    return false;\n}\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\nfunction schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {\n    if (!$data) {\n        if (typeof schema == \"number\" || typeof schema == \"boolean\")\n            return schema;\n        if (typeof schema == \"string\")\n            return (0, codegen_1._) `${schema}`;\n    }\n    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;\n}\nexports.schemaRefOrVal = schemaRefOrVal;\nfunction unescapeFragment(str) {\n    return unescapeJsonPointer(decodeURIComponent(str));\n}\nexports.unescapeFragment = unescapeFragment;\nfunction escapeFragment(str) {\n    return encodeURIComponent(escapeJsonPointer(str));\n}\nexports.escapeFragment = escapeFragment;\nfunction escapeJsonPointer(str) {\n    if (typeof str == \"number\")\n        return `${str}`;\n    return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nexports.escapeJsonPointer = escapeJsonPointer;\nfunction unescapeJsonPointer(str) {\n    return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nexports.unescapeJsonPointer = unescapeJsonPointer;\nfunction eachItem(xs, f) {\n    if (Array.isArray(xs)) {\n        for (const x of xs)\n            f(x);\n    }\n    else {\n        f(xs);\n    }\n}\nexports.eachItem = eachItem;\nfunction makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {\n    return (gen, from, to, toName) => {\n        const res = to === undefined\n            ? from\n            : to instanceof codegen_1.Name\n                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n                : from instanceof codegen_1.Name\n                    ? (mergeToName(gen, to, from), from)\n                    : mergeValues(from, to);\n        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n    };\n}\nexports.mergeEvaluated = {\n    props: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {\n            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));\n        }),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {\n            if (from === true) {\n                gen.assign(to, true);\n            }\n            else {\n                gen.assign(to, (0, codegen_1._) `${to} || {}`);\n                setEvaluated(gen, to, from);\n            }\n        }),\n        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),\n        resultToName: evaluatedPropsToName,\n    }),\n    items: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),\n        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n        resultToName: (gen, items) => gen.var(\"items\", items),\n    }),\n};\nfunction evaluatedPropsToName(gen, ps) {\n    if (ps === true)\n        return gen.var(\"props\", true);\n    const props = gen.var(\"props\", (0, codegen_1._) `{}`);\n    if (ps !== undefined)\n        setEvaluated(gen, props, ps);\n    return props;\n}\nexports.evaluatedPropsToName = evaluatedPropsToName;\nfunction setEvaluated(gen, props, ps) {\n    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));\n}\nexports.setEvaluated = setEvaluated;\nconst snippets = {};\nfunction useFunc(gen, f) {\n    return gen.scopeValue(\"func\", {\n        ref: f,\n        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),\n    });\n}\nexports.useFunc = useFunc;\nvar Type;\n(function (Type) {\n    Type[Type[\"Num\"] = 0] = \"Num\";\n    Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type || (exports.Type = Type = {}));\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n    // let path\n    if (dataProp instanceof codegen_1.Name) {\n        const isNumber = dataPropType === Type.Num;\n        return jsPropertySyntax\n            ? isNumber\n                ? (0, codegen_1._) `\"[\" + ${dataProp} + \"]\"`\n                : (0, codegen_1._) `\"['\" + ${dataProp} + \"']\"`\n            : isNumber\n                ? (0, codegen_1._) `\"/\" + ${dataProp}`\n                : (0, codegen_1._) `\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`; // TODO maybe use global escapePointer\n    }\n    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n}\nexports.getErrorPath = getErrorPath;\nfunction checkStrictMode(it, msg, mode = it.opts.strictSchema) {\n    if (!mode)\n        return;\n    msg = `strict mode: ${msg}`;\n    if (mode === true)\n        throw new Error(msg);\n    it.self.logger.warn(msg);\n}\nexports.checkStrictMode = checkStrictMode;\n//# sourceMappingURL=util.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;\nfunction schemaHasRulesForType({ schema, self }, type) {\n    const group = self.RULES.types[type];\n    return group && group !== true && shouldUseGroup(schema, group);\n}\nexports.schemaHasRulesForType = schemaHasRulesForType;\nfunction shouldUseGroup(schema, group) {\n    return group.rules.some((rule) => shouldUseRule(schema, rule));\n}\nexports.shouldUseGroup = shouldUseGroup;\nfunction shouldUseRule(schema, rule) {\n    var _a;\n    return (schema[rule.keyword] !== undefined ||\n        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));\n}\nexports.shouldUseRule = shouldUseRule;\n//# sourceMappingURL=applicability.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst boolError = {\n    message: \"boolean schema is false\",\n};\nfunction topBoolOrEmptySchema(it) {\n    const { gen, schema, validateName } = it;\n    if (schema === false) {\n        falseSchemaError(it, false);\n    }\n    else if (typeof schema == \"object\" && schema.$async === true) {\n        gen.return(names_1.default.data);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, null);\n        gen.return(true);\n    }\n}\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\nfunction boolOrEmptySchema(it, valid) {\n    const { gen, schema } = it;\n    if (schema === false) {\n        gen.var(valid, false); // TODO var\n        falseSchemaError(it);\n    }\n    else {\n        gen.var(valid, true); // TODO var\n    }\n}\nexports.boolOrEmptySchema = boolOrEmptySchema;\nfunction falseSchemaError(it, overrideAllErrors) {\n    const { gen, data } = it;\n    // TODO maybe some other interface should be used for non-keyword validation errors...\n    const cxt = {\n        gen,\n        keyword: \"false schema\",\n        data,\n        schema: false,\n        schemaCode: false,\n        schemaValue: false,\n        params: {},\n        it,\n    };\n    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);\n}\n//# sourceMappingURL=boolSchema.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\nconst rules_1 = require(\"../rules\");\nconst applicability_1 = require(\"./applicability\");\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n    DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType || (exports.DataType = DataType = {}));\nfunction getSchemaTypes(schema) {\n    const types = getJSONTypes(schema.type);\n    const hasNull = types.includes(\"null\");\n    if (hasNull) {\n        if (schema.nullable === false)\n            throw new Error(\"type: null contradicts nullable: false\");\n    }\n    else {\n        if (!types.length && schema.nullable !== undefined) {\n            throw new Error('\"nullable\" cannot be used without \"type\"');\n        }\n        if (schema.nullable === true)\n            types.push(\"null\");\n    }\n    return types;\n}\nexports.getSchemaTypes = getSchemaTypes;\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nfunction getJSONTypes(ts) {\n    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n    if (types.every(rules_1.isJSONType))\n        return types;\n    throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\nexports.getJSONTypes = getJSONTypes;\nfunction coerceAndCheckDataType(it, types) {\n    const { gen, data, opts } = it;\n    const coerceTo = coerceToTypes(types, opts.coerceTypes);\n    const checkTypes = types.length > 0 &&\n        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n    if (checkTypes) {\n        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n        gen.if(wrongType, () => {\n            if (coerceTo.length)\n                coerceData(it, types, coerceTo);\n            else\n                reportTypeError(it);\n        });\n    }\n    return checkTypes;\n}\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\nfunction coerceToTypes(types, coerceTypes) {\n    return coerceTypes\n        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n        : [];\n}\nfunction coerceData(it, types, coerceTo) {\n    const { gen, data, opts } = it;\n    const dataType = gen.let(\"dataType\", (0, codegen_1._) `typeof ${data}`);\n    const coerced = gen.let(\"coerced\", (0, codegen_1._) `undefined`);\n    if (opts.coerceTypes === \"array\") {\n        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen\n            .assign(data, (0, codegen_1._) `${data}[0]`)\n            .assign(dataType, (0, codegen_1._) `typeof ${data}`)\n            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n    }\n    gen.if((0, codegen_1._) `${coerced} !== undefined`);\n    for (const t of coerceTo) {\n        if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n            coerceSpecificType(t);\n        }\n    }\n    gen.else();\n    reportTypeError(it);\n    gen.endIf();\n    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {\n        gen.assign(data, coerced);\n        assignParentData(it, coerced);\n    });\n    function coerceSpecificType(t) {\n        switch (t) {\n            case \"string\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n                    .assign(coerced, (0, codegen_1._) `\"\" + ${data}`)\n                    .elseIf((0, codegen_1._) `${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `\"\"`);\n                return;\n            case \"number\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"integer\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"boolean\":\n                gen\n                    .elseIf((0, codegen_1._) `${data} === \"false\" || ${data} === 0 || ${data} === null`)\n                    .assign(coerced, false)\n                    .elseIf((0, codegen_1._) `${data} === \"true\" || ${data} === 1`)\n                    .assign(coerced, true);\n                return;\n            case \"null\":\n                gen.elseIf((0, codegen_1._) `${data} === \"\" || ${data} === 0 || ${data} === false`);\n                gen.assign(coerced, null);\n                return;\n            case \"array\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `[${data}]`);\n        }\n    }\n}\nfunction assignParentData({ gen, parentData, parentDataProperty }, expr) {\n    // TODO use gen.property\n    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));\n}\nfunction checkDataType(dataType, data, strictNums, correct = DataType.Correct) {\n    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n    let cond;\n    switch (dataType) {\n        case \"null\":\n            return (0, codegen_1._) `${data} ${EQ} null`;\n        case \"array\":\n            cond = (0, codegen_1._) `Array.isArray(${data})`;\n            break;\n        case \"object\":\n            cond = (0, codegen_1._) `${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n            break;\n        case \"integer\":\n            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);\n            break;\n        case \"number\":\n            cond = numCond();\n            break;\n        default:\n            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;\n    }\n    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n    function numCond(_cond = codegen_1.nil) {\n        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == \"number\"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);\n    }\n}\nexports.checkDataType = checkDataType;\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n    if (dataTypes.length === 1) {\n        return checkDataType(dataTypes[0], data, strictNums, correct);\n    }\n    let cond;\n    const types = (0, util_1.toHash)(dataTypes);\n    if (types.array && types.object) {\n        const notObj = (0, codegen_1._) `typeof ${data} != \"object\"`;\n        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;\n        delete types.null;\n        delete types.array;\n        delete types.object;\n    }\n    else {\n        cond = codegen_1.nil;\n    }\n    if (types.number)\n        delete types.integer;\n    for (const t in types)\n        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n    return cond;\n}\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n    message: ({ schema }) => `must be ${schema}`,\n    params: ({ schema, schemaValue }) => typeof schema == \"string\" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,\n};\nfunction reportTypeError(it) {\n    const cxt = getTypeErrorContext(it);\n    (0, errors_1.reportError)(cxt, typeError);\n}\nexports.reportTypeError = reportTypeError;\nfunction getTypeErrorContext(it) {\n    const { gen, data, schema } = it;\n    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n    return {\n        gen,\n        keyword: \"type\",\n        data,\n        schema: schema.type,\n        schemaCode,\n        schemaValue: schemaCode,\n        parentSchema: schema,\n        params: {},\n        it,\n    };\n}\n//# sourceMappingURL=dataType.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assignDefaults = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nfunction assignDefaults(it, ty) {\n    const { properties, items } = it.schema;\n    if (ty === \"object\" && properties) {\n        for (const key in properties) {\n            assignDefault(it, key, properties[key].default);\n        }\n    }\n    else if (ty === \"array\" && Array.isArray(items)) {\n        items.forEach((sch, i) => assignDefault(it, i, sch.default));\n    }\n}\nexports.assignDefaults = assignDefaults;\nfunction assignDefault(it, prop, defaultValue) {\n    const { gen, compositeRule, data, opts } = it;\n    if (defaultValue === undefined)\n        return;\n    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;\n    if (compositeRule) {\n        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);\n        return;\n    }\n    let condition = (0, codegen_1._) `${childData} === undefined`;\n    if (opts.useDefaults === \"empty\") {\n        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === \"\"`;\n    }\n    // `${childData} === undefined` +\n    // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);\n}\n//# sourceMappingURL=defaults.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = require(\"./boolSchema\");\nconst dataType_1 = require(\"./dataType\");\nconst applicability_1 = require(\"./applicability\");\nconst dataType_2 = require(\"./dataType\");\nconst defaults_1 = require(\"./defaults\");\nconst keyword_1 = require(\"./keyword\");\nconst subschema_1 = require(\"./subschema\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst resolve_1 = require(\"../resolve\");\nconst util_1 = require(\"../util\");\nconst errors_1 = require(\"../errors\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            topSchemaObjCode(it);\n            return;\n        }\n    }\n    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {\n    if (opts.code.es5) {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n            gen.code((0, codegen_1._) `\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n            destructureValCxtES5(gen, opts);\n            gen.code(body);\n        });\n    }\n    else {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n    }\n}\nfunction destructureValCxt(opts) {\n    return (0, codegen_1._) `{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n    gen.if(names_1.default.valCxt, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n    }, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `\"\"`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.rootData, names_1.default.data);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);\n    });\n}\nfunction topSchemaObjCode(it) {\n    const { schema, opts, gen } = it;\n    validateFunction(it, () => {\n        if (opts.$comment && schema.$comment)\n            commentKeyword(it);\n        checkNoDefault(it);\n        gen.let(names_1.default.vErrors, null);\n        gen.let(names_1.default.errors, 0);\n        if (opts.unevaluated)\n            resetEvaluated(it);\n        typeAndKeywords(it);\n        returnResults(it);\n    });\n    return;\n}\nfunction resetEvaluated(it) {\n    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n    const { gen, validateName } = it;\n    it.evaluated = gen.const(\"evaluated\", (0, codegen_1._) `${validateName}.evaluated`);\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n    const schId = typeof schema == \"object\" && schema[opts.schemaId];\n    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            subSchemaObjCode(it, valid);\n            return;\n        }\n    }\n    (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules({ schema, self }) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (self.RULES.all[key])\n            return true;\n    return false;\n}\nfunction isSchemaObj(it) {\n    return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n    const { schema, gen, opts } = it;\n    if (opts.$comment && schema.$comment)\n        commentKeyword(it);\n    updateContext(it);\n    checkAsyncSchema(it);\n    const errsCount = gen.const(\"_errs\", names_1.default.errors);\n    typeAndKeywords(it, errsCount);\n    // TODO var\n    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n    (0, util_1.checkUnknownRules)(it);\n    checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n    if (it.opts.jtd)\n        return schemaKeywords(it, [], false, errsCount);\n    const types = (0, dataType_1.getSchemaTypes)(it.schema);\n    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n    schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n    const { schema, errSchemaPath, opts, self } = it;\n    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n        self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n    }\n}\nfunction checkNoDefault(it) {\n    const { schema, opts } = it;\n    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n        (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n    }\n}\nfunction updateContext(it) {\n    const schId = it.schema[it.opts.schemaId];\n    if (schId)\n        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n    if (it.schema.$async && !it.schemaEnv.$async)\n        throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {\n    const msg = schema.$comment;\n    if (opts.$comment === true) {\n        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);\n    }\n    else if (typeof opts.$comment == \"function\") {\n        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue(\"root\", { ref: schemaEnv.root });\n        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n    }\n}\nfunction returnResults(it) {\n    const { gen, schemaEnv, validateName, ValidationError, opts } = it;\n    if (schemaEnv.$async) {\n        // TODO assign unevaluated\n        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);\n        if (opts.unevaluated)\n            assignEvaluated(it);\n        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);\n    }\n}\nfunction assignEvaluated({ gen, evaluated, props, items }) {\n    if (props instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.props`, props);\n    if (items instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.items`, items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n    const { gen, schema, data, allErrors, opts, self } = it;\n    const { RULES } = self;\n    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n        gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n        return;\n    }\n    if (!opts.jtd)\n        checkStrictTypes(it, types);\n    gen.block(() => {\n        for (const group of RULES.rules)\n            groupKeywords(group);\n        groupKeywords(RULES.post);\n    });\n    function groupKeywords(group) {\n        if (!(0, applicability_1.shouldUseGroup)(schema, group))\n            return;\n        if (group.type) {\n            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n            iterateKeywords(it, group);\n            if (types.length === 1 && types[0] === group.type && typeErrors) {\n                gen.else();\n                (0, dataType_2.reportTypeError)(it);\n            }\n            gen.endIf();\n        }\n        else {\n            iterateKeywords(it, group);\n        }\n        // TODO make it \"ok\" call?\n        if (!allErrors)\n            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);\n    }\n}\nfunction iterateKeywords(it, group) {\n    const { gen, schema, opts: { useDefaults }, } = it;\n    if (useDefaults)\n        (0, defaults_1.assignDefaults)(it, group.type);\n    gen.block(() => {\n        for (const rule of group.rules) {\n            if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n                keywordCode(it, rule.keyword, rule.definition, group.type);\n            }\n        }\n    });\n}\nfunction checkStrictTypes(it, types) {\n    if (it.schemaEnv.meta || !it.opts.strictTypes)\n        return;\n    checkContextTypes(it, types);\n    if (!it.opts.allowUnionTypes)\n        checkMultipleTypes(it, types);\n    checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n    if (!types.length)\n        return;\n    if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n    }\n    types.forEach((t) => {\n        if (!includesType(it.dataTypes, t)) {\n            strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n        }\n    });\n    narrowSchemaTypes(it, types);\n}\nfunction checkMultipleTypes(it, ts) {\n    if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n        strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n    }\n}\nfunction checkKeywordTypes(it, ts) {\n    const rules = it.self.RULES.all;\n    for (const keyword in rules) {\n        const rule = rules[keyword];\n        if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n            const { type } = rule.definition;\n            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n                strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n            }\n        }\n    }\n}\nfunction hasApplicableType(schTs, kwdT) {\n    return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"));\n}\nfunction includesType(ts, t) {\n    return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"));\n}\nfunction narrowSchemaTypes(it, withTypes) {\n    const ts = [];\n    for (const t of it.dataTypes) {\n        if (includesType(withTypes, t))\n            ts.push(t);\n        else if (withTypes.includes(\"integer\") && t === \"number\")\n            ts.push(\"integer\");\n    }\n    it.dataTypes = ts;\n}\nfunction strictTypesError(it, msg) {\n    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n    msg += ` at \"${schemaPath}\" (strictTypes)`;\n    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n    constructor(it, def, keyword) {\n        (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) {\n            this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n        }\n        else {\n            this.schemaCode = this.schemaValue;\n            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n            }\n        }\n        if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n            this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n        }\n    }\n    result(condition, successAction, failAction) {\n        this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n    }\n    failResult(condition, successAction, failAction) {\n        this.gen.if(condition);\n        if (failAction)\n            failAction();\n        else\n            this.error();\n        if (successAction) {\n            this.gen.else();\n            successAction();\n            if (this.allErrors)\n                this.gen.endIf();\n        }\n        else {\n            if (this.allErrors)\n                this.gen.endIf();\n            else\n                this.gen.else();\n        }\n    }\n    pass(condition, failAction) {\n        this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n    }\n    fail(condition) {\n        if (condition === undefined) {\n            this.error();\n            if (!this.allErrors)\n                this.gen.if(false); // this branch will be removed by gen.optimize\n            return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors)\n            this.gen.endIf();\n        else\n            this.gen.else();\n    }\n    fail$data(condition) {\n        if (!this.$data)\n            return this.fail(condition);\n        const { schemaCode } = this;\n        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n    }\n    error(append, errorParams, errorPaths) {\n        if (errorParams) {\n            this.setParams(errorParams);\n            this._error(append, errorPaths);\n            this.setParams({});\n            return;\n        }\n        this._error(append, errorPaths);\n    }\n    _error(append, errorPaths) {\n        ;\n        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n    $dataError() {\n        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n    reset() {\n        if (this.errsCount === undefined)\n            throw new Error('add \"trackErrors\" to keyword definition');\n        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n    }\n    ok(cond) {\n        if (!this.allErrors)\n            this.gen.if(cond);\n    }\n    setParams(obj, assign) {\n        if (assign)\n            Object.assign(this.params, obj);\n        else\n            this.params = obj;\n    }\n    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n        this.gen.block(() => {\n            this.check$data(valid, $dataValid);\n            codeBlock();\n        });\n    }\n    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n        if (!this.$data)\n            return;\n        const { gen, schemaCode, schemaType, def } = this;\n        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));\n        if (valid !== codegen_1.nil)\n            gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n            gen.elseIf(this.invalid$data());\n            this.$dataError();\n            if (valid !== codegen_1.nil)\n                gen.assign(valid, false);\n        }\n        gen.else();\n    }\n    invalid$data() {\n        const { gen, schemaCode, schemaType, def, it } = this;\n        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n            if (schemaType.length) {\n                /* istanbul ignore if */\n                if (!(schemaCode instanceof codegen_1.Name))\n                    throw new Error(\"ajv implementation error\");\n                const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n            }\n            return codegen_1.nil;\n        }\n        function invalid$DataSchema() {\n            if (def.validateSchema) {\n                const validateSchemaRef = gen.scopeValue(\"validate$data\", { ref: def.validateSchema }); // TODO value.code for standalone\n                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;\n            }\n            return codegen_1.nil;\n        }\n    }\n    subschema(appl, valid) {\n        const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n        (0, subschema_1.extendSubschemaMode)(subschema, appl);\n        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };\n        subschemaCode(nextContext, valid);\n        return nextContext;\n    }\n    mergeEvaluated(schemaCxt, toName) {\n        const { it, gen } = this;\n        if (!it.opts.unevaluated)\n            return;\n        if (it.props !== true && schemaCxt.props !== undefined) {\n            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        }\n        if (it.items !== true && schemaCxt.items !== undefined) {\n            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n        }\n    }\n    mergeValidEvaluated(schemaCxt, valid) {\n        const { it, gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n            return true;\n        }\n    }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n    const cxt = new KeywordCxt(it, def, keyword);\n    if (\"code\" in def) {\n        def.code(cxt, ruleType);\n    }\n    else if (cxt.$data && def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n    else if (\"macro\" in def) {\n        (0, keyword_1.macroKeywordCode)(cxt, def);\n    }\n    else if (def.compile || def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, { dataLevel, dataNames, dataPathArr }) {\n    let jsonPointer;\n    let data;\n    if ($data === \"\")\n        return names_1.default.rootData;\n    if ($data[0] === \"/\") {\n        if (!JSON_POINTER.test($data))\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = names_1.default.rootData;\n    }\n    else {\n        const matches = RELATIVE_JSON_POINTER.exec($data);\n        if (!matches)\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === \"#\") {\n            if (up >= dataLevel)\n                throw new Error(errorMsg(\"property/index\", up));\n            return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel)\n            throw new Error(errorMsg(\"data\", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer)\n            return data;\n    }\n    let expr = data;\n    const segments = jsonPointer.split(\"/\");\n    for (const segment of segments) {\n        if (segment) {\n            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n            expr = (0, codegen_1._) `${expr} && ${data}`;\n        }\n    }\n    return expr;\n    function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n    }\n}\nexports.getData = getData;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst errors_1 = require(\"../errors\");\nfunction macroKeywordCode(cxt, def) {\n    const { gen, keyword, schema, parentSchema, it } = cxt;\n    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n    const schemaRef = useKeyword(gen, keyword, macroSchema);\n    if (it.opts.validateSchema !== false)\n        it.self.validateSchema(macroSchema, true);\n    const valid = gen.name(\"valid\");\n    cxt.subschema({\n        schema: macroSchema,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true,\n    }, valid);\n    cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n    var _a;\n    const { gen, keyword, schema, parentSchema, $data, it } = cxt;\n    checkAsyncKeyword(it, def);\n    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n    const validateRef = useKeyword(gen, keyword, validate);\n    const valid = gen.let(\"valid\");\n    cxt.block$data(valid, validateKeyword);\n    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n    function validateKeyword() {\n        if (def.errors === false) {\n            assignValid();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => cxt.error());\n        }\n        else {\n            const ruleErrs = def.async ? validateAsync() : validateSync();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => addErrs(cxt, ruleErrs));\n        }\n    }\n    function validateAsync() {\n        const ruleErrs = gen.let(\"ruleErrs\", null);\n        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));\n        return ruleErrs;\n    }\n    function validateSync() {\n        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid(codegen_1.nil);\n        return validateErrs;\n    }\n    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {\n        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n        const passSchema = !((\"compile\" in def && !$data) || def.schema === false);\n        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n    }\n    function reportErrs(errors) {\n        var _a;\n        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n    }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n    const { gen, data, it } = cxt;\n    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n    const { gen } = cxt;\n    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {\n        gen\n            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)\n            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n        (0, errors_1.extendErrors)(cxt);\n    }, () => cxt.error());\n}\nfunction checkAsyncKeyword({ schemaEnv }, def) {\n    if (def.async && !schemaEnv.$async)\n        throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n    if (result === undefined)\n        throw new Error(`keyword \"${keyword}\" failed to compile`);\n    return gen.scopeValue(\"keyword\", typeof result == \"function\" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });\n}\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n    // TODO add tests\n    return (!schemaType.length ||\n        schemaType.some((st) => st === \"array\"\n            ? Array.isArray(schema)\n            : st === \"object\"\n                ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n                : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")));\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {\n    /* istanbul ignore if */\n    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n        throw new Error(\"ajv implementation error\");\n    }\n    const deps = def.dependencies;\n    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n    }\n    if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n            const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n                self.errorsText(def.validateSchema.errors);\n            if (opts.validateSchema === \"log\")\n                self.logger.error(msg);\n            else\n                throw new Error(msg);\n        }\n    }\n}\nexports.validateKeywordUsage = validateKeywordUsage;\n//# sourceMappingURL=keyword.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nfunction getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {\n    if (keyword !== undefined && schema !== undefined) {\n        throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n    }\n    if (keyword !== undefined) {\n        const sch = it.schema[keyword];\n        return schemaProp === undefined\n            ? {\n                schema: sch,\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n            }\n            : {\n                schema: sch[schemaProp],\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,\n            };\n    }\n    if (schema !== undefined) {\n        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n            throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"');\n        }\n        return {\n            schema,\n            schemaPath,\n            topSchemaRef,\n            errSchemaPath,\n        };\n    }\n    throw new Error('either \"keyword\" or \"schema\" must be passed');\n}\nexports.getSubschema = getSubschema;\nfunction extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {\n    if (data !== undefined && dataProp !== undefined) {\n        throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n    }\n    const { gen } = it;\n    if (dataProp !== undefined) {\n        const { errorPath, dataPathArr, opts } = it;\n        const nextData = gen.let(\"data\", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);\n        dataContextProps(nextData);\n        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;\n        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;\n        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];\n    }\n    if (data !== undefined) {\n        const nextData = data instanceof codegen_1.Name ? data : gen.let(\"data\", data, true); // replaceable if used once?\n        dataContextProps(nextData);\n        if (propertyName !== undefined)\n            subschema.propertyName = propertyName;\n        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n    }\n    if (dataTypes)\n        subschema.dataTypes = dataTypes;\n    function dataContextProps(_nextData) {\n        subschema.data = _nextData;\n        subschema.dataLevel = it.dataLevel + 1;\n        subschema.dataTypes = [];\n        it.definedProperties = new Set();\n        subschema.parentData = it.data;\n        subschema.dataNames = [...it.dataNames, _nextData];\n    }\n}\nexports.extendSubschemaData = extendSubschemaData;\nfunction extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {\n    if (compositeRule !== undefined)\n        subschema.compositeRule = compositeRule;\n    if (createErrors !== undefined)\n        subschema.createErrors = createErrors;\n    if (allErrors !== undefined)\n        subschema.allErrors = allErrors;\n    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited\n    subschema.jtdMetadata = jtdMetadata; // not inherited\n}\nexports.extendSubschemaMode = extendSubschemaMode;\n//# sourceMappingURL=subschema.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return codegen_1._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return codegen_1.str; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return codegen_1.stringify; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return codegen_1.nil; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return codegen_1.Name; } });\nObject.defineProperty(exports, \"CodeGen\", { enumerable: true, get: function () { return codegen_1.CodeGen; } });\nconst validation_error_1 = require(\"./runtime/validation_error\");\nconst ref_error_1 = require(\"./compile/ref_error\");\nconst rules_1 = require(\"./compile/rules\");\nconst compile_1 = require(\"./compile\");\nconst codegen_2 = require(\"./compile/codegen\");\nconst resolve_1 = require(\"./compile/resolve\");\nconst dataType_1 = require(\"./compile/validate/dataType\");\nconst util_1 = require(\"./compile/util\");\nconst $dataRefSchema = require(\"./refs/data.json\");\nconst uri_1 = require(\"./runtime/uri\");\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\n    \"validate\",\n    \"serialize\",\n    \"parse\",\n    \"wrapper\",\n    \"root\",\n    \"schema\",\n    \"keyword\",\n    \"pattern\",\n    \"formats\",\n    \"validate$data\",\n    \"func\",\n    \"obj\",\n    \"Error\",\n]);\nconst removedOptions = {\n    errorDataPath: \"\",\n    format: \"`validateFormats: false` can be used instead.\",\n    nullable: '\"nullable\" keyword is supported by default.',\n    jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n    extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n    missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n    processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n    sourceCode: \"Use option `code: {source: true}`\",\n    strictDefaults: \"It is default now, see option `strict`.\",\n    strictKeywords: \"It is default now, see option `strict`.\",\n    uniqueItems: '\"uniqueItems\" keyword is always validated.',\n    unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n    cache: \"Map is used as cache, schema object as key.\",\n    serialize: \"Map is used as cache, schema object as key.\",\n    ajvErrors: \"It is default now.\",\n};\nconst deprecatedOptions = {\n    ignoreKeywordsWithRef: \"\",\n    jsPropertySyntax: \"\",\n    unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n    const s = o.strict;\n    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n    return {\n        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },\n        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n        uriResolver: uriResolver,\n    };\n}\nclass Ajv {\n    constructor(opts = {}) {\n        this.schemas = {};\n        this.refs = {};\n        this.formats = {};\n        this._compilations = new Set();\n        this._loading = {};\n        this._cache = new Map();\n        opts = this.opts = { ...opts, ...requiredOptions(opts) };\n        const { es5, lines } = this.opts.code;\n        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });\n        this.logger = getLogger(opts.logger);\n        const formatOpt = opts.validateFormats;\n        opts.validateFormats = false;\n        this.RULES = (0, rules_1.getRules)();\n        checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n        checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n        this._metaOpts = getMetaSchemaOptions.call(this);\n        if (opts.formats)\n            addInitialFormats.call(this);\n        this._addVocabularies();\n        this._addDefaultMetaSchema();\n        if (opts.keywords)\n            addInitialKeywords.call(this, opts.keywords);\n        if (typeof opts.meta == \"object\")\n            this.addMetaSchema(opts.meta);\n        addInitialSchemas.call(this);\n        opts.validateFormats = formatOpt;\n    }\n    _addVocabularies() {\n        this.addKeyword(\"$async\");\n    }\n    _addDefaultMetaSchema() {\n        const { $data, meta, schemaId } = this.opts;\n        let _dataRefSchema = $dataRefSchema;\n        if (schemaId === \"id\") {\n            _dataRefSchema = { ...$dataRefSchema };\n            _dataRefSchema.id = _dataRefSchema.$id;\n            delete _dataRefSchema.$id;\n        }\n        if (meta && $data)\n            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n    }\n    defaultMeta() {\n        const { meta, schemaId } = this.opts;\n        return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined);\n    }\n    validate(schemaKeyRef, // key, ref or schema object\n    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n    data // to be validated\n    ) {\n        let v;\n        if (typeof schemaKeyRef == \"string\") {\n            v = this.getSchema(schemaKeyRef);\n            if (!v)\n                throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n        }\n        else {\n            v = this.compile(schemaKeyRef);\n        }\n        const valid = v(data);\n        if (!(\"$async\" in v))\n            this.errors = v.errors;\n        return valid;\n    }\n    compile(schema, _meta) {\n        const sch = this._addSchema(schema, _meta);\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    compileAsync(schema, meta) {\n        if (typeof this.opts.loadSchema != \"function\") {\n            throw new Error(\"options.loadSchema should be a function\");\n        }\n        const { loadSchema } = this.opts;\n        return runCompileAsync.call(this, schema, meta);\n        async function runCompileAsync(_schema, _meta) {\n            await loadMetaSchema.call(this, _schema.$schema);\n            const sch = this._addSchema(_schema, _meta);\n            return sch.validate || _compileAsync.call(this, sch);\n        }\n        async function loadMetaSchema($ref) {\n            if ($ref && !this.getSchema($ref)) {\n                await runCompileAsync.call(this, { $ref }, true);\n            }\n        }\n        async function _compileAsync(sch) {\n            try {\n                return this._compileSchemaEnv(sch);\n            }\n            catch (e) {\n                if (!(e instanceof ref_error_1.default))\n                    throw e;\n                checkLoaded.call(this, e);\n                await loadMissingSchema.call(this, e.missingSchema);\n                return _compileAsync.call(this, sch);\n            }\n        }\n        function checkLoaded({ missingSchema: ref, missingRef }) {\n            if (this.refs[ref]) {\n                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n            }\n        }\n        async function loadMissingSchema(ref) {\n            const _schema = await _loadSchema.call(this, ref);\n            if (!this.refs[ref])\n                await loadMetaSchema.call(this, _schema.$schema);\n            if (!this.refs[ref])\n                this.addSchema(_schema, ref, meta);\n        }\n        async function _loadSchema(ref) {\n            const p = this._loading[ref];\n            if (p)\n                return p;\n            try {\n                return await (this._loading[ref] = loadSchema(ref));\n            }\n            finally {\n                delete this._loading[ref];\n            }\n        }\n    }\n    // Adds schema to the instance\n    addSchema(schema, // If array is passed, `key` will be ignored\n    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n    ) {\n        if (Array.isArray(schema)) {\n            for (const sch of schema)\n                this.addSchema(sch, undefined, _meta, _validateSchema);\n            return this;\n        }\n        let id;\n        if (typeof schema === \"object\") {\n            const { schemaId } = this.opts;\n            id = schema[schemaId];\n            if (id !== undefined && typeof id != \"string\") {\n                throw new Error(`schema ${schemaId} must be string`);\n            }\n        }\n        key = (0, resolve_1.normalizeId)(key || id);\n        this._checkUnique(key);\n        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n        return this;\n    }\n    // Add schema that will be used to validate other schemas\n    // options in META_IGNORE_OPTIONS are alway set to false\n    addMetaSchema(schema, key, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n    ) {\n        this.addSchema(schema, key, true, _validateSchema);\n        return this;\n    }\n    //  Validate schema against its meta-schema\n    validateSchema(schema, throwOrLogError) {\n        if (typeof schema == \"boolean\")\n            return true;\n        let $schema;\n        $schema = schema.$schema;\n        if ($schema !== undefined && typeof $schema != \"string\") {\n            throw new Error(\"$schema must be a string\");\n        }\n        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n        if (!$schema) {\n            this.logger.warn(\"meta-schema not available\");\n            this.errors = null;\n            return true;\n        }\n        const valid = this.validate($schema, schema);\n        if (!valid && throwOrLogError) {\n            const message = \"schema is invalid: \" + this.errorsText();\n            if (this.opts.validateSchema === \"log\")\n                this.logger.error(message);\n            else\n                throw new Error(message);\n        }\n        return valid;\n    }\n    // Get compiled schema by `key` or `ref`.\n    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n    getSchema(keyRef) {\n        let sch;\n        while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\")\n            keyRef = sch;\n        if (sch === undefined) {\n            const { schemaId } = this.opts;\n            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });\n            sch = compile_1.resolveSchema.call(this, root, keyRef);\n            if (!sch)\n                return;\n            this.refs[keyRef] = sch;\n        }\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    // Remove cached schema(s).\n    // If no parameter is passed all schemas but meta-schemas are removed.\n    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n    removeSchema(schemaKeyRef) {\n        if (schemaKeyRef instanceof RegExp) {\n            this._removeAllSchemas(this.schemas, schemaKeyRef);\n            this._removeAllSchemas(this.refs, schemaKeyRef);\n            return this;\n        }\n        switch (typeof schemaKeyRef) {\n            case \"undefined\":\n                this._removeAllSchemas(this.schemas);\n                this._removeAllSchemas(this.refs);\n                this._cache.clear();\n                return this;\n            case \"string\": {\n                const sch = getSchEnv.call(this, schemaKeyRef);\n                if (typeof sch == \"object\")\n                    this._cache.delete(sch.schema);\n                delete this.schemas[schemaKeyRef];\n                delete this.refs[schemaKeyRef];\n                return this;\n            }\n            case \"object\": {\n                const cacheKey = schemaKeyRef;\n                this._cache.delete(cacheKey);\n                let id = schemaKeyRef[this.opts.schemaId];\n                if (id) {\n                    id = (0, resolve_1.normalizeId)(id);\n                    delete this.schemas[id];\n                    delete this.refs[id];\n                }\n                return this;\n            }\n            default:\n                throw new Error(\"ajv.removeSchema: invalid parameter\");\n        }\n    }\n    // add \"vocabulary\" - a collection of keywords\n    addVocabulary(definitions) {\n        for (const def of definitions)\n            this.addKeyword(def);\n        return this;\n    }\n    addKeyword(kwdOrDef, def // deprecated\n    ) {\n        let keyword;\n        if (typeof kwdOrDef == \"string\") {\n            keyword = kwdOrDef;\n            if (typeof def == \"object\") {\n                this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n                def.keyword = keyword;\n            }\n        }\n        else if (typeof kwdOrDef == \"object\" && def === undefined) {\n            def = kwdOrDef;\n            keyword = def.keyword;\n            if (Array.isArray(keyword) && !keyword.length) {\n                throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n            }\n        }\n        else {\n            throw new Error(\"invalid addKeywords parameters\");\n        }\n        checkKeyword.call(this, keyword, def);\n        if (!def) {\n            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));\n            return this;\n        }\n        keywordMetaschema.call(this, def);\n        const definition = {\n            ...def,\n            type: (0, dataType_1.getJSONTypes)(def.type),\n            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),\n        };\n        (0, util_1.eachItem)(keyword, definition.type.length === 0\n            ? (k) => addRule.call(this, k, definition)\n            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));\n        return this;\n    }\n    getKeyword(keyword) {\n        const rule = this.RULES.all[keyword];\n        return typeof rule == \"object\" ? rule.definition : !!rule;\n    }\n    // Remove keyword\n    removeKeyword(keyword) {\n        // TODO return type should be Ajv\n        const { RULES } = this;\n        delete RULES.keywords[keyword];\n        delete RULES.all[keyword];\n        for (const group of RULES.rules) {\n            const i = group.rules.findIndex((rule) => rule.keyword === keyword);\n            if (i >= 0)\n                group.rules.splice(i, 1);\n        }\n        return this;\n    }\n    // Add format\n    addFormat(name, format) {\n        if (typeof format == \"string\")\n            format = new RegExp(format);\n        this.formats[name] = format;\n        return this;\n    }\n    errorsText(errors = this.errors, // optional array of validation errors\n    { separator = \", \", dataVar = \"data\" } = {} // optional options with properties `separator` and `dataVar`\n    ) {\n        if (!errors || errors.length === 0)\n            return \"No errors\";\n        return errors\n            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n            .reduce((text, msg) => text + separator + msg);\n    }\n    $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n        const rules = this.RULES.all;\n        metaSchema = JSON.parse(JSON.stringify(metaSchema));\n        for (const jsonPointer of keywordsJsonPointers) {\n            const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n            let keywords = metaSchema;\n            for (const seg of segments)\n                keywords = keywords[seg];\n            for (const key in rules) {\n                const rule = rules[key];\n                if (typeof rule != \"object\")\n                    continue;\n                const { $data } = rule.definition;\n                const schema = keywords[key];\n                if ($data && schema)\n                    keywords[key] = schemaOrData(schema);\n            }\n        }\n        return metaSchema;\n    }\n    _removeAllSchemas(schemas, regex) {\n        for (const keyRef in schemas) {\n            const sch = schemas[keyRef];\n            if (!regex || regex.test(keyRef)) {\n                if (typeof sch == \"string\") {\n                    delete schemas[keyRef];\n                }\n                else if (sch && !sch.meta) {\n                    this._cache.delete(sch.schema);\n                    delete schemas[keyRef];\n                }\n            }\n        }\n    }\n    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n        let id;\n        const { schemaId } = this.opts;\n        if (typeof schema == \"object\") {\n            id = schema[schemaId];\n        }\n        else {\n            if (this.opts.jtd)\n                throw new Error(\"schema must be object\");\n            else if (typeof schema != \"boolean\")\n                throw new Error(\"schema must be object or boolean\");\n        }\n        let sch = this._cache.get(schema);\n        if (sch !== undefined)\n            return sch;\n        baseId = (0, resolve_1.normalizeId)(id || baseId);\n        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });\n        this._cache.set(sch.schema, sch);\n        if (addSchema && !baseId.startsWith(\"#\")) {\n            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n            if (baseId)\n                this._checkUnique(baseId);\n            this.refs[baseId] = sch;\n        }\n        if (validateSchema)\n            this.validateSchema(schema, true);\n        return sch;\n    }\n    _checkUnique(id) {\n        if (this.schemas[id] || this.refs[id]) {\n            throw new Error(`schema with key or id \"${id}\" already exists`);\n        }\n    }\n    _compileSchemaEnv(sch) {\n        if (sch.meta)\n            this._compileMetaSchema(sch);\n        else\n            compile_1.compileSchema.call(this, sch);\n        /* istanbul ignore if */\n        if (!sch.validate)\n            throw new Error(\"ajv implementation error\");\n        return sch.validate;\n    }\n    _compileMetaSchema(sch) {\n        const currentOpts = this.opts;\n        this.opts = this._metaOpts;\n        try {\n            compile_1.compileSchema.call(this, sch);\n        }\n        finally {\n            this.opts = currentOpts;\n        }\n    }\n}\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nexports.default = Ajv;\nfunction checkOptions(checkOpts, options, msg, log = \"error\") {\n    for (const key in checkOpts) {\n        const opt = key;\n        if (opt in options)\n            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n    }\n}\nfunction getSchEnv(keyRef) {\n    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n    return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n    const optsSchemas = this.opts.schemas;\n    if (!optsSchemas)\n        return;\n    if (Array.isArray(optsSchemas))\n        this.addSchema(optsSchemas);\n    else\n        for (const key in optsSchemas)\n            this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n    for (const name in this.opts.formats) {\n        const format = this.opts.formats[name];\n        if (format)\n            this.addFormat(name, format);\n    }\n}\nfunction addInitialKeywords(defs) {\n    if (Array.isArray(defs)) {\n        this.addVocabulary(defs);\n        return;\n    }\n    this.logger.warn(\"keywords option as map is deprecated, pass array\");\n    for (const keyword in defs) {\n        const def = defs[keyword];\n        if (!def.keyword)\n            def.keyword = keyword;\n        this.addKeyword(def);\n    }\n}\nfunction getMetaSchemaOptions() {\n    const metaOpts = { ...this.opts };\n    for (const opt of META_IGNORE_OPTIONS)\n        delete metaOpts[opt];\n    return metaOpts;\n}\nconst noLogs = { log() { }, warn() { }, error() { } };\nfunction getLogger(logger) {\n    if (logger === false)\n        return noLogs;\n    if (logger === undefined)\n        return console;\n    if (logger.log && logger.warn && logger.error)\n        return logger;\n    throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n    const { RULES } = this;\n    (0, util_1.eachItem)(keyword, (kwd) => {\n        if (RULES.keywords[kwd])\n            throw new Error(`Keyword ${kwd} is already defined`);\n        if (!KEYWORD_NAME.test(kwd))\n            throw new Error(`Keyword ${kwd} has invalid name`);\n    });\n    if (!def)\n        return;\n    if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n        throw new Error('$data keyword must have \"code\" or \"validate\" function');\n    }\n}\nfunction addRule(keyword, definition, dataType) {\n    var _a;\n    const post = definition === null || definition === void 0 ? void 0 : definition.post;\n    if (dataType && post)\n        throw new Error('keyword with \"post\" flag cannot have \"type\"');\n    const { RULES } = this;\n    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);\n    if (!ruleGroup) {\n        ruleGroup = { type: dataType, rules: [] };\n        RULES.rules.push(ruleGroup);\n    }\n    RULES.keywords[keyword] = true;\n    if (!definition)\n        return;\n    const rule = {\n        keyword,\n        definition: {\n            ...definition,\n            type: (0, dataType_1.getJSONTypes)(definition.type),\n            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),\n        },\n    };\n    if (definition.before)\n        addBeforeRule.call(this, ruleGroup, rule, definition.before);\n    else\n        ruleGroup.rules.push(rule);\n    RULES.all[keyword] = rule;\n    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);\n    if (i >= 0) {\n        ruleGroup.rules.splice(i, 0, rule);\n    }\n    else {\n        ruleGroup.rules.push(rule);\n        this.logger.warn(`rule ${before} is not defined`);\n    }\n}\nfunction keywordMetaschema(def) {\n    let { metaSchema } = def;\n    if (metaSchema === undefined)\n        return;\n    if (def.$data && this.opts.$data)\n        metaSchema = schemaOrData(metaSchema);\n    def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n    $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n};\nfunction schemaOrData(schema) {\n    return { anyOf: [schema, $dataRef] };\n}\n//# sourceMappingURL=core.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// https://github.com/ajv-validator/ajv/issues/889\nconst equal = require(\"fast-deep-equal\");\nequal.code = 'require(\"ajv/dist/runtime/equal\").default';\nexports.default = equal;\n//# sourceMappingURL=equal.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nfunction ucs2length(str) {\n    const len = str.length;\n    let length = 0;\n    let pos = 0;\n    let value;\n    while (pos < len) {\n        length++;\n        value = str.charCodeAt(pos++);\n        if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n            // high surrogate, and there is a next character\n            value = str.charCodeAt(pos);\n            if ((value & 0xfc00) === 0xdc00)\n                pos++; // low surrogate\n        }\n    }\n    return length;\n}\nexports.default = ucs2length;\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default';\n//# sourceMappingURL=ucs2length.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst uri = require(\"fast-uri\");\nuri.code = 'require(\"ajv/dist/runtime/uri\").default';\nexports.default = uri;\n//# sourceMappingURL=uri.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass ValidationError extends Error {\n    constructor(errors) {\n        super(\"validation failed\");\n        this.errors = errors;\n        this.ajv = this.validation = true;\n    }\n}\nexports.default = ValidationError;\n//# sourceMappingURL=validation_error.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateAdditionalItems = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"additionalItems\",\n    type: \"array\",\n    schemaType: [\"boolean\", \"object\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { parentSchema, it } = cxt;\n        const { items } = parentSchema;\n        if (!Array.isArray(items)) {\n            (0, util_1.checkStrictMode)(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n            return;\n        }\n        validateAdditionalItems(cxt, items);\n    },\n};\nfunction validateAdditionalItems(cxt, items) {\n    const { gen, schema, data, keyword, it } = cxt;\n    it.items = true;\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    if (schema === false) {\n        cxt.setParams({ len: items.length });\n        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);\n    }\n    else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.var(\"valid\", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var\n        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));\n        cxt.ok(valid);\n    }\n    function validateItems(valid) {\n        gen.forRange(\"i\", items.length, len, (i) => {\n            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);\n            if (!it.allErrors)\n                gen.if((0, codegen_1.not)(valid), () => gen.break());\n        });\n    }\n}\nexports.validateAdditionalItems = validateAdditionalItems;\nexports.default = def;\n//# sourceMappingURL=additionalItems.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"must NOT have additional properties\",\n    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,\n};\nconst def = {\n    keyword: \"additionalProperties\",\n    type: [\"object\"],\n    schemaType: [\"boolean\", \"object\"],\n    allowUndefined: true,\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, errsCount, it } = cxt;\n        /* istanbul ignore if */\n        if (!errsCount)\n            throw new Error(\"ajv implementation error\");\n        const { allErrors, opts } = it;\n        it.props = true;\n        if (opts.removeAdditional !== \"all\" && (0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);\n        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);\n        checkAdditionalProperties();\n        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n        function checkAdditionalProperties() {\n            gen.forIn(\"key\", data, (key) => {\n                if (!props.length && !patProps.length)\n                    additionalPropertyCode(key);\n                else\n                    gen.if(isAdditional(key), () => additionalPropertyCode(key));\n            });\n        }\n        function isAdditional(key) {\n            let definedProp;\n            if (props.length > 8) {\n                // TODO maybe an option instead of hard-coded 8?\n                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, \"properties\");\n                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);\n            }\n            else if (props.length) {\n                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));\n            }\n            else {\n                definedProp = codegen_1.nil;\n            }\n            if (patProps.length) {\n                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));\n            }\n            return (0, codegen_1.not)(definedProp);\n        }\n        function deleteAdditional(key) {\n            gen.code((0, codegen_1._) `delete ${data}[${key}]`);\n        }\n        function additionalPropertyCode(key) {\n            if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n                deleteAdditional(key);\n                return;\n            }\n            if (schema === false) {\n                cxt.setParams({ additionalProperty: key });\n                cxt.error();\n                if (!allErrors)\n                    gen.break();\n                return;\n            }\n            if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n                const valid = gen.name(\"valid\");\n                if (opts.removeAdditional === \"failing\") {\n                    applyAdditionalSchema(key, valid, false);\n                    gen.if((0, codegen_1.not)(valid), () => {\n                        cxt.reset();\n                        deleteAdditional(key);\n                    });\n                }\n                else {\n                    applyAdditionalSchema(key, valid);\n                    if (!allErrors)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                }\n            }\n        }\n        function applyAdditionalSchema(key, valid, errors) {\n            const subschema = {\n                keyword: \"additionalProperties\",\n                dataProp: key,\n                dataPropType: util_1.Type.Str,\n            };\n            if (errors === false) {\n                Object.assign(subschema, {\n                    compositeRule: true,\n                    createErrors: false,\n                    allErrors: false,\n                });\n            }\n            cxt.subschema(subschema, valid);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=additionalProperties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"allOf\",\n    schemaType: \"array\",\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        const valid = gen.name(\"valid\");\n        schema.forEach((sch, i) => {\n            if ((0, util_1.alwaysValidSchema)(it, sch))\n                return;\n            const schCxt = cxt.subschema({ keyword: \"allOf\", schemaProp: i }, valid);\n            cxt.ok(valid);\n            cxt.mergeEvaluated(schCxt);\n        });\n    },\n};\nexports.default = def;\n//# sourceMappingURL=allOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst def = {\n    keyword: \"anyOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    code: code_1.validateUnion,\n    error: { message: \"must match a schema in anyOf\" },\n};\nexports.default = def;\n//# sourceMappingURL=anyOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { min, max } }) => max === undefined\n        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`\n        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,\n    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,\n};\nconst def = {\n    keyword: \"contains\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        let min;\n        let max;\n        const { minContains, maxContains } = parentSchema;\n        if (it.opts.next) {\n            min = minContains === undefined ? 1 : minContains;\n            max = maxContains;\n        }\n        else {\n            min = 1;\n        }\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        cxt.setParams({ min, max });\n        if (max === undefined && min === 0) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n            return;\n        }\n        if (max !== undefined && min > max) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" > \"maxContains\" is always invalid`);\n            cxt.fail();\n            return;\n        }\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            let cond = (0, codegen_1._) `${len} >= ${min}`;\n            if (max !== undefined)\n                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;\n            cxt.pass(cond);\n            return;\n        }\n        it.items = true;\n        const valid = gen.name(\"valid\");\n        if (max === undefined && min === 1) {\n            validateItems(valid, () => gen.if(valid, () => gen.break()));\n        }\n        else if (min === 0) {\n            gen.let(valid, true);\n            if (max !== undefined)\n                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);\n        }\n        else {\n            gen.let(valid, false);\n            validateItemsWithCount();\n        }\n        cxt.result(valid, () => cxt.reset());\n        function validateItemsWithCount() {\n            const schValid = gen.name(\"_valid\");\n            const count = gen.let(\"count\", 0);\n            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n        }\n        function validateItems(_valid, block) {\n            gen.forRange(\"i\", 0, len, (i) => {\n                cxt.subschema({\n                    keyword: \"contains\",\n                    dataProp: i,\n                    dataPropType: util_1.Type.Num,\n                    compositeRule: true,\n                }, _valid);\n                block();\n            });\n        }\n        function checkLimits(count) {\n            gen.code((0, codegen_1._) `${count}++`);\n            if (max === undefined) {\n                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());\n            }\n            else {\n                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());\n                if (min === 1)\n                    gen.assign(valid, true);\n                else\n                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=contains.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nexports.error = {\n    message: ({ params: { property, depsCount, deps } }) => {\n        const property_ies = depsCount === 1 ? \"property\" : \"properties\";\n        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;\n    },\n    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n};\nconst def = {\n    keyword: \"dependencies\",\n    type: \"object\",\n    schemaType: \"object\",\n    error: exports.error,\n    code(cxt) {\n        const [propDeps, schDeps] = splitDependencies(cxt);\n        validatePropertyDeps(cxt, propDeps);\n        validateSchemaDeps(cxt, schDeps);\n    },\n};\nfunction splitDependencies({ schema }) {\n    const propertyDeps = {};\n    const schemaDeps = {};\n    for (const key in schema) {\n        if (key === \"__proto__\")\n            continue;\n        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n        deps[key] = schema[key];\n    }\n    return [propertyDeps, schemaDeps];\n}\nfunction validatePropertyDeps(cxt, propertyDeps = cxt.schema) {\n    const { gen, data, it } = cxt;\n    if (Object.keys(propertyDeps).length === 0)\n        return;\n    const missing = gen.let(\"missing\");\n    for (const prop in propertyDeps) {\n        const deps = propertyDeps[prop];\n        if (deps.length === 0)\n            continue;\n        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);\n        cxt.setParams({\n            property: prop,\n            depsCount: deps.length,\n            deps: deps.join(\", \"),\n        });\n        if (it.allErrors) {\n            gen.if(hasProperty, () => {\n                for (const depProp of deps) {\n                    (0, code_1.checkReportMissingProp)(cxt, depProp);\n                }\n            });\n        }\n        else {\n            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);\n            (0, code_1.reportMissingProp)(cxt, missing);\n            gen.else();\n        }\n    }\n}\nexports.validatePropertyDeps = validatePropertyDeps;\nfunction validateSchemaDeps(cxt, schemaDeps = cxt.schema) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    for (const prop in schemaDeps) {\n        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))\n            continue;\n        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {\n            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);\n            cxt.mergeValidEvaluated(schCxt, valid);\n        }, () => gen.var(valid, true) // TODO var\n        );\n        cxt.ok(valid);\n    }\n}\nexports.validateSchemaDeps = validateSchemaDeps;\nexports.default = def;\n//# sourceMappingURL=dependencies.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params }) => (0, codegen_1.str) `must match \"${params.ifClause}\" schema`,\n    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,\n};\nconst def = {\n    keyword: \"if\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, parentSchema, it } = cxt;\n        if (parentSchema.then === undefined && parentSchema.else === undefined) {\n            (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n        }\n        const hasThen = hasSchema(it, \"then\");\n        const hasElse = hasSchema(it, \"else\");\n        if (!hasThen && !hasElse)\n            return;\n        const valid = gen.let(\"valid\", true);\n        const schValid = gen.name(\"_valid\");\n        validateIf();\n        cxt.reset();\n        if (hasThen && hasElse) {\n            const ifClause = gen.let(\"ifClause\");\n            cxt.setParams({ ifClause });\n            gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n        }\n        else if (hasThen) {\n            gen.if(schValid, validateClause(\"then\"));\n        }\n        else {\n            gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n        }\n        cxt.pass(valid, () => cxt.error(true));\n        function validateIf() {\n            const schCxt = cxt.subschema({\n                keyword: \"if\",\n                compositeRule: true,\n                createErrors: false,\n                allErrors: false,\n            }, schValid);\n            cxt.mergeEvaluated(schCxt);\n        }\n        function validateClause(keyword, ifClause) {\n            return () => {\n                const schCxt = cxt.subschema({ keyword }, schValid);\n                gen.assign(valid, schValid);\n                cxt.mergeValidEvaluated(schCxt, valid);\n                if (ifClause)\n                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);\n                else\n                    cxt.setParams({ ifClause: keyword });\n            };\n        }\n    },\n};\nfunction hasSchema(it, keyword) {\n    const schema = it.schema[keyword];\n    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\nexports.default = def;\n//# sourceMappingURL=if.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst additionalItems_1 = require(\"./additionalItems\");\nconst prefixItems_1 = require(\"./prefixItems\");\nconst items_1 = require(\"./items\");\nconst items2020_1 = require(\"./items2020\");\nconst contains_1 = require(\"./contains\");\nconst dependencies_1 = require(\"./dependencies\");\nconst propertyNames_1 = require(\"./propertyNames\");\nconst additionalProperties_1 = require(\"./additionalProperties\");\nconst properties_1 = require(\"./properties\");\nconst patternProperties_1 = require(\"./patternProperties\");\nconst not_1 = require(\"./not\");\nconst anyOf_1 = require(\"./anyOf\");\nconst oneOf_1 = require(\"./oneOf\");\nconst allOf_1 = require(\"./allOf\");\nconst if_1 = require(\"./if\");\nconst thenElse_1 = require(\"./thenElse\");\nfunction getApplicator(draft2020 = false) {\n    const applicator = [\n        // any\n        not_1.default,\n        anyOf_1.default,\n        oneOf_1.default,\n        allOf_1.default,\n        if_1.default,\n        thenElse_1.default,\n        // object\n        propertyNames_1.default,\n        additionalProperties_1.default,\n        dependencies_1.default,\n        properties_1.default,\n        patternProperties_1.default,\n    ];\n    // array\n    if (draft2020)\n        applicator.push(prefixItems_1.default, items2020_1.default);\n    else\n        applicator.push(additionalItems_1.default, items_1.default);\n    applicator.push(contains_1.default);\n    return applicator;\n}\nexports.default = getApplicator;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateTuple = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"array\", \"boolean\"],\n    before: \"uniqueItems\",\n    code(cxt) {\n        const { schema, it } = cxt;\n        if (Array.isArray(schema))\n            return validateTuple(cxt, \"additionalItems\", schema);\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nfunction validateTuple(cxt, extraItems, schArr = cxt.schema) {\n    const { gen, parentSchema, data, keyword, it } = cxt;\n    checkStrictTuple(parentSchema);\n    if (it.opts.unevaluated && schArr.length && it.items !== true) {\n        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n    }\n    const valid = gen.name(\"valid\");\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    schArr.forEach((sch, i) => {\n        if ((0, util_1.alwaysValidSchema)(it, sch))\n            return;\n        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({\n            keyword,\n            schemaProp: i,\n            dataProp: i,\n        }, valid));\n        cxt.ok(valid);\n    });\n    function checkStrictTuple(sch) {\n        const { opts, errSchemaPath } = it;\n        const l = schArr.length;\n        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n        if (opts.strictTuples && !fullTuple) {\n            const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n        }\n    }\n}\nexports.validateTuple = validateTuple;\nexports.default = def;\n//# sourceMappingURL=items.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nconst additionalItems_1 = require(\"./additionalItems\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { schema, parentSchema, it } = cxt;\n        const { prefixItems } = parentSchema;\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        if (prefixItems)\n            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);\n        else\n            cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nexports.default = def;\n//# sourceMappingURL=items2020.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"not\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            cxt.fail();\n            return;\n        }\n        const valid = gen.name(\"valid\");\n        cxt.subschema({\n            keyword: \"not\",\n            compositeRule: true,\n            createErrors: false,\n            allErrors: false,\n        }, valid);\n        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());\n    },\n    error: { message: \"must NOT be valid\" },\n};\nexports.default = def;\n//# sourceMappingURL=not.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"must match exactly one schema in oneOf\",\n    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,\n};\nconst def = {\n    keyword: \"oneOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        if (it.opts.discriminator && parentSchema.discriminator)\n            return;\n        const schArr = schema;\n        const valid = gen.let(\"valid\", false);\n        const passing = gen.let(\"passing\", null);\n        const schValid = gen.name(\"_valid\");\n        cxt.setParams({ passing });\n        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n        gen.block(validateOneOf);\n        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n        function validateOneOf() {\n            schArr.forEach((sch, i) => {\n                let schCxt;\n                if ((0, util_1.alwaysValidSchema)(it, sch)) {\n                    gen.var(schValid, true);\n                }\n                else {\n                    schCxt = cxt.subschema({\n                        keyword: \"oneOf\",\n                        schemaProp: i,\n                        compositeRule: true,\n                    }, schValid);\n                }\n                if (i > 0) {\n                    gen\n                        .if((0, codegen_1._) `${schValid} && ${valid}`)\n                        .assign(valid, false)\n                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)\n                        .else();\n                }\n                gen.if(schValid, () => {\n                    gen.assign(valid, true);\n                    gen.assign(passing, i);\n                    if (schCxt)\n                        cxt.mergeEvaluated(schCxt, codegen_1.Name);\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=oneOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst util_2 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"patternProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, data, parentSchema, it } = cxt;\n        const { opts } = it;\n        const patterns = (0, code_1.allSchemaProperties)(schema);\n        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (patterns.length === 0 ||\n            (alwaysValidPatterns.length === patterns.length &&\n                (!it.opts.unevaluated || it.props === true))) {\n            return;\n        }\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name(\"valid\");\n        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n        }\n        const { props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n            for (const pat of patterns) {\n                if (checkProperties)\n                    checkMatchingProperties(pat);\n                if (it.allErrors) {\n                    validateProperties(pat);\n                }\n                else {\n                    gen.var(valid, true); // TODO var\n                    validateProperties(pat);\n                    gen.if(valid);\n                }\n            }\n        }\n        function checkMatchingProperties(pat) {\n            for (const prop in checkProperties) {\n                if (new RegExp(pat).test(prop)) {\n                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n                }\n            }\n        }\n        function validateProperties(pat) {\n            gen.forIn(\"key\", data, (key) => {\n                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n                    const alwaysValid = alwaysValidPatterns.includes(pat);\n                    if (!alwaysValid) {\n                        cxt.subschema({\n                            keyword: \"patternProperties\",\n                            schemaProp: pat,\n                            dataProp: key,\n                            dataPropType: util_2.Type.Str,\n                        }, valid);\n                    }\n                    if (it.opts.unevaluated && props !== true) {\n                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);\n                    }\n                    else if (!alwaysValid && !it.allErrors) {\n                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n                        // or if all properties were evaluated (props === true)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                    }\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=patternProperties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst items_1 = require(\"./items\");\nconst def = {\n    keyword: \"prefixItems\",\n    type: \"array\",\n    schemaType: [\"array\"],\n    before: \"uniqueItems\",\n    code: (cxt) => (0, items_1.validateTuple)(cxt, \"items\"),\n};\nexports.default = def;\n//# sourceMappingURL=prefixItems.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst validate_1 = require(\"../../compile/validate\");\nconst code_1 = require(\"../code\");\nconst util_1 = require(\"../../compile/util\");\nconst additionalProperties_1 = require(\"./additionalProperties\");\nconst def = {\n    keyword: \"properties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, \"additionalProperties\"));\n        }\n        const allProps = (0, code_1.allSchemaProperties)(schema);\n        for (const prop of allProps) {\n            it.definedProperties.add(prop);\n        }\n        if (it.opts.unevaluated && allProps.length && it.props !== true) {\n            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);\n        }\n        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (properties.length === 0)\n            return;\n        const valid = gen.name(\"valid\");\n        for (const prop of properties) {\n            if (hasDefault(prop)) {\n                applyPropertySchema(prop);\n            }\n            else {\n                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));\n                applyPropertySchema(prop);\n                if (!it.allErrors)\n                    gen.else().var(valid, true);\n                gen.endIf();\n            }\n            cxt.it.definedProperties.add(prop);\n            cxt.ok(valid);\n        }\n        function hasDefault(prop) {\n            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;\n        }\n        function applyPropertySchema(prop) {\n            cxt.subschema({\n                keyword: \"properties\",\n                schemaProp: prop,\n                dataProp: prop,\n            }, valid);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=properties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"property name must be valid\",\n    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,\n};\nconst def = {\n    keyword: \"propertyNames\",\n    type: \"object\",\n    schemaType: [\"object\", \"boolean\"],\n    error,\n    code(cxt) {\n        const { gen, schema, data, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const valid = gen.name(\"valid\");\n        gen.forIn(\"key\", data, (key) => {\n            cxt.setParams({ propertyName: key });\n            cxt.subschema({\n                keyword: \"propertyNames\",\n                data: key,\n                dataTypes: [\"string\"],\n                propertyName: key,\n                compositeRule: true,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), () => {\n                cxt.error(true);\n                if (!it.allErrors)\n                    gen.break();\n            });\n        });\n        cxt.ok(valid);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=propertyNames.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: [\"then\", \"else\"],\n    schemaType: [\"object\", \"boolean\"],\n    code({ keyword, parentSchema, it }) {\n        if (parentSchema.if === undefined)\n            (0, util_1.checkStrictMode)(it, `\"${keyword}\" without \"if\" is ignored`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=thenElse.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;\nconst codegen_1 = require(\"../compile/codegen\");\nconst util_1 = require(\"../compile/util\");\nconst names_1 = require(\"../compile/names\");\nconst util_2 = require(\"../compile/util\");\nfunction checkReportMissingProp(cxt, prop) {\n    const { gen, data, it } = cxt;\n    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);\n        cxt.error();\n    });\n}\nexports.checkReportMissingProp = checkReportMissingProp;\nfunction checkMissingProp({ gen, data, it: { opts } }, properties, missing) {\n    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));\n}\nexports.checkMissingProp = checkMissingProp;\nfunction reportMissingProp(cxt, missing) {\n    cxt.setParams({ missingProperty: missing }, true);\n    cxt.error();\n}\nexports.reportMissingProp = reportMissingProp;\nfunction hasPropFunc(gen) {\n    return gen.scopeValue(\"func\", {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        ref: Object.prototype.hasOwnProperty,\n        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,\n    });\n}\nexports.hasPropFunc = hasPropFunc;\nfunction isOwnProperty(gen, data, property) {\n    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;\n}\nexports.isOwnProperty = isOwnProperty;\nfunction propertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;\n    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;\n}\nexports.propertyInData = propertyInData;\nfunction noPropertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;\n    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;\n}\nexports.noPropertyInData = noPropertyInData;\nfunction allSchemaProperties(schemaMap) {\n    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : [];\n}\nexports.allSchemaProperties = allSchemaProperties;\nfunction schemaProperties(it, schemaMap) {\n    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));\n}\nexports.schemaProperties = schemaProperties;\nfunction callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {\n    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;\n    const valCxt = [\n        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],\n        [names_1.default.parentData, it.parentData],\n        [names_1.default.parentDataProperty, it.parentDataProperty],\n        [names_1.default.rootData, names_1.default.rootData],\n    ];\n    if (it.opts.dynamicRef)\n        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);\n    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;\n    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;\n}\nexports.callValidateCode = callValidateCode;\nconst newRegExp = (0, codegen_1._) `new RegExp`;\nfunction usePattern({ gen, it: { opts } }, pattern) {\n    const u = opts.unicodeRegExp ? \"u\" : \"\";\n    const { regExp } = opts.code;\n    const rx = regExp(pattern, u);\n    return gen.scopeValue(\"pattern\", {\n        key: rx.toString(),\n        ref: rx,\n        code: (0, codegen_1._) `${regExp.code === \"new RegExp\" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,\n    });\n}\nexports.usePattern = usePattern;\nfunction validateArray(cxt) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    if (it.allErrors) {\n        const validArr = gen.let(\"valid\", true);\n        validateItems(() => gen.assign(validArr, false));\n        return validArr;\n    }\n    gen.var(valid, true);\n    validateItems(() => gen.break());\n    return valid;\n    function validateItems(notValid) {\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        gen.forRange(\"i\", 0, len, (i) => {\n            cxt.subschema({\n                keyword,\n                dataProp: i,\n                dataPropType: util_1.Type.Num,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), notValid);\n        });\n    }\n}\nexports.validateArray = validateArray;\nfunction validateUnion(cxt) {\n    const { gen, schema, keyword, it } = cxt;\n    /* istanbul ignore if */\n    if (!Array.isArray(schema))\n        throw new Error(\"ajv implementation error\");\n    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));\n    if (alwaysValid && !it.opts.unevaluated)\n        return;\n    const valid = gen.let(\"valid\", false);\n    const schValid = gen.name(\"_valid\");\n    gen.block(() => schema.forEach((_sch, i) => {\n        const schCxt = cxt.subschema({\n            keyword,\n            schemaProp: i,\n            compositeRule: true,\n        }, schValid);\n        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);\n        const merged = cxt.mergeValidEvaluated(schCxt, schValid);\n        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n        // or if all properties and items were evaluated (it.props === true && it.items === true)\n        if (!merged)\n            gen.if((0, codegen_1.not)(valid));\n    }));\n    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n}\nexports.validateUnion = validateUnion;\n//# sourceMappingURL=code.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst def = {\n    keyword: \"id\",\n    code() {\n        throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID');\n    },\n};\nexports.default = def;\n//# sourceMappingURL=id.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst id_1 = require(\"./id\");\nconst ref_1 = require(\"./ref\");\nconst core = [\n    \"$schema\",\n    \"$id\",\n    \"$defs\",\n    \"$vocabulary\",\n    { keyword: \"$comment\" },\n    \"definitions\",\n    id_1.default,\n    ref_1.default,\n];\nexports.default = core;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"$ref\",\n    schemaType: \"string\",\n    code(cxt) {\n        const { gen, schema: $ref, it } = cxt;\n        const { baseId, schemaEnv: env, validateName, opts, self } = it;\n        const { root } = env;\n        if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId)\n            return callRootRef();\n        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n        if (schOrEnv === undefined)\n            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n        if (schOrEnv instanceof compile_1.SchemaEnv)\n            return callValidate(schOrEnv);\n        return inlineRefSchema(schOrEnv);\n        function callRootRef() {\n            if (env === root)\n                return callRef(cxt, validateName, env, env.$async);\n            const rootName = gen.scopeValue(\"root\", { ref: root });\n            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);\n        }\n        function callValidate(sch) {\n            const v = getValidate(cxt, sch);\n            callRef(cxt, v, sch, sch.$async);\n        }\n        function inlineRefSchema(sch) {\n            const schName = gen.scopeValue(\"schema\", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });\n            const valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({\n                schema: sch,\n                dataTypes: [],\n                schemaPath: codegen_1.nil,\n                topSchemaRef: schName,\n                errSchemaPath: $ref,\n            }, valid);\n            cxt.mergeEvaluated(schCxt);\n            cxt.ok(valid);\n        }\n    },\n};\nfunction getValidate(cxt, sch) {\n    const { gen } = cxt;\n    return sch.validate\n        ? gen.scopeValue(\"validate\", { ref: sch.validate })\n        : (0, codegen_1._) `${gen.scopeValue(\"wrapper\", { ref: sch })}.validate`;\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n    const { gen, it } = cxt;\n    const { allErrors, schemaEnv: env, opts } = it;\n    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n    if ($async)\n        callAsyncRef();\n    else\n        callSyncRef();\n    function callAsyncRef() {\n        if (!env.$async)\n            throw new Error(\"async schema referenced by sync schema\");\n        const valid = gen.let(\"valid\");\n        gen.try(() => {\n            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n            if (!allErrors)\n                gen.assign(valid, true);\n        }, (e) => {\n            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n            addErrorsFrom(e);\n            if (!allErrors)\n                gen.assign(valid, false);\n        });\n        cxt.ok(valid);\n    }\n    function callSyncRef() {\n        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n    }\n    function addErrorsFrom(source) {\n        const errs = (0, codegen_1._) `${source}.errors`;\n        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n    }\n    function addEvaluatedFrom(source) {\n        var _a;\n        if (!it.opts.unevaluated)\n            return;\n        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n        // TODO refactor\n        if (it.props !== true) {\n            if (schEvaluated && !schEvaluated.dynamicProps) {\n                if (schEvaluated.props !== undefined) {\n                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n                }\n            }\n            else {\n                const props = gen.var(\"props\", (0, codegen_1._) `${source}.evaluated.props`);\n                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n            }\n        }\n        if (it.items !== true) {\n            if (schEvaluated && !schEvaluated.dynamicItems) {\n                if (schEvaluated.items !== undefined) {\n                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n                }\n            }\n            else {\n                const items = gen.var(\"items\", (0, codegen_1._) `${source}.evaluated.items`);\n                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n            }\n        }\n    }\n}\nexports.callRef = callRef;\nexports.default = def;\n//# sourceMappingURL=ref.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst types_1 = require(\"../discriminator/types\");\nconst compile_1 = require(\"../../compile\");\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag\n        ? `tag \"${tagName}\" must be string`\n        : `value of tag \"${tagName}\" must be in oneOf`,\n    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n};\nconst def = {\n    keyword: \"discriminator\",\n    type: \"object\",\n    schemaType: \"object\",\n    error,\n    code(cxt) {\n        const { gen, data, schema, parentSchema, it } = cxt;\n        const { oneOf } = parentSchema;\n        if (!it.opts.discriminator) {\n            throw new Error(\"discriminator: requires discriminator option\");\n        }\n        const tagName = schema.propertyName;\n        if (typeof tagName != \"string\")\n            throw new Error(\"discriminator: requires propertyName\");\n        if (schema.mapping)\n            throw new Error(\"discriminator: mapping is not supported\");\n        if (!oneOf)\n            throw new Error(\"discriminator: requires oneOf keyword\");\n        const valid = gen.let(\"valid\", false);\n        const tag = gen.const(\"tag\", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);\n        gen.if((0, codegen_1._) `typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));\n        cxt.ok(valid);\n        function validateMapping() {\n            const mapping = getMapping();\n            gen.if(false);\n            for (const tagValue in mapping) {\n                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);\n                gen.assign(valid, applyTagSchema(mapping[tagValue]));\n            }\n            gen.else();\n            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });\n            gen.endIf();\n        }\n        function applyTagSchema(schemaProp) {\n            const _valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({ keyword: \"oneOf\", schemaProp }, _valid);\n            cxt.mergeEvaluated(schCxt, codegen_1.Name);\n            return _valid;\n        }\n        function getMapping() {\n            var _a;\n            const oneOfMapping = {};\n            const topRequired = hasRequired(parentSchema);\n            let tagRequired = true;\n            for (let i = 0; i < oneOf.length; i++) {\n                let sch = oneOf[i];\n                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n                    const ref = sch.$ref;\n                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);\n                    if (sch instanceof compile_1.SchemaEnv)\n                        sch = sch.schema;\n                    if (sch === undefined)\n                        throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);\n                }\n                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n                if (typeof propSch != \"object\") {\n                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`);\n                }\n                tagRequired = tagRequired && (topRequired || hasRequired(sch));\n                addMappings(propSch, i);\n            }\n            if (!tagRequired)\n                throw new Error(`discriminator: \"${tagName}\" must be required`);\n            return oneOfMapping;\n            function hasRequired({ required }) {\n                return Array.isArray(required) && required.includes(tagName);\n            }\n            function addMappings(sch, i) {\n                if (sch.const) {\n                    addMapping(sch.const, i);\n                }\n                else if (sch.enum) {\n                    for (const tagValue of sch.enum) {\n                        addMapping(tagValue, i);\n                    }\n                }\n                else {\n                    throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n                }\n            }\n            function addMapping(tagValue, i) {\n                if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n                    throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n                }\n                oneOfMapping[tagValue] = i;\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DiscrError = void 0;\nvar DiscrError;\n(function (DiscrError) {\n    DiscrError[\"Tag\"] = \"tag\";\n    DiscrError[\"Mapping\"] = \"mapping\";\n})(DiscrError || (exports.DiscrError = DiscrError = {}));\n//# sourceMappingURL=types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_1 = require(\"./core\");\nconst validation_1 = require(\"./validation\");\nconst applicator_1 = require(\"./applicator\");\nconst format_1 = require(\"./format\");\nconst metadata_1 = require(\"./metadata\");\nconst draft7Vocabularies = [\n    core_1.default,\n    validation_1.default,\n    (0, applicator_1.default)(),\n    format_1.default,\n    metadata_1.metadataVocabulary,\n    metadata_1.contentVocabulary,\n];\nexports.default = draft7Vocabularies;\n//# sourceMappingURL=draft7.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match format \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"format\",\n    type: [\"number\", \"string\"],\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt, ruleType) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        const { opts, errSchemaPath, schemaEnv, self } = it;\n        if (!opts.validateFormats)\n            return;\n        if ($data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fDef = gen.const(\"fDef\", (0, codegen_1._) `${fmts}[${schemaCode}]`);\n            const fType = gen.let(\"fType\");\n            const format = gen.let(\"format\");\n            // TODO simplify\n            gen.if((0, codegen_1._) `typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || \"string\"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `\"string\"`).assign(format, fDef));\n            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n            function unknownFmt() {\n                if (opts.strictSchema === false)\n                    return codegen_1.nil;\n                return (0, codegen_1._) `${schemaCode} && !${format}`;\n            }\n            function invalidFmt() {\n                const callFormat = schemaEnv.$async\n                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n                    : (0, codegen_1._) `${format}(${data})`;\n                const validData = (0, codegen_1._) `(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n            }\n        }\n        function validateFormat() {\n            const formatDef = self.formats[schema];\n            if (!formatDef) {\n                unknownFormat();\n                return;\n            }\n            if (formatDef === true)\n                return;\n            const [fmtType, format, fmtRef] = getFormat(formatDef);\n            if (fmtType === ruleType)\n                cxt.pass(validCondition());\n            function unknownFormat() {\n                if (opts.strictSchema === false) {\n                    self.logger.warn(unknownMsg());\n                    return;\n                }\n                throw new Error(unknownMsg());\n                function unknownMsg() {\n                    return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n                }\n            }\n            function getFormat(fmtDef) {\n                const code = fmtDef instanceof RegExp\n                    ? (0, codegen_1.regexpCode)(fmtDef)\n                    : opts.code.formats\n                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`\n                        : undefined;\n                const fmt = gen.scopeValue(\"formats\", { key: schema, ref: fmtDef, code });\n                if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n                    return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];\n                }\n                return [\"string\", fmtDef, fmt];\n            }\n            function validCondition() {\n                if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n                    if (!schemaEnv.$async)\n                        throw new Error(\"async format in sync schema\");\n                    return (0, codegen_1._) `await ${fmtRef}(${data})`;\n                }\n                return typeof format == \"function\" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=format.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst format_1 = require(\"./format\");\nconst format = [format_1.default];\nexports.default = format;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.contentVocabulary = exports.metadataVocabulary = void 0;\nexports.metadataVocabulary = [\n    \"title\",\n    \"description\",\n    \"default\",\n    \"deprecated\",\n    \"readOnly\",\n    \"writeOnly\",\n    \"examples\",\n];\nexports.contentVocabulary = [\n    \"contentMediaType\",\n    \"contentEncoding\",\n    \"contentSchema\",\n];\n//# sourceMappingURL=metadata.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: \"must be equal to constant\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"const\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schemaCode, schema } = cxt;\n        if ($data || (schema && typeof schema == \"object\")) {\n            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);\n        }\n        else {\n            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=const.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: \"must be equal to one of the allowed values\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"enum\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        if (!$data && schema.length === 0)\n            throw new Error(\"enum must have non-empty array\");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        let eql;\n        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));\n        let valid;\n        if (useLoop || $data) {\n            valid = gen.let(\"valid\");\n            cxt.block$data(valid, loopEnum);\n        }\n        else {\n            /* istanbul ignore if */\n            if (!Array.isArray(schema))\n                throw new Error(\"ajv implementation error\");\n            const vSchema = gen.const(\"vSchema\", schemaCode);\n            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n            gen.assign(valid, false);\n            gen.forOf(\"v\", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n            const sch = schema[i];\n            return typeof sch === \"object\" && sch !== null\n                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`\n                : (0, codegen_1._) `${data} === ${sch}`;\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=enum.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst limitNumber_1 = require(\"./limitNumber\");\nconst multipleOf_1 = require(\"./multipleOf\");\nconst limitLength_1 = require(\"./limitLength\");\nconst pattern_1 = require(\"./pattern\");\nconst limitProperties_1 = require(\"./limitProperties\");\nconst required_1 = require(\"./required\");\nconst limitItems_1 = require(\"./limitItems\");\nconst uniqueItems_1 = require(\"./uniqueItems\");\nconst const_1 = require(\"./const\");\nconst enum_1 = require(\"./enum\");\nconst validation = [\n    // number\n    limitNumber_1.default,\n    multipleOf_1.default,\n    // string\n    limitLength_1.default,\n    pattern_1.default,\n    // object\n    limitProperties_1.default,\n    required_1.default,\n    // array\n    limitItems_1.default,\n    uniqueItems_1.default,\n    // any\n    { keyword: \"type\", schemaType: [\"string\", \"array\"] },\n    { keyword: \"nullable\", schemaType: \"boolean\" },\n    const_1.default,\n    enum_1.default,\n];\nexports.default = validation;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxItems\", \"minItems\"],\n    type: \"array\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxItems\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitItems.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst ucs2length_1 = require(\"../../runtime/ucs2length\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxLength\", \"minLength\"],\n    type: \"string\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode, it } = cxt;\n        const op = keyword === \"maxLength\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;\n        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitLength.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n    maximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n    minimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n    exclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n    exclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE },\n};\nconst error = {\n    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: Object.keys(KWDs),\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitNumber.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} properties`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxProperties\", \"minProperties\"],\n    type: \"object\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxProperties\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitProperties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"multipleOf\",\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, schemaCode, it } = cxt;\n        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n        const prec = it.opts.multipleOfPrecision;\n        const res = gen.let(\"res\");\n        const invalid = prec\n            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n            : (0, codegen_1._) `${res} !== parseInt(${res})`;\n        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=multipleOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"pattern\",\n    type: \"string\",\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { data, $data, schema, schemaCode, it } = cxt;\n        // TODO regexp should be wrapped in try/catchs\n        const u = it.opts.unicodeRegExp ? \"u\" : \"\";\n        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);\n        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=pattern.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,\n    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,\n};\nconst def = {\n    keyword: \"required\",\n    type: \"object\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, schema, schemaCode, data, $data, it } = cxt;\n        const { opts } = it;\n        if (!$data && schema.length === 0)\n            return;\n        const useLoop = schema.length >= opts.loopRequired;\n        if (it.allErrors)\n            allErrorsMode();\n        else\n            exitOnErrorMode();\n        if (opts.strictRequired) {\n            const props = cxt.parentSchema.properties;\n            const { definedProperties } = cxt.it;\n            for (const requiredKey of schema) {\n                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n                    const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n                }\n            }\n        }\n        function allErrorsMode() {\n            if (useLoop || $data) {\n                cxt.block$data(codegen_1.nil, loopAllRequired);\n            }\n            else {\n                for (const prop of schema) {\n                    (0, code_1.checkReportMissingProp)(cxt, prop);\n                }\n            }\n        }\n        function exitOnErrorMode() {\n            const missing = gen.let(\"missing\");\n            if (useLoop || $data) {\n                const valid = gen.let(\"valid\", true);\n                cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n                cxt.ok(valid);\n            }\n            else {\n                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n                (0, code_1.reportMissingProp)(cxt, missing);\n                gen.else();\n            }\n        }\n        function loopAllRequired() {\n            gen.forOf(\"prop\", schemaCode, (prop) => {\n                cxt.setParams({ missingProperty: prop });\n                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n            });\n        }\n        function loopUntilMissing(missing, valid) {\n            cxt.setParams({ missingProperty: missing });\n            gen.forOf(missing, schemaCode, () => {\n                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n                gen.if((0, codegen_1.not)(valid), () => {\n                    cxt.error();\n                    gen.break();\n                });\n            }, codegen_1.nil);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=required.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dataType_1 = require(\"../../compile/validate/dataType\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,\n};\nconst def = {\n    keyword: \"uniqueItems\",\n    type: \"array\",\n    schemaType: \"boolean\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;\n        if (!$data && !schema)\n            return;\n        const valid = gen.let(\"valid\");\n        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];\n        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);\n        cxt.ok(valid);\n        function validateUniqueItems() {\n            const i = gen.let(\"i\", (0, codegen_1._) `${data}.length`);\n            const j = gen.let(\"j\");\n            cxt.setParams({ i, j });\n            gen.assign(valid, true);\n            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n        }\n        function canOptimize() {\n            return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\");\n        }\n        function loopN(i, j) {\n            const item = gen.name(\"item\");\n            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n            const indices = gen.const(\"indices\", (0, codegen_1._) `{}`);\n            gen.for((0, codegen_1._) `;${i}--;`, () => {\n                gen.let(item, (0, codegen_1._) `${data}[${i}]`);\n                gen.if(wrongType, (0, codegen_1._) `continue`);\n                if (itemTypes.length > 1)\n                    gen.if((0, codegen_1._) `typeof ${item} == \"string\"`, (0, codegen_1._) `${item} += \"_\"`);\n                gen\n                    .if((0, codegen_1._) `typeof ${indices}[${item}] == \"number\"`, () => {\n                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);\n                    cxt.error();\n                    gen.assign(valid, false).break();\n                })\n                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);\n            });\n        }\n        function loopN2(i, j) {\n            const eql = (0, util_1.useFunc)(gen, equal_1.default);\n            const outer = gen.name(\"outer\");\n            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {\n                cxt.error();\n                gen.assign(valid, false).break(outer);\n            })));\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=uniqueItems.js.map","'use strict';\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n","export const ignoreOverride = Symbol(\"Let zodToJsonSchema decide on which parser to use\");\nexport const jsonDescription = (jsonSchema, def) => {\n    if (def.description) {\n        try {\n            return {\n                ...jsonSchema,\n                ...JSON.parse(def.description),\n            };\n        }\n        catch { }\n    }\n    return jsonSchema;\n};\nexport const defaultOptions = {\n    name: undefined,\n    $refStrategy: \"root\",\n    basePath: [\"#\"],\n    effectStrategy: \"input\",\n    pipeStrategy: \"all\",\n    dateStrategy: \"format:date-time\",\n    mapStrategy: \"entries\",\n    removeAdditionalStrategy: \"passthrough\",\n    allowedAdditionalProperties: true,\n    rejectedAdditionalProperties: false,\n    definitionPath: \"definitions\",\n    target: \"jsonSchema7\",\n    strictUnions: false,\n    definitions: {},\n    errorMessages: false,\n    markdownDescription: false,\n    patternStrategy: \"escape\",\n    applyRegexFlags: false,\n    emailStrategy: \"format:email\",\n    base64Strategy: \"contentEncoding:base64\",\n    nameStrategy: \"ref\",\n    openAiAnyTypeName: \"OpenAiAnyType\"\n};\nexport const getDefaultOptions = (options) => (typeof options === \"string\"\n    ? {\n        ...defaultOptions,\n        name: options,\n    }\n    : {\n        ...defaultOptions,\n        ...options,\n    });\n","import { getDefaultOptions } from \"./Options.js\";\nexport const getRefs = (options) => {\n    const _options = getDefaultOptions(options);\n    const currentPath = _options.name !== undefined\n        ? [..._options.basePath, _options.definitionPath, _options.name]\n        : _options.basePath;\n    return {\n        ..._options,\n        flags: { hasReferencedOpenAiAnyType: false },\n        currentPath: currentPath,\n        propertyPath: undefined,\n        seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [\n            def._def,\n            {\n                def: def._def,\n                path: [..._options.basePath, _options.definitionPath, name],\n                // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n                jsonSchema: undefined,\n            },\n        ])),\n    };\n};\n","export function addErrorMessage(res, key, errorMessage, refs) {\n    if (!refs?.errorMessages)\n        return;\n    if (errorMessage) {\n        res.errorMessage = {\n            ...res.errorMessage,\n            [key]: errorMessage,\n        };\n    }\n}\nexport function setResponseValueAndErrors(res, key, value, errorMessage, refs) {\n    res[key] = value;\n    addErrorMessage(res, key, errorMessage, refs);\n}\n","export const getRelativePath = (pathA, pathB) => {\n    let i = 0;\n    for (; i < pathA.length && i < pathB.length; i++) {\n        if (pathA[i] !== pathB[i])\n            break;\n    }\n    return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n};\n","export * from \"./Options.js\";\nexport * from \"./Refs.js\";\nexport * from \"./errorMessages.js\";\nexport * from \"./getRelativePath.js\";\nexport * from \"./parseDef.js\";\nexport * from \"./parseTypes.js\";\nexport * from \"./parsers/any.js\";\nexport * from \"./parsers/array.js\";\nexport * from \"./parsers/bigint.js\";\nexport * from \"./parsers/boolean.js\";\nexport * from \"./parsers/branded.js\";\nexport * from \"./parsers/catch.js\";\nexport * from \"./parsers/date.js\";\nexport * from \"./parsers/default.js\";\nexport * from \"./parsers/effects.js\";\nexport * from \"./parsers/enum.js\";\nexport * from \"./parsers/intersection.js\";\nexport * from \"./parsers/literal.js\";\nexport * from \"./parsers/map.js\";\nexport * from \"./parsers/nativeEnum.js\";\nexport * from \"./parsers/never.js\";\nexport * from \"./parsers/null.js\";\nexport * from \"./parsers/nullable.js\";\nexport * from \"./parsers/number.js\";\nexport * from \"./parsers/object.js\";\nexport * from \"./parsers/optional.js\";\nexport * from \"./parsers/pipeline.js\";\nexport * from \"./parsers/promise.js\";\nexport * from \"./parsers/readonly.js\";\nexport * from \"./parsers/record.js\";\nexport * from \"./parsers/set.js\";\nexport * from \"./parsers/string.js\";\nexport * from \"./parsers/tuple.js\";\nexport * from \"./parsers/undefined.js\";\nexport * from \"./parsers/union.js\";\nexport * from \"./parsers/unknown.js\";\nexport * from \"./selectParser.js\";\nexport * from \"./zodToJsonSchema.js\";\nimport { zodToJsonSchema } from \"./zodToJsonSchema.js\";\nexport default zodToJsonSchema;\n","import { ignoreOverride } from \"./Options.js\";\nimport { selectParser } from \"./selectParser.js\";\nimport { getRelativePath } from \"./getRelativePath.js\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nexport function parseDef(def, refs, forceResolution = false) {\n    const seenItem = refs.seen.get(def);\n    if (refs.override) {\n        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n        if (overrideResult !== ignoreOverride) {\n            return overrideResult;\n        }\n    }\n    if (seenItem && !forceResolution) {\n        const seenSchema = get$ref(seenItem, refs);\n        if (seenSchema !== undefined) {\n            return seenSchema;\n        }\n    }\n    const newItem = { def, path: refs.currentPath, jsonSchema: undefined };\n    refs.seen.set(def, newItem);\n    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n    // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)\n    const jsonSchema = typeof jsonSchemaOrGetter === \"function\"\n        ? parseDef(jsonSchemaOrGetter(), refs)\n        : jsonSchemaOrGetter;\n    if (jsonSchema) {\n        addMeta(def, refs, jsonSchema);\n    }\n    if (refs.postProcess) {\n        const postProcessResult = refs.postProcess(jsonSchema, def, refs);\n        newItem.jsonSchema = jsonSchema;\n        return postProcessResult;\n    }\n    newItem.jsonSchema = jsonSchema;\n    return jsonSchema;\n}\nconst get$ref = (item, refs) => {\n    switch (refs.$refStrategy) {\n        case \"root\":\n            return { $ref: item.path.join(\"/\") };\n        case \"relative\":\n            return { $ref: getRelativePath(refs.currentPath, item.path) };\n        case \"none\":\n        case \"seen\": {\n            if (item.path.length < refs.currentPath.length &&\n                item.path.every((value, index) => refs.currentPath[index] === value)) {\n                console.warn(`Recursive reference detected at ${refs.currentPath.join(\"/\")}! Defaulting to any`);\n                return parseAnyDef(refs);\n            }\n            return refs.$refStrategy === \"seen\" ? parseAnyDef(refs) : undefined;\n        }\n    }\n};\nconst addMeta = (def, refs, jsonSchema) => {\n    if (def.description) {\n        jsonSchema.description = def.description;\n        if (refs.markdownDescription) {\n            jsonSchema.markdownDescription = def.description;\n        }\n    }\n    return jsonSchema;\n};\n","export {};\n","import { getRelativePath } from \"../getRelativePath.js\";\nexport function parseAnyDef(refs) {\n    if (refs.target !== \"openAi\") {\n        return {};\n    }\n    const anyDefinitionPath = [\n        ...refs.basePath,\n        refs.definitionPath,\n        refs.openAiAnyTypeName,\n    ];\n    refs.flags.hasReferencedOpenAiAnyType = true;\n    return {\n        $ref: refs.$refStrategy === \"relative\"\n            ? getRelativePath(anyDefinitionPath, refs.currentPath)\n            : anyDefinitionPath.join(\"/\"),\n    };\n}\n","import { ZodFirstPartyTypeKind } from \"zod/v3\";\nimport { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseArrayDef(def, refs) {\n    const res = {\n        type: \"array\",\n    };\n    if (def.type?._def &&\n        def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {\n        res.items = parseDef(def.type._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"items\"],\n        });\n    }\n    if (def.minLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.minLength.value, def.minLength.message, refs);\n    }\n    if (def.maxLength) {\n        setResponseValueAndErrors(res, \"maxItems\", def.maxLength.value, def.maxLength.message, refs);\n    }\n    if (def.exactLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.exactLength.value, def.exactLength.message, refs);\n        setResponseValueAndErrors(res, \"maxItems\", def.exactLength.value, def.exactLength.message, refs);\n    }\n    return res;\n}\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseBigintDef(def, refs) {\n    const res = {\n        type: \"integer\",\n        format: \"int64\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n","export function parseBooleanDef() {\n    return {\n        type: \"boolean\",\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseBrandedDef(_def, refs) {\n    return parseDef(_def.type._def, refs);\n}\n","import { parseDef } from \"../parseDef.js\";\nexport const parseCatchDef = (def, refs) => {\n    return parseDef(def.innerType._def, refs);\n};\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseDateDef(def, refs, overrideDateStrategy) {\n    const strategy = overrideDateStrategy ?? refs.dateStrategy;\n    if (Array.isArray(strategy)) {\n        return {\n            anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)),\n        };\n    }\n    switch (strategy) {\n        case \"string\":\n        case \"format:date-time\":\n            return {\n                type: \"string\",\n                format: \"date-time\",\n            };\n        case \"format:date\":\n            return {\n                type: \"string\",\n                format: \"date\",\n            };\n        case \"integer\":\n            return integerDateParser(def, refs);\n    }\n}\nconst integerDateParser = (def, refs) => {\n    const res = {\n        type: \"integer\",\n        format: \"unix-time\",\n    };\n    if (refs.target === \"openApi3\") {\n        return res;\n    }\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                setResponseValueAndErrors(res, \"minimum\", check.value, // This is in milliseconds\n                check.message, refs);\n                break;\n            case \"max\":\n                setResponseValueAndErrors(res, \"maximum\", check.value, // This is in milliseconds\n                check.message, refs);\n                break;\n        }\n    }\n    return res;\n};\n","import { parseDef } from \"../parseDef.js\";\nexport function parseDefaultDef(_def, refs) {\n    return {\n        ...parseDef(_def.innerType._def, refs),\n        default: _def.defaultValue(),\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport function parseEffectsDef(_def, refs) {\n    return refs.effectStrategy === \"input\"\n        ? parseDef(_def.schema._def, refs)\n        : parseAnyDef(refs);\n}\n","export function parseEnumDef(def) {\n    return {\n        type: \"string\",\n        enum: Array.from(def.values),\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nconst isJsonSchema7AllOfType = (type) => {\n    if (\"type\" in type && type.type === \"string\")\n        return false;\n    return \"allOf\" in type;\n};\nexport function parseIntersectionDef(def, refs) {\n    const allOf = [\n        parseDef(def.left._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n        }),\n        parseDef(def.right._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"1\"],\n        }),\n    ].filter((x) => !!x);\n    let unevaluatedProperties = refs.target === \"jsonSchema2019-09\"\n        ? { unevaluatedProperties: false }\n        : undefined;\n    const mergedAllOf = [];\n    // If either of the schemas is an allOf, merge them into a single allOf\n    allOf.forEach((schema) => {\n        if (isJsonSchema7AllOfType(schema)) {\n            mergedAllOf.push(...schema.allOf);\n            if (schema.unevaluatedProperties === undefined) {\n                // If one of the schemas has no unevaluatedProperties set,\n                // the merged schema should also have no unevaluatedProperties set\n                unevaluatedProperties = undefined;\n            }\n        }\n        else {\n            let nestedSchema = schema;\n            if (\"additionalProperties\" in schema &&\n                schema.additionalProperties === false) {\n                const { additionalProperties, ...rest } = schema;\n                nestedSchema = rest;\n            }\n            else {\n                // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n                unevaluatedProperties = undefined;\n            }\n            mergedAllOf.push(nestedSchema);\n        }\n    });\n    return mergedAllOf.length\n        ? {\n            allOf: mergedAllOf,\n            ...unevaluatedProperties,\n        }\n        : undefined;\n}\n","export function parseLiteralDef(def, refs) {\n    const parsedType = typeof def.value;\n    if (parsedType !== \"bigint\" &&\n        parsedType !== \"number\" &&\n        parsedType !== \"boolean\" &&\n        parsedType !== \"string\") {\n        return {\n            type: Array.isArray(def.value) ? \"array\" : \"object\",\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        return {\n            type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n            enum: [def.value],\n        };\n    }\n    return {\n        type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n        const: def.value,\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nimport { parseRecordDef } from \"./record.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport function parseMapDef(def, refs) {\n    if (refs.mapStrategy === \"record\") {\n        return parseRecordDef(def, refs);\n    }\n    const keys = parseDef(def.keyType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"0\"],\n    }) || parseAnyDef(refs);\n    const values = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"1\"],\n    }) || parseAnyDef(refs);\n    return {\n        type: \"array\",\n        maxItems: 125,\n        items: {\n            type: \"array\",\n            items: [keys, values],\n            minItems: 2,\n            maxItems: 2,\n        },\n    };\n}\n","export function parseNativeEnumDef(def) {\n    const object = def.values;\n    const actualKeys = Object.keys(def.values).filter((key) => {\n        return typeof object[object[key]] !== \"number\";\n    });\n    const actualValues = actualKeys.map((key) => object[key]);\n    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));\n    return {\n        type: parsedTypes.length === 1\n            ? parsedTypes[0] === \"string\"\n                ? \"string\"\n                : \"number\"\n            : [\"string\", \"number\"],\n        enum: actualValues,\n    };\n}\n","import { parseAnyDef } from \"./any.js\";\nexport function parseNeverDef(refs) {\n    return refs.target === \"openAi\"\n        ? undefined\n        : {\n            not: parseAnyDef({\n                ...refs,\n                currentPath: [...refs.currentPath, \"not\"],\n            }),\n        };\n}\n","export function parseNullDef(refs) {\n    return refs.target === \"openApi3\"\n        ? {\n            enum: [\"null\"],\n            nullable: true,\n        }\n        : {\n            type: \"null\",\n        };\n}\n","import { parseDef } from \"../parseDef.js\";\nimport { primitiveMappings } from \"./union.js\";\nexport function parseNullableDef(def, refs) {\n    if ([\"ZodString\", \"ZodNumber\", \"ZodBigInt\", \"ZodBoolean\", \"ZodNull\"].includes(def.innerType._def.typeName) &&\n        (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n        if (refs.target === \"openApi3\") {\n            return {\n                type: primitiveMappings[def.innerType._def.typeName],\n                nullable: true,\n            };\n        }\n        return {\n            type: [\n                primitiveMappings[def.innerType._def.typeName],\n                \"null\",\n            ],\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        const base = parseDef(def.innerType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath],\n        });\n        if (base && \"$ref\" in base)\n            return { allOf: [base], nullable: true };\n        return base && { ...base, nullable: true };\n    }\n    const base = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"0\"],\n    });\n    return base && { anyOf: [base, { type: \"null\" }] };\n}\n","import { addErrorMessage, setResponseValueAndErrors, } from \"../errorMessages.js\";\nexport function parseNumberDef(def, refs) {\n    const res = {\n        type: \"number\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"int\":\n                res.type = \"integer\";\n                addErrorMessage(res, \"type\", check.message, refs);\n                break;\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseObjectDef(def, refs) {\n    const forceOptionalIntoNullable = refs.target === \"openAi\";\n    const result = {\n        type: \"object\",\n        properties: {},\n    };\n    const required = [];\n    const shape = def.shape();\n    for (const propName in shape) {\n        let propDef = shape[propName];\n        if (propDef === undefined || propDef._def === undefined) {\n            continue;\n        }\n        let propOptional = safeIsOptional(propDef);\n        if (propOptional && forceOptionalIntoNullable) {\n            if (propDef._def.typeName === \"ZodOptional\") {\n                propDef = propDef._def.innerType;\n            }\n            if (!propDef.isNullable()) {\n                propDef = propDef.nullable();\n            }\n            propOptional = false;\n        }\n        const parsedDef = parseDef(propDef._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"properties\", propName],\n            propertyPath: [...refs.currentPath, \"properties\", propName],\n        });\n        if (parsedDef === undefined) {\n            continue;\n        }\n        result.properties[propName] = parsedDef;\n        if (!propOptional) {\n            required.push(propName);\n        }\n    }\n    if (required.length) {\n        result.required = required;\n    }\n    const additionalProperties = decideAdditionalProperties(def, refs);\n    if (additionalProperties !== undefined) {\n        result.additionalProperties = additionalProperties;\n    }\n    return result;\n}\nfunction decideAdditionalProperties(def, refs) {\n    if (def.catchall._def.typeName !== \"ZodNever\") {\n        return parseDef(def.catchall._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"additionalProperties\"],\n        });\n    }\n    switch (def.unknownKeys) {\n        case \"passthrough\":\n            return refs.allowedAdditionalProperties;\n        case \"strict\":\n            return refs.rejectedAdditionalProperties;\n        case \"strip\":\n            return refs.removeAdditionalStrategy === \"strict\"\n                ? refs.allowedAdditionalProperties\n                : refs.rejectedAdditionalProperties;\n    }\n}\nfunction safeIsOptional(schema) {\n    try {\n        return schema.isOptional();\n    }\n    catch {\n        return true;\n    }\n}\n","import { parseDef } from \"../parseDef.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport const parseOptionalDef = (def, refs) => {\n    if (refs.currentPath.toString() === refs.propertyPath?.toString()) {\n        return parseDef(def.innerType._def, refs);\n    }\n    const innerSchema = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"1\"],\n    });\n    return innerSchema\n        ? {\n            anyOf: [\n                {\n                    not: parseAnyDef(refs),\n                },\n                innerSchema,\n            ],\n        }\n        : parseAnyDef(refs);\n};\n","import { parseDef } from \"../parseDef.js\";\nexport const parsePipelineDef = (def, refs) => {\n    if (refs.pipeStrategy === \"input\") {\n        return parseDef(def.in._def, refs);\n    }\n    else if (refs.pipeStrategy === \"output\") {\n        return parseDef(def.out._def, refs);\n    }\n    const a = parseDef(def.in._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n    });\n    const b = parseDef(def.out._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", a ? \"1\" : \"0\"],\n    });\n    return {\n        allOf: [a, b].filter((x) => x !== undefined),\n    };\n};\n","import { parseDef } from \"../parseDef.js\";\nexport function parsePromiseDef(def, refs) {\n    return parseDef(def.type._def, refs);\n}\n","import { parseDef } from \"../parseDef.js\";\nexport const parseReadonlyDef = (def, refs) => {\n    return parseDef(def.innerType._def, refs);\n};\n","import { ZodFirstPartyTypeKind, } from \"zod/v3\";\nimport { parseDef } from \"../parseDef.js\";\nimport { parseStringDef } from \"./string.js\";\nimport { parseBrandedDef } from \"./branded.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport function parseRecordDef(def, refs) {\n    if (refs.target === \"openAi\") {\n        console.warn(\"Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.\");\n    }\n    if (refs.target === \"openApi3\" &&\n        def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            type: \"object\",\n            required: def.keyType._def.values,\n            properties: def.keyType._def.values.reduce((acc, key) => ({\n                ...acc,\n                [key]: parseDef(def.valueType._def, {\n                    ...refs,\n                    currentPath: [...refs.currentPath, \"properties\", key],\n                }) ?? parseAnyDef(refs),\n            }), {}),\n            additionalProperties: refs.rejectedAdditionalProperties,\n        };\n    }\n    const schema = {\n        type: \"object\",\n        additionalProperties: parseDef(def.valueType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"additionalProperties\"],\n        }) ?? refs.allowedAdditionalProperties,\n    };\n    if (refs.target === \"openApi3\") {\n        return schema;\n    }\n    if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n        def.keyType._def.checks?.length) {\n        const { type, ...keyType } = parseStringDef(def.keyType._def, refs);\n        return {\n            ...schema,\n            propertyNames: keyType,\n        };\n    }\n    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            ...schema,\n            propertyNames: {\n                enum: def.keyType._def.values,\n            },\n        };\n    }\n    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded &&\n        def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n        def.keyType._def.type._def.checks?.length) {\n        const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);\n        return {\n            ...schema,\n            propertyNames: keyType,\n        };\n    }\n    return schema;\n}\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseSetDef(def, refs) {\n    const items = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\"],\n    });\n    const schema = {\n        type: \"array\",\n        uniqueItems: true,\n        items,\n    };\n    if (def.minSize) {\n        setResponseValueAndErrors(schema, \"minItems\", def.minSize.value, def.minSize.message, refs);\n    }\n    if (def.maxSize) {\n        setResponseValueAndErrors(schema, \"maxItems\", def.maxSize.value, def.maxSize.message, refs);\n    }\n    return schema;\n}\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nlet emojiRegex = undefined;\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n    /**\n     * `c` was changed to `[cC]` to replicate /i flag\n     */\n    cuid: /^[cC][^\\s-]{8,}$/,\n    cuid2: /^[0-9a-z]+$/,\n    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n    /**\n     * `a-z` was added to replicate /i flag\n     */\n    email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n    /**\n     * Constructed a valid Unicode RegExp\n     *\n     * Lazily instantiate since this type of regex isn't supported\n     * in all envs (e.g. React Native).\n     *\n     * See:\n     * https://github.com/colinhacks/zod/issues/2433\n     * Fix in Zod:\n     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n     */\n    emoji: () => {\n        if (emojiRegex === undefined) {\n            emojiRegex = RegExp(\"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\", \"u\");\n        }\n        return emojiRegex;\n    },\n    /**\n     * Unused\n     */\n    uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n    /**\n     * Unused\n     */\n    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n    /**\n     * Unused\n     */\n    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n    nanoid: /^[a-zA-Z0-9_-]{21}$/,\n    jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/,\n};\nexport function parseStringDef(def, refs) {\n    const res = {\n        type: \"string\",\n    };\n    if (def.checks) {\n        for (const check of def.checks) {\n            switch (check.kind) {\n                case \"min\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"max\":\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"email\":\n                    switch (refs.emailStrategy) {\n                        case \"format:email\":\n                            addFormat(res, \"email\", check.message, refs);\n                            break;\n                        case \"format:idn-email\":\n                            addFormat(res, \"idn-email\", check.message, refs);\n                            break;\n                        case \"pattern:zod\":\n                            addPattern(res, zodPatterns.email, check.message, refs);\n                            break;\n                    }\n                    break;\n                case \"url\":\n                    addFormat(res, \"uri\", check.message, refs);\n                    break;\n                case \"uuid\":\n                    addFormat(res, \"uuid\", check.message, refs);\n                    break;\n                case \"regex\":\n                    addPattern(res, check.regex, check.message, refs);\n                    break;\n                case \"cuid\":\n                    addPattern(res, zodPatterns.cuid, check.message, refs);\n                    break;\n                case \"cuid2\":\n                    addPattern(res, zodPatterns.cuid2, check.message, refs);\n                    break;\n                case \"startsWith\":\n                    addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);\n                    break;\n                case \"endsWith\":\n                    addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);\n                    break;\n                case \"datetime\":\n                    addFormat(res, \"date-time\", check.message, refs);\n                    break;\n                case \"date\":\n                    addFormat(res, \"date\", check.message, refs);\n                    break;\n                case \"time\":\n                    addFormat(res, \"time\", check.message, refs);\n                    break;\n                case \"duration\":\n                    addFormat(res, \"duration\", check.message, refs);\n                    break;\n                case \"length\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"includes\": {\n                    addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);\n                    break;\n                }\n                case \"ip\": {\n                    if (check.version !== \"v6\") {\n                        addFormat(res, \"ipv4\", check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addFormat(res, \"ipv6\", check.message, refs);\n                    }\n                    break;\n                }\n                case \"base64url\":\n                    addPattern(res, zodPatterns.base64url, check.message, refs);\n                    break;\n                case \"jwt\":\n                    addPattern(res, zodPatterns.jwt, check.message, refs);\n                    break;\n                case \"cidr\": {\n                    if (check.version !== \"v6\") {\n                        addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n                    }\n                    break;\n                }\n                case \"emoji\":\n                    addPattern(res, zodPatterns.emoji(), check.message, refs);\n                    break;\n                case \"ulid\": {\n                    addPattern(res, zodPatterns.ulid, check.message, refs);\n                    break;\n                }\n                case \"base64\": {\n                    switch (refs.base64Strategy) {\n                        case \"format:binary\": {\n                            addFormat(res, \"binary\", check.message, refs);\n                            break;\n                        }\n                        case \"contentEncoding:base64\": {\n                            setResponseValueAndErrors(res, \"contentEncoding\", \"base64\", check.message, refs);\n                            break;\n                        }\n                        case \"pattern:zod\": {\n                            addPattern(res, zodPatterns.base64, check.message, refs);\n                            break;\n                        }\n                    }\n                    break;\n                }\n                case \"nanoid\": {\n                    addPattern(res, zodPatterns.nanoid, check.message, refs);\n                }\n                case \"toLowerCase\":\n                case \"toUpperCase\":\n                case \"trim\":\n                    break;\n                default:\n                    ((_) => { })(check);\n            }\n        }\n    }\n    return res;\n}\nfunction escapeLiteralCheckValue(literal, refs) {\n    return refs.patternStrategy === \"escape\"\n        ? escapeNonAlphaNumeric(literal)\n        : literal;\n}\nconst ALPHA_NUMERIC = new Set(\"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\");\nfunction escapeNonAlphaNumeric(source) {\n    let result = \"\";\n    for (let i = 0; i < source.length; i++) {\n        if (!ALPHA_NUMERIC.has(source[i])) {\n            result += \"\\\\\";\n        }\n        result += source[i];\n    }\n    return result;\n}\n// Adds a \"format\" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.\nfunction addFormat(schema, value, message, refs) {\n    if (schema.format || schema.anyOf?.some((x) => x.format)) {\n        if (!schema.anyOf) {\n            schema.anyOf = [];\n        }\n        if (schema.format) {\n            schema.anyOf.push({\n                format: schema.format,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { format: schema.errorMessage.format },\n                }),\n            });\n            delete schema.format;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.format;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.anyOf.push({\n            format: value,\n            ...(message &&\n                refs.errorMessages && { errorMessage: { format: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"format\", value, message, refs);\n    }\n}\n// Adds a \"pattern\" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.\nfunction addPattern(schema, regex, message, refs) {\n    if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n        if (!schema.allOf) {\n            schema.allOf = [];\n        }\n        if (schema.pattern) {\n            schema.allOf.push({\n                pattern: schema.pattern,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { pattern: schema.errorMessage.pattern },\n                }),\n            });\n            delete schema.pattern;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.pattern;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.allOf.push({\n            pattern: stringifyRegExpWithFlags(regex, refs),\n            ...(message &&\n                refs.errorMessages && { errorMessage: { pattern: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"pattern\", stringifyRegExpWithFlags(regex, refs), message, refs);\n    }\n}\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nfunction stringifyRegExpWithFlags(regex, refs) {\n    if (!refs.applyRegexFlags || !regex.flags) {\n        return regex.source;\n    }\n    // Currently handled flags\n    const flags = {\n        i: regex.flags.includes(\"i\"),\n        m: regex.flags.includes(\"m\"),\n        s: regex.flags.includes(\"s\"), // `.` matches newlines\n    };\n    // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n    const source = flags.i ? regex.source.toLowerCase() : regex.source;\n    let pattern = \"\";\n    let isEscaped = false;\n    let inCharGroup = false;\n    let inCharRange = false;\n    for (let i = 0; i < source.length; i++) {\n        if (isEscaped) {\n            pattern += source[i];\n            isEscaped = false;\n            continue;\n        }\n        if (flags.i) {\n            if (inCharGroup) {\n                if (source[i].match(/[a-z]/)) {\n                    if (inCharRange) {\n                        pattern += source[i];\n                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n                        inCharRange = false;\n                    }\n                    else if (source[i + 1] === \"-\" && source[i + 2]?.match(/[a-z]/)) {\n                        pattern += source[i];\n                        inCharRange = true;\n                    }\n                    else {\n                        pattern += `${source[i]}${source[i].toUpperCase()}`;\n                    }\n                    continue;\n                }\n            }\n            else if (source[i].match(/[a-z]/)) {\n                pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n                continue;\n            }\n        }\n        if (flags.m) {\n            if (source[i] === \"^\") {\n                pattern += `(^|(?<=[\\r\\n]))`;\n                continue;\n            }\n            else if (source[i] === \"$\") {\n                pattern += `($|(?=[\\r\\n]))`;\n                continue;\n            }\n        }\n        if (flags.s && source[i] === \".\") {\n            pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n            continue;\n        }\n        pattern += source[i];\n        if (source[i] === \"\\\\\") {\n            isEscaped = true;\n        }\n        else if (inCharGroup && source[i] === \"]\") {\n            inCharGroup = false;\n        }\n        else if (!inCharGroup && source[i] === \"[\") {\n            inCharGroup = true;\n        }\n    }\n    try {\n        new RegExp(pattern);\n    }\n    catch {\n        console.warn(`Could not convert regex pattern at ${refs.currentPath.join(\"/\")} to a flag-independent form! Falling back to the flag-ignorant source`);\n        return regex.source;\n    }\n    return pattern;\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseTupleDef(def, refs) {\n    if (def.rest) {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n            additionalItems: parseDef(def.rest._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"additionalItems\"],\n            }),\n        };\n    }\n    else {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            maxItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n        };\n    }\n}\n","import { parseAnyDef } from \"./any.js\";\nexport function parseUndefinedDef(refs) {\n    return {\n        not: parseAnyDef(refs),\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nexport const primitiveMappings = {\n    ZodString: \"string\",\n    ZodNumber: \"number\",\n    ZodBigInt: \"integer\",\n    ZodBoolean: \"boolean\",\n    ZodNull: \"null\",\n};\nexport function parseUnionDef(def, refs) {\n    if (refs.target === \"openApi3\")\n        return asAnyOf(def, refs);\n    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n    // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n    if (options.every((x) => x._def.typeName in primitiveMappings &&\n        (!x._def.checks || !x._def.checks.length))) {\n        // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n        const types = options.reduce((types, x) => {\n            const type = primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43\n            return type && !types.includes(type) ? [...types, type] : types;\n        }, []);\n        return {\n            type: types.length > 1 ? types : types[0],\n        };\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n        // all options literals\n        const types = options.reduce((acc, x) => {\n            const type = typeof x._def.value;\n            switch (type) {\n                case \"string\":\n                case \"number\":\n                case \"boolean\":\n                    return [...acc, type];\n                case \"bigint\":\n                    return [...acc, \"integer\"];\n                case \"object\":\n                    if (x._def.value === null)\n                        return [...acc, \"null\"];\n                case \"symbol\":\n                case \"undefined\":\n                case \"function\":\n                default:\n                    return acc;\n            }\n        }, []);\n        if (types.length === options.length) {\n            // all the literals are primitive, as far as null can be considered primitive\n            const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n            return {\n                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n                enum: options.reduce((acc, x) => {\n                    return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n                }, []),\n            };\n        }\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodEnum\")) {\n        return {\n            type: \"string\",\n            enum: options.reduce((acc, x) => [\n                ...acc,\n                ...x._def.values.filter((x) => !acc.includes(x)),\n            ], []),\n        };\n    }\n    return asAnyOf(def, refs);\n}\nconst asAnyOf = (def, refs) => {\n    const anyOf = (def.options instanceof Map\n        ? Array.from(def.options.values())\n        : def.options)\n        .map((x, i) => parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", `${i}`],\n    }))\n        .filter((x) => !!x &&\n        (!refs.strictUnions ||\n            (typeof x === \"object\" && Object.keys(x).length > 0)));\n    return anyOf.length ? { anyOf } : undefined;\n};\n","import { parseAnyDef } from \"./any.js\";\nexport function parseUnknownDef(refs) {\n    return parseAnyDef(refs);\n}\n","import { ZodFirstPartyTypeKind } from \"zod/v3\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nimport { parseArrayDef } from \"./parsers/array.js\";\nimport { parseBigintDef } from \"./parsers/bigint.js\";\nimport { parseBooleanDef } from \"./parsers/boolean.js\";\nimport { parseBrandedDef } from \"./parsers/branded.js\";\nimport { parseCatchDef } from \"./parsers/catch.js\";\nimport { parseDateDef } from \"./parsers/date.js\";\nimport { parseDefaultDef } from \"./parsers/default.js\";\nimport { parseEffectsDef } from \"./parsers/effects.js\";\nimport { parseEnumDef } from \"./parsers/enum.js\";\nimport { parseIntersectionDef } from \"./parsers/intersection.js\";\nimport { parseLiteralDef } from \"./parsers/literal.js\";\nimport { parseMapDef } from \"./parsers/map.js\";\nimport { parseNativeEnumDef } from \"./parsers/nativeEnum.js\";\nimport { parseNeverDef } from \"./parsers/never.js\";\nimport { parseNullDef } from \"./parsers/null.js\";\nimport { parseNullableDef } from \"./parsers/nullable.js\";\nimport { parseNumberDef } from \"./parsers/number.js\";\nimport { parseObjectDef } from \"./parsers/object.js\";\nimport { parseOptionalDef } from \"./parsers/optional.js\";\nimport { parsePipelineDef } from \"./parsers/pipeline.js\";\nimport { parsePromiseDef } from \"./parsers/promise.js\";\nimport { parseRecordDef } from \"./parsers/record.js\";\nimport { parseSetDef } from \"./parsers/set.js\";\nimport { parseStringDef } from \"./parsers/string.js\";\nimport { parseTupleDef } from \"./parsers/tuple.js\";\nimport { parseUndefinedDef } from \"./parsers/undefined.js\";\nimport { parseUnionDef } from \"./parsers/union.js\";\nimport { parseUnknownDef } from \"./parsers/unknown.js\";\nimport { parseReadonlyDef } from \"./parsers/readonly.js\";\nexport const selectParser = (def, typeName, refs) => {\n    switch (typeName) {\n        case ZodFirstPartyTypeKind.ZodString:\n            return parseStringDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNumber:\n            return parseNumberDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodObject:\n            return parseObjectDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBigInt:\n            return parseBigintDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBoolean:\n            return parseBooleanDef();\n        case ZodFirstPartyTypeKind.ZodDate:\n            return parseDateDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUndefined:\n            return parseUndefinedDef(refs);\n        case ZodFirstPartyTypeKind.ZodNull:\n            return parseNullDef(refs);\n        case ZodFirstPartyTypeKind.ZodArray:\n            return parseArrayDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUnion:\n        case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n            return parseUnionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodIntersection:\n            return parseIntersectionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodTuple:\n            return parseTupleDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodRecord:\n            return parseRecordDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLiteral:\n            return parseLiteralDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodEnum:\n            return parseEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNativeEnum:\n            return parseNativeEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNullable:\n            return parseNullableDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodOptional:\n            return parseOptionalDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodMap:\n            return parseMapDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodSet:\n            return parseSetDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLazy:\n            return () => def.getter()._def;\n        case ZodFirstPartyTypeKind.ZodPromise:\n            return parsePromiseDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNaN:\n        case ZodFirstPartyTypeKind.ZodNever:\n            return parseNeverDef(refs);\n        case ZodFirstPartyTypeKind.ZodEffects:\n            return parseEffectsDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodAny:\n            return parseAnyDef(refs);\n        case ZodFirstPartyTypeKind.ZodUnknown:\n            return parseUnknownDef(refs);\n        case ZodFirstPartyTypeKind.ZodDefault:\n            return parseDefaultDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBranded:\n            return parseBrandedDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodReadonly:\n            return parseReadonlyDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodCatch:\n            return parseCatchDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodPipeline:\n            return parsePipelineDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodFunction:\n        case ZodFirstPartyTypeKind.ZodVoid:\n        case ZodFirstPartyTypeKind.ZodSymbol:\n            return undefined;\n        default:\n            return ((_) => undefined)(typeName);\n    }\n};\n","import { parseDef } from \"./parseDef.js\";\nimport { getRefs } from \"./Refs.js\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nconst zodToJsonSchema = (schema, options) => {\n    const refs = getRefs(options);\n    let definitions = typeof options === \"object\" && options.definitions\n        ? Object.entries(options.definitions).reduce((acc, [name, schema]) => ({\n            ...acc,\n            [name]: parseDef(schema._def, {\n                ...refs,\n                currentPath: [...refs.basePath, refs.definitionPath, name],\n            }, true) ?? parseAnyDef(refs),\n        }), {})\n        : undefined;\n    const name = typeof options === \"string\"\n        ? options\n        : options?.nameStrategy === \"title\"\n            ? undefined\n            : options?.name;\n    const main = parseDef(schema._def, name === undefined\n        ? refs\n        : {\n            ...refs,\n            currentPath: [...refs.basePath, refs.definitionPath, name],\n        }, false) ?? parseAnyDef(refs);\n    const title = typeof options === \"object\" &&\n        options.name !== undefined &&\n        options.nameStrategy === \"title\"\n        ? options.name\n        : undefined;\n    if (title !== undefined) {\n        main.title = title;\n    }\n    if (refs.flags.hasReferencedOpenAiAnyType) {\n        if (!definitions) {\n            definitions = {};\n        }\n        if (!definitions[refs.openAiAnyTypeName]) {\n            definitions[refs.openAiAnyTypeName] = {\n                // Skipping \"object\" as no properties can be defined and additionalProperties must be \"false\"\n                type: [\"string\", \"number\", \"integer\", \"boolean\", \"array\", \"null\"],\n                items: {\n                    $ref: refs.$refStrategy === \"relative\"\n                        ? \"1\"\n                        : [\n                            ...refs.basePath,\n                            refs.definitionPath,\n                            refs.openAiAnyTypeName,\n                        ].join(\"/\"),\n                },\n            };\n        }\n    }\n    const combined = name === undefined\n        ? definitions\n            ? {\n                ...main,\n                [refs.definitionPath]: definitions,\n            }\n            : main\n        : {\n            $ref: [\n                ...(refs.$refStrategy === \"relative\" ? [] : refs.basePath),\n                refs.definitionPath,\n                name,\n            ].join(\"/\"),\n            [refs.definitionPath]: {\n                ...definitions,\n                [name]: main,\n            },\n        };\n    if (refs.target === \"jsonSchema7\") {\n        combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n    }\n    else if (refs.target === \"jsonSchema2019-09\" || refs.target === \"openAi\") {\n        combined.$schema = \"https://json-schema.org/draft/2019-09/schema#\";\n    }\n    if (refs.target === \"openAi\" &&\n        (\"anyOf\" in combined ||\n            \"oneOf\" in combined ||\n            \"allOf\" in combined ||\n            (\"type\" in combined && Array.isArray(combined.type)))) {\n        console.warn(\"Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.\");\n    }\n    return combined;\n};\nexport { zodToJsonSchema };\n","import { util } from \"./helpers/util.js\";\nexport const ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nexport const quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nexport class ZodError extends Error {\n    get errors() {\n        return this.issues;\n    }\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof ZodError)) {\n            throw new Error(`Not a ZodError: ${value}`);\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = Object.create(null);\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                const firstEl = sub.path[0];\n                fieldErrors[firstEl] = fieldErrors[firstEl] || [];\n                fieldErrors[firstEl].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n","import defaultErrorMap from \"./locales/en.js\";\nlet overrideErrorMap = defaultErrorMap;\nexport { defaultErrorMap };\nexport function setErrorMap(map) {\n    overrideErrorMap = map;\n}\nexport function getErrorMap() {\n    return overrideErrorMap;\n}\n","export * from \"./errors.js\";\nexport * from \"./helpers/parseUtil.js\";\nexport * from \"./helpers/typeAliases.js\";\nexport * from \"./helpers/util.js\";\nexport * from \"./types.js\";\nexport * from \"./ZodError.js\";\n","export var errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    // biome-ignore lint:\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message?.message;\n})(errorUtil || (errorUtil = {}));\n","import { getErrorMap } from \"../errors.js\";\nimport defaultErrorMap from \"../locales/en.js\";\nexport const makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    if (issueData.message !== undefined) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message,\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage,\n    };\n};\nexport const EMPTY_PATH = [];\nexport function addIssueToContext(ctx, issueData) {\n    const overrideMap = getErrorMap();\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap, // contextual error map is first priority\n            ctx.schemaErrorMap, // then schema-bound map if available\n            overrideMap, // then global override map\n            overrideMap === defaultErrorMap ? undefined : defaultErrorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nexport class ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nexport const INVALID = Object.freeze({\n    status: \"aborted\",\n});\nexport const DIRTY = (value) => ({ status: \"dirty\", value });\nexport const OK = (value) => ({ status: \"valid\", value });\nexport const isAborted = (x) => x.status === \"aborted\";\nexport const isDirty = (x) => x.status === \"dirty\";\nexport const isValid = (x) => x.status === \"valid\";\nexport const isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n","export {};\n","export var util;\n(function (util) {\n    util.assertEqual = (_) => { };\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array.map((val) => (typeof val === \"string\" ? `'${val}'` : val)).join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nexport var objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nexport const ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nexport const getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n","import * as z from \"./external.js\";\nexport * from \"./external.js\";\nexport { z };\nexport default z;\n","import { ZodIssueCode } from \"../ZodError.js\";\nimport { util, ZodParsedType } from \"../helpers/util.js\";\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"bigint\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\nexport default errorMap;\n","import { ZodError, ZodIssueCode, } from \"./ZodError.js\";\nimport { defaultErrorMap, getErrorMap } from \"./errors.js\";\nimport { errorUtil } from \"./helpers/errorUtil.js\";\nimport { DIRTY, INVALID, OK, ParseStatus, addIssueToContext, isAborted, isAsync, isDirty, isValid, makeIssue, } from \"./helpers/parseUtil.js\";\nimport { util, ZodParsedType, getParsedType } from \"./helpers/util.js\";\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (Array.isArray(this._key)) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return { message: message ?? ctx.defaultError };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return { message: message ?? required_error ?? ctx.defaultError };\n        }\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        return { message: message ?? invalid_type_error ?? ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nexport class ZodType {\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: params?.async ?? false,\n                contextualErrorMap: params?.errorMap,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    \"~validate\"(data) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: !!this[\"~standard\"].async,\n            },\n            path: [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        if (!this[\"~standard\"].async) {\n            try {\n                const result = this._parseSync({ data, path: [], parent: ctx });\n                return isValid(result)\n                    ? {\n                        value: result.value,\n                    }\n                    : {\n                        issues: ctx.common.issues,\n                    };\n            }\n            catch (err) {\n                if (err?.message?.toLowerCase()?.includes(\"encountered\")) {\n                    this[\"~standard\"].async = true;\n                }\n                ctx.common = {\n                    issues: [],\n                    async: true,\n                };\n            }\n        }\n        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)\n            ? {\n                value: result.value,\n            }\n            : {\n                issues: ctx.common.issues,\n            });\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params?.errorMap,\n                async: true,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n        this[\"~standard\"] = {\n            version: 1,\n            vendor: \"zod\",\n            validate: (data) => this[\"~validate\"](data),\n        };\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[0-9a-z]+$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\nconst jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\n// faster, simpler, safer\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nconst ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\n// const ipv6Regex =\n// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nconst ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nconst ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n// https://base64.guru/standards/base64url\nconst base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\n// simple\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n// no leap year validation\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n// with leap year validation\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n    let secondsRegexSource = `[0-5]\\\\d`;\n    if (args.precision) {\n        secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n    }\n    else if (args.precision == null) {\n        secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n    }\n    const secondsQuantifier = args.precision ? \"+\" : \"?\"; // require seconds if precision is nonzero\n    return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n    return new RegExp(`^${timeRegexSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nexport function datetimeRegex(args) {\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n    const opts = [];\n    opts.push(args.local ? `Z?` : `Z`);\n    if (args.offset)\n        opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n    regex = `${regex}(${opts.join(\"|\")})`;\n    return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nfunction isValidJWT(jwt, alg) {\n    if (!jwtRegex.test(jwt))\n        return false;\n    try {\n        const [header] = jwt.split(\".\");\n        if (!header)\n            return false;\n        // Convert base64url to base64\n        const base64 = header\n            .replace(/-/g, \"+\")\n            .replace(/_/g, \"/\")\n            .padEnd(header.length + ((4 - (header.length % 4)) % 4), \"=\");\n        // @ts-ignore\n        const decoded = JSON.parse(atob(base64));\n        if (typeof decoded !== \"object\" || decoded === null)\n            return false;\n        if (\"typ\" in decoded && decoded?.typ !== \"JWT\")\n            return false;\n        if (!decoded.alg)\n            return false;\n        if (alg && decoded.alg !== alg)\n            return false;\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction isValidCidr(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nexport class ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"nanoid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    // @ts-ignore\n                    new URL(input.data);\n                }\n                catch {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"duration\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"jwt\") {\n                if (!isValidJWT(input.data, check.alg)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"jwt\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cidr\") {\n                if (!isValidCidr(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cidr\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64url\") {\n                if (!base64urlRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    nanoid(message) {\n        return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n    }\n    base64(message) {\n        return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n    }\n    base64url(message) {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return this._addCheck({\n            kind: \"base64url\",\n            ...errorUtil.errToObj(message),\n        });\n    }\n    jwt(options) {\n        return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n    }\n    cidr(options) {\n        return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            offset: options?.offset ?? false,\n            local: options?.local ?? false,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    date(message) {\n        return this._addCheck({ kind: \"date\", message });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    duration(message) {\n        return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options?.position,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    /**\n     * Equivalent to `.min(1)`\n     */\n    nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch) => ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get isCIDR() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n    }\n    get isBase64url() {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / 10 ** decCount;\n}\nexport class ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" || (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null;\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            try {\n                input.data = BigInt(input.data);\n            }\n            catch {\n                return this._getInvalidInput(input);\n            }\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            return this._getInvalidInput(input);\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _getInvalidInput(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.bigint,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (Number.isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: params?.coerce || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nexport class ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        this._cached = { shape, keys };\n        return this._cached;\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") {\n            }\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: errorUtil.errToObj(message).message ?? defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(mask)) {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return util.objectValues(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else if (type instanceof ZodOptional) {\n        return [undefined, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodNullable) {\n        return [null, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else {\n        return [];\n    }\n};\nexport class ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nexport class ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\n// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];\nexport class ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nexport class ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function (...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nexport class ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nexport class ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(this._def.values);\n        }\n        if (!this._cache.has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values, newDef = this._def) {\n        return ZodEnum.create(values, {\n            ...this._def,\n            ...newDef,\n        });\n    }\n    exclude(values, newDef = this._def) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n            ...this._def,\n            ...newDef,\n        });\n    }\n}\nZodEnum.create = createZodEnum;\nexport class ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(util.getValidEnumValues(this._def.values));\n        }\n        if (!this._cache.has(input.data)) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed) => {\n                    if (status.value === \"aborted\")\n                        return INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                    if (result.status === \"aborted\")\n                        return INVALID;\n                    if (result.status === \"dirty\")\n                        return DIRTY(result.value);\n                    if (status.value === \"dirty\")\n                        return DIRTY(result.value);\n                    return result;\n                });\n            }\n            else {\n                if (status.value === \"aborted\")\n                    return INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (result.status === \"aborted\")\n                    return INVALID;\n                if (result.status === \"dirty\")\n                    return DIRTY(result.value);\n                if (status.value === \"dirty\")\n                    return DIRTY(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!isValid(base))\n                    return INVALID;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n                    if (!isValid(base))\n                        return INVALID;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n                        status: status.value,\n                        value: result,\n                    }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nexport { ZodEffects as ZodTransformer };\nexport class ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nexport const BRAND = Symbol(\"zod_brand\");\nexport class ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nexport class ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nexport class ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data) => {\n            if (isValid(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      z.custom      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nfunction cleanParams(params, data) {\n    const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n    const p2 = typeof p === \"string\" ? { message: p } : p;\n    return p2;\n}\nexport function custom(check, _params = {}, \n/**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            const r = check(data);\n            if (r instanceof Promise) {\n                return r.then((r) => {\n                    if (!r) {\n                        const params = cleanParams(_params, data);\n                        const _fatal = params.fatal ?? fatal ?? true;\n                        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n                    }\n                });\n            }\n            if (!r) {\n                const params = cleanParams(_params, data);\n                const _fatal = params.fatal ?? fatal ?? true;\n                ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n            }\n            return;\n        });\n    return ZodAny.create();\n}\nexport { ZodType as Schema, ZodType as ZodSchema };\nexport const late = {\n    object: ZodObject.lazycreate,\n};\nexport var ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\n// requires TS 4.4+\nclass Class {\n    constructor(..._) { }\n}\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nexport const coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nexport { anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, dateType as date, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, instanceOfType as instanceof, intersectionType as intersection, lazyType as lazy, literalType as literal, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, recordType as record, setType as set, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, voidType as void, };\nexport const NEVER = INVALID;\n","export * from \"../v4/mini/index.js\";\n","export { _lt as lt, _lte as lte, _gt as gt, _gte as gte, _positive as positive, _negative as negative, _nonpositive as nonpositive, _nonnegative as nonnegative, _multipleOf as multipleOf, _maxSize as maxSize, _minSize as minSize, _size as size, _maxLength as maxLength, _minLength as minLength, _length as length, _regex as regex, _lowercase as lowercase, _uppercase as uppercase, _includes as includes, _startsWith as startsWith, _endsWith as endsWith, _property as property, _mime as mime, _overwrite as overwrite, _normalize as normalize, _trim as trim, _toLowerCase as toLowerCase, _toUpperCase as toUpperCase, _slugify as slugify, } from \"../core/index.js\";\n","import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\nexport function string(params) {\n    return core._coercedString(schemas.ZodString, params);\n}\nexport function number(params) {\n    return core._coercedNumber(schemas.ZodNumber, params);\n}\nexport function boolean(params) {\n    return core._coercedBoolean(schemas.ZodBoolean, params);\n}\nexport function bigint(params) {\n    return core._coercedBigint(schemas.ZodBigInt, params);\n}\nexport function date(params) {\n    return core._coercedDate(schemas.ZodDate, params);\n}\n","// Zod 3 compat layer\nimport * as core from \"../core/index.js\";\n/** @deprecated Use the raw string literal codes instead, e.g. \"invalid_type\". */\nexport const ZodIssueCode = {\n    invalid_type: \"invalid_type\",\n    too_big: \"too_big\",\n    too_small: \"too_small\",\n    invalid_format: \"invalid_format\",\n    not_multiple_of: \"not_multiple_of\",\n    unrecognized_keys: \"unrecognized_keys\",\n    invalid_union: \"invalid_union\",\n    invalid_key: \"invalid_key\",\n    invalid_element: \"invalid_element\",\n    invalid_value: \"invalid_value\",\n    custom: \"custom\",\n};\nexport { $brand, config } from \"../core/index.js\";\n/** @deprecated Use `z.config(params)` instead. */\nexport function setErrorMap(map) {\n    core.config({\n        customError: map,\n    });\n}\n/** @deprecated Use `z.config()` instead. */\nexport function getErrorMap() {\n    return core.config().customError;\n}\n/** @deprecated Do not use. Stub definition, only included for zod-to-json-schema compatibility. */\nexport var ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\n","import * as core from \"../core/index.js\";\nimport { $ZodError } from \"../core/index.js\";\nimport * as util from \"../core/util.js\";\nconst initializer = (inst, issues) => {\n    $ZodError.init(inst, issues);\n    inst.name = \"ZodError\";\n    Object.defineProperties(inst, {\n        format: {\n            value: (mapper) => core.formatError(inst, mapper),\n            // enumerable: false,\n        },\n        flatten: {\n            value: (mapper) => core.flattenError(inst, mapper),\n            // enumerable: false,\n        },\n        addIssue: {\n            value: (issue) => {\n                inst.issues.push(issue);\n                inst.message = JSON.stringify(inst.issues, util.jsonStringifyReplacer, 2);\n            },\n            // enumerable: false,\n        },\n        addIssues: {\n            value: (issues) => {\n                inst.issues.push(...issues);\n                inst.message = JSON.stringify(inst.issues, util.jsonStringifyReplacer, 2);\n            },\n            // enumerable: false,\n        },\n        isEmpty: {\n            get() {\n                return inst.issues.length === 0;\n            },\n            // enumerable: false,\n        },\n    });\n    // Object.defineProperty(inst, \"isEmpty\", {\n    //   get() {\n    //     return inst.issues.length === 0;\n    //   },\n    // });\n};\nexport const ZodError = core.$constructor(\"ZodError\", initializer);\nexport const ZodRealError = core.$constructor(\"ZodError\", initializer, {\n    Parent: Error,\n});\n// /** @deprecated Use `z.core.$ZodErrorMapCtx` instead. */\n// export type ErrorMapCtx = core.$ZodErrorMapCtx;\n","export * as core from \"../core/index.js\";\nexport * from \"./schemas.js\";\nexport * from \"./checks.js\";\nexport * from \"./errors.js\";\nexport * from \"./parse.js\";\nexport * from \"./compat.js\";\n// zod-specified\nimport { config } from \"../core/index.js\";\nimport en from \"../locales/en.js\";\nconfig(en());\nexport { globalRegistry, registry, config, $output, $input, $brand, clone, regexes, treeifyError, prettifyError, formatError, flattenError, TimePrecision, util, NEVER, } from \"../core/index.js\";\nexport { toJSONSchema } from \"../core/json-schema-processors.js\";\nexport { fromJSONSchema } from \"./from-json-schema.js\";\nexport * as locales from \"../locales/index.js\";\n// iso\n// must be exported from top-level\n// https://github.com/colinhacks/zod/issues/4491\nexport { ZodISODateTime, ZodISODate, ZodISOTime, ZodISODuration } from \"./iso.js\";\nexport * as iso from \"./iso.js\";\nexport * as coerce from \"./coerce.js\";\n","import { globalRegistry } from \"../core/registries.js\";\nimport * as _checks from \"./checks.js\";\nimport * as _iso from \"./iso.js\";\nimport * as _schemas from \"./schemas.js\";\n// Local z object to avoid circular dependency with ../index.js\nconst z = {\n    ..._schemas,\n    ..._checks,\n    iso: _iso,\n};\n// Keys that are recognized and handled by the conversion logic\nconst RECOGNIZED_KEYS = new Set([\n    // Schema identification\n    \"$schema\",\n    \"$ref\",\n    \"$defs\",\n    \"definitions\",\n    // Core schema keywords\n    \"$id\",\n    \"id\",\n    \"$comment\",\n    \"$anchor\",\n    \"$vocabulary\",\n    \"$dynamicRef\",\n    \"$dynamicAnchor\",\n    // Type\n    \"type\",\n    \"enum\",\n    \"const\",\n    // Composition\n    \"anyOf\",\n    \"oneOf\",\n    \"allOf\",\n    \"not\",\n    // Object\n    \"properties\",\n    \"required\",\n    \"additionalProperties\",\n    \"patternProperties\",\n    \"propertyNames\",\n    \"minProperties\",\n    \"maxProperties\",\n    // Array\n    \"items\",\n    \"prefixItems\",\n    \"additionalItems\",\n    \"minItems\",\n    \"maxItems\",\n    \"uniqueItems\",\n    \"contains\",\n    \"minContains\",\n    \"maxContains\",\n    // String\n    \"minLength\",\n    \"maxLength\",\n    \"pattern\",\n    \"format\",\n    // Number\n    \"minimum\",\n    \"maximum\",\n    \"exclusiveMinimum\",\n    \"exclusiveMaximum\",\n    \"multipleOf\",\n    // Already handled metadata\n    \"description\",\n    \"default\",\n    // Content\n    \"contentEncoding\",\n    \"contentMediaType\",\n    \"contentSchema\",\n    // Unsupported (error-throwing)\n    \"unevaluatedItems\",\n    \"unevaluatedProperties\",\n    \"if\",\n    \"then\",\n    \"else\",\n    \"dependentSchemas\",\n    \"dependentRequired\",\n    // OpenAPI\n    \"nullable\",\n    \"readOnly\",\n]);\nfunction detectVersion(schema, defaultTarget) {\n    const $schema = schema.$schema;\n    if ($schema === \"https://json-schema.org/draft/2020-12/schema\") {\n        return \"draft-2020-12\";\n    }\n    if ($schema === \"http://json-schema.org/draft-07/schema#\") {\n        return \"draft-7\";\n    }\n    if ($schema === \"http://json-schema.org/draft-04/schema#\") {\n        return \"draft-4\";\n    }\n    // Use defaultTarget if provided, otherwise default to draft-2020-12\n    return defaultTarget ?? \"draft-2020-12\";\n}\nfunction resolveRef(ref, ctx) {\n    if (!ref.startsWith(\"#\")) {\n        throw new Error(\"External $ref is not supported, only local refs (#/...) are allowed\");\n    }\n    const path = ref.slice(1).split(\"/\").filter(Boolean);\n    // Handle root reference \"#\"\n    if (path.length === 0) {\n        return ctx.rootSchema;\n    }\n    const defsKey = ctx.version === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n    if (path[0] === defsKey) {\n        const key = path[1];\n        if (!key || !ctx.defs[key]) {\n            throw new Error(`Reference not found: ${ref}`);\n        }\n        return ctx.defs[key];\n    }\n    throw new Error(`Reference not found: ${ref}`);\n}\nfunction convertBaseSchema(schema, ctx) {\n    // Handle unsupported features\n    if (schema.not !== undefined) {\n        // Special case: { not: {} } represents never\n        if (typeof schema.not === \"object\" && Object.keys(schema.not).length === 0) {\n            return z.never();\n        }\n        throw new Error(\"not is not supported in Zod (except { not: {} } for never)\");\n    }\n    if (schema.unevaluatedItems !== undefined) {\n        throw new Error(\"unevaluatedItems is not supported\");\n    }\n    if (schema.unevaluatedProperties !== undefined) {\n        throw new Error(\"unevaluatedProperties is not supported\");\n    }\n    if (schema.if !== undefined || schema.then !== undefined || schema.else !== undefined) {\n        throw new Error(\"Conditional schemas (if/then/else) are not supported\");\n    }\n    if (schema.dependentSchemas !== undefined || schema.dependentRequired !== undefined) {\n        throw new Error(\"dependentSchemas and dependentRequired are not supported\");\n    }\n    // Handle $ref\n    if (schema.$ref) {\n        const refPath = schema.$ref;\n        if (ctx.refs.has(refPath)) {\n            return ctx.refs.get(refPath);\n        }\n        if (ctx.processing.has(refPath)) {\n            // Circular reference - use lazy\n            return z.lazy(() => {\n                if (!ctx.refs.has(refPath)) {\n                    throw new Error(`Circular reference not resolved: ${refPath}`);\n                }\n                return ctx.refs.get(refPath);\n            });\n        }\n        ctx.processing.add(refPath);\n        const resolved = resolveRef(refPath, ctx);\n        const zodSchema = convertSchema(resolved, ctx);\n        ctx.refs.set(refPath, zodSchema);\n        ctx.processing.delete(refPath);\n        return zodSchema;\n    }\n    // Handle enum\n    if (schema.enum !== undefined) {\n        const enumValues = schema.enum;\n        // Special case: OpenAPI 3.0 null representation { type: \"string\", nullable: true, enum: [null] }\n        if (ctx.version === \"openapi-3.0\" &&\n            schema.nullable === true &&\n            enumValues.length === 1 &&\n            enumValues[0] === null) {\n            return z.null();\n        }\n        if (enumValues.length === 0) {\n            return z.never();\n        }\n        if (enumValues.length === 1) {\n            return z.literal(enumValues[0]);\n        }\n        // Check if all values are strings\n        if (enumValues.every((v) => typeof v === \"string\")) {\n            return z.enum(enumValues);\n        }\n        // Mixed types - use union of literals\n        const literalSchemas = enumValues.map((v) => z.literal(v));\n        if (literalSchemas.length < 2) {\n            return literalSchemas[0];\n        }\n        return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);\n    }\n    // Handle const\n    if (schema.const !== undefined) {\n        return z.literal(schema.const);\n    }\n    // Handle type\n    const type = schema.type;\n    if (Array.isArray(type)) {\n        // Expand type array into anyOf union\n        const typeSchemas = type.map((t) => {\n            const typeSchema = { ...schema, type: t };\n            return convertBaseSchema(typeSchema, ctx);\n        });\n        if (typeSchemas.length === 0) {\n            return z.never();\n        }\n        if (typeSchemas.length === 1) {\n            return typeSchemas[0];\n        }\n        return z.union(typeSchemas);\n    }\n    if (!type) {\n        // No type specified - empty schema (any)\n        return z.any();\n    }\n    let zodSchema;\n    switch (type) {\n        case \"string\": {\n            let stringSchema = z.string();\n            // Apply format using .check() with Zod format functions\n            if (schema.format) {\n                const format = schema.format;\n                // Map common formats to Zod check functions\n                if (format === \"email\") {\n                    stringSchema = stringSchema.check(z.email());\n                }\n                else if (format === \"uri\" || format === \"uri-reference\") {\n                    stringSchema = stringSchema.check(z.url());\n                }\n                else if (format === \"uuid\" || format === \"guid\") {\n                    stringSchema = stringSchema.check(z.uuid());\n                }\n                else if (format === \"date-time\") {\n                    stringSchema = stringSchema.check(z.iso.datetime());\n                }\n                else if (format === \"date\") {\n                    stringSchema = stringSchema.check(z.iso.date());\n                }\n                else if (format === \"time\") {\n                    stringSchema = stringSchema.check(z.iso.time());\n                }\n                else if (format === \"duration\") {\n                    stringSchema = stringSchema.check(z.iso.duration());\n                }\n                else if (format === \"ipv4\") {\n                    stringSchema = stringSchema.check(z.ipv4());\n                }\n                else if (format === \"ipv6\") {\n                    stringSchema = stringSchema.check(z.ipv6());\n                }\n                else if (format === \"mac\") {\n                    stringSchema = stringSchema.check(z.mac());\n                }\n                else if (format === \"cidr\") {\n                    stringSchema = stringSchema.check(z.cidrv4());\n                }\n                else if (format === \"cidr-v6\") {\n                    stringSchema = stringSchema.check(z.cidrv6());\n                }\n                else if (format === \"base64\") {\n                    stringSchema = stringSchema.check(z.base64());\n                }\n                else if (format === \"base64url\") {\n                    stringSchema = stringSchema.check(z.base64url());\n                }\n                else if (format === \"e164\") {\n                    stringSchema = stringSchema.check(z.e164());\n                }\n                else if (format === \"jwt\") {\n                    stringSchema = stringSchema.check(z.jwt());\n                }\n                else if (format === \"emoji\") {\n                    stringSchema = stringSchema.check(z.emoji());\n                }\n                else if (format === \"nanoid\") {\n                    stringSchema = stringSchema.check(z.nanoid());\n                }\n                else if (format === \"cuid\") {\n                    stringSchema = stringSchema.check(z.cuid());\n                }\n                else if (format === \"cuid2\") {\n                    stringSchema = stringSchema.check(z.cuid2());\n                }\n                else if (format === \"ulid\") {\n                    stringSchema = stringSchema.check(z.ulid());\n                }\n                else if (format === \"xid\") {\n                    stringSchema = stringSchema.check(z.xid());\n                }\n                else if (format === \"ksuid\") {\n                    stringSchema = stringSchema.check(z.ksuid());\n                }\n                // Note: json-string format is not currently supported by Zod\n                // Custom formats are ignored - keep as plain string\n            }\n            // Apply constraints\n            if (typeof schema.minLength === \"number\") {\n                stringSchema = stringSchema.min(schema.minLength);\n            }\n            if (typeof schema.maxLength === \"number\") {\n                stringSchema = stringSchema.max(schema.maxLength);\n            }\n            if (schema.pattern) {\n                // JSON Schema patterns are not implicitly anchored (match anywhere in string)\n                stringSchema = stringSchema.regex(new RegExp(schema.pattern));\n            }\n            zodSchema = stringSchema;\n            break;\n        }\n        case \"number\":\n        case \"integer\": {\n            let numberSchema = type === \"integer\" ? z.number().int() : z.number();\n            // Apply constraints\n            if (typeof schema.minimum === \"number\") {\n                numberSchema = numberSchema.min(schema.minimum);\n            }\n            if (typeof schema.maximum === \"number\") {\n                numberSchema = numberSchema.max(schema.maximum);\n            }\n            if (typeof schema.exclusiveMinimum === \"number\") {\n                numberSchema = numberSchema.gt(schema.exclusiveMinimum);\n            }\n            else if (schema.exclusiveMinimum === true && typeof schema.minimum === \"number\") {\n                numberSchema = numberSchema.gt(schema.minimum);\n            }\n            if (typeof schema.exclusiveMaximum === \"number\") {\n                numberSchema = numberSchema.lt(schema.exclusiveMaximum);\n            }\n            else if (schema.exclusiveMaximum === true && typeof schema.maximum === \"number\") {\n                numberSchema = numberSchema.lt(schema.maximum);\n            }\n            if (typeof schema.multipleOf === \"number\") {\n                numberSchema = numberSchema.multipleOf(schema.multipleOf);\n            }\n            zodSchema = numberSchema;\n            break;\n        }\n        case \"boolean\": {\n            zodSchema = z.boolean();\n            break;\n        }\n        case \"null\": {\n            zodSchema = z.null();\n            break;\n        }\n        case \"object\": {\n            const shape = {};\n            const properties = schema.properties || {};\n            const requiredSet = new Set(schema.required || []);\n            // Convert properties - mark optional ones\n            for (const [key, propSchema] of Object.entries(properties)) {\n                const propZodSchema = convertSchema(propSchema, ctx);\n                // If not in required array, make it optional\n                shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();\n            }\n            // Handle propertyNames\n            if (schema.propertyNames) {\n                const keySchema = convertSchema(schema.propertyNames, ctx);\n                const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === \"object\"\n                    ? convertSchema(schema.additionalProperties, ctx)\n                    : z.any();\n                // Case A: No properties (pure record)\n                if (Object.keys(shape).length === 0) {\n                    zodSchema = z.record(keySchema, valueSchema);\n                    break;\n                }\n                // Case B: With properties (intersection of object and looseRecord)\n                const objectSchema = z.object(shape).passthrough();\n                const recordSchema = z.looseRecord(keySchema, valueSchema);\n                zodSchema = z.intersection(objectSchema, recordSchema);\n                break;\n            }\n            // Handle patternProperties\n            if (schema.patternProperties) {\n                // patternProperties: keys matching pattern must satisfy corresponding schema\n                // Use loose records so non-matching keys pass through\n                const patternProps = schema.patternProperties;\n                const patternKeys = Object.keys(patternProps);\n                const looseRecords = [];\n                for (const pattern of patternKeys) {\n                    const patternValue = convertSchema(patternProps[pattern], ctx);\n                    const keySchema = z.string().regex(new RegExp(pattern));\n                    looseRecords.push(z.looseRecord(keySchema, patternValue));\n                }\n                // Build intersection: object schema + all pattern property records\n                const schemasToIntersect = [];\n                if (Object.keys(shape).length > 0) {\n                    // Use passthrough so patternProperties can validate additional keys\n                    schemasToIntersect.push(z.object(shape).passthrough());\n                }\n                schemasToIntersect.push(...looseRecords);\n                if (schemasToIntersect.length === 0) {\n                    zodSchema = z.object({}).passthrough();\n                }\n                else if (schemasToIntersect.length === 1) {\n                    zodSchema = schemasToIntersect[0];\n                }\n                else {\n                    // Chain intersections: (A & B) & C & D ...\n                    let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);\n                    for (let i = 2; i < schemasToIntersect.length; i++) {\n                        result = z.intersection(result, schemasToIntersect[i]);\n                    }\n                    zodSchema = result;\n                }\n                break;\n            }\n            // Handle additionalProperties\n            // In JSON Schema, additionalProperties defaults to true (allow any extra properties)\n            // In Zod, objects strip unknown keys by default, so we need to handle this explicitly\n            const objectSchema = z.object(shape);\n            if (schema.additionalProperties === false) {\n                // Strict mode - no extra properties allowed\n                zodSchema = objectSchema.strict();\n            }\n            else if (typeof schema.additionalProperties === \"object\") {\n                // Extra properties must match the specified schema\n                zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));\n            }\n            else {\n                // additionalProperties is true or undefined - allow any extra properties (passthrough)\n                zodSchema = objectSchema.passthrough();\n            }\n            break;\n        }\n        case \"array\": {\n            // TODO: uniqueItems is not supported\n            // TODO: contains/minContains/maxContains are not supported\n            // Check if this is a tuple (prefixItems or items as array)\n            const prefixItems = schema.prefixItems;\n            const items = schema.items;\n            if (prefixItems && Array.isArray(prefixItems)) {\n                // Tuple with prefixItems (draft-2020-12)\n                const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));\n                const rest = items && typeof items === \"object\" && !Array.isArray(items)\n                    ? convertSchema(items, ctx)\n                    : undefined;\n                if (rest) {\n                    zodSchema = z.tuple(tupleItems).rest(rest);\n                }\n                else {\n                    zodSchema = z.tuple(tupleItems);\n                }\n                // Apply minItems/maxItems constraints to tuples\n                if (typeof schema.minItems === \"number\") {\n                    zodSchema = zodSchema.check(z.minLength(schema.minItems));\n                }\n                if (typeof schema.maxItems === \"number\") {\n                    zodSchema = zodSchema.check(z.maxLength(schema.maxItems));\n                }\n            }\n            else if (Array.isArray(items)) {\n                // Tuple with items array (draft-7)\n                const tupleItems = items.map((item) => convertSchema(item, ctx));\n                const rest = schema.additionalItems && typeof schema.additionalItems === \"object\"\n                    ? convertSchema(schema.additionalItems, ctx)\n                    : undefined; // additionalItems: false means no rest, handled by default tuple behavior\n                if (rest) {\n                    zodSchema = z.tuple(tupleItems).rest(rest);\n                }\n                else {\n                    zodSchema = z.tuple(tupleItems);\n                }\n                // Apply minItems/maxItems constraints to tuples\n                if (typeof schema.minItems === \"number\") {\n                    zodSchema = zodSchema.check(z.minLength(schema.minItems));\n                }\n                if (typeof schema.maxItems === \"number\") {\n                    zodSchema = zodSchema.check(z.maxLength(schema.maxItems));\n                }\n            }\n            else if (items !== undefined) {\n                // Regular array\n                const element = convertSchema(items, ctx);\n                let arraySchema = z.array(element);\n                // Apply constraints\n                if (typeof schema.minItems === \"number\") {\n                    arraySchema = arraySchema.min(schema.minItems);\n                }\n                if (typeof schema.maxItems === \"number\") {\n                    arraySchema = arraySchema.max(schema.maxItems);\n                }\n                zodSchema = arraySchema;\n            }\n            else {\n                // No items specified - array of any\n                zodSchema = z.array(z.any());\n            }\n            break;\n        }\n        default:\n            throw new Error(`Unsupported type: ${type}`);\n    }\n    // Apply metadata\n    if (schema.description) {\n        zodSchema = zodSchema.describe(schema.description);\n    }\n    if (schema.default !== undefined) {\n        zodSchema = zodSchema.default(schema.default);\n    }\n    return zodSchema;\n}\nfunction convertSchema(schema, ctx) {\n    if (typeof schema === \"boolean\") {\n        return schema ? z.any() : z.never();\n    }\n    // Convert base schema first (ignoring composition keywords)\n    let baseSchema = convertBaseSchema(schema, ctx);\n    const hasExplicitType = schema.type || schema.enum !== undefined || schema.const !== undefined;\n    // Process composition keywords LAST (they can appear together)\n    // Handle anyOf - wrap base schema with union\n    if (schema.anyOf && Array.isArray(schema.anyOf)) {\n        const options = schema.anyOf.map((s) => convertSchema(s, ctx));\n        const anyOfUnion = z.union(options);\n        baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;\n    }\n    // Handle oneOf - exclusive union (exactly one must match)\n    if (schema.oneOf && Array.isArray(schema.oneOf)) {\n        const options = schema.oneOf.map((s) => convertSchema(s, ctx));\n        const oneOfUnion = z.xor(options);\n        baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;\n    }\n    // Handle allOf - wrap base schema with intersection\n    if (schema.allOf && Array.isArray(schema.allOf)) {\n        if (schema.allOf.length === 0) {\n            baseSchema = hasExplicitType ? baseSchema : z.any();\n        }\n        else {\n            let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);\n            const startIdx = hasExplicitType ? 0 : 1;\n            for (let i = startIdx; i < schema.allOf.length; i++) {\n                result = z.intersection(result, convertSchema(schema.allOf[i], ctx));\n            }\n            baseSchema = result;\n        }\n    }\n    // Handle nullable (OpenAPI 3.0)\n    if (schema.nullable === true && ctx.version === \"openapi-3.0\") {\n        baseSchema = z.nullable(baseSchema);\n    }\n    // Handle readOnly\n    if (schema.readOnly === true) {\n        baseSchema = z.readonly(baseSchema);\n    }\n    // Collect metadata: core schema keywords and unrecognized keys\n    const extraMeta = {};\n    // Core schema keywords that should be captured as metadata\n    const coreMetadataKeys = [\"$id\", \"id\", \"$comment\", \"$anchor\", \"$vocabulary\", \"$dynamicRef\", \"$dynamicAnchor\"];\n    for (const key of coreMetadataKeys) {\n        if (key in schema) {\n            extraMeta[key] = schema[key];\n        }\n    }\n    // Content keywords - store as metadata\n    const contentMetadataKeys = [\"contentEncoding\", \"contentMediaType\", \"contentSchema\"];\n    for (const key of contentMetadataKeys) {\n        if (key in schema) {\n            extraMeta[key] = schema[key];\n        }\n    }\n    // Unrecognized keys (custom metadata)\n    for (const key of Object.keys(schema)) {\n        if (!RECOGNIZED_KEYS.has(key)) {\n            extraMeta[key] = schema[key];\n        }\n    }\n    if (Object.keys(extraMeta).length > 0) {\n        ctx.registry.add(baseSchema, extraMeta);\n    }\n    return baseSchema;\n}\n/**\n * Converts a JSON Schema to a Zod schema. This function should be considered semi-experimental. It's behavior is liable to change. */\nexport function fromJSONSchema(schema, params) {\n    // Handle boolean schemas\n    if (typeof schema === \"boolean\") {\n        return schema ? z.any() : z.never();\n    }\n    const version = detectVersion(schema, params?.defaultTarget);\n    const defs = (schema.$defs || schema.definitions || {});\n    const ctx = {\n        version,\n        defs,\n        refs: new Map(),\n        processing: new Set(),\n        rootSchema: schema,\n        registry: params?.registry ?? globalRegistry,\n    };\n    return convertSchema(schema, ctx);\n}\n","import * as z from \"./external.js\";\nexport { z };\nexport * from \"./external.js\";\nexport default z;\n","import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\nexport const ZodISODateTime = /*@__PURE__*/ core.$constructor(\"ZodISODateTime\", (inst, def) => {\n    core.$ZodISODateTime.init(inst, def);\n    schemas.ZodStringFormat.init(inst, def);\n});\nexport function datetime(params) {\n    return core._isoDateTime(ZodISODateTime, params);\n}\nexport const ZodISODate = /*@__PURE__*/ core.$constructor(\"ZodISODate\", (inst, def) => {\n    core.$ZodISODate.init(inst, def);\n    schemas.ZodStringFormat.init(inst, def);\n});\nexport function date(params) {\n    return core._isoDate(ZodISODate, params);\n}\nexport const ZodISOTime = /*@__PURE__*/ core.$constructor(\"ZodISOTime\", (inst, def) => {\n    core.$ZodISOTime.init(inst, def);\n    schemas.ZodStringFormat.init(inst, def);\n});\nexport function time(params) {\n    return core._isoTime(ZodISOTime, params);\n}\nexport const ZodISODuration = /*@__PURE__*/ core.$constructor(\"ZodISODuration\", (inst, def) => {\n    core.$ZodISODuration.init(inst, def);\n    schemas.ZodStringFormat.init(inst, def);\n});\nexport function duration(params) {\n    return core._isoDuration(ZodISODuration, params);\n}\n","import * as core from \"../core/index.js\";\nimport { ZodRealError } from \"./errors.js\";\nexport const parse = /* @__PURE__ */ core._parse(ZodRealError);\nexport const parseAsync = /* @__PURE__ */ core._parseAsync(ZodRealError);\nexport const safeParse = /* @__PURE__ */ core._safeParse(ZodRealError);\nexport const safeParseAsync = /* @__PURE__ */ core._safeParseAsync(ZodRealError);\n// Codec functions\nexport const encode = /* @__PURE__ */ core._encode(ZodRealError);\nexport const decode = /* @__PURE__ */ core._decode(ZodRealError);\nexport const encodeAsync = /* @__PURE__ */ core._encodeAsync(ZodRealError);\nexport const decodeAsync = /* @__PURE__ */ core._decodeAsync(ZodRealError);\nexport const safeEncode = /* @__PURE__ */ core._safeEncode(ZodRealError);\nexport const safeDecode = /* @__PURE__ */ core._safeDecode(ZodRealError);\nexport const safeEncodeAsync = /* @__PURE__ */ core._safeEncodeAsync(ZodRealError);\nexport const safeDecodeAsync = /* @__PURE__ */ core._safeDecodeAsync(ZodRealError);\n","import * as core from \"../core/index.js\";\nimport { util } from \"../core/index.js\";\nimport * as processors from \"../core/json-schema-processors.js\";\nimport { createStandardJSONSchemaMethod, createToJSONSchemaMethod } from \"../core/to-json-schema.js\";\nimport * as checks from \"./checks.js\";\nimport * as iso from \"./iso.js\";\nimport * as parse from \"./parse.js\";\nexport const ZodType = /*@__PURE__*/ core.$constructor(\"ZodType\", (inst, def) => {\n    core.$ZodType.init(inst, def);\n    Object.assign(inst[\"~standard\"], {\n        jsonSchema: {\n            input: createStandardJSONSchemaMethod(inst, \"input\"),\n            output: createStandardJSONSchemaMethod(inst, \"output\"),\n        },\n    });\n    inst.toJSONSchema = createToJSONSchemaMethod(inst, {});\n    inst.def = def;\n    inst.type = def.type;\n    Object.defineProperty(inst, \"_def\", { value: def });\n    // base methods\n    inst.check = (...checks) => {\n        return inst.clone(util.mergeDefs(def, {\n            checks: [\n                ...(def.checks ?? []),\n                ...checks.map((ch) => typeof ch === \"function\" ? { _zod: { check: ch, def: { check: \"custom\" }, onattach: [] } } : ch),\n            ],\n        }), {\n            parent: true,\n        });\n    };\n    inst.with = inst.check;\n    inst.clone = (def, params) => core.clone(inst, def, params);\n    inst.brand = () => inst;\n    inst.register = ((reg, meta) => {\n        reg.add(inst, meta);\n        return inst;\n    });\n    // parsing\n    inst.parse = (data, params) => parse.parse(inst, data, params, { callee: inst.parse });\n    inst.safeParse = (data, params) => parse.safeParse(inst, data, params);\n    inst.parseAsync = async (data, params) => parse.parseAsync(inst, data, params, { callee: inst.parseAsync });\n    inst.safeParseAsync = async (data, params) => parse.safeParseAsync(inst, data, params);\n    inst.spa = inst.safeParseAsync;\n    // encoding/decoding\n    inst.encode = (data, params) => parse.encode(inst, data, params);\n    inst.decode = (data, params) => parse.decode(inst, data, params);\n    inst.encodeAsync = async (data, params) => parse.encodeAsync(inst, data, params);\n    inst.decodeAsync = async (data, params) => parse.decodeAsync(inst, data, params);\n    inst.safeEncode = (data, params) => parse.safeEncode(inst, data, params);\n    inst.safeDecode = (data, params) => parse.safeDecode(inst, data, params);\n    inst.safeEncodeAsync = async (data, params) => parse.safeEncodeAsync(inst, data, params);\n    inst.safeDecodeAsync = async (data, params) => parse.safeDecodeAsync(inst, data, params);\n    // refinements\n    inst.refine = (check, params) => inst.check(refine(check, params));\n    inst.superRefine = (refinement) => inst.check(superRefine(refinement));\n    inst.overwrite = (fn) => inst.check(checks.overwrite(fn));\n    // wrappers\n    inst.optional = () => optional(inst);\n    inst.exactOptional = () => exactOptional(inst);\n    inst.nullable = () => nullable(inst);\n    inst.nullish = () => optional(nullable(inst));\n    inst.nonoptional = (params) => nonoptional(inst, params);\n    inst.array = () => array(inst);\n    inst.or = (arg) => union([inst, arg]);\n    inst.and = (arg) => intersection(inst, arg);\n    inst.transform = (tx) => pipe(inst, transform(tx));\n    inst.default = (def) => _default(inst, def);\n    inst.prefault = (def) => prefault(inst, def);\n    // inst.coalesce = (def, params) => coalesce(inst, def, params);\n    inst.catch = (params) => _catch(inst, params);\n    inst.pipe = (target) => pipe(inst, target);\n    inst.readonly = () => readonly(inst);\n    // meta\n    inst.describe = (description) => {\n        const cl = inst.clone();\n        core.globalRegistry.add(cl, { description });\n        return cl;\n    };\n    Object.defineProperty(inst, \"description\", {\n        get() {\n            return core.globalRegistry.get(inst)?.description;\n        },\n        configurable: true,\n    });\n    inst.meta = (...args) => {\n        if (args.length === 0) {\n            return core.globalRegistry.get(inst);\n        }\n        const cl = inst.clone();\n        core.globalRegistry.add(cl, args[0]);\n        return cl;\n    };\n    // helpers\n    inst.isOptional = () => inst.safeParse(undefined).success;\n    inst.isNullable = () => inst.safeParse(null).success;\n    inst.apply = (fn) => fn(inst);\n    return inst;\n});\n/** @internal */\nexport const _ZodString = /*@__PURE__*/ core.$constructor(\"_ZodString\", (inst, def) => {\n    core.$ZodString.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.stringProcessor(inst, ctx, json, params);\n    const bag = inst._zod.bag;\n    inst.format = bag.format ?? null;\n    inst.minLength = bag.minimum ?? null;\n    inst.maxLength = bag.maximum ?? null;\n    // validations\n    inst.regex = (...args) => inst.check(checks.regex(...args));\n    inst.includes = (...args) => inst.check(checks.includes(...args));\n    inst.startsWith = (...args) => inst.check(checks.startsWith(...args));\n    inst.endsWith = (...args) => inst.check(checks.endsWith(...args));\n    inst.min = (...args) => inst.check(checks.minLength(...args));\n    inst.max = (...args) => inst.check(checks.maxLength(...args));\n    inst.length = (...args) => inst.check(checks.length(...args));\n    inst.nonempty = (...args) => inst.check(checks.minLength(1, ...args));\n    inst.lowercase = (params) => inst.check(checks.lowercase(params));\n    inst.uppercase = (params) => inst.check(checks.uppercase(params));\n    // transforms\n    inst.trim = () => inst.check(checks.trim());\n    inst.normalize = (...args) => inst.check(checks.normalize(...args));\n    inst.toLowerCase = () => inst.check(checks.toLowerCase());\n    inst.toUpperCase = () => inst.check(checks.toUpperCase());\n    inst.slugify = () => inst.check(checks.slugify());\n});\nexport const ZodString = /*@__PURE__*/ core.$constructor(\"ZodString\", (inst, def) => {\n    core.$ZodString.init(inst, def);\n    _ZodString.init(inst, def);\n    inst.email = (params) => inst.check(core._email(ZodEmail, params));\n    inst.url = (params) => inst.check(core._url(ZodURL, params));\n    inst.jwt = (params) => inst.check(core._jwt(ZodJWT, params));\n    inst.emoji = (params) => inst.check(core._emoji(ZodEmoji, params));\n    inst.guid = (params) => inst.check(core._guid(ZodGUID, params));\n    inst.uuid = (params) => inst.check(core._uuid(ZodUUID, params));\n    inst.uuidv4 = (params) => inst.check(core._uuidv4(ZodUUID, params));\n    inst.uuidv6 = (params) => inst.check(core._uuidv6(ZodUUID, params));\n    inst.uuidv7 = (params) => inst.check(core._uuidv7(ZodUUID, params));\n    inst.nanoid = (params) => inst.check(core._nanoid(ZodNanoID, params));\n    inst.guid = (params) => inst.check(core._guid(ZodGUID, params));\n    inst.cuid = (params) => inst.check(core._cuid(ZodCUID, params));\n    inst.cuid2 = (params) => inst.check(core._cuid2(ZodCUID2, params));\n    inst.ulid = (params) => inst.check(core._ulid(ZodULID, params));\n    inst.base64 = (params) => inst.check(core._base64(ZodBase64, params));\n    inst.base64url = (params) => inst.check(core._base64url(ZodBase64URL, params));\n    inst.xid = (params) => inst.check(core._xid(ZodXID, params));\n    inst.ksuid = (params) => inst.check(core._ksuid(ZodKSUID, params));\n    inst.ipv4 = (params) => inst.check(core._ipv4(ZodIPv4, params));\n    inst.ipv6 = (params) => inst.check(core._ipv6(ZodIPv6, params));\n    inst.cidrv4 = (params) => inst.check(core._cidrv4(ZodCIDRv4, params));\n    inst.cidrv6 = (params) => inst.check(core._cidrv6(ZodCIDRv6, params));\n    inst.e164 = (params) => inst.check(core._e164(ZodE164, params));\n    // iso\n    inst.datetime = (params) => inst.check(iso.datetime(params));\n    inst.date = (params) => inst.check(iso.date(params));\n    inst.time = (params) => inst.check(iso.time(params));\n    inst.duration = (params) => inst.check(iso.duration(params));\n});\nexport function string(params) {\n    return core._string(ZodString, params);\n}\nexport const ZodStringFormat = /*@__PURE__*/ core.$constructor(\"ZodStringFormat\", (inst, def) => {\n    core.$ZodStringFormat.init(inst, def);\n    _ZodString.init(inst, def);\n});\nexport const ZodEmail = /*@__PURE__*/ core.$constructor(\"ZodEmail\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodEmail.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function email(params) {\n    return core._email(ZodEmail, params);\n}\nexport const ZodGUID = /*@__PURE__*/ core.$constructor(\"ZodGUID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodGUID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function guid(params) {\n    return core._guid(ZodGUID, params);\n}\nexport const ZodUUID = /*@__PURE__*/ core.$constructor(\"ZodUUID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodUUID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function uuid(params) {\n    return core._uuid(ZodUUID, params);\n}\nexport function uuidv4(params) {\n    return core._uuidv4(ZodUUID, params);\n}\n// ZodUUIDv6\nexport function uuidv6(params) {\n    return core._uuidv6(ZodUUID, params);\n}\n// ZodUUIDv7\nexport function uuidv7(params) {\n    return core._uuidv7(ZodUUID, params);\n}\nexport const ZodURL = /*@__PURE__*/ core.$constructor(\"ZodURL\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodURL.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function url(params) {\n    return core._url(ZodURL, params);\n}\nexport function httpUrl(params) {\n    return core._url(ZodURL, {\n        protocol: /^https?$/,\n        hostname: core.regexes.domain,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodEmoji = /*@__PURE__*/ core.$constructor(\"ZodEmoji\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodEmoji.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function emoji(params) {\n    return core._emoji(ZodEmoji, params);\n}\nexport const ZodNanoID = /*@__PURE__*/ core.$constructor(\"ZodNanoID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodNanoID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function nanoid(params) {\n    return core._nanoid(ZodNanoID, params);\n}\nexport const ZodCUID = /*@__PURE__*/ core.$constructor(\"ZodCUID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodCUID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function cuid(params) {\n    return core._cuid(ZodCUID, params);\n}\nexport const ZodCUID2 = /*@__PURE__*/ core.$constructor(\"ZodCUID2\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodCUID2.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function cuid2(params) {\n    return core._cuid2(ZodCUID2, params);\n}\nexport const ZodULID = /*@__PURE__*/ core.$constructor(\"ZodULID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodULID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function ulid(params) {\n    return core._ulid(ZodULID, params);\n}\nexport const ZodXID = /*@__PURE__*/ core.$constructor(\"ZodXID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodXID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function xid(params) {\n    return core._xid(ZodXID, params);\n}\nexport const ZodKSUID = /*@__PURE__*/ core.$constructor(\"ZodKSUID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodKSUID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function ksuid(params) {\n    return core._ksuid(ZodKSUID, params);\n}\nexport const ZodIPv4 = /*@__PURE__*/ core.$constructor(\"ZodIPv4\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodIPv4.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function ipv4(params) {\n    return core._ipv4(ZodIPv4, params);\n}\nexport const ZodMAC = /*@__PURE__*/ core.$constructor(\"ZodMAC\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodMAC.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function mac(params) {\n    return core._mac(ZodMAC, params);\n}\nexport const ZodIPv6 = /*@__PURE__*/ core.$constructor(\"ZodIPv6\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodIPv6.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function ipv6(params) {\n    return core._ipv6(ZodIPv6, params);\n}\nexport const ZodCIDRv4 = /*@__PURE__*/ core.$constructor(\"ZodCIDRv4\", (inst, def) => {\n    core.$ZodCIDRv4.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function cidrv4(params) {\n    return core._cidrv4(ZodCIDRv4, params);\n}\nexport const ZodCIDRv6 = /*@__PURE__*/ core.$constructor(\"ZodCIDRv6\", (inst, def) => {\n    core.$ZodCIDRv6.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function cidrv6(params) {\n    return core._cidrv6(ZodCIDRv6, params);\n}\nexport const ZodBase64 = /*@__PURE__*/ core.$constructor(\"ZodBase64\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodBase64.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function base64(params) {\n    return core._base64(ZodBase64, params);\n}\nexport const ZodBase64URL = /*@__PURE__*/ core.$constructor(\"ZodBase64URL\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodBase64URL.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function base64url(params) {\n    return core._base64url(ZodBase64URL, params);\n}\nexport const ZodE164 = /*@__PURE__*/ core.$constructor(\"ZodE164\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodE164.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function e164(params) {\n    return core._e164(ZodE164, params);\n}\nexport const ZodJWT = /*@__PURE__*/ core.$constructor(\"ZodJWT\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodJWT.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function jwt(params) {\n    return core._jwt(ZodJWT, params);\n}\nexport const ZodCustomStringFormat = /*@__PURE__*/ core.$constructor(\"ZodCustomStringFormat\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodCustomStringFormat.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function stringFormat(format, fnOrRegex, _params = {}) {\n    return core._stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);\n}\nexport function hostname(_params) {\n    return core._stringFormat(ZodCustomStringFormat, \"hostname\", core.regexes.hostname, _params);\n}\nexport function hex(_params) {\n    return core._stringFormat(ZodCustomStringFormat, \"hex\", core.regexes.hex, _params);\n}\nexport function hash(alg, params) {\n    const enc = params?.enc ?? \"hex\";\n    const format = `${alg}_${enc}`;\n    const regex = core.regexes[format];\n    if (!regex)\n        throw new Error(`Unrecognized hash format: ${format}`);\n    return core._stringFormat(ZodCustomStringFormat, format, regex, params);\n}\nexport const ZodNumber = /*@__PURE__*/ core.$constructor(\"ZodNumber\", (inst, def) => {\n    core.$ZodNumber.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.numberProcessor(inst, ctx, json, params);\n    inst.gt = (value, params) => inst.check(checks.gt(value, params));\n    inst.gte = (value, params) => inst.check(checks.gte(value, params));\n    inst.min = (value, params) => inst.check(checks.gte(value, params));\n    inst.lt = (value, params) => inst.check(checks.lt(value, params));\n    inst.lte = (value, params) => inst.check(checks.lte(value, params));\n    inst.max = (value, params) => inst.check(checks.lte(value, params));\n    inst.int = (params) => inst.check(int(params));\n    inst.safe = (params) => inst.check(int(params));\n    inst.positive = (params) => inst.check(checks.gt(0, params));\n    inst.nonnegative = (params) => inst.check(checks.gte(0, params));\n    inst.negative = (params) => inst.check(checks.lt(0, params));\n    inst.nonpositive = (params) => inst.check(checks.lte(0, params));\n    inst.multipleOf = (value, params) => inst.check(checks.multipleOf(value, params));\n    inst.step = (value, params) => inst.check(checks.multipleOf(value, params));\n    // inst.finite = (params) => inst.check(core.finite(params));\n    inst.finite = () => inst;\n    const bag = inst._zod.bag;\n    inst.minValue =\n        Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;\n    inst.maxValue =\n        Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;\n    inst.isInt = (bag.format ?? \"\").includes(\"int\") || Number.isSafeInteger(bag.multipleOf ?? 0.5);\n    inst.isFinite = true;\n    inst.format = bag.format ?? null;\n});\nexport function number(params) {\n    return core._number(ZodNumber, params);\n}\nexport const ZodNumberFormat = /*@__PURE__*/ core.$constructor(\"ZodNumberFormat\", (inst, def) => {\n    core.$ZodNumberFormat.init(inst, def);\n    ZodNumber.init(inst, def);\n});\nexport function int(params) {\n    return core._int(ZodNumberFormat, params);\n}\nexport function float32(params) {\n    return core._float32(ZodNumberFormat, params);\n}\nexport function float64(params) {\n    return core._float64(ZodNumberFormat, params);\n}\nexport function int32(params) {\n    return core._int32(ZodNumberFormat, params);\n}\nexport function uint32(params) {\n    return core._uint32(ZodNumberFormat, params);\n}\nexport const ZodBoolean = /*@__PURE__*/ core.$constructor(\"ZodBoolean\", (inst, def) => {\n    core.$ZodBoolean.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.booleanProcessor(inst, ctx, json, params);\n});\nexport function boolean(params) {\n    return core._boolean(ZodBoolean, params);\n}\nexport const ZodBigInt = /*@__PURE__*/ core.$constructor(\"ZodBigInt\", (inst, def) => {\n    core.$ZodBigInt.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.bigintProcessor(inst, ctx, json, params);\n    inst.gte = (value, params) => inst.check(checks.gte(value, params));\n    inst.min = (value, params) => inst.check(checks.gte(value, params));\n    inst.gt = (value, params) => inst.check(checks.gt(value, params));\n    inst.gte = (value, params) => inst.check(checks.gte(value, params));\n    inst.min = (value, params) => inst.check(checks.gte(value, params));\n    inst.lt = (value, params) => inst.check(checks.lt(value, params));\n    inst.lte = (value, params) => inst.check(checks.lte(value, params));\n    inst.max = (value, params) => inst.check(checks.lte(value, params));\n    inst.positive = (params) => inst.check(checks.gt(BigInt(0), params));\n    inst.negative = (params) => inst.check(checks.lt(BigInt(0), params));\n    inst.nonpositive = (params) => inst.check(checks.lte(BigInt(0), params));\n    inst.nonnegative = (params) => inst.check(checks.gte(BigInt(0), params));\n    inst.multipleOf = (value, params) => inst.check(checks.multipleOf(value, params));\n    const bag = inst._zod.bag;\n    inst.minValue = bag.minimum ?? null;\n    inst.maxValue = bag.maximum ?? null;\n    inst.format = bag.format ?? null;\n});\nexport function bigint(params) {\n    return core._bigint(ZodBigInt, params);\n}\nexport const ZodBigIntFormat = /*@__PURE__*/ core.$constructor(\"ZodBigIntFormat\", (inst, def) => {\n    core.$ZodBigIntFormat.init(inst, def);\n    ZodBigInt.init(inst, def);\n});\n// int64\nexport function int64(params) {\n    return core._int64(ZodBigIntFormat, params);\n}\n// uint64\nexport function uint64(params) {\n    return core._uint64(ZodBigIntFormat, params);\n}\nexport const ZodSymbol = /*@__PURE__*/ core.$constructor(\"ZodSymbol\", (inst, def) => {\n    core.$ZodSymbol.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.symbolProcessor(inst, ctx, json, params);\n});\nexport function symbol(params) {\n    return core._symbol(ZodSymbol, params);\n}\nexport const ZodUndefined = /*@__PURE__*/ core.$constructor(\"ZodUndefined\", (inst, def) => {\n    core.$ZodUndefined.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.undefinedProcessor(inst, ctx, json, params);\n});\nfunction _undefined(params) {\n    return core._undefined(ZodUndefined, params);\n}\nexport { _undefined as undefined };\nexport const ZodNull = /*@__PURE__*/ core.$constructor(\"ZodNull\", (inst, def) => {\n    core.$ZodNull.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.nullProcessor(inst, ctx, json, params);\n});\nfunction _null(params) {\n    return core._null(ZodNull, params);\n}\nexport { _null as null };\nexport const ZodAny = /*@__PURE__*/ core.$constructor(\"ZodAny\", (inst, def) => {\n    core.$ZodAny.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.anyProcessor(inst, ctx, json, params);\n});\nexport function any() {\n    return core._any(ZodAny);\n}\nexport const ZodUnknown = /*@__PURE__*/ core.$constructor(\"ZodUnknown\", (inst, def) => {\n    core.$ZodUnknown.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.unknownProcessor(inst, ctx, json, params);\n});\nexport function unknown() {\n    return core._unknown(ZodUnknown);\n}\nexport const ZodNever = /*@__PURE__*/ core.$constructor(\"ZodNever\", (inst, def) => {\n    core.$ZodNever.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.neverProcessor(inst, ctx, json, params);\n});\nexport function never(params) {\n    return core._never(ZodNever, params);\n}\nexport const ZodVoid = /*@__PURE__*/ core.$constructor(\"ZodVoid\", (inst, def) => {\n    core.$ZodVoid.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.voidProcessor(inst, ctx, json, params);\n});\nfunction _void(params) {\n    return core._void(ZodVoid, params);\n}\nexport { _void as void };\nexport const ZodDate = /*@__PURE__*/ core.$constructor(\"ZodDate\", (inst, def) => {\n    core.$ZodDate.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.dateProcessor(inst, ctx, json, params);\n    inst.min = (value, params) => inst.check(checks.gte(value, params));\n    inst.max = (value, params) => inst.check(checks.lte(value, params));\n    const c = inst._zod.bag;\n    inst.minDate = c.minimum ? new Date(c.minimum) : null;\n    inst.maxDate = c.maximum ? new Date(c.maximum) : null;\n});\nexport function date(params) {\n    return core._date(ZodDate, params);\n}\nexport const ZodArray = /*@__PURE__*/ core.$constructor(\"ZodArray\", (inst, def) => {\n    core.$ZodArray.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.arrayProcessor(inst, ctx, json, params);\n    inst.element = def.element;\n    inst.min = (minLength, params) => inst.check(checks.minLength(minLength, params));\n    inst.nonempty = (params) => inst.check(checks.minLength(1, params));\n    inst.max = (maxLength, params) => inst.check(checks.maxLength(maxLength, params));\n    inst.length = (len, params) => inst.check(checks.length(len, params));\n    inst.unwrap = () => inst.element;\n});\nexport function array(element, params) {\n    return core._array(ZodArray, element, params);\n}\n// .keyof\nexport function keyof(schema) {\n    const shape = schema._zod.def.shape;\n    return _enum(Object.keys(shape));\n}\nexport const ZodObject = /*@__PURE__*/ core.$constructor(\"ZodObject\", (inst, def) => {\n    core.$ZodObjectJIT.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.objectProcessor(inst, ctx, json, params);\n    util.defineLazy(inst, \"shape\", () => {\n        return def.shape;\n    });\n    inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));\n    inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall: catchall });\n    inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n    inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n    inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });\n    inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });\n    inst.extend = (incoming) => {\n        return util.extend(inst, incoming);\n    };\n    inst.safeExtend = (incoming) => {\n        return util.safeExtend(inst, incoming);\n    };\n    inst.merge = (other) => util.merge(inst, other);\n    inst.pick = (mask) => util.pick(inst, mask);\n    inst.omit = (mask) => util.omit(inst, mask);\n    inst.partial = (...args) => util.partial(ZodOptional, inst, args[0]);\n    inst.required = (...args) => util.required(ZodNonOptional, inst, args[0]);\n});\nexport function object(shape, params) {\n    const def = {\n        type: \"object\",\n        shape: shape ?? {},\n        ...util.normalizeParams(params),\n    };\n    return new ZodObject(def);\n}\n// strictObject\nexport function strictObject(shape, params) {\n    return new ZodObject({\n        type: \"object\",\n        shape,\n        catchall: never(),\n        ...util.normalizeParams(params),\n    });\n}\n// looseObject\nexport function looseObject(shape, params) {\n    return new ZodObject({\n        type: \"object\",\n        shape,\n        catchall: unknown(),\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodUnion = /*@__PURE__*/ core.$constructor(\"ZodUnion\", (inst, def) => {\n    core.$ZodUnion.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.unionProcessor(inst, ctx, json, params);\n    inst.options = def.options;\n});\nexport function union(options, params) {\n    return new ZodUnion({\n        type: \"union\",\n        options: options,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodXor = /*@__PURE__*/ core.$constructor(\"ZodXor\", (inst, def) => {\n    ZodUnion.init(inst, def);\n    core.$ZodXor.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.unionProcessor(inst, ctx, json, params);\n    inst.options = def.options;\n});\n/** Creates an exclusive union (XOR) where exactly one option must match.\n * Unlike regular unions that succeed when any option matches, xor fails if\n * zero or more than one option matches the input. */\nexport function xor(options, params) {\n    return new ZodXor({\n        type: \"union\",\n        options: options,\n        inclusive: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodDiscriminatedUnion = /*@__PURE__*/ core.$constructor(\"ZodDiscriminatedUnion\", (inst, def) => {\n    ZodUnion.init(inst, def);\n    core.$ZodDiscriminatedUnion.init(inst, def);\n});\nexport function discriminatedUnion(discriminator, options, params) {\n    // const [options, params] = args;\n    return new ZodDiscriminatedUnion({\n        type: \"union\",\n        options,\n        discriminator,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodIntersection = /*@__PURE__*/ core.$constructor(\"ZodIntersection\", (inst, def) => {\n    core.$ZodIntersection.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.intersectionProcessor(inst, ctx, json, params);\n});\nexport function intersection(left, right) {\n    return new ZodIntersection({\n        type: \"intersection\",\n        left: left,\n        right: right,\n    });\n}\nexport const ZodTuple = /*@__PURE__*/ core.$constructor(\"ZodTuple\", (inst, def) => {\n    core.$ZodTuple.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.tupleProcessor(inst, ctx, json, params);\n    inst.rest = (rest) => inst.clone({\n        ...inst._zod.def,\n        rest: rest,\n    });\n});\nexport function tuple(items, _paramsOrRest, _params) {\n    const hasRest = _paramsOrRest instanceof core.$ZodType;\n    const params = hasRest ? _params : _paramsOrRest;\n    const rest = hasRest ? _paramsOrRest : null;\n    return new ZodTuple({\n        type: \"tuple\",\n        items: items,\n        rest,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodRecord = /*@__PURE__*/ core.$constructor(\"ZodRecord\", (inst, def) => {\n    core.$ZodRecord.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.recordProcessor(inst, ctx, json, params);\n    inst.keyType = def.keyType;\n    inst.valueType = def.valueType;\n});\nexport function record(keyType, valueType, params) {\n    return new ZodRecord({\n        type: \"record\",\n        keyType,\n        valueType: valueType,\n        ...util.normalizeParams(params),\n    });\n}\n// type alksjf = core.output<core.$ZodRecordKey>;\nexport function partialRecord(keyType, valueType, params) {\n    const k = core.clone(keyType);\n    k._zod.values = undefined;\n    return new ZodRecord({\n        type: \"record\",\n        keyType: k,\n        valueType: valueType,\n        ...util.normalizeParams(params),\n    });\n}\nexport function looseRecord(keyType, valueType, params) {\n    return new ZodRecord({\n        type: \"record\",\n        keyType,\n        valueType: valueType,\n        mode: \"loose\",\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodMap = /*@__PURE__*/ core.$constructor(\"ZodMap\", (inst, def) => {\n    core.$ZodMap.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.mapProcessor(inst, ctx, json, params);\n    inst.keyType = def.keyType;\n    inst.valueType = def.valueType;\n    inst.min = (...args) => inst.check(core._minSize(...args));\n    inst.nonempty = (params) => inst.check(core._minSize(1, params));\n    inst.max = (...args) => inst.check(core._maxSize(...args));\n    inst.size = (...args) => inst.check(core._size(...args));\n});\nexport function map(keyType, valueType, params) {\n    return new ZodMap({\n        type: \"map\",\n        keyType: keyType,\n        valueType: valueType,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodSet = /*@__PURE__*/ core.$constructor(\"ZodSet\", (inst, def) => {\n    core.$ZodSet.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.setProcessor(inst, ctx, json, params);\n    inst.min = (...args) => inst.check(core._minSize(...args));\n    inst.nonempty = (params) => inst.check(core._minSize(1, params));\n    inst.max = (...args) => inst.check(core._maxSize(...args));\n    inst.size = (...args) => inst.check(core._size(...args));\n});\nexport function set(valueType, params) {\n    return new ZodSet({\n        type: \"set\",\n        valueType: valueType,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodEnum = /*@__PURE__*/ core.$constructor(\"ZodEnum\", (inst, def) => {\n    core.$ZodEnum.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.enumProcessor(inst, ctx, json, params);\n    inst.enum = def.entries;\n    inst.options = Object.values(def.entries);\n    const keys = new Set(Object.keys(def.entries));\n    inst.extract = (values, params) => {\n        const newEntries = {};\n        for (const value of values) {\n            if (keys.has(value)) {\n                newEntries[value] = def.entries[value];\n            }\n            else\n                throw new Error(`Key ${value} not found in enum`);\n        }\n        return new ZodEnum({\n            ...def,\n            checks: [],\n            ...util.normalizeParams(params),\n            entries: newEntries,\n        });\n    };\n    inst.exclude = (values, params) => {\n        const newEntries = { ...def.entries };\n        for (const value of values) {\n            if (keys.has(value)) {\n                delete newEntries[value];\n            }\n            else\n                throw new Error(`Key ${value} not found in enum`);\n        }\n        return new ZodEnum({\n            ...def,\n            checks: [],\n            ...util.normalizeParams(params),\n            entries: newEntries,\n        });\n    };\n});\nfunction _enum(values, params) {\n    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n    return new ZodEnum({\n        type: \"enum\",\n        entries,\n        ...util.normalizeParams(params),\n    });\n}\nexport { _enum as enum };\n/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.\n *\n * ```ts\n * enum Colors { red, green, blue }\n * z.enum(Colors);\n * ```\n */\nexport function nativeEnum(entries, params) {\n    return new ZodEnum({\n        type: \"enum\",\n        entries,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodLiteral = /*@__PURE__*/ core.$constructor(\"ZodLiteral\", (inst, def) => {\n    core.$ZodLiteral.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.literalProcessor(inst, ctx, json, params);\n    inst.values = new Set(def.values);\n    Object.defineProperty(inst, \"value\", {\n        get() {\n            if (def.values.length > 1) {\n                throw new Error(\"This schema contains multiple valid literal values. Use `.values` instead.\");\n            }\n            return def.values[0];\n        },\n    });\n});\nexport function literal(value, params) {\n    return new ZodLiteral({\n        type: \"literal\",\n        values: Array.isArray(value) ? value : [value],\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodFile = /*@__PURE__*/ core.$constructor(\"ZodFile\", (inst, def) => {\n    core.$ZodFile.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.fileProcessor(inst, ctx, json, params);\n    inst.min = (size, params) => inst.check(core._minSize(size, params));\n    inst.max = (size, params) => inst.check(core._maxSize(size, params));\n    inst.mime = (types, params) => inst.check(core._mime(Array.isArray(types) ? types : [types], params));\n});\nexport function file(params) {\n    return core._file(ZodFile, params);\n}\nexport const ZodTransform = /*@__PURE__*/ core.$constructor(\"ZodTransform\", (inst, def) => {\n    core.$ZodTransform.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.transformProcessor(inst, ctx, json, params);\n    inst._zod.parse = (payload, _ctx) => {\n        if (_ctx.direction === \"backward\") {\n            throw new core.$ZodEncodeError(inst.constructor.name);\n        }\n        payload.addIssue = (issue) => {\n            if (typeof issue === \"string\") {\n                payload.issues.push(util.issue(issue, payload.value, def));\n            }\n            else {\n                // for Zod 3 backwards compatibility\n                const _issue = issue;\n                if (_issue.fatal)\n                    _issue.continue = false;\n                _issue.code ?? (_issue.code = \"custom\");\n                _issue.input ?? (_issue.input = payload.value);\n                _issue.inst ?? (_issue.inst = inst);\n                // _issue.continue ??= true;\n                payload.issues.push(util.issue(_issue));\n            }\n        };\n        const output = def.transform(payload.value, payload);\n        if (output instanceof Promise) {\n            return output.then((output) => {\n                payload.value = output;\n                return payload;\n            });\n        }\n        payload.value = output;\n        return payload;\n    };\n});\nexport function transform(fn) {\n    return new ZodTransform({\n        type: \"transform\",\n        transform: fn,\n    });\n}\nexport const ZodOptional = /*@__PURE__*/ core.$constructor(\"ZodOptional\", (inst, def) => {\n    core.$ZodOptional.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.optionalProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function optional(innerType) {\n    return new ZodOptional({\n        type: \"optional\",\n        innerType: innerType,\n    });\n}\nexport const ZodExactOptional = /*@__PURE__*/ core.$constructor(\"ZodExactOptional\", (inst, def) => {\n    core.$ZodExactOptional.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.optionalProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function exactOptional(innerType) {\n    return new ZodExactOptional({\n        type: \"optional\",\n        innerType: innerType,\n    });\n}\nexport const ZodNullable = /*@__PURE__*/ core.$constructor(\"ZodNullable\", (inst, def) => {\n    core.$ZodNullable.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.nullableProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function nullable(innerType) {\n    return new ZodNullable({\n        type: \"nullable\",\n        innerType: innerType,\n    });\n}\n// nullish\nexport function nullish(innerType) {\n    return optional(nullable(innerType));\n}\nexport const ZodDefault = /*@__PURE__*/ core.$constructor(\"ZodDefault\", (inst, def) => {\n    core.$ZodDefault.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.defaultProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n    inst.removeDefault = inst.unwrap;\n});\nexport function _default(innerType, defaultValue) {\n    return new ZodDefault({\n        type: \"default\",\n        innerType: innerType,\n        get defaultValue() {\n            return typeof defaultValue === \"function\" ? defaultValue() : util.shallowClone(defaultValue);\n        },\n    });\n}\nexport const ZodPrefault = /*@__PURE__*/ core.$constructor(\"ZodPrefault\", (inst, def) => {\n    core.$ZodPrefault.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.prefaultProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function prefault(innerType, defaultValue) {\n    return new ZodPrefault({\n        type: \"prefault\",\n        innerType: innerType,\n        get defaultValue() {\n            return typeof defaultValue === \"function\" ? defaultValue() : util.shallowClone(defaultValue);\n        },\n    });\n}\nexport const ZodNonOptional = /*@__PURE__*/ core.$constructor(\"ZodNonOptional\", (inst, def) => {\n    core.$ZodNonOptional.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.nonoptionalProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function nonoptional(innerType, params) {\n    return new ZodNonOptional({\n        type: \"nonoptional\",\n        innerType: innerType,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodSuccess = /*@__PURE__*/ core.$constructor(\"ZodSuccess\", (inst, def) => {\n    core.$ZodSuccess.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.successProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function success(innerType) {\n    return new ZodSuccess({\n        type: \"success\",\n        innerType: innerType,\n    });\n}\nexport const ZodCatch = /*@__PURE__*/ core.$constructor(\"ZodCatch\", (inst, def) => {\n    core.$ZodCatch.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.catchProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n    inst.removeCatch = inst.unwrap;\n});\nfunction _catch(innerType, catchValue) {\n    return new ZodCatch({\n        type: \"catch\",\n        innerType: innerType,\n        catchValue: (typeof catchValue === \"function\" ? catchValue : () => catchValue),\n    });\n}\nexport { _catch as catch };\nexport const ZodNaN = /*@__PURE__*/ core.$constructor(\"ZodNaN\", (inst, def) => {\n    core.$ZodNaN.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.nanProcessor(inst, ctx, json, params);\n});\nexport function nan(params) {\n    return core._nan(ZodNaN, params);\n}\nexport const ZodPipe = /*@__PURE__*/ core.$constructor(\"ZodPipe\", (inst, def) => {\n    core.$ZodPipe.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.pipeProcessor(inst, ctx, json, params);\n    inst.in = def.in;\n    inst.out = def.out;\n});\nexport function pipe(in_, out) {\n    return new ZodPipe({\n        type: \"pipe\",\n        in: in_,\n        out: out,\n        // ...util.normalizeParams(params),\n    });\n}\nexport const ZodCodec = /*@__PURE__*/ core.$constructor(\"ZodCodec\", (inst, def) => {\n    ZodPipe.init(inst, def);\n    core.$ZodCodec.init(inst, def);\n});\nexport function codec(in_, out, params) {\n    return new ZodCodec({\n        type: \"pipe\",\n        in: in_,\n        out: out,\n        transform: params.decode,\n        reverseTransform: params.encode,\n    });\n}\nexport const ZodReadonly = /*@__PURE__*/ core.$constructor(\"ZodReadonly\", (inst, def) => {\n    core.$ZodReadonly.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.readonlyProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function readonly(innerType) {\n    return new ZodReadonly({\n        type: \"readonly\",\n        innerType: innerType,\n    });\n}\nexport const ZodTemplateLiteral = /*@__PURE__*/ core.$constructor(\"ZodTemplateLiteral\", (inst, def) => {\n    core.$ZodTemplateLiteral.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.templateLiteralProcessor(inst, ctx, json, params);\n});\nexport function templateLiteral(parts, params) {\n    return new ZodTemplateLiteral({\n        type: \"template_literal\",\n        parts,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodLazy = /*@__PURE__*/ core.$constructor(\"ZodLazy\", (inst, def) => {\n    core.$ZodLazy.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.lazyProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.getter();\n});\nexport function lazy(getter) {\n    return new ZodLazy({\n        type: \"lazy\",\n        getter: getter,\n    });\n}\nexport const ZodPromise = /*@__PURE__*/ core.$constructor(\"ZodPromise\", (inst, def) => {\n    core.$ZodPromise.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.promiseProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function promise(innerType) {\n    return new ZodPromise({\n        type: \"promise\",\n        innerType: innerType,\n    });\n}\nexport const ZodFunction = /*@__PURE__*/ core.$constructor(\"ZodFunction\", (inst, def) => {\n    core.$ZodFunction.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.functionProcessor(inst, ctx, json, params);\n});\nexport function _function(params) {\n    return new ZodFunction({\n        type: \"function\",\n        input: Array.isArray(params?.input) ? tuple(params?.input) : (params?.input ?? array(unknown())),\n        output: params?.output ?? unknown(),\n    });\n}\nexport { _function as function };\nexport const ZodCustom = /*@__PURE__*/ core.$constructor(\"ZodCustom\", (inst, def) => {\n    core.$ZodCustom.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.customProcessor(inst, ctx, json, params);\n});\n// custom checks\nexport function check(fn) {\n    const ch = new core.$ZodCheck({\n        check: \"custom\",\n        // ...util.normalizeParams(params),\n    });\n    ch._zod.check = fn;\n    return ch;\n}\nexport function custom(fn, _params) {\n    return core._custom(ZodCustom, fn ?? (() => true), _params);\n}\nexport function refine(fn, _params = {}) {\n    return core._refine(ZodCustom, fn, _params);\n}\n// superRefine\nexport function superRefine(fn) {\n    return core._superRefine(fn);\n}\n// Re-export describe and meta from core\nexport const describe = core.describe;\nexport const meta = core.meta;\nfunction _instanceof(cls, params = {}) {\n    const inst = new ZodCustom({\n        type: \"custom\",\n        check: \"custom\",\n        fn: (data) => data instanceof cls,\n        abort: true,\n        ...util.normalizeParams(params),\n    });\n    inst._zod.bag.Class = cls;\n    // Override check to emit invalid_type instead of custom\n    inst._zod.check = (payload) => {\n        if (!(payload.value instanceof cls)) {\n            payload.issues.push({\n                code: \"invalid_type\",\n                expected: cls.name,\n                input: payload.value,\n                inst,\n                path: [...(inst._zod.def.path ?? [])],\n            });\n        }\n    };\n    return inst;\n}\nexport { _instanceof as instanceof };\n// stringbool\nexport const stringbool = (...args) => core._stringbool({\n    Codec: ZodCodec,\n    Boolean: ZodBoolean,\n    String: ZodString,\n}, ...args);\nexport function json(params) {\n    const jsonSchema = lazy(() => {\n        return union([string(params), number(), boolean(), _null(), array(jsonSchema), record(string(), jsonSchema)]);\n    });\n    return jsonSchema;\n}\n// preprocess\n// /** @deprecated Use `z.pipe()` and `z.transform()` instead. */\nexport function preprocess(fn, schema) {\n    return pipe(transform(fn), schema);\n}\n","import * as checks from \"./checks.js\";\nimport * as registries from \"./registries.js\";\nimport * as schemas from \"./schemas.js\";\nimport * as util from \"./util.js\";\n// @__NO_SIDE_EFFECTS__\nexport function _string(Class, params) {\n    return new Class({\n        type: \"string\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _coercedString(Class, params) {\n    return new Class({\n        type: \"string\",\n        coerce: true,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _email(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"email\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _guid(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"guid\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _uuid(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"uuid\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _uuidv4(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"uuid\",\n        check: \"string_format\",\n        abort: false,\n        version: \"v4\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _uuidv6(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"uuid\",\n        check: \"string_format\",\n        abort: false,\n        version: \"v6\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _uuidv7(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"uuid\",\n        check: \"string_format\",\n        abort: false,\n        version: \"v7\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _url(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"url\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _emoji(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"emoji\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _nanoid(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"nanoid\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _cuid(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"cuid\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _cuid2(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"cuid2\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _ulid(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"ulid\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _xid(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"xid\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _ksuid(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"ksuid\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _ipv4(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"ipv4\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _ipv6(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"ipv6\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _mac(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"mac\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _cidrv4(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"cidrv4\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _cidrv6(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"cidrv6\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _base64(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"base64\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _base64url(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"base64url\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _e164(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"e164\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _jwt(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"jwt\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport const TimePrecision = {\n    Any: null,\n    Minute: -1,\n    Second: 0,\n    Millisecond: 3,\n    Microsecond: 6,\n};\n// @__NO_SIDE_EFFECTS__\nexport function _isoDateTime(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"datetime\",\n        check: \"string_format\",\n        offset: false,\n        local: false,\n        precision: null,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _isoDate(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"date\",\n        check: \"string_format\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _isoTime(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"time\",\n        check: \"string_format\",\n        precision: null,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _isoDuration(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"duration\",\n        check: \"string_format\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _number(Class, params) {\n    return new Class({\n        type: \"number\",\n        checks: [],\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _coercedNumber(Class, params) {\n    return new Class({\n        type: \"number\",\n        coerce: true,\n        checks: [],\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _int(Class, params) {\n    return new Class({\n        type: \"number\",\n        check: \"number_format\",\n        abort: false,\n        format: \"safeint\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _float32(Class, params) {\n    return new Class({\n        type: \"number\",\n        check: \"number_format\",\n        abort: false,\n        format: \"float32\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _float64(Class, params) {\n    return new Class({\n        type: \"number\",\n        check: \"number_format\",\n        abort: false,\n        format: \"float64\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _int32(Class, params) {\n    return new Class({\n        type: \"number\",\n        check: \"number_format\",\n        abort: false,\n        format: \"int32\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _uint32(Class, params) {\n    return new Class({\n        type: \"number\",\n        check: \"number_format\",\n        abort: false,\n        format: \"uint32\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _boolean(Class, params) {\n    return new Class({\n        type: \"boolean\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _coercedBoolean(Class, params) {\n    return new Class({\n        type: \"boolean\",\n        coerce: true,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _bigint(Class, params) {\n    return new Class({\n        type: \"bigint\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _coercedBigint(Class, params) {\n    return new Class({\n        type: \"bigint\",\n        coerce: true,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _int64(Class, params) {\n    return new Class({\n        type: \"bigint\",\n        check: \"bigint_format\",\n        abort: false,\n        format: \"int64\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _uint64(Class, params) {\n    return new Class({\n        type: \"bigint\",\n        check: \"bigint_format\",\n        abort: false,\n        format: \"uint64\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _symbol(Class, params) {\n    return new Class({\n        type: \"symbol\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _undefined(Class, params) {\n    return new Class({\n        type: \"undefined\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _null(Class, params) {\n    return new Class({\n        type: \"null\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _any(Class) {\n    return new Class({\n        type: \"any\",\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _unknown(Class) {\n    return new Class({\n        type: \"unknown\",\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _never(Class, params) {\n    return new Class({\n        type: \"never\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _void(Class, params) {\n    return new Class({\n        type: \"void\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _date(Class, params) {\n    return new Class({\n        type: \"date\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _coercedDate(Class, params) {\n    return new Class({\n        type: \"date\",\n        coerce: true,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _nan(Class, params) {\n    return new Class({\n        type: \"nan\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _lt(value, params) {\n    return new checks.$ZodCheckLessThan({\n        check: \"less_than\",\n        ...util.normalizeParams(params),\n        value,\n        inclusive: false,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _lte(value, params) {\n    return new checks.$ZodCheckLessThan({\n        check: \"less_than\",\n        ...util.normalizeParams(params),\n        value,\n        inclusive: true,\n    });\n}\nexport { \n/** @deprecated Use `z.lte()` instead. */\n_lte as _max, };\n// @__NO_SIDE_EFFECTS__\nexport function _gt(value, params) {\n    return new checks.$ZodCheckGreaterThan({\n        check: \"greater_than\",\n        ...util.normalizeParams(params),\n        value,\n        inclusive: false,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _gte(value, params) {\n    return new checks.$ZodCheckGreaterThan({\n        check: \"greater_than\",\n        ...util.normalizeParams(params),\n        value,\n        inclusive: true,\n    });\n}\nexport { \n/** @deprecated Use `z.gte()` instead. */\n_gte as _min, };\n// @__NO_SIDE_EFFECTS__\nexport function _positive(params) {\n    return _gt(0, params);\n}\n// negative\n// @__NO_SIDE_EFFECTS__\nexport function _negative(params) {\n    return _lt(0, params);\n}\n// nonpositive\n// @__NO_SIDE_EFFECTS__\nexport function _nonpositive(params) {\n    return _lte(0, params);\n}\n// nonnegative\n// @__NO_SIDE_EFFECTS__\nexport function _nonnegative(params) {\n    return _gte(0, params);\n}\n// @__NO_SIDE_EFFECTS__\nexport function _multipleOf(value, params) {\n    return new checks.$ZodCheckMultipleOf({\n        check: \"multiple_of\",\n        ...util.normalizeParams(params),\n        value,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _maxSize(maximum, params) {\n    return new checks.$ZodCheckMaxSize({\n        check: \"max_size\",\n        ...util.normalizeParams(params),\n        maximum,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _minSize(minimum, params) {\n    return new checks.$ZodCheckMinSize({\n        check: \"min_size\",\n        ...util.normalizeParams(params),\n        minimum,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _size(size, params) {\n    return new checks.$ZodCheckSizeEquals({\n        check: \"size_equals\",\n        ...util.normalizeParams(params),\n        size,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _maxLength(maximum, params) {\n    const ch = new checks.$ZodCheckMaxLength({\n        check: \"max_length\",\n        ...util.normalizeParams(params),\n        maximum,\n    });\n    return ch;\n}\n// @__NO_SIDE_EFFECTS__\nexport function _minLength(minimum, params) {\n    return new checks.$ZodCheckMinLength({\n        check: \"min_length\",\n        ...util.normalizeParams(params),\n        minimum,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _length(length, params) {\n    return new checks.$ZodCheckLengthEquals({\n        check: \"length_equals\",\n        ...util.normalizeParams(params),\n        length,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _regex(pattern, params) {\n    return new checks.$ZodCheckRegex({\n        check: \"string_format\",\n        format: \"regex\",\n        ...util.normalizeParams(params),\n        pattern,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _lowercase(params) {\n    return new checks.$ZodCheckLowerCase({\n        check: \"string_format\",\n        format: \"lowercase\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _uppercase(params) {\n    return new checks.$ZodCheckUpperCase({\n        check: \"string_format\",\n        format: \"uppercase\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _includes(includes, params) {\n    return new checks.$ZodCheckIncludes({\n        check: \"string_format\",\n        format: \"includes\",\n        ...util.normalizeParams(params),\n        includes,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _startsWith(prefix, params) {\n    return new checks.$ZodCheckStartsWith({\n        check: \"string_format\",\n        format: \"starts_with\",\n        ...util.normalizeParams(params),\n        prefix,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _endsWith(suffix, params) {\n    return new checks.$ZodCheckEndsWith({\n        check: \"string_format\",\n        format: \"ends_with\",\n        ...util.normalizeParams(params),\n        suffix,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _property(property, schema, params) {\n    return new checks.$ZodCheckProperty({\n        check: \"property\",\n        property,\n        schema,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _mime(types, params) {\n    return new checks.$ZodCheckMimeType({\n        check: \"mime_type\",\n        mime: types,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _overwrite(tx) {\n    return new checks.$ZodCheckOverwrite({\n        check: \"overwrite\",\n        tx,\n    });\n}\n// normalize\n// @__NO_SIDE_EFFECTS__\nexport function _normalize(form) {\n    return _overwrite((input) => input.normalize(form));\n}\n// trim\n// @__NO_SIDE_EFFECTS__\nexport function _trim() {\n    return _overwrite((input) => input.trim());\n}\n// toLowerCase\n// @__NO_SIDE_EFFECTS__\nexport function _toLowerCase() {\n    return _overwrite((input) => input.toLowerCase());\n}\n// toUpperCase\n// @__NO_SIDE_EFFECTS__\nexport function _toUpperCase() {\n    return _overwrite((input) => input.toUpperCase());\n}\n// slugify\n// @__NO_SIDE_EFFECTS__\nexport function _slugify() {\n    return _overwrite((input) => util.slugify(input));\n}\n// @__NO_SIDE_EFFECTS__\nexport function _array(Class, element, params) {\n    return new Class({\n        type: \"array\",\n        element,\n        // get element() {\n        //   return element;\n        // },\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _union(Class, options, params) {\n    return new Class({\n        type: \"union\",\n        options,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _xor(Class, options, params) {\n    return new Class({\n        type: \"union\",\n        options,\n        inclusive: false,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _discriminatedUnion(Class, discriminator, options, params) {\n    return new Class({\n        type: \"union\",\n        options,\n        discriminator,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _intersection(Class, left, right) {\n    return new Class({\n        type: \"intersection\",\n        left,\n        right,\n    });\n}\n// export function _tuple(\n//   Class: util.SchemaClass<schemas.$ZodTuple>,\n//   items: [],\n//   params?: string | $ZodTupleParams\n// ): schemas.$ZodTuple<[], null>;\n// @__NO_SIDE_EFFECTS__\nexport function _tuple(Class, items, _paramsOrRest, _params) {\n    const hasRest = _paramsOrRest instanceof schemas.$ZodType;\n    const params = hasRest ? _params : _paramsOrRest;\n    const rest = hasRest ? _paramsOrRest : null;\n    return new Class({\n        type: \"tuple\",\n        items,\n        rest,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _record(Class, keyType, valueType, params) {\n    return new Class({\n        type: \"record\",\n        keyType,\n        valueType,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _map(Class, keyType, valueType, params) {\n    return new Class({\n        type: \"map\",\n        keyType,\n        valueType,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _set(Class, valueType, params) {\n    return new Class({\n        type: \"set\",\n        valueType,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _enum(Class, values, params) {\n    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n    // if (Array.isArray(values)) {\n    //   for (const value of values) {\n    //     entries[value] = value;\n    //   }\n    // } else {\n    //   Object.assign(entries, values);\n    // }\n    // const entries: util.EnumLike = {};\n    // for (const val of values) {\n    //   entries[val] = val;\n    // }\n    return new Class({\n        type: \"enum\",\n        entries,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\n/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.\n *\n * ```ts\n * enum Colors { red, green, blue }\n * z.enum(Colors);\n * ```\n */\nexport function _nativeEnum(Class, entries, params) {\n    return new Class({\n        type: \"enum\",\n        entries,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _literal(Class, value, params) {\n    return new Class({\n        type: \"literal\",\n        values: Array.isArray(value) ? value : [value],\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _file(Class, params) {\n    return new Class({\n        type: \"file\",\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _transform(Class, fn) {\n    return new Class({\n        type: \"transform\",\n        transform: fn,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _optional(Class, innerType) {\n    return new Class({\n        type: \"optional\",\n        innerType,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _nullable(Class, innerType) {\n    return new Class({\n        type: \"nullable\",\n        innerType,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _default(Class, innerType, defaultValue) {\n    return new Class({\n        type: \"default\",\n        innerType,\n        get defaultValue() {\n            return typeof defaultValue === \"function\" ? defaultValue() : util.shallowClone(defaultValue);\n        },\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _nonoptional(Class, innerType, params) {\n    return new Class({\n        type: \"nonoptional\",\n        innerType,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _success(Class, innerType) {\n    return new Class({\n        type: \"success\",\n        innerType,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _catch(Class, innerType, catchValue) {\n    return new Class({\n        type: \"catch\",\n        innerType,\n        catchValue: (typeof catchValue === \"function\" ? catchValue : () => catchValue),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _pipe(Class, in_, out) {\n    return new Class({\n        type: \"pipe\",\n        in: in_,\n        out,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _readonly(Class, innerType) {\n    return new Class({\n        type: \"readonly\",\n        innerType,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _templateLiteral(Class, parts, params) {\n    return new Class({\n        type: \"template_literal\",\n        parts,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _lazy(Class, getter) {\n    return new Class({\n        type: \"lazy\",\n        getter,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _promise(Class, innerType) {\n    return new Class({\n        type: \"promise\",\n        innerType,\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function _custom(Class, fn, _params) {\n    const norm = util.normalizeParams(_params);\n    norm.abort ?? (norm.abort = true); // default to abort:false\n    const schema = new Class({\n        type: \"custom\",\n        check: \"custom\",\n        fn: fn,\n        ...norm,\n    });\n    return schema;\n}\n// same as _custom but defaults to abort:false\n// @__NO_SIDE_EFFECTS__\nexport function _refine(Class, fn, _params) {\n    const schema = new Class({\n        type: \"custom\",\n        check: \"custom\",\n        fn: fn,\n        ...util.normalizeParams(_params),\n    });\n    return schema;\n}\n// @__NO_SIDE_EFFECTS__\nexport function _superRefine(fn) {\n    const ch = _check((payload) => {\n        payload.addIssue = (issue) => {\n            if (typeof issue === \"string\") {\n                payload.issues.push(util.issue(issue, payload.value, ch._zod.def));\n            }\n            else {\n                // for Zod 3 backwards compatibility\n                const _issue = issue;\n                if (_issue.fatal)\n                    _issue.continue = false;\n                _issue.code ?? (_issue.code = \"custom\");\n                _issue.input ?? (_issue.input = payload.value);\n                _issue.inst ?? (_issue.inst = ch);\n                _issue.continue ?? (_issue.continue = !ch._zod.def.abort); // abort is always undefined, so this is always true...\n                payload.issues.push(util.issue(_issue));\n            }\n        };\n        return fn(payload.value, payload);\n    });\n    return ch;\n}\n// @__NO_SIDE_EFFECTS__\nexport function _check(fn, params) {\n    const ch = new checks.$ZodCheck({\n        check: \"custom\",\n        ...util.normalizeParams(params),\n    });\n    ch._zod.check = fn;\n    return ch;\n}\n// @__NO_SIDE_EFFECTS__\nexport function describe(description) {\n    const ch = new checks.$ZodCheck({ check: \"describe\" });\n    ch._zod.onattach = [\n        (inst) => {\n            const existing = registries.globalRegistry.get(inst) ?? {};\n            registries.globalRegistry.add(inst, { ...existing, description });\n        },\n    ];\n    ch._zod.check = () => { }; // no-op check\n    return ch;\n}\n// @__NO_SIDE_EFFECTS__\nexport function meta(metadata) {\n    const ch = new checks.$ZodCheck({ check: \"meta\" });\n    ch._zod.onattach = [\n        (inst) => {\n            const existing = registries.globalRegistry.get(inst) ?? {};\n            registries.globalRegistry.add(inst, { ...existing, ...metadata });\n        },\n    ];\n    ch._zod.check = () => { }; // no-op check\n    return ch;\n}\n// @__NO_SIDE_EFFECTS__\nexport function _stringbool(Classes, _params) {\n    const params = util.normalizeParams(_params);\n    let truthyArray = params.truthy ?? [\"true\", \"1\", \"yes\", \"on\", \"y\", \"enabled\"];\n    let falsyArray = params.falsy ?? [\"false\", \"0\", \"no\", \"off\", \"n\", \"disabled\"];\n    if (params.case !== \"sensitive\") {\n        truthyArray = truthyArray.map((v) => (typeof v === \"string\" ? v.toLowerCase() : v));\n        falsyArray = falsyArray.map((v) => (typeof v === \"string\" ? v.toLowerCase() : v));\n    }\n    const truthySet = new Set(truthyArray);\n    const falsySet = new Set(falsyArray);\n    const _Codec = Classes.Codec ?? schemas.$ZodCodec;\n    const _Boolean = Classes.Boolean ?? schemas.$ZodBoolean;\n    const _String = Classes.String ?? schemas.$ZodString;\n    const stringSchema = new _String({ type: \"string\", error: params.error });\n    const booleanSchema = new _Boolean({ type: \"boolean\", error: params.error });\n    const codec = new _Codec({\n        type: \"pipe\",\n        in: stringSchema,\n        out: booleanSchema,\n        transform: ((input, payload) => {\n            let data = input;\n            if (params.case !== \"sensitive\")\n                data = data.toLowerCase();\n            if (truthySet.has(data)) {\n                return true;\n            }\n            else if (falsySet.has(data)) {\n                return false;\n            }\n            else {\n                payload.issues.push({\n                    code: \"invalid_value\",\n                    expected: \"stringbool\",\n                    values: [...truthySet, ...falsySet],\n                    input: payload.value,\n                    inst: codec,\n                    continue: false,\n                });\n                return {};\n            }\n        }),\n        reverseTransform: ((input, _payload) => {\n            if (input === true) {\n                return truthyArray[0] || \"true\";\n            }\n            else {\n                return falsyArray[0] || \"false\";\n            }\n        }),\n        error: params.error,\n    });\n    return codec;\n}\n// @__NO_SIDE_EFFECTS__\nexport function _stringFormat(Class, format, fnOrRegex, _params = {}) {\n    const params = util.normalizeParams(_params);\n    const def = {\n        ...util.normalizeParams(_params),\n        check: \"string_format\",\n        type: \"string\",\n        format,\n        fn: typeof fnOrRegex === \"function\" ? fnOrRegex : (val) => fnOrRegex.test(val),\n        ...params,\n    };\n    if (fnOrRegex instanceof RegExp) {\n        def.pattern = fnOrRegex;\n    }\n    const inst = new Class(def);\n    return inst;\n}\n","// import { $ZodType } from \"./schemas.js\";\nimport * as core from \"./core.js\";\nimport * as regexes from \"./regexes.js\";\nimport * as util from \"./util.js\";\nexport const $ZodCheck = /*@__PURE__*/ core.$constructor(\"$ZodCheck\", (inst, def) => {\n    var _a;\n    inst._zod ?? (inst._zod = {});\n    inst._zod.def = def;\n    (_a = inst._zod).onattach ?? (_a.onattach = []);\n});\nconst numericOriginMap = {\n    number: \"number\",\n    bigint: \"bigint\",\n    object: \"date\",\n};\nexport const $ZodCheckLessThan = /*@__PURE__*/ core.$constructor(\"$ZodCheckLessThan\", (inst, def) => {\n    $ZodCheck.init(inst, def);\n    const origin = numericOriginMap[typeof def.value];\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;\n        if (def.value < curr) {\n            if (def.inclusive)\n                bag.maximum = def.value;\n            else\n                bag.exclusiveMaximum = def.value;\n        }\n    });\n    inst._zod.check = (payload) => {\n        if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {\n            return;\n        }\n        payload.issues.push({\n            origin,\n            code: \"too_big\",\n            maximum: typeof def.value === \"object\" ? def.value.getTime() : def.value,\n            input: payload.value,\n            inclusive: def.inclusive,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckGreaterThan = /*@__PURE__*/ core.$constructor(\"$ZodCheckGreaterThan\", (inst, def) => {\n    $ZodCheck.init(inst, def);\n    const origin = numericOriginMap[typeof def.value];\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;\n        if (def.value > curr) {\n            if (def.inclusive)\n                bag.minimum = def.value;\n            else\n                bag.exclusiveMinimum = def.value;\n        }\n    });\n    inst._zod.check = (payload) => {\n        if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {\n            return;\n        }\n        payload.issues.push({\n            origin,\n            code: \"too_small\",\n            minimum: typeof def.value === \"object\" ? def.value.getTime() : def.value,\n            input: payload.value,\n            inclusive: def.inclusive,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckMultipleOf = \n/*@__PURE__*/ core.$constructor(\"$ZodCheckMultipleOf\", (inst, def) => {\n    $ZodCheck.init(inst, def);\n    inst._zod.onattach.push((inst) => {\n        var _a;\n        (_a = inst._zod.bag).multipleOf ?? (_a.multipleOf = def.value);\n    });\n    inst._zod.check = (payload) => {\n        if (typeof payload.value !== typeof def.value)\n            throw new Error(\"Cannot mix number and bigint in multiple_of check.\");\n        const isMultiple = typeof payload.value === \"bigint\"\n            ? payload.value % def.value === BigInt(0)\n            : util.floatSafeRemainder(payload.value, def.value) === 0;\n        if (isMultiple)\n            return;\n        payload.issues.push({\n            origin: typeof payload.value,\n            code: \"not_multiple_of\",\n            divisor: def.value,\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckNumberFormat = /*@__PURE__*/ core.$constructor(\"$ZodCheckNumberFormat\", (inst, def) => {\n    $ZodCheck.init(inst, def); // no format checks\n    def.format = def.format || \"float64\";\n    const isInt = def.format?.includes(\"int\");\n    const origin = isInt ? \"int\" : \"number\";\n    const [minimum, maximum] = util.NUMBER_FORMAT_RANGES[def.format];\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        bag.format = def.format;\n        bag.minimum = minimum;\n        bag.maximum = maximum;\n        if (isInt)\n            bag.pattern = regexes.integer;\n    });\n    inst._zod.check = (payload) => {\n        const input = payload.value;\n        if (isInt) {\n            if (!Number.isInteger(input)) {\n                // invalid_format issue\n                // payload.issues.push({\n                //   expected: def.format,\n                //   format: def.format,\n                //   code: \"invalid_format\",\n                //   input,\n                //   inst,\n                // });\n                // invalid_type issue\n                payload.issues.push({\n                    expected: origin,\n                    format: def.format,\n                    code: \"invalid_type\",\n                    continue: false,\n                    input,\n                    inst,\n                });\n                return;\n                // not_multiple_of issue\n                // payload.issues.push({\n                //   code: \"not_multiple_of\",\n                //   origin: \"number\",\n                //   input,\n                //   inst,\n                //   divisor: 1,\n                // });\n            }\n            if (!Number.isSafeInteger(input)) {\n                if (input > 0) {\n                    // too_big\n                    payload.issues.push({\n                        input,\n                        code: \"too_big\",\n                        maximum: Number.MAX_SAFE_INTEGER,\n                        note: \"Integers must be within the safe integer range.\",\n                        inst,\n                        origin,\n                        inclusive: true,\n                        continue: !def.abort,\n                    });\n                }\n                else {\n                    // too_small\n                    payload.issues.push({\n                        input,\n                        code: \"too_small\",\n                        minimum: Number.MIN_SAFE_INTEGER,\n                        note: \"Integers must be within the safe integer range.\",\n                        inst,\n                        origin,\n                        inclusive: true,\n                        continue: !def.abort,\n                    });\n                }\n                return;\n            }\n        }\n        if (input < minimum) {\n            payload.issues.push({\n                origin: \"number\",\n                input,\n                code: \"too_small\",\n                minimum,\n                inclusive: true,\n                inst,\n                continue: !def.abort,\n            });\n        }\n        if (input > maximum) {\n            payload.issues.push({\n                origin: \"number\",\n                input,\n                code: \"too_big\",\n                maximum,\n                inclusive: true,\n                inst,\n                continue: !def.abort,\n            });\n        }\n    };\n});\nexport const $ZodCheckBigIntFormat = /*@__PURE__*/ core.$constructor(\"$ZodCheckBigIntFormat\", (inst, def) => {\n    $ZodCheck.init(inst, def); // no format checks\n    const [minimum, maximum] = util.BIGINT_FORMAT_RANGES[def.format];\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        bag.format = def.format;\n        bag.minimum = minimum;\n        bag.maximum = maximum;\n    });\n    inst._zod.check = (payload) => {\n        const input = payload.value;\n        if (input < minimum) {\n            payload.issues.push({\n                origin: \"bigint\",\n                input,\n                code: \"too_small\",\n                minimum: minimum,\n                inclusive: true,\n                inst,\n                continue: !def.abort,\n            });\n        }\n        if (input > maximum) {\n            payload.issues.push({\n                origin: \"bigint\",\n                input,\n                code: \"too_big\",\n                maximum,\n                inclusive: true,\n                inst,\n                continue: !def.abort,\n            });\n        }\n    };\n});\nexport const $ZodCheckMaxSize = /*@__PURE__*/ core.$constructor(\"$ZodCheckMaxSize\", (inst, def) => {\n    var _a;\n    $ZodCheck.init(inst, def);\n    (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n        const val = payload.value;\n        return !util.nullish(val) && val.size !== undefined;\n    });\n    inst._zod.onattach.push((inst) => {\n        const curr = (inst._zod.bag.maximum ?? Number.POSITIVE_INFINITY);\n        if (def.maximum < curr)\n            inst._zod.bag.maximum = def.maximum;\n    });\n    inst._zod.check = (payload) => {\n        const input = payload.value;\n        const size = input.size;\n        if (size <= def.maximum)\n            return;\n        payload.issues.push({\n            origin: util.getSizableOrigin(input),\n            code: \"too_big\",\n            maximum: def.maximum,\n            inclusive: true,\n            input,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckMinSize = /*@__PURE__*/ core.$constructor(\"$ZodCheckMinSize\", (inst, def) => {\n    var _a;\n    $ZodCheck.init(inst, def);\n    (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n        const val = payload.value;\n        return !util.nullish(val) && val.size !== undefined;\n    });\n    inst._zod.onattach.push((inst) => {\n        const curr = (inst._zod.bag.minimum ?? Number.NEGATIVE_INFINITY);\n        if (def.minimum > curr)\n            inst._zod.bag.minimum = def.minimum;\n    });\n    inst._zod.check = (payload) => {\n        const input = payload.value;\n        const size = input.size;\n        if (size >= def.minimum)\n            return;\n        payload.issues.push({\n            origin: util.getSizableOrigin(input),\n            code: \"too_small\",\n            minimum: def.minimum,\n            inclusive: true,\n            input,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckSizeEquals = /*@__PURE__*/ core.$constructor(\"$ZodCheckSizeEquals\", (inst, def) => {\n    var _a;\n    $ZodCheck.init(inst, def);\n    (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n        const val = payload.value;\n        return !util.nullish(val) && val.size !== undefined;\n    });\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        bag.minimum = def.size;\n        bag.maximum = def.size;\n        bag.size = def.size;\n    });\n    inst._zod.check = (payload) => {\n        const input = payload.value;\n        const size = input.size;\n        if (size === def.size)\n            return;\n        const tooBig = size > def.size;\n        payload.issues.push({\n            origin: util.getSizableOrigin(input),\n            ...(tooBig ? { code: \"too_big\", maximum: def.size } : { code: \"too_small\", minimum: def.size }),\n            inclusive: true,\n            exact: true,\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckMaxLength = /*@__PURE__*/ core.$constructor(\"$ZodCheckMaxLength\", (inst, def) => {\n    var _a;\n    $ZodCheck.init(inst, def);\n    (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n        const val = payload.value;\n        return !util.nullish(val) && val.length !== undefined;\n    });\n    inst._zod.onattach.push((inst) => {\n        const curr = (inst._zod.bag.maximum ?? Number.POSITIVE_INFINITY);\n        if (def.maximum < curr)\n            inst._zod.bag.maximum = def.maximum;\n    });\n    inst._zod.check = (payload) => {\n        const input = payload.value;\n        const length = input.length;\n        if (length <= def.maximum)\n            return;\n        const origin = util.getLengthableOrigin(input);\n        payload.issues.push({\n            origin,\n            code: \"too_big\",\n            maximum: def.maximum,\n            inclusive: true,\n            input,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckMinLength = /*@__PURE__*/ core.$constructor(\"$ZodCheckMinLength\", (inst, def) => {\n    var _a;\n    $ZodCheck.init(inst, def);\n    (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n        const val = payload.value;\n        return !util.nullish(val) && val.length !== undefined;\n    });\n    inst._zod.onattach.push((inst) => {\n        const curr = (inst._zod.bag.minimum ?? Number.NEGATIVE_INFINITY);\n        if (def.minimum > curr)\n            inst._zod.bag.minimum = def.minimum;\n    });\n    inst._zod.check = (payload) => {\n        const input = payload.value;\n        const length = input.length;\n        if (length >= def.minimum)\n            return;\n        const origin = util.getLengthableOrigin(input);\n        payload.issues.push({\n            origin,\n            code: \"too_small\",\n            minimum: def.minimum,\n            inclusive: true,\n            input,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckLengthEquals = /*@__PURE__*/ core.$constructor(\"$ZodCheckLengthEquals\", (inst, def) => {\n    var _a;\n    $ZodCheck.init(inst, def);\n    (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n        const val = payload.value;\n        return !util.nullish(val) && val.length !== undefined;\n    });\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        bag.minimum = def.length;\n        bag.maximum = def.length;\n        bag.length = def.length;\n    });\n    inst._zod.check = (payload) => {\n        const input = payload.value;\n        const length = input.length;\n        if (length === def.length)\n            return;\n        const origin = util.getLengthableOrigin(input);\n        const tooBig = length > def.length;\n        payload.issues.push({\n            origin,\n            ...(tooBig ? { code: \"too_big\", maximum: def.length } : { code: \"too_small\", minimum: def.length }),\n            inclusive: true,\n            exact: true,\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckStringFormat = /*@__PURE__*/ core.$constructor(\"$ZodCheckStringFormat\", (inst, def) => {\n    var _a, _b;\n    $ZodCheck.init(inst, def);\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        bag.format = def.format;\n        if (def.pattern) {\n            bag.patterns ?? (bag.patterns = new Set());\n            bag.patterns.add(def.pattern);\n        }\n    });\n    if (def.pattern)\n        (_a = inst._zod).check ?? (_a.check = (payload) => {\n            def.pattern.lastIndex = 0;\n            if (def.pattern.test(payload.value))\n                return;\n            payload.issues.push({\n                origin: \"string\",\n                code: \"invalid_format\",\n                format: def.format,\n                input: payload.value,\n                ...(def.pattern ? { pattern: def.pattern.toString() } : {}),\n                inst,\n                continue: !def.abort,\n            });\n        });\n    else\n        (_b = inst._zod).check ?? (_b.check = () => { });\n});\nexport const $ZodCheckRegex = /*@__PURE__*/ core.$constructor(\"$ZodCheckRegex\", (inst, def) => {\n    $ZodCheckStringFormat.init(inst, def);\n    inst._zod.check = (payload) => {\n        def.pattern.lastIndex = 0;\n        if (def.pattern.test(payload.value))\n            return;\n        payload.issues.push({\n            origin: \"string\",\n            code: \"invalid_format\",\n            format: \"regex\",\n            input: payload.value,\n            pattern: def.pattern.toString(),\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckLowerCase = /*@__PURE__*/ core.$constructor(\"$ZodCheckLowerCase\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.lowercase);\n    $ZodCheckStringFormat.init(inst, def);\n});\nexport const $ZodCheckUpperCase = /*@__PURE__*/ core.$constructor(\"$ZodCheckUpperCase\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.uppercase);\n    $ZodCheckStringFormat.init(inst, def);\n});\nexport const $ZodCheckIncludes = /*@__PURE__*/ core.$constructor(\"$ZodCheckIncludes\", (inst, def) => {\n    $ZodCheck.init(inst, def);\n    const escapedRegex = util.escapeRegex(def.includes);\n    const pattern = new RegExp(typeof def.position === \"number\" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);\n    def.pattern = pattern;\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        bag.patterns ?? (bag.patterns = new Set());\n        bag.patterns.add(pattern);\n    });\n    inst._zod.check = (payload) => {\n        if (payload.value.includes(def.includes, def.position))\n            return;\n        payload.issues.push({\n            origin: \"string\",\n            code: \"invalid_format\",\n            format: \"includes\",\n            includes: def.includes,\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckStartsWith = /*@__PURE__*/ core.$constructor(\"$ZodCheckStartsWith\", (inst, def) => {\n    $ZodCheck.init(inst, def);\n    const pattern = new RegExp(`^${util.escapeRegex(def.prefix)}.*`);\n    def.pattern ?? (def.pattern = pattern);\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        bag.patterns ?? (bag.patterns = new Set());\n        bag.patterns.add(pattern);\n    });\n    inst._zod.check = (payload) => {\n        if (payload.value.startsWith(def.prefix))\n            return;\n        payload.issues.push({\n            origin: \"string\",\n            code: \"invalid_format\",\n            format: \"starts_with\",\n            prefix: def.prefix,\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckEndsWith = /*@__PURE__*/ core.$constructor(\"$ZodCheckEndsWith\", (inst, def) => {\n    $ZodCheck.init(inst, def);\n    const pattern = new RegExp(`.*${util.escapeRegex(def.suffix)}$`);\n    def.pattern ?? (def.pattern = pattern);\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        bag.patterns ?? (bag.patterns = new Set());\n        bag.patterns.add(pattern);\n    });\n    inst._zod.check = (payload) => {\n        if (payload.value.endsWith(def.suffix))\n            return;\n        payload.issues.push({\n            origin: \"string\",\n            code: \"invalid_format\",\n            format: \"ends_with\",\n            suffix: def.suffix,\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\n///////////////////////////////////\n/////    $ZodCheckProperty    /////\n///////////////////////////////////\nfunction handleCheckPropertyResult(result, payload, property) {\n    if (result.issues.length) {\n        payload.issues.push(...util.prefixIssues(property, result.issues));\n    }\n}\nexport const $ZodCheckProperty = /*@__PURE__*/ core.$constructor(\"$ZodCheckProperty\", (inst, def) => {\n    $ZodCheck.init(inst, def);\n    inst._zod.check = (payload) => {\n        const result = def.schema._zod.run({\n            value: payload.value[def.property],\n            issues: [],\n        }, {});\n        if (result instanceof Promise) {\n            return result.then((result) => handleCheckPropertyResult(result, payload, def.property));\n        }\n        handleCheckPropertyResult(result, payload, def.property);\n        return;\n    };\n});\nexport const $ZodCheckMimeType = /*@__PURE__*/ core.$constructor(\"$ZodCheckMimeType\", (inst, def) => {\n    $ZodCheck.init(inst, def);\n    const mimeSet = new Set(def.mime);\n    inst._zod.onattach.push((inst) => {\n        inst._zod.bag.mime = def.mime;\n    });\n    inst._zod.check = (payload) => {\n        if (mimeSet.has(payload.value.type))\n            return;\n        payload.issues.push({\n            code: \"invalid_value\",\n            values: def.mime,\n            input: payload.value.type,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckOverwrite = /*@__PURE__*/ core.$constructor(\"$ZodCheckOverwrite\", (inst, def) => {\n    $ZodCheck.init(inst, def);\n    inst._zod.check = (payload) => {\n        payload.value = def.tx(payload.value);\n    };\n});\n","/** A special constant with type `never` */\nexport const NEVER = Object.freeze({\n    status: \"aborted\",\n});\nexport /*@__NO_SIDE_EFFECTS__*/ function $constructor(name, initializer, params) {\n    function init(inst, def) {\n        if (!inst._zod) {\n            Object.defineProperty(inst, \"_zod\", {\n                value: {\n                    def,\n                    constr: _,\n                    traits: new Set(),\n                },\n                enumerable: false,\n            });\n        }\n        if (inst._zod.traits.has(name)) {\n            return;\n        }\n        inst._zod.traits.add(name);\n        initializer(inst, def);\n        // support prototype modifications\n        const proto = _.prototype;\n        const keys = Object.keys(proto);\n        for (let i = 0; i < keys.length; i++) {\n            const k = keys[i];\n            if (!(k in inst)) {\n                inst[k] = proto[k].bind(inst);\n            }\n        }\n    }\n    // doesn't work if Parent has a constructor with arguments\n    const Parent = params?.Parent ?? Object;\n    class Definition extends Parent {\n    }\n    Object.defineProperty(Definition, \"name\", { value: name });\n    function _(def) {\n        var _a;\n        const inst = params?.Parent ? new Definition() : this;\n        init(inst, def);\n        (_a = inst._zod).deferred ?? (_a.deferred = []);\n        for (const fn of inst._zod.deferred) {\n            fn();\n        }\n        return inst;\n    }\n    Object.defineProperty(_, \"init\", { value: init });\n    Object.defineProperty(_, Symbol.hasInstance, {\n        value: (inst) => {\n            if (params?.Parent && inst instanceof params.Parent)\n                return true;\n            return inst?._zod?.traits?.has(name);\n        },\n    });\n    Object.defineProperty(_, \"name\", { value: name });\n    return _;\n}\n//////////////////////////////   UTILITIES   ///////////////////////////////////////\nexport const $brand = Symbol(\"zod_brand\");\nexport class $ZodAsyncError extends Error {\n    constructor() {\n        super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);\n    }\n}\nexport class $ZodEncodeError extends Error {\n    constructor(name) {\n        super(`Encountered unidirectional transform during encode: ${name}`);\n        this.name = \"ZodEncodeError\";\n    }\n}\nexport const globalConfig = {};\nexport function config(newConfig) {\n    if (newConfig)\n        Object.assign(globalConfig, newConfig);\n    return globalConfig;\n}\n","export class Doc {\n    constructor(args = []) {\n        this.content = [];\n        this.indent = 0;\n        if (this)\n            this.args = args;\n    }\n    indented(fn) {\n        this.indent += 1;\n        fn(this);\n        this.indent -= 1;\n    }\n    write(arg) {\n        if (typeof arg === \"function\") {\n            arg(this, { execution: \"sync\" });\n            arg(this, { execution: \"async\" });\n            return;\n        }\n        const content = arg;\n        const lines = content.split(\"\\n\").filter((x) => x);\n        const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));\n        const dedented = lines.map((x) => x.slice(minIndent)).map((x) => \" \".repeat(this.indent * 2) + x);\n        for (const line of dedented) {\n            this.content.push(line);\n        }\n    }\n    compile() {\n        const F = Function;\n        const args = this?.args;\n        const content = this?.content ?? [``];\n        const lines = [...content.map((x) => `  ${x}`)];\n        // console.log(lines.join(\"\\n\"));\n        return new F(...args, lines.join(\"\\n\"));\n    }\n}\n","import { $constructor } from \"./core.js\";\nimport * as util from \"./util.js\";\nconst initializer = (inst, def) => {\n    inst.name = \"$ZodError\";\n    Object.defineProperty(inst, \"_zod\", {\n        value: inst._zod,\n        enumerable: false,\n    });\n    Object.defineProperty(inst, \"issues\", {\n        value: def,\n        enumerable: false,\n    });\n    inst.message = JSON.stringify(def, util.jsonStringifyReplacer, 2);\n    Object.defineProperty(inst, \"toString\", {\n        value: () => inst.message,\n        enumerable: false,\n    });\n};\nexport const $ZodError = $constructor(\"$ZodError\", initializer);\nexport const $ZodRealError = $constructor(\"$ZodError\", initializer, { Parent: Error });\nexport function flattenError(error, mapper = (issue) => issue.message) {\n    const fieldErrors = {};\n    const formErrors = [];\n    for (const sub of error.issues) {\n        if (sub.path.length > 0) {\n            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n            fieldErrors[sub.path[0]].push(mapper(sub));\n        }\n        else {\n            formErrors.push(mapper(sub));\n        }\n    }\n    return { formErrors, fieldErrors };\n}\nexport function formatError(error, mapper = (issue) => issue.message) {\n    const fieldErrors = { _errors: [] };\n    const processError = (error) => {\n        for (const issue of error.issues) {\n            if (issue.code === \"invalid_union\" && issue.errors.length) {\n                issue.errors.map((issues) => processError({ issues }));\n            }\n            else if (issue.code === \"invalid_key\") {\n                processError({ issues: issue.issues });\n            }\n            else if (issue.code === \"invalid_element\") {\n                processError({ issues: issue.issues });\n            }\n            else if (issue.path.length === 0) {\n                fieldErrors._errors.push(mapper(issue));\n            }\n            else {\n                let curr = fieldErrors;\n                let i = 0;\n                while (i < issue.path.length) {\n                    const el = issue.path[i];\n                    const terminal = i === issue.path.length - 1;\n                    if (!terminal) {\n                        curr[el] = curr[el] || { _errors: [] };\n                    }\n                    else {\n                        curr[el] = curr[el] || { _errors: [] };\n                        curr[el]._errors.push(mapper(issue));\n                    }\n                    curr = curr[el];\n                    i++;\n                }\n            }\n        }\n    };\n    processError(error);\n    return fieldErrors;\n}\nexport function treeifyError(error, mapper = (issue) => issue.message) {\n    const result = { errors: [] };\n    const processError = (error, path = []) => {\n        var _a, _b;\n        for (const issue of error.issues) {\n            if (issue.code === \"invalid_union\" && issue.errors.length) {\n                // regular union error\n                issue.errors.map((issues) => processError({ issues }, issue.path));\n            }\n            else if (issue.code === \"invalid_key\") {\n                processError({ issues: issue.issues }, issue.path);\n            }\n            else if (issue.code === \"invalid_element\") {\n                processError({ issues: issue.issues }, issue.path);\n            }\n            else {\n                const fullpath = [...path, ...issue.path];\n                if (fullpath.length === 0) {\n                    result.errors.push(mapper(issue));\n                    continue;\n                }\n                let curr = result;\n                let i = 0;\n                while (i < fullpath.length) {\n                    const el = fullpath[i];\n                    const terminal = i === fullpath.length - 1;\n                    if (typeof el === \"string\") {\n                        curr.properties ?? (curr.properties = {});\n                        (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });\n                        curr = curr.properties[el];\n                    }\n                    else {\n                        curr.items ?? (curr.items = []);\n                        (_b = curr.items)[el] ?? (_b[el] = { errors: [] });\n                        curr = curr.items[el];\n                    }\n                    if (terminal) {\n                        curr.errors.push(mapper(issue));\n                    }\n                    i++;\n                }\n            }\n        }\n    };\n    processError(error);\n    return result;\n}\n/** Format a ZodError as a human-readable string in the following form.\n *\n * From\n *\n * ```ts\n * ZodError {\n *   issues: [\n *     {\n *       expected: 'string',\n *       code: 'invalid_type',\n *       path: [ 'username' ],\n *       message: 'Invalid input: expected string'\n *     },\n *     {\n *       expected: 'number',\n *       code: 'invalid_type',\n *       path: [ 'favoriteNumbers', 1 ],\n *       message: 'Invalid input: expected number'\n *     }\n *   ];\n * }\n * ```\n *\n * to\n *\n * ```\n * username\n *    Expected number, received string at \"username\n * favoriteNumbers[0]\n *    Invalid input: expected number\n * ```\n */\nexport function toDotPath(_path) {\n    const segs = [];\n    const path = _path.map((seg) => (typeof seg === \"object\" ? seg.key : seg));\n    for (const seg of path) {\n        if (typeof seg === \"number\")\n            segs.push(`[${seg}]`);\n        else if (typeof seg === \"symbol\")\n            segs.push(`[${JSON.stringify(String(seg))}]`);\n        else if (/[^\\w$]/.test(seg))\n            segs.push(`[${JSON.stringify(seg)}]`);\n        else {\n            if (segs.length)\n                segs.push(\".\");\n            segs.push(seg);\n        }\n    }\n    return segs.join(\"\");\n}\nexport function prettifyError(error) {\n    const lines = [];\n    // sort by path length\n    const issues = [...error.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);\n    // Process each issue\n    for (const issue of issues) {\n        lines.push(` ${issue.message}`);\n        if (issue.path?.length)\n            lines.push(`   at ${toDotPath(issue.path)}`);\n    }\n    // Convert Map to formatted string\n    return lines.join(\"\\n\");\n}\n","export * from \"./core.js\";\nexport * from \"./parse.js\";\nexport * from \"./errors.js\";\nexport * from \"./schemas.js\";\nexport * from \"./checks.js\";\nexport * from \"./versions.js\";\nexport * as util from \"./util.js\";\nexport * as regexes from \"./regexes.js\";\nexport * as locales from \"../locales/index.js\";\nexport * from \"./registries.js\";\nexport * from \"./doc.js\";\nexport * from \"./api.js\";\nexport * from \"./to-json-schema.js\";\nexport { toJSONSchema } from \"./json-schema-processors.js\";\nexport { JSONSchemaGenerator } from \"./json-schema-generator.js\";\nexport * as JSONSchema from \"./json-schema.js\";\n","import { allProcessors } from \"./json-schema-processors.js\";\nimport { extractDefs, finalize, initializeContext, process, } from \"./to-json-schema.js\";\n/**\n * Legacy class-based interface for JSON Schema generation.\n * This class wraps the new functional implementation to provide backward compatibility.\n *\n * @deprecated Use the `toJSONSchema` function instead for new code.\n *\n * @example\n * ```typescript\n * // Legacy usage (still supported)\n * const gen = new JSONSchemaGenerator({ target: \"draft-07\" });\n * gen.process(schema);\n * const result = gen.emit(schema);\n *\n * // Preferred modern usage\n * const result = toJSONSchema(schema, { target: \"draft-07\" });\n * ```\n */\nexport class JSONSchemaGenerator {\n    /** @deprecated Access via ctx instead */\n    get metadataRegistry() {\n        return this.ctx.metadataRegistry;\n    }\n    /** @deprecated Access via ctx instead */\n    get target() {\n        return this.ctx.target;\n    }\n    /** @deprecated Access via ctx instead */\n    get unrepresentable() {\n        return this.ctx.unrepresentable;\n    }\n    /** @deprecated Access via ctx instead */\n    get override() {\n        return this.ctx.override;\n    }\n    /** @deprecated Access via ctx instead */\n    get io() {\n        return this.ctx.io;\n    }\n    /** @deprecated Access via ctx instead */\n    get counter() {\n        return this.ctx.counter;\n    }\n    set counter(value) {\n        this.ctx.counter = value;\n    }\n    /** @deprecated Access via ctx instead */\n    get seen() {\n        return this.ctx.seen;\n    }\n    constructor(params) {\n        // Normalize target for internal context\n        let normalizedTarget = params?.target ?? \"draft-2020-12\";\n        if (normalizedTarget === \"draft-4\")\n            normalizedTarget = \"draft-04\";\n        if (normalizedTarget === \"draft-7\")\n            normalizedTarget = \"draft-07\";\n        this.ctx = initializeContext({\n            processors: allProcessors,\n            target: normalizedTarget,\n            ...(params?.metadata && { metadata: params.metadata }),\n            ...(params?.unrepresentable && { unrepresentable: params.unrepresentable }),\n            ...(params?.override && { override: params.override }),\n            ...(params?.io && { io: params.io }),\n        });\n    }\n    /**\n     * Process a schema to prepare it for JSON Schema generation.\n     * This must be called before emit().\n     */\n    process(schema, _params = { path: [], schemaPath: [] }) {\n        return process(schema, this.ctx, _params);\n    }\n    /**\n     * Emit the final JSON Schema after processing.\n     * Must call process() first.\n     */\n    emit(schema, _params) {\n        // Apply emit params to the context\n        if (_params) {\n            if (_params.cycles)\n                this.ctx.cycles = _params.cycles;\n            if (_params.reused)\n                this.ctx.reused = _params.reused;\n            if (_params.external)\n                this.ctx.external = _params.external;\n        }\n        extractDefs(this.ctx, schema);\n        const result = finalize(this.ctx, schema);\n        // Strip ~standard property to match old implementation's return type\n        const { \"~standard\": _, ...plainResult } = result;\n        return plainResult;\n    }\n}\n","import { extractDefs, finalize, initializeContext, process, } from \"./to-json-schema.js\";\nimport { getEnumValues } from \"./util.js\";\nconst formatMap = {\n    guid: \"uuid\",\n    url: \"uri\",\n    datetime: \"date-time\",\n    json_string: \"json-string\",\n    regex: \"\", // do not set\n};\n// ==================== SIMPLE TYPE PROCESSORS ====================\nexport const stringProcessor = (schema, ctx, _json, _params) => {\n    const json = _json;\n    json.type = \"string\";\n    const { minimum, maximum, format, patterns, contentEncoding } = schema._zod\n        .bag;\n    if (typeof minimum === \"number\")\n        json.minLength = minimum;\n    if (typeof maximum === \"number\")\n        json.maxLength = maximum;\n    // custom pattern overrides format\n    if (format) {\n        json.format = formatMap[format] ?? format;\n        if (json.format === \"\")\n            delete json.format; // empty format is not valid\n        // JSON Schema format: \"time\" requires a full time with offset or Z\n        // z.iso.time() does not include timezone information, so format: \"time\" should never be used\n        if (format === \"time\") {\n            delete json.format;\n        }\n    }\n    if (contentEncoding)\n        json.contentEncoding = contentEncoding;\n    if (patterns && patterns.size > 0) {\n        const regexes = [...patterns];\n        if (regexes.length === 1)\n            json.pattern = regexes[0].source;\n        else if (regexes.length > 1) {\n            json.allOf = [\n                ...regexes.map((regex) => ({\n                    ...(ctx.target === \"draft-07\" || ctx.target === \"draft-04\" || ctx.target === \"openapi-3.0\"\n                        ? { type: \"string\" }\n                        : {}),\n                    pattern: regex.source,\n                })),\n            ];\n        }\n    }\n};\nexport const numberProcessor = (schema, ctx, _json, _params) => {\n    const json = _json;\n    const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;\n    if (typeof format === \"string\" && format.includes(\"int\"))\n        json.type = \"integer\";\n    else\n        json.type = \"number\";\n    if (typeof exclusiveMinimum === \"number\") {\n        if (ctx.target === \"draft-04\" || ctx.target === \"openapi-3.0\") {\n            json.minimum = exclusiveMinimum;\n            json.exclusiveMinimum = true;\n        }\n        else {\n            json.exclusiveMinimum = exclusiveMinimum;\n        }\n    }\n    if (typeof minimum === \"number\") {\n        json.minimum = minimum;\n        if (typeof exclusiveMinimum === \"number\" && ctx.target !== \"draft-04\") {\n            if (exclusiveMinimum >= minimum)\n                delete json.minimum;\n            else\n                delete json.exclusiveMinimum;\n        }\n    }\n    if (typeof exclusiveMaximum === \"number\") {\n        if (ctx.target === \"draft-04\" || ctx.target === \"openapi-3.0\") {\n            json.maximum = exclusiveMaximum;\n            json.exclusiveMaximum = true;\n        }\n        else {\n            json.exclusiveMaximum = exclusiveMaximum;\n        }\n    }\n    if (typeof maximum === \"number\") {\n        json.maximum = maximum;\n        if (typeof exclusiveMaximum === \"number\" && ctx.target !== \"draft-04\") {\n            if (exclusiveMaximum <= maximum)\n                delete json.maximum;\n            else\n                delete json.exclusiveMaximum;\n        }\n    }\n    if (typeof multipleOf === \"number\")\n        json.multipleOf = multipleOf;\n};\nexport const booleanProcessor = (_schema, _ctx, json, _params) => {\n    json.type = \"boolean\";\n};\nexport const bigintProcessor = (_schema, ctx, _json, _params) => {\n    if (ctx.unrepresentable === \"throw\") {\n        throw new Error(\"BigInt cannot be represented in JSON Schema\");\n    }\n};\nexport const symbolProcessor = (_schema, ctx, _json, _params) => {\n    if (ctx.unrepresentable === \"throw\") {\n        throw new Error(\"Symbols cannot be represented in JSON Schema\");\n    }\n};\nexport const nullProcessor = (_schema, ctx, json, _params) => {\n    if (ctx.target === \"openapi-3.0\") {\n        json.type = \"string\";\n        json.nullable = true;\n        json.enum = [null];\n    }\n    else {\n        json.type = \"null\";\n    }\n};\nexport const undefinedProcessor = (_schema, ctx, _json, _params) => {\n    if (ctx.unrepresentable === \"throw\") {\n        throw new Error(\"Undefined cannot be represented in JSON Schema\");\n    }\n};\nexport const voidProcessor = (_schema, ctx, _json, _params) => {\n    if (ctx.unrepresentable === \"throw\") {\n        throw new Error(\"Void cannot be represented in JSON Schema\");\n    }\n};\nexport const neverProcessor = (_schema, _ctx, json, _params) => {\n    json.not = {};\n};\nexport const anyProcessor = (_schema, _ctx, _json, _params) => {\n    // empty schema accepts anything\n};\nexport const unknownProcessor = (_schema, _ctx, _json, _params) => {\n    // empty schema accepts anything\n};\nexport const dateProcessor = (_schema, ctx, _json, _params) => {\n    if (ctx.unrepresentable === \"throw\") {\n        throw new Error(\"Date cannot be represented in JSON Schema\");\n    }\n};\nexport const enumProcessor = (schema, _ctx, json, _params) => {\n    const def = schema._zod.def;\n    const values = getEnumValues(def.entries);\n    // Number enums can have both string and number values\n    if (values.every((v) => typeof v === \"number\"))\n        json.type = \"number\";\n    if (values.every((v) => typeof v === \"string\"))\n        json.type = \"string\";\n    json.enum = values;\n};\nexport const literalProcessor = (schema, ctx, json, _params) => {\n    const def = schema._zod.def;\n    const vals = [];\n    for (const val of def.values) {\n        if (val === undefined) {\n            if (ctx.unrepresentable === \"throw\") {\n                throw new Error(\"Literal `undefined` cannot be represented in JSON Schema\");\n            }\n            else {\n                // do not add to vals\n            }\n        }\n        else if (typeof val === \"bigint\") {\n            if (ctx.unrepresentable === \"throw\") {\n                throw new Error(\"BigInt literals cannot be represented in JSON Schema\");\n            }\n            else {\n                vals.push(Number(val));\n            }\n        }\n        else {\n            vals.push(val);\n        }\n    }\n    if (vals.length === 0) {\n        // do nothing (an undefined literal was stripped)\n    }\n    else if (vals.length === 1) {\n        const val = vals[0];\n        json.type = val === null ? \"null\" : typeof val;\n        if (ctx.target === \"draft-04\" || ctx.target === \"openapi-3.0\") {\n            json.enum = [val];\n        }\n        else {\n            json.const = val;\n        }\n    }\n    else {\n        if (vals.every((v) => typeof v === \"number\"))\n            json.type = \"number\";\n        if (vals.every((v) => typeof v === \"string\"))\n            json.type = \"string\";\n        if (vals.every((v) => typeof v === \"boolean\"))\n            json.type = \"boolean\";\n        if (vals.every((v) => v === null))\n            json.type = \"null\";\n        json.enum = vals;\n    }\n};\nexport const nanProcessor = (_schema, ctx, _json, _params) => {\n    if (ctx.unrepresentable === \"throw\") {\n        throw new Error(\"NaN cannot be represented in JSON Schema\");\n    }\n};\nexport const templateLiteralProcessor = (schema, _ctx, json, _params) => {\n    const _json = json;\n    const pattern = schema._zod.pattern;\n    if (!pattern)\n        throw new Error(\"Pattern not found in template literal\");\n    _json.type = \"string\";\n    _json.pattern = pattern.source;\n};\nexport const fileProcessor = (schema, _ctx, json, _params) => {\n    const _json = json;\n    const file = {\n        type: \"string\",\n        format: \"binary\",\n        contentEncoding: \"binary\",\n    };\n    const { minimum, maximum, mime } = schema._zod.bag;\n    if (minimum !== undefined)\n        file.minLength = minimum;\n    if (maximum !== undefined)\n        file.maxLength = maximum;\n    if (mime) {\n        if (mime.length === 1) {\n            file.contentMediaType = mime[0];\n            Object.assign(_json, file);\n        }\n        else {\n            Object.assign(_json, file); // shared props at root\n            _json.anyOf = mime.map((m) => ({ contentMediaType: m })); // only contentMediaType differs\n        }\n    }\n    else {\n        Object.assign(_json, file);\n    }\n};\nexport const successProcessor = (_schema, _ctx, json, _params) => {\n    json.type = \"boolean\";\n};\nexport const customProcessor = (_schema, ctx, _json, _params) => {\n    if (ctx.unrepresentable === \"throw\") {\n        throw new Error(\"Custom types cannot be represented in JSON Schema\");\n    }\n};\nexport const functionProcessor = (_schema, ctx, _json, _params) => {\n    if (ctx.unrepresentable === \"throw\") {\n        throw new Error(\"Function types cannot be represented in JSON Schema\");\n    }\n};\nexport const transformProcessor = (_schema, ctx, _json, _params) => {\n    if (ctx.unrepresentable === \"throw\") {\n        throw new Error(\"Transforms cannot be represented in JSON Schema\");\n    }\n};\nexport const mapProcessor = (_schema, ctx, _json, _params) => {\n    if (ctx.unrepresentable === \"throw\") {\n        throw new Error(\"Map cannot be represented in JSON Schema\");\n    }\n};\nexport const setProcessor = (_schema, ctx, _json, _params) => {\n    if (ctx.unrepresentable === \"throw\") {\n        throw new Error(\"Set cannot be represented in JSON Schema\");\n    }\n};\n// ==================== COMPOSITE TYPE PROCESSORS ====================\nexport const arrayProcessor = (schema, ctx, _json, params) => {\n    const json = _json;\n    const def = schema._zod.def;\n    const { minimum, maximum } = schema._zod.bag;\n    if (typeof minimum === \"number\")\n        json.minItems = minimum;\n    if (typeof maximum === \"number\")\n        json.maxItems = maximum;\n    json.type = \"array\";\n    json.items = process(def.element, ctx, { ...params, path: [...params.path, \"items\"] });\n};\nexport const objectProcessor = (schema, ctx, _json, params) => {\n    const json = _json;\n    const def = schema._zod.def;\n    json.type = \"object\";\n    json.properties = {};\n    const shape = def.shape;\n    for (const key in shape) {\n        json.properties[key] = process(shape[key], ctx, {\n            ...params,\n            path: [...params.path, \"properties\", key],\n        });\n    }\n    // required keys\n    const allKeys = new Set(Object.keys(shape));\n    const requiredKeys = new Set([...allKeys].filter((key) => {\n        const v = def.shape[key]._zod;\n        if (ctx.io === \"input\") {\n            return v.optin === undefined;\n        }\n        else {\n            return v.optout === undefined;\n        }\n    }));\n    if (requiredKeys.size > 0) {\n        json.required = Array.from(requiredKeys);\n    }\n    // catchall\n    if (def.catchall?._zod.def.type === \"never\") {\n        // strict\n        json.additionalProperties = false;\n    }\n    else if (!def.catchall) {\n        // regular\n        if (ctx.io === \"output\")\n            json.additionalProperties = false;\n    }\n    else if (def.catchall) {\n        json.additionalProperties = process(def.catchall, ctx, {\n            ...params,\n            path: [...params.path, \"additionalProperties\"],\n        });\n    }\n};\nexport const unionProcessor = (schema, ctx, json, params) => {\n    const def = schema._zod.def;\n    // Exclusive unions (inclusive === false) use oneOf (exactly one match) instead of anyOf (one or more matches)\n    // This includes both z.xor() and discriminated unions\n    const isExclusive = def.inclusive === false;\n    const options = def.options.map((x, i) => process(x, ctx, {\n        ...params,\n        path: [...params.path, isExclusive ? \"oneOf\" : \"anyOf\", i],\n    }));\n    if (isExclusive) {\n        json.oneOf = options;\n    }\n    else {\n        json.anyOf = options;\n    }\n};\nexport const intersectionProcessor = (schema, ctx, json, params) => {\n    const def = schema._zod.def;\n    const a = process(def.left, ctx, {\n        ...params,\n        path: [...params.path, \"allOf\", 0],\n    });\n    const b = process(def.right, ctx, {\n        ...params,\n        path: [...params.path, \"allOf\", 1],\n    });\n    const isSimpleIntersection = (val) => \"allOf\" in val && Object.keys(val).length === 1;\n    const allOf = [\n        ...(isSimpleIntersection(a) ? a.allOf : [a]),\n        ...(isSimpleIntersection(b) ? b.allOf : [b]),\n    ];\n    json.allOf = allOf;\n};\nexport const tupleProcessor = (schema, ctx, _json, params) => {\n    const json = _json;\n    const def = schema._zod.def;\n    json.type = \"array\";\n    const prefixPath = ctx.target === \"draft-2020-12\" ? \"prefixItems\" : \"items\";\n    const restPath = ctx.target === \"draft-2020-12\" ? \"items\" : ctx.target === \"openapi-3.0\" ? \"items\" : \"additionalItems\";\n    const prefixItems = def.items.map((x, i) => process(x, ctx, {\n        ...params,\n        path: [...params.path, prefixPath, i],\n    }));\n    const rest = def.rest\n        ? process(def.rest, ctx, {\n            ...params,\n            path: [...params.path, restPath, ...(ctx.target === \"openapi-3.0\" ? [def.items.length] : [])],\n        })\n        : null;\n    if (ctx.target === \"draft-2020-12\") {\n        json.prefixItems = prefixItems;\n        if (rest) {\n            json.items = rest;\n        }\n    }\n    else if (ctx.target === \"openapi-3.0\") {\n        json.items = {\n            anyOf: prefixItems,\n        };\n        if (rest) {\n            json.items.anyOf.push(rest);\n        }\n        json.minItems = prefixItems.length;\n        if (!rest) {\n            json.maxItems = prefixItems.length;\n        }\n    }\n    else {\n        json.items = prefixItems;\n        if (rest) {\n            json.additionalItems = rest;\n        }\n    }\n    // length\n    const { minimum, maximum } = schema._zod.bag;\n    if (typeof minimum === \"number\")\n        json.minItems = minimum;\n    if (typeof maximum === \"number\")\n        json.maxItems = maximum;\n};\nexport const recordProcessor = (schema, ctx, _json, params) => {\n    const json = _json;\n    const def = schema._zod.def;\n    json.type = \"object\";\n    // For looseRecord with regex patterns, use patternProperties\n    // This correctly represents \"only validate keys matching the pattern\" semantics\n    // and composes well with allOf (intersections)\n    const keyType = def.keyType;\n    const keyBag = keyType._zod.bag;\n    const patterns = keyBag?.patterns;\n    if (def.mode === \"loose\" && patterns && patterns.size > 0) {\n        // Use patternProperties for looseRecord with regex patterns\n        const valueSchema = process(def.valueType, ctx, {\n            ...params,\n            path: [...params.path, \"patternProperties\", \"*\"],\n        });\n        json.patternProperties = {};\n        for (const pattern of patterns) {\n            json.patternProperties[pattern.source] = valueSchema;\n        }\n    }\n    else {\n        // Default behavior: use propertyNames + additionalProperties\n        if (ctx.target === \"draft-07\" || ctx.target === \"draft-2020-12\") {\n            json.propertyNames = process(def.keyType, ctx, {\n                ...params,\n                path: [...params.path, \"propertyNames\"],\n            });\n        }\n        json.additionalProperties = process(def.valueType, ctx, {\n            ...params,\n            path: [...params.path, \"additionalProperties\"],\n        });\n    }\n    // Add required for keys with discrete values (enum, literal, etc.)\n    const keyValues = keyType._zod.values;\n    if (keyValues) {\n        const validKeyValues = [...keyValues].filter((v) => typeof v === \"string\" || typeof v === \"number\");\n        if (validKeyValues.length > 0) {\n            json.required = validKeyValues;\n        }\n    }\n};\nexport const nullableProcessor = (schema, ctx, json, params) => {\n    const def = schema._zod.def;\n    const inner = process(def.innerType, ctx, params);\n    const seen = ctx.seen.get(schema);\n    if (ctx.target === \"openapi-3.0\") {\n        seen.ref = def.innerType;\n        json.nullable = true;\n    }\n    else {\n        json.anyOf = [inner, { type: \"null\" }];\n    }\n};\nexport const nonoptionalProcessor = (schema, ctx, _json, params) => {\n    const def = schema._zod.def;\n    process(def.innerType, ctx, params);\n    const seen = ctx.seen.get(schema);\n    seen.ref = def.innerType;\n};\nexport const defaultProcessor = (schema, ctx, json, params) => {\n    const def = schema._zod.def;\n    process(def.innerType, ctx, params);\n    const seen = ctx.seen.get(schema);\n    seen.ref = def.innerType;\n    json.default = JSON.parse(JSON.stringify(def.defaultValue));\n};\nexport const prefaultProcessor = (schema, ctx, json, params) => {\n    const def = schema._zod.def;\n    process(def.innerType, ctx, params);\n    const seen = ctx.seen.get(schema);\n    seen.ref = def.innerType;\n    if (ctx.io === \"input\")\n        json._prefault = JSON.parse(JSON.stringify(def.defaultValue));\n};\nexport const catchProcessor = (schema, ctx, json, params) => {\n    const def = schema._zod.def;\n    process(def.innerType, ctx, params);\n    const seen = ctx.seen.get(schema);\n    seen.ref = def.innerType;\n    let catchValue;\n    try {\n        catchValue = def.catchValue(undefined);\n    }\n    catch {\n        throw new Error(\"Dynamic catch values are not supported in JSON Schema\");\n    }\n    json.default = catchValue;\n};\nexport const pipeProcessor = (schema, ctx, _json, params) => {\n    const def = schema._zod.def;\n    const innerType = ctx.io === \"input\" ? (def.in._zod.def.type === \"transform\" ? def.out : def.in) : def.out;\n    process(innerType, ctx, params);\n    const seen = ctx.seen.get(schema);\n    seen.ref = innerType;\n};\nexport const readonlyProcessor = (schema, ctx, json, params) => {\n    const def = schema._zod.def;\n    process(def.innerType, ctx, params);\n    const seen = ctx.seen.get(schema);\n    seen.ref = def.innerType;\n    json.readOnly = true;\n};\nexport const promiseProcessor = (schema, ctx, _json, params) => {\n    const def = schema._zod.def;\n    process(def.innerType, ctx, params);\n    const seen = ctx.seen.get(schema);\n    seen.ref = def.innerType;\n};\nexport const optionalProcessor = (schema, ctx, _json, params) => {\n    const def = schema._zod.def;\n    process(def.innerType, ctx, params);\n    const seen = ctx.seen.get(schema);\n    seen.ref = def.innerType;\n};\nexport const lazyProcessor = (schema, ctx, _json, params) => {\n    const innerType = schema._zod.innerType;\n    process(innerType, ctx, params);\n    const seen = ctx.seen.get(schema);\n    seen.ref = innerType;\n};\n// ==================== ALL PROCESSORS ====================\nexport const allProcessors = {\n    string: stringProcessor,\n    number: numberProcessor,\n    boolean: booleanProcessor,\n    bigint: bigintProcessor,\n    symbol: symbolProcessor,\n    null: nullProcessor,\n    undefined: undefinedProcessor,\n    void: voidProcessor,\n    never: neverProcessor,\n    any: anyProcessor,\n    unknown: unknownProcessor,\n    date: dateProcessor,\n    enum: enumProcessor,\n    literal: literalProcessor,\n    nan: nanProcessor,\n    template_literal: templateLiteralProcessor,\n    file: fileProcessor,\n    success: successProcessor,\n    custom: customProcessor,\n    function: functionProcessor,\n    transform: transformProcessor,\n    map: mapProcessor,\n    set: setProcessor,\n    array: arrayProcessor,\n    object: objectProcessor,\n    union: unionProcessor,\n    intersection: intersectionProcessor,\n    tuple: tupleProcessor,\n    record: recordProcessor,\n    nullable: nullableProcessor,\n    nonoptional: nonoptionalProcessor,\n    default: defaultProcessor,\n    prefault: prefaultProcessor,\n    catch: catchProcessor,\n    pipe: pipeProcessor,\n    readonly: readonlyProcessor,\n    promise: promiseProcessor,\n    optional: optionalProcessor,\n    lazy: lazyProcessor,\n};\nexport function toJSONSchema(input, params) {\n    if (\"_idmap\" in input) {\n        // Registry case\n        const registry = input;\n        const ctx = initializeContext({ ...params, processors: allProcessors });\n        const defs = {};\n        // First pass: process all schemas to build the seen map\n        for (const entry of registry._idmap.entries()) {\n            const [_, schema] = entry;\n            process(schema, ctx);\n        }\n        const schemas = {};\n        const external = {\n            registry,\n            uri: params?.uri,\n            defs,\n        };\n        // Update the context with external configuration\n        ctx.external = external;\n        // Second pass: emit each schema\n        for (const entry of registry._idmap.entries()) {\n            const [key, schema] = entry;\n            extractDefs(ctx, schema);\n            schemas[key] = finalize(ctx, schema);\n        }\n        if (Object.keys(defs).length > 0) {\n            const defsSegment = ctx.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n            schemas.__shared = {\n                [defsSegment]: defs,\n            };\n        }\n        return { schemas };\n    }\n    // Single schema case\n    const ctx = initializeContext({ ...params, processors: allProcessors });\n    process(input, ctx);\n    extractDefs(ctx, input);\n    return finalize(ctx, input);\n}\n","export {};\n","import * as core from \"./core.js\";\nimport * as errors from \"./errors.js\";\nimport * as util from \"./util.js\";\nexport const _parse = (_Err) => (schema, value, _ctx, _params) => {\n    const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };\n    const result = schema._zod.run({ value, issues: [] }, ctx);\n    if (result instanceof Promise) {\n        throw new core.$ZodAsyncError();\n    }\n    if (result.issues.length) {\n        const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())));\n        util.captureStackTrace(e, _params?.callee);\n        throw e;\n    }\n    return result.value;\n};\nexport const parse = /* @__PURE__*/ _parse(errors.$ZodRealError);\nexport const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {\n    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n    let result = schema._zod.run({ value, issues: [] }, ctx);\n    if (result instanceof Promise)\n        result = await result;\n    if (result.issues.length) {\n        const e = new (params?.Err ?? _Err)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())));\n        util.captureStackTrace(e, params?.callee);\n        throw e;\n    }\n    return result.value;\n};\nexport const parseAsync = /* @__PURE__*/ _parseAsync(errors.$ZodRealError);\nexport const _safeParse = (_Err) => (schema, value, _ctx) => {\n    const ctx = _ctx ? { ..._ctx, async: false } : { async: false };\n    const result = schema._zod.run({ value, issues: [] }, ctx);\n    if (result instanceof Promise) {\n        throw new core.$ZodAsyncError();\n    }\n    return result.issues.length\n        ? {\n            success: false,\n            error: new (_Err ?? errors.$ZodError)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))),\n        }\n        : { success: true, data: result.value };\n};\nexport const safeParse = /* @__PURE__*/ _safeParse(errors.$ZodRealError);\nexport const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {\n    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n    let result = schema._zod.run({ value, issues: [] }, ctx);\n    if (result instanceof Promise)\n        result = await result;\n    return result.issues.length\n        ? {\n            success: false,\n            error: new _Err(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))),\n        }\n        : { success: true, data: result.value };\n};\nexport const safeParseAsync = /* @__PURE__*/ _safeParseAsync(errors.$ZodRealError);\nexport const _encode = (_Err) => (schema, value, _ctx) => {\n    const ctx = _ctx ? Object.assign(_ctx, { direction: \"backward\" }) : { direction: \"backward\" };\n    return _parse(_Err)(schema, value, ctx);\n};\nexport const encode = /* @__PURE__*/ _encode(errors.$ZodRealError);\nexport const _decode = (_Err) => (schema, value, _ctx) => {\n    return _parse(_Err)(schema, value, _ctx);\n};\nexport const decode = /* @__PURE__*/ _decode(errors.$ZodRealError);\nexport const _encodeAsync = (_Err) => async (schema, value, _ctx) => {\n    const ctx = _ctx ? Object.assign(_ctx, { direction: \"backward\" }) : { direction: \"backward\" };\n    return _parseAsync(_Err)(schema, value, ctx);\n};\nexport const encodeAsync = /* @__PURE__*/ _encodeAsync(errors.$ZodRealError);\nexport const _decodeAsync = (_Err) => async (schema, value, _ctx) => {\n    return _parseAsync(_Err)(schema, value, _ctx);\n};\nexport const decodeAsync = /* @__PURE__*/ _decodeAsync(errors.$ZodRealError);\nexport const _safeEncode = (_Err) => (schema, value, _ctx) => {\n    const ctx = _ctx ? Object.assign(_ctx, { direction: \"backward\" }) : { direction: \"backward\" };\n    return _safeParse(_Err)(schema, value, ctx);\n};\nexport const safeEncode = /* @__PURE__*/ _safeEncode(errors.$ZodRealError);\nexport const _safeDecode = (_Err) => (schema, value, _ctx) => {\n    return _safeParse(_Err)(schema, value, _ctx);\n};\nexport const safeDecode = /* @__PURE__*/ _safeDecode(errors.$ZodRealError);\nexport const _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {\n    const ctx = _ctx ? Object.assign(_ctx, { direction: \"backward\" }) : { direction: \"backward\" };\n    return _safeParseAsync(_Err)(schema, value, ctx);\n};\nexport const safeEncodeAsync = /* @__PURE__*/ _safeEncodeAsync(errors.$ZodRealError);\nexport const _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {\n    return _safeParseAsync(_Err)(schema, value, _ctx);\n};\nexport const safeDecodeAsync = /* @__PURE__*/ _safeDecodeAsync(errors.$ZodRealError);\n","import * as util from \"./util.js\";\nexport const cuid = /^[cC][^\\s-]{8,}$/;\nexport const cuid2 = /^[0-9a-z]+$/;\nexport const ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;\nexport const xid = /^[0-9a-vA-V]{20}$/;\nexport const ksuid = /^[A-Za-z0-9]{27}$/;\nexport const nanoid = /^[a-zA-Z0-9_-]{21}$/;\n/** ISO 8601-1 duration regex. Does not support the 8601-2 extensions like negative durations or fractional/negative components. */\nexport const duration = /^P(?:(\\d+W)|(?!.*W)(?=\\d|T\\d)(\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+([.,]\\d+)?S)?)?)$/;\n/** Implements ISO 8601-2 extensions like explicit +- prefixes, mixing weeks with other units, and fractional/negative components. */\nexport const extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n/** A regex for any UUID-like identifier: 8-4-4-4-12 hex pattern */\nexport const guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;\n/** Returns a regex for validating an RFC 9562/4122 UUID.\n *\n * @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */\nexport const uuid = (version) => {\n    if (!version)\n        return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;\n    return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);\n};\nexport const uuid4 = /*@__PURE__*/ uuid(4);\nexport const uuid6 = /*@__PURE__*/ uuid(6);\nexport const uuid7 = /*@__PURE__*/ uuid(7);\n/** Practical email validation */\nexport const email = /^(?!\\.)(?!.*\\.\\.)([A-Za-z0-9_'+\\-\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\-]*\\.)+[A-Za-z]{2,}$/;\n/** Equivalent to the HTML5 input[type=email] validation implemented by browsers. Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email */\nexport const html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n/** The classic emailregex.com regex for RFC 5322-compliant emails */\nexport const rfc5322Email = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n/** A loose regex that allows Unicode characters, enforces length limits, and that's about it. */\nexport const unicodeEmail = /^[^\\s@\"]{1,64}@[^\\s@]{1,255}$/u;\nexport const idnEmail = unicodeEmail;\nexport const browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emoji = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nexport function emoji() {\n    return new RegExp(_emoji, \"u\");\n}\nexport const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nexport const ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;\nexport const mac = (delimiter) => {\n    const escapedDelim = util.escapeRegex(delimiter ?? \":\");\n    return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);\n};\nexport const cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/([0-9]|[1-2][0-9]|3[0-2])$/;\nexport const cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nexport const base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;\nexport const base64url = /^[A-Za-z0-9_-]*$/;\n// based on https://stackoverflow.com/questions/106179/regular-expression-to-match-dns-hostname-or-ip-address\n// export const hostname: RegExp = /^([a-zA-Z0-9-]+\\.)*[a-zA-Z0-9-]+$/;\nexport const hostname = /^(?=.{1,253}\\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\\.?$/;\nexport const domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}$/;\n// https://blog.stevenlevithan.com/archives/validate-phone-number#r4-3 (regex sans spaces)\n// E.164: leading digit must be 1-9; total digits (excluding '+') between 7-15\nexport const e164 = /^\\+[1-9]\\d{6,14}$/;\n// const dateSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateSource = `(?:(?:\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\\\d|30)|(?:02)-(?:0[1-9]|1\\\\d|2[0-8])))`;\nexport const date = /*@__PURE__*/ new RegExp(`^${dateSource}$`);\nfunction timeSource(args) {\n    const hhmm = `(?:[01]\\\\d|2[0-3]):[0-5]\\\\d`;\n    const regex = typeof args.precision === \"number\"\n        ? args.precision === -1\n            ? `${hhmm}`\n            : args.precision === 0\n                ? `${hhmm}:[0-5]\\\\d`\n                : `${hhmm}:[0-5]\\\\d\\\\.\\\\d{${args.precision}}`\n        : `${hhmm}(?::[0-5]\\\\d(?:\\\\.\\\\d+)?)?`;\n    return regex;\n}\nexport function time(args) {\n    return new RegExp(`^${timeSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nexport function datetime(args) {\n    const time = timeSource({ precision: args.precision });\n    const opts = [\"Z\"];\n    if (args.local)\n        opts.push(\"\");\n    // if (args.offset) opts.push(`([+-]\\\\d{2}:\\\\d{2})`);\n    if (args.offset)\n        opts.push(`([+-](?:[01]\\\\d|2[0-3]):[0-5]\\\\d)`);\n    const timeRegex = `${time}(?:${opts.join(\"|\")})`;\n    return new RegExp(`^${dateSource}T(?:${timeRegex})$`);\n}\nexport const string = (params) => {\n    const regex = params ? `[\\\\s\\\\S]{${params?.minimum ?? 0},${params?.maximum ?? \"\"}}` : `[\\\\s\\\\S]*`;\n    return new RegExp(`^${regex}$`);\n};\nexport const bigint = /^-?\\d+n?$/;\nexport const integer = /^-?\\d+$/;\nexport const number = /^-?\\d+(?:\\.\\d+)?$/;\nexport const boolean = /^(?:true|false)$/i;\nconst _null = /^null$/i;\nexport { _null as null };\nconst _undefined = /^undefined$/i;\nexport { _undefined as undefined };\n// regex for string with no uppercase letters\nexport const lowercase = /^[^A-Z]*$/;\n// regex for string with no lowercase letters\nexport const uppercase = /^[^a-z]*$/;\n// regex for hexadecimal strings (any length)\nexport const hex = /^[0-9a-fA-F]*$/;\n// Hash regexes for different algorithms and encodings\n// Helper function to create base64 regex with exact length and padding\nfunction fixedBase64(bodyLength, padding) {\n    return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);\n}\n// Helper function to create base64url regex with exact length (no padding)\nfunction fixedBase64url(length) {\n    return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);\n}\n// MD5 (16 bytes): base64 = 24 chars total (22 + \"==\")\nexport const md5_hex = /^[0-9a-fA-F]{32}$/;\nexport const md5_base64 = /*@__PURE__*/ fixedBase64(22, \"==\");\nexport const md5_base64url = /*@__PURE__*/ fixedBase64url(22);\n// SHA1 (20 bytes): base64 = 28 chars total (27 + \"=\")\nexport const sha1_hex = /^[0-9a-fA-F]{40}$/;\nexport const sha1_base64 = /*@__PURE__*/ fixedBase64(27, \"=\");\nexport const sha1_base64url = /*@__PURE__*/ fixedBase64url(27);\n// SHA256 (32 bytes): base64 = 44 chars total (43 + \"=\")\nexport const sha256_hex = /^[0-9a-fA-F]{64}$/;\nexport const sha256_base64 = /*@__PURE__*/ fixedBase64(43, \"=\");\nexport const sha256_base64url = /*@__PURE__*/ fixedBase64url(43);\n// SHA384 (48 bytes): base64 = 64 chars total (no padding)\nexport const sha384_hex = /^[0-9a-fA-F]{96}$/;\nexport const sha384_base64 = /*@__PURE__*/ fixedBase64(64, \"\");\nexport const sha384_base64url = /*@__PURE__*/ fixedBase64url(64);\n// SHA512 (64 bytes): base64 = 88 chars total (86 + \"==\")\nexport const sha512_hex = /^[0-9a-fA-F]{128}$/;\nexport const sha512_base64 = /*@__PURE__*/ fixedBase64(86, \"==\");\nexport const sha512_base64url = /*@__PURE__*/ fixedBase64url(86);\n","var _a;\nexport const $output = Symbol(\"ZodOutput\");\nexport const $input = Symbol(\"ZodInput\");\nexport class $ZodRegistry {\n    constructor() {\n        this._map = new WeakMap();\n        this._idmap = new Map();\n    }\n    add(schema, ..._meta) {\n        const meta = _meta[0];\n        this._map.set(schema, meta);\n        if (meta && typeof meta === \"object\" && \"id\" in meta) {\n            this._idmap.set(meta.id, schema);\n        }\n        return this;\n    }\n    clear() {\n        this._map = new WeakMap();\n        this._idmap = new Map();\n        return this;\n    }\n    remove(schema) {\n        const meta = this._map.get(schema);\n        if (meta && typeof meta === \"object\" && \"id\" in meta) {\n            this._idmap.delete(meta.id);\n        }\n        this._map.delete(schema);\n        return this;\n    }\n    get(schema) {\n        // return this._map.get(schema) as any;\n        // inherit metadata\n        const p = schema._zod.parent;\n        if (p) {\n            const pm = { ...(this.get(p) ?? {}) };\n            delete pm.id; // do not inherit id\n            const f = { ...pm, ...this._map.get(schema) };\n            return Object.keys(f).length ? f : undefined;\n        }\n        return this._map.get(schema);\n    }\n    has(schema) {\n        return this._map.has(schema);\n    }\n}\n// registries\nexport function registry() {\n    return new $ZodRegistry();\n}\n(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());\nexport const globalRegistry = globalThis.__zod_globalRegistry;\n","import * as checks from \"./checks.js\";\nimport * as core from \"./core.js\";\nimport { Doc } from \"./doc.js\";\nimport { parse, parseAsync, safeParse, safeParseAsync } from \"./parse.js\";\nimport * as regexes from \"./regexes.js\";\nimport * as util from \"./util.js\";\nimport { version } from \"./versions.js\";\nexport const $ZodType = /*@__PURE__*/ core.$constructor(\"$ZodType\", (inst, def) => {\n    var _a;\n    inst ?? (inst = {});\n    inst._zod.def = def; // set _def property\n    inst._zod.bag = inst._zod.bag || {}; // initialize _bag object\n    inst._zod.version = version;\n    const checks = [...(inst._zod.def.checks ?? [])];\n    // if inst is itself a checks.$ZodCheck, run it as a check\n    if (inst._zod.traits.has(\"$ZodCheck\")) {\n        checks.unshift(inst);\n    }\n    for (const ch of checks) {\n        for (const fn of ch._zod.onattach) {\n            fn(inst);\n        }\n    }\n    if (checks.length === 0) {\n        // deferred initializer\n        // inst._zod.parse is not yet defined\n        (_a = inst._zod).deferred ?? (_a.deferred = []);\n        inst._zod.deferred?.push(() => {\n            inst._zod.run = inst._zod.parse;\n        });\n    }\n    else {\n        const runChecks = (payload, checks, ctx) => {\n            let isAborted = util.aborted(payload);\n            let asyncResult;\n            for (const ch of checks) {\n                if (ch._zod.def.when) {\n                    const shouldRun = ch._zod.def.when(payload);\n                    if (!shouldRun)\n                        continue;\n                }\n                else if (isAborted) {\n                    continue;\n                }\n                const currLen = payload.issues.length;\n                const _ = ch._zod.check(payload);\n                if (_ instanceof Promise && ctx?.async === false) {\n                    throw new core.$ZodAsyncError();\n                }\n                if (asyncResult || _ instanceof Promise) {\n                    asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {\n                        await _;\n                        const nextLen = payload.issues.length;\n                        if (nextLen === currLen)\n                            return;\n                        if (!isAborted)\n                            isAborted = util.aborted(payload, currLen);\n                    });\n                }\n                else {\n                    const nextLen = payload.issues.length;\n                    if (nextLen === currLen)\n                        continue;\n                    if (!isAborted)\n                        isAborted = util.aborted(payload, currLen);\n                }\n            }\n            if (asyncResult) {\n                return asyncResult.then(() => {\n                    return payload;\n                });\n            }\n            return payload;\n        };\n        const handleCanaryResult = (canary, payload, ctx) => {\n            // abort if the canary is aborted\n            if (util.aborted(canary)) {\n                canary.aborted = true;\n                return canary;\n            }\n            // run checks first, then\n            const checkResult = runChecks(payload, checks, ctx);\n            if (checkResult instanceof Promise) {\n                if (ctx.async === false)\n                    throw new core.$ZodAsyncError();\n                return checkResult.then((checkResult) => inst._zod.parse(checkResult, ctx));\n            }\n            return inst._zod.parse(checkResult, ctx);\n        };\n        inst._zod.run = (payload, ctx) => {\n            if (ctx.skipChecks) {\n                return inst._zod.parse(payload, ctx);\n            }\n            if (ctx.direction === \"backward\") {\n                // run canary\n                // initial pass (no checks)\n                const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });\n                if (canary instanceof Promise) {\n                    return canary.then((canary) => {\n                        return handleCanaryResult(canary, payload, ctx);\n                    });\n                }\n                return handleCanaryResult(canary, payload, ctx);\n            }\n            // forward\n            const result = inst._zod.parse(payload, ctx);\n            if (result instanceof Promise) {\n                if (ctx.async === false)\n                    throw new core.$ZodAsyncError();\n                return result.then((result) => runChecks(result, checks, ctx));\n            }\n            return runChecks(result, checks, ctx);\n        };\n    }\n    // Lazy initialize ~standard to avoid creating objects for every schema\n    util.defineLazy(inst, \"~standard\", () => ({\n        validate: (value) => {\n            try {\n                const r = safeParse(inst, value);\n                return r.success ? { value: r.data } : { issues: r.error?.issues };\n            }\n            catch (_) {\n                return safeParseAsync(inst, value).then((r) => (r.success ? { value: r.data } : { issues: r.error?.issues }));\n            }\n        },\n        vendor: \"zod\",\n        version: 1,\n    }));\n});\nexport { clone } from \"./util.js\";\nexport const $ZodString = /*@__PURE__*/ core.$constructor(\"$ZodString\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = [...(inst?._zod.bag?.patterns ?? [])].pop() ?? regexes.string(inst._zod.bag);\n    inst._zod.parse = (payload, _) => {\n        if (def.coerce)\n            try {\n                payload.value = String(payload.value);\n            }\n            catch (_) { }\n        if (typeof payload.value === \"string\")\n            return payload;\n        payload.issues.push({\n            expected: \"string\",\n            code: \"invalid_type\",\n            input: payload.value,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodStringFormat = /*@__PURE__*/ core.$constructor(\"$ZodStringFormat\", (inst, def) => {\n    // check initialization must come first\n    checks.$ZodCheckStringFormat.init(inst, def);\n    $ZodString.init(inst, def);\n});\nexport const $ZodGUID = /*@__PURE__*/ core.$constructor(\"$ZodGUID\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.guid);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodUUID = /*@__PURE__*/ core.$constructor(\"$ZodUUID\", (inst, def) => {\n    if (def.version) {\n        const versionMap = {\n            v1: 1,\n            v2: 2,\n            v3: 3,\n            v4: 4,\n            v5: 5,\n            v6: 6,\n            v7: 7,\n            v8: 8,\n        };\n        const v = versionMap[def.version];\n        if (v === undefined)\n            throw new Error(`Invalid UUID version: \"${def.version}\"`);\n        def.pattern ?? (def.pattern = regexes.uuid(v));\n    }\n    else\n        def.pattern ?? (def.pattern = regexes.uuid());\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodEmail = /*@__PURE__*/ core.$constructor(\"$ZodEmail\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.email);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodURL = /*@__PURE__*/ core.$constructor(\"$ZodURL\", (inst, def) => {\n    $ZodStringFormat.init(inst, def);\n    inst._zod.check = (payload) => {\n        try {\n            // Trim whitespace from input\n            const trimmed = payload.value.trim();\n            // @ts-ignore\n            const url = new URL(trimmed);\n            if (def.hostname) {\n                def.hostname.lastIndex = 0;\n                if (!def.hostname.test(url.hostname)) {\n                    payload.issues.push({\n                        code: \"invalid_format\",\n                        format: \"url\",\n                        note: \"Invalid hostname\",\n                        pattern: def.hostname.source,\n                        input: payload.value,\n                        inst,\n                        continue: !def.abort,\n                    });\n                }\n            }\n            if (def.protocol) {\n                def.protocol.lastIndex = 0;\n                if (!def.protocol.test(url.protocol.endsWith(\":\") ? url.protocol.slice(0, -1) : url.protocol)) {\n                    payload.issues.push({\n                        code: \"invalid_format\",\n                        format: \"url\",\n                        note: \"Invalid protocol\",\n                        pattern: def.protocol.source,\n                        input: payload.value,\n                        inst,\n                        continue: !def.abort,\n                    });\n                }\n            }\n            // Set the output value based on normalize flag\n            if (def.normalize) {\n                // Use normalized URL\n                payload.value = url.href;\n            }\n            else {\n                // Preserve the original input (trimmed)\n                payload.value = trimmed;\n            }\n            return;\n        }\n        catch (_) {\n            payload.issues.push({\n                code: \"invalid_format\",\n                format: \"url\",\n                input: payload.value,\n                inst,\n                continue: !def.abort,\n            });\n        }\n    };\n});\nexport const $ZodEmoji = /*@__PURE__*/ core.$constructor(\"$ZodEmoji\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.emoji());\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodNanoID = /*@__PURE__*/ core.$constructor(\"$ZodNanoID\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.nanoid);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodCUID = /*@__PURE__*/ core.$constructor(\"$ZodCUID\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.cuid);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodCUID2 = /*@__PURE__*/ core.$constructor(\"$ZodCUID2\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.cuid2);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodULID = /*@__PURE__*/ core.$constructor(\"$ZodULID\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.ulid);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodXID = /*@__PURE__*/ core.$constructor(\"$ZodXID\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.xid);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodKSUID = /*@__PURE__*/ core.$constructor(\"$ZodKSUID\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.ksuid);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISODateTime = /*@__PURE__*/ core.$constructor(\"$ZodISODateTime\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.datetime(def));\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISODate = /*@__PURE__*/ core.$constructor(\"$ZodISODate\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.date);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISOTime = /*@__PURE__*/ core.$constructor(\"$ZodISOTime\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.time(def));\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISODuration = /*@__PURE__*/ core.$constructor(\"$ZodISODuration\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.duration);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodIPv4 = /*@__PURE__*/ core.$constructor(\"$ZodIPv4\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.ipv4);\n    $ZodStringFormat.init(inst, def);\n    inst._zod.bag.format = `ipv4`;\n});\nexport const $ZodIPv6 = /*@__PURE__*/ core.$constructor(\"$ZodIPv6\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.ipv6);\n    $ZodStringFormat.init(inst, def);\n    inst._zod.bag.format = `ipv6`;\n    inst._zod.check = (payload) => {\n        try {\n            // @ts-ignore\n            new URL(`http://[${payload.value}]`);\n            // return;\n        }\n        catch {\n            payload.issues.push({\n                code: \"invalid_format\",\n                format: \"ipv6\",\n                input: payload.value,\n                inst,\n                continue: !def.abort,\n            });\n        }\n    };\n});\nexport const $ZodMAC = /*@__PURE__*/ core.$constructor(\"$ZodMAC\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.mac(def.delimiter));\n    $ZodStringFormat.init(inst, def);\n    inst._zod.bag.format = `mac`;\n});\nexport const $ZodCIDRv4 = /*@__PURE__*/ core.$constructor(\"$ZodCIDRv4\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.cidrv4);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodCIDRv6 = /*@__PURE__*/ core.$constructor(\"$ZodCIDRv6\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.cidrv6); // not used for validation\n    $ZodStringFormat.init(inst, def);\n    inst._zod.check = (payload) => {\n        const parts = payload.value.split(\"/\");\n        try {\n            if (parts.length !== 2)\n                throw new Error();\n            const [address, prefix] = parts;\n            if (!prefix)\n                throw new Error();\n            const prefixNum = Number(prefix);\n            if (`${prefixNum}` !== prefix)\n                throw new Error();\n            if (prefixNum < 0 || prefixNum > 128)\n                throw new Error();\n            // @ts-ignore\n            new URL(`http://[${address}]`);\n        }\n        catch {\n            payload.issues.push({\n                code: \"invalid_format\",\n                format: \"cidrv6\",\n                input: payload.value,\n                inst,\n                continue: !def.abort,\n            });\n        }\n    };\n});\n//////////////////////////////   ZodBase64   //////////////////////////////\nexport function isValidBase64(data) {\n    if (data === \"\")\n        return true;\n    if (data.length % 4 !== 0)\n        return false;\n    try {\n        // @ts-ignore\n        atob(data);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nexport const $ZodBase64 = /*@__PURE__*/ core.$constructor(\"$ZodBase64\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.base64);\n    $ZodStringFormat.init(inst, def);\n    inst._zod.bag.contentEncoding = \"base64\";\n    inst._zod.check = (payload) => {\n        if (isValidBase64(payload.value))\n            return;\n        payload.issues.push({\n            code: \"invalid_format\",\n            format: \"base64\",\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\n//////////////////////////////   ZodBase64   //////////////////////////////\nexport function isValidBase64URL(data) {\n    if (!regexes.base64url.test(data))\n        return false;\n    const base64 = data.replace(/[-_]/g, (c) => (c === \"-\" ? \"+\" : \"/\"));\n    const padded = base64.padEnd(Math.ceil(base64.length / 4) * 4, \"=\");\n    return isValidBase64(padded);\n}\nexport const $ZodBase64URL = /*@__PURE__*/ core.$constructor(\"$ZodBase64URL\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.base64url);\n    $ZodStringFormat.init(inst, def);\n    inst._zod.bag.contentEncoding = \"base64url\";\n    inst._zod.check = (payload) => {\n        if (isValidBase64URL(payload.value))\n            return;\n        payload.issues.push({\n            code: \"invalid_format\",\n            format: \"base64url\",\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodE164 = /*@__PURE__*/ core.$constructor(\"$ZodE164\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.e164);\n    $ZodStringFormat.init(inst, def);\n});\n//////////////////////////////   ZodJWT   //////////////////////////////\nexport function isValidJWT(token, algorithm = null) {\n    try {\n        const tokensParts = token.split(\".\");\n        if (tokensParts.length !== 3)\n            return false;\n        const [header] = tokensParts;\n        if (!header)\n            return false;\n        // @ts-ignore\n        const parsedHeader = JSON.parse(atob(header));\n        if (\"typ\" in parsedHeader && parsedHeader?.typ !== \"JWT\")\n            return false;\n        if (!parsedHeader.alg)\n            return false;\n        if (algorithm && (!(\"alg\" in parsedHeader) || parsedHeader.alg !== algorithm))\n            return false;\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nexport const $ZodJWT = /*@__PURE__*/ core.$constructor(\"$ZodJWT\", (inst, def) => {\n    $ZodStringFormat.init(inst, def);\n    inst._zod.check = (payload) => {\n        if (isValidJWT(payload.value, def.alg))\n            return;\n        payload.issues.push({\n            code: \"invalid_format\",\n            format: \"jwt\",\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCustomStringFormat = /*@__PURE__*/ core.$constructor(\"$ZodCustomStringFormat\", (inst, def) => {\n    $ZodStringFormat.init(inst, def);\n    inst._zod.check = (payload) => {\n        if (def.fn(payload.value))\n            return;\n        payload.issues.push({\n            code: \"invalid_format\",\n            format: def.format,\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodNumber = /*@__PURE__*/ core.$constructor(\"$ZodNumber\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = inst._zod.bag.pattern ?? regexes.number;\n    inst._zod.parse = (payload, _ctx) => {\n        if (def.coerce)\n            try {\n                payload.value = Number(payload.value);\n            }\n            catch (_) { }\n        const input = payload.value;\n        if (typeof input === \"number\" && !Number.isNaN(input) && Number.isFinite(input)) {\n            return payload;\n        }\n        const received = typeof input === \"number\"\n            ? Number.isNaN(input)\n                ? \"NaN\"\n                : !Number.isFinite(input)\n                    ? \"Infinity\"\n                    : undefined\n            : undefined;\n        payload.issues.push({\n            expected: \"number\",\n            code: \"invalid_type\",\n            input,\n            inst,\n            ...(received ? { received } : {}),\n        });\n        return payload;\n    };\n});\nexport const $ZodNumberFormat = /*@__PURE__*/ core.$constructor(\"$ZodNumberFormat\", (inst, def) => {\n    checks.$ZodCheckNumberFormat.init(inst, def);\n    $ZodNumber.init(inst, def); // no format checks\n});\nexport const $ZodBoolean = /*@__PURE__*/ core.$constructor(\"$ZodBoolean\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = regexes.boolean;\n    inst._zod.parse = (payload, _ctx) => {\n        if (def.coerce)\n            try {\n                payload.value = Boolean(payload.value);\n            }\n            catch (_) { }\n        const input = payload.value;\n        if (typeof input === \"boolean\")\n            return payload;\n        payload.issues.push({\n            expected: \"boolean\",\n            code: \"invalid_type\",\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodBigInt = /*@__PURE__*/ core.$constructor(\"$ZodBigInt\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = regexes.bigint;\n    inst._zod.parse = (payload, _ctx) => {\n        if (def.coerce)\n            try {\n                payload.value = BigInt(payload.value);\n            }\n            catch (_) { }\n        if (typeof payload.value === \"bigint\")\n            return payload;\n        payload.issues.push({\n            expected: \"bigint\",\n            code: \"invalid_type\",\n            input: payload.value,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodBigIntFormat = /*@__PURE__*/ core.$constructor(\"$ZodBigIntFormat\", (inst, def) => {\n    checks.$ZodCheckBigIntFormat.init(inst, def);\n    $ZodBigInt.init(inst, def); // no format checks\n});\nexport const $ZodSymbol = /*@__PURE__*/ core.$constructor(\"$ZodSymbol\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        if (typeof input === \"symbol\")\n            return payload;\n        payload.issues.push({\n            expected: \"symbol\",\n            code: \"invalid_type\",\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodUndefined = /*@__PURE__*/ core.$constructor(\"$ZodUndefined\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = regexes.undefined;\n    inst._zod.values = new Set([undefined]);\n    inst._zod.optin = \"optional\";\n    inst._zod.optout = \"optional\";\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        if (typeof input === \"undefined\")\n            return payload;\n        payload.issues.push({\n            expected: \"undefined\",\n            code: \"invalid_type\",\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodNull = /*@__PURE__*/ core.$constructor(\"$ZodNull\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = regexes.null;\n    inst._zod.values = new Set([null]);\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        if (input === null)\n            return payload;\n        payload.issues.push({\n            expected: \"null\",\n            code: \"invalid_type\",\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodAny = /*@__PURE__*/ core.$constructor(\"$ZodAny\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload) => payload;\n});\nexport const $ZodUnknown = /*@__PURE__*/ core.$constructor(\"$ZodUnknown\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload) => payload;\n});\nexport const $ZodNever = /*@__PURE__*/ core.$constructor(\"$ZodNever\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n        payload.issues.push({\n            expected: \"never\",\n            code: \"invalid_type\",\n            input: payload.value,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodVoid = /*@__PURE__*/ core.$constructor(\"$ZodVoid\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        if (typeof input === \"undefined\")\n            return payload;\n        payload.issues.push({\n            expected: \"void\",\n            code: \"invalid_type\",\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodDate = /*@__PURE__*/ core.$constructor(\"$ZodDate\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n        if (def.coerce) {\n            try {\n                payload.value = new Date(payload.value);\n            }\n            catch (_err) { }\n        }\n        const input = payload.value;\n        const isDate = input instanceof Date;\n        const isValidDate = isDate && !Number.isNaN(input.getTime());\n        if (isValidDate)\n            return payload;\n        payload.issues.push({\n            expected: \"date\",\n            code: \"invalid_type\",\n            input,\n            ...(isDate ? { received: \"Invalid Date\" } : {}),\n            inst,\n        });\n        return payload;\n    };\n});\nfunction handleArrayResult(result, final, index) {\n    if (result.issues.length) {\n        final.issues.push(...util.prefixIssues(index, result.issues));\n    }\n    final.value[index] = result.value;\n}\nexport const $ZodArray = /*@__PURE__*/ core.$constructor(\"$ZodArray\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        if (!Array.isArray(input)) {\n            payload.issues.push({\n                expected: \"array\",\n                code: \"invalid_type\",\n                input,\n                inst,\n            });\n            return payload;\n        }\n        payload.value = Array(input.length);\n        const proms = [];\n        for (let i = 0; i < input.length; i++) {\n            const item = input[i];\n            const result = def.element._zod.run({\n                value: item,\n                issues: [],\n            }, ctx);\n            if (result instanceof Promise) {\n                proms.push(result.then((result) => handleArrayResult(result, payload, i)));\n            }\n            else {\n                handleArrayResult(result, payload, i);\n            }\n        }\n        if (proms.length) {\n            return Promise.all(proms).then(() => payload);\n        }\n        return payload; //handleArrayResultsAsync(parseResults, final);\n    };\n});\nfunction handlePropertyResult(result, final, key, input, isOptionalOut) {\n    if (result.issues.length) {\n        // For optional-out schemas, ignore errors on absent keys\n        if (isOptionalOut && !(key in input)) {\n            return;\n        }\n        final.issues.push(...util.prefixIssues(key, result.issues));\n    }\n    if (result.value === undefined) {\n        if (key in input) {\n            final.value[key] = undefined;\n        }\n    }\n    else {\n        final.value[key] = result.value;\n    }\n}\nfunction normalizeDef(def) {\n    const keys = Object.keys(def.shape);\n    for (const k of keys) {\n        if (!def.shape?.[k]?._zod?.traits?.has(\"$ZodType\")) {\n            throw new Error(`Invalid element at key \"${k}\": expected a Zod schema`);\n        }\n    }\n    const okeys = util.optionalKeys(def.shape);\n    return {\n        ...def,\n        keys,\n        keySet: new Set(keys),\n        numKeys: keys.length,\n        optionalKeys: new Set(okeys),\n    };\n}\nfunction handleCatchall(proms, input, payload, ctx, def, inst) {\n    const unrecognized = [];\n    // iterate over input keys\n    const keySet = def.keySet;\n    const _catchall = def.catchall._zod;\n    const t = _catchall.def.type;\n    const isOptionalOut = _catchall.optout === \"optional\";\n    for (const key in input) {\n        if (keySet.has(key))\n            continue;\n        if (t === \"never\") {\n            unrecognized.push(key);\n            continue;\n        }\n        const r = _catchall.run({ value: input[key], issues: [] }, ctx);\n        if (r instanceof Promise) {\n            proms.push(r.then((r) => handlePropertyResult(r, payload, key, input, isOptionalOut)));\n        }\n        else {\n            handlePropertyResult(r, payload, key, input, isOptionalOut);\n        }\n    }\n    if (unrecognized.length) {\n        payload.issues.push({\n            code: \"unrecognized_keys\",\n            keys: unrecognized,\n            input,\n            inst,\n        });\n    }\n    if (!proms.length)\n        return payload;\n    return Promise.all(proms).then(() => {\n        return payload;\n    });\n}\nexport const $ZodObject = /*@__PURE__*/ core.$constructor(\"$ZodObject\", (inst, def) => {\n    // requires cast because technically $ZodObject doesn't extend\n    $ZodType.init(inst, def);\n    // const sh = def.shape;\n    const desc = Object.getOwnPropertyDescriptor(def, \"shape\");\n    if (!desc?.get) {\n        const sh = def.shape;\n        Object.defineProperty(def, \"shape\", {\n            get: () => {\n                const newSh = { ...sh };\n                Object.defineProperty(def, \"shape\", {\n                    value: newSh,\n                });\n                return newSh;\n            },\n        });\n    }\n    const _normalized = util.cached(() => normalizeDef(def));\n    util.defineLazy(inst._zod, \"propValues\", () => {\n        const shape = def.shape;\n        const propValues = {};\n        for (const key in shape) {\n            const field = shape[key]._zod;\n            if (field.values) {\n                propValues[key] ?? (propValues[key] = new Set());\n                for (const v of field.values)\n                    propValues[key].add(v);\n            }\n        }\n        return propValues;\n    });\n    const isObject = util.isObject;\n    const catchall = def.catchall;\n    let value;\n    inst._zod.parse = (payload, ctx) => {\n        value ?? (value = _normalized.value);\n        const input = payload.value;\n        if (!isObject(input)) {\n            payload.issues.push({\n                expected: \"object\",\n                code: \"invalid_type\",\n                input,\n                inst,\n            });\n            return payload;\n        }\n        payload.value = {};\n        const proms = [];\n        const shape = value.shape;\n        for (const key of value.keys) {\n            const el = shape[key];\n            const isOptionalOut = el._zod.optout === \"optional\";\n            const r = el._zod.run({ value: input[key], issues: [] }, ctx);\n            if (r instanceof Promise) {\n                proms.push(r.then((r) => handlePropertyResult(r, payload, key, input, isOptionalOut)));\n            }\n            else {\n                handlePropertyResult(r, payload, key, input, isOptionalOut);\n            }\n        }\n        if (!catchall) {\n            return proms.length ? Promise.all(proms).then(() => payload) : payload;\n        }\n        return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);\n    };\n});\nexport const $ZodObjectJIT = /*@__PURE__*/ core.$constructor(\"$ZodObjectJIT\", (inst, def) => {\n    // requires cast because technically $ZodObject doesn't extend\n    $ZodObject.init(inst, def);\n    const superParse = inst._zod.parse;\n    const _normalized = util.cached(() => normalizeDef(def));\n    const generateFastpass = (shape) => {\n        const doc = new Doc([\"shape\", \"payload\", \"ctx\"]);\n        const normalized = _normalized.value;\n        const parseStr = (key) => {\n            const k = util.esc(key);\n            return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;\n        };\n        doc.write(`const input = payload.value;`);\n        const ids = Object.create(null);\n        let counter = 0;\n        for (const key of normalized.keys) {\n            ids[key] = `key_${counter++}`;\n        }\n        // A: preserve key order {\n        doc.write(`const newResult = {};`);\n        for (const key of normalized.keys) {\n            const id = ids[key];\n            const k = util.esc(key);\n            const schema = shape[key];\n            const isOptionalOut = schema?._zod?.optout === \"optional\";\n            doc.write(`const ${id} = ${parseStr(key)};`);\n            if (isOptionalOut) {\n                // For optional-out schemas, ignore errors on absent keys\n                doc.write(`\n        if (${id}.issues.length) {\n          if (${k} in input) {\n            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({\n              ...iss,\n              path: iss.path ? [${k}, ...iss.path] : [${k}]\n            })));\n          }\n        }\n        \n        if (${id}.value === undefined) {\n          if (${k} in input) {\n            newResult[${k}] = undefined;\n          }\n        } else {\n          newResult[${k}] = ${id}.value;\n        }\n        \n      `);\n            }\n            else {\n                doc.write(`\n        if (${id}.issues.length) {\n          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${k}, ...iss.path] : [${k}]\n          })));\n        }\n        \n        if (${id}.value === undefined) {\n          if (${k} in input) {\n            newResult[${k}] = undefined;\n          }\n        } else {\n          newResult[${k}] = ${id}.value;\n        }\n        \n      `);\n            }\n        }\n        doc.write(`payload.value = newResult;`);\n        doc.write(`return payload;`);\n        const fn = doc.compile();\n        return (payload, ctx) => fn(shape, payload, ctx);\n    };\n    let fastpass;\n    const isObject = util.isObject;\n    const jit = !core.globalConfig.jitless;\n    const allowsEval = util.allowsEval;\n    const fastEnabled = jit && allowsEval.value; // && !def.catchall;\n    const catchall = def.catchall;\n    let value;\n    inst._zod.parse = (payload, ctx) => {\n        value ?? (value = _normalized.value);\n        const input = payload.value;\n        if (!isObject(input)) {\n            payload.issues.push({\n                expected: \"object\",\n                code: \"invalid_type\",\n                input,\n                inst,\n            });\n            return payload;\n        }\n        if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {\n            // always synchronous\n            if (!fastpass)\n                fastpass = generateFastpass(def.shape);\n            payload = fastpass(payload, ctx);\n            if (!catchall)\n                return payload;\n            return handleCatchall([], input, payload, ctx, value, inst);\n        }\n        return superParse(payload, ctx);\n    };\n});\nfunction handleUnionResults(results, final, inst, ctx) {\n    for (const result of results) {\n        if (result.issues.length === 0) {\n            final.value = result.value;\n            return final;\n        }\n    }\n    const nonaborted = results.filter((r) => !util.aborted(r));\n    if (nonaborted.length === 1) {\n        final.value = nonaborted[0].value;\n        return nonaborted[0];\n    }\n    final.issues.push({\n        code: \"invalid_union\",\n        input: final.value,\n        inst,\n        errors: results.map((result) => result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))),\n    });\n    return final;\n}\nexport const $ZodUnion = /*@__PURE__*/ core.$constructor(\"$ZodUnion\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"optin\", () => def.options.some((o) => o._zod.optin === \"optional\") ? \"optional\" : undefined);\n    util.defineLazy(inst._zod, \"optout\", () => def.options.some((o) => o._zod.optout === \"optional\") ? \"optional\" : undefined);\n    util.defineLazy(inst._zod, \"values\", () => {\n        if (def.options.every((o) => o._zod.values)) {\n            return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));\n        }\n        return undefined;\n    });\n    util.defineLazy(inst._zod, \"pattern\", () => {\n        if (def.options.every((o) => o._zod.pattern)) {\n            const patterns = def.options.map((o) => o._zod.pattern);\n            return new RegExp(`^(${patterns.map((p) => util.cleanRegex(p.source)).join(\"|\")})$`);\n        }\n        return undefined;\n    });\n    const single = def.options.length === 1;\n    const first = def.options[0]._zod.run;\n    inst._zod.parse = (payload, ctx) => {\n        if (single) {\n            return first(payload, ctx);\n        }\n        let async = false;\n        const results = [];\n        for (const option of def.options) {\n            const result = option._zod.run({\n                value: payload.value,\n                issues: [],\n            }, ctx);\n            if (result instanceof Promise) {\n                results.push(result);\n                async = true;\n            }\n            else {\n                if (result.issues.length === 0)\n                    return result;\n                results.push(result);\n            }\n        }\n        if (!async)\n            return handleUnionResults(results, payload, inst, ctx);\n        return Promise.all(results).then((results) => {\n            return handleUnionResults(results, payload, inst, ctx);\n        });\n    };\n});\nfunction handleExclusiveUnionResults(results, final, inst, ctx) {\n    const successes = results.filter((r) => r.issues.length === 0);\n    if (successes.length === 1) {\n        final.value = successes[0].value;\n        return final;\n    }\n    if (successes.length === 0) {\n        // No matches - same as regular union\n        final.issues.push({\n            code: \"invalid_union\",\n            input: final.value,\n            inst,\n            errors: results.map((result) => result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))),\n        });\n    }\n    else {\n        // Multiple matches - exclusive union failure\n        final.issues.push({\n            code: \"invalid_union\",\n            input: final.value,\n            inst,\n            errors: [],\n            inclusive: false,\n        });\n    }\n    return final;\n}\nexport const $ZodXor = /*@__PURE__*/ core.$constructor(\"$ZodXor\", (inst, def) => {\n    $ZodUnion.init(inst, def);\n    def.inclusive = false;\n    const single = def.options.length === 1;\n    const first = def.options[0]._zod.run;\n    inst._zod.parse = (payload, ctx) => {\n        if (single) {\n            return first(payload, ctx);\n        }\n        let async = false;\n        const results = [];\n        for (const option of def.options) {\n            const result = option._zod.run({\n                value: payload.value,\n                issues: [],\n            }, ctx);\n            if (result instanceof Promise) {\n                results.push(result);\n                async = true;\n            }\n            else {\n                results.push(result);\n            }\n        }\n        if (!async)\n            return handleExclusiveUnionResults(results, payload, inst, ctx);\n        return Promise.all(results).then((results) => {\n            return handleExclusiveUnionResults(results, payload, inst, ctx);\n        });\n    };\n});\nexport const $ZodDiscriminatedUnion = \n/*@__PURE__*/\ncore.$constructor(\"$ZodDiscriminatedUnion\", (inst, def) => {\n    def.inclusive = false;\n    $ZodUnion.init(inst, def);\n    const _super = inst._zod.parse;\n    util.defineLazy(inst._zod, \"propValues\", () => {\n        const propValues = {};\n        for (const option of def.options) {\n            const pv = option._zod.propValues;\n            if (!pv || Object.keys(pv).length === 0)\n                throw new Error(`Invalid discriminated union option at index \"${def.options.indexOf(option)}\"`);\n            for (const [k, v] of Object.entries(pv)) {\n                if (!propValues[k])\n                    propValues[k] = new Set();\n                for (const val of v) {\n                    propValues[k].add(val);\n                }\n            }\n        }\n        return propValues;\n    });\n    const disc = util.cached(() => {\n        const opts = def.options;\n        const map = new Map();\n        for (const o of opts) {\n            const values = o._zod.propValues?.[def.discriminator];\n            if (!values || values.size === 0)\n                throw new Error(`Invalid discriminated union option at index \"${def.options.indexOf(o)}\"`);\n            for (const v of values) {\n                if (map.has(v)) {\n                    throw new Error(`Duplicate discriminator value \"${String(v)}\"`);\n                }\n                map.set(v, o);\n            }\n        }\n        return map;\n    });\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        if (!util.isObject(input)) {\n            payload.issues.push({\n                code: \"invalid_type\",\n                expected: \"object\",\n                input,\n                inst,\n            });\n            return payload;\n        }\n        const opt = disc.value.get(input?.[def.discriminator]);\n        if (opt) {\n            return opt._zod.run(payload, ctx);\n        }\n        if (def.unionFallback) {\n            return _super(payload, ctx);\n        }\n        // no matching discriminator\n        payload.issues.push({\n            code: \"invalid_union\",\n            errors: [],\n            note: \"No matching discriminator\",\n            discriminator: def.discriminator,\n            input,\n            path: [def.discriminator],\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodIntersection = /*@__PURE__*/ core.$constructor(\"$ZodIntersection\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        const left = def.left._zod.run({ value: input, issues: [] }, ctx);\n        const right = def.right._zod.run({ value: input, issues: [] }, ctx);\n        const async = left instanceof Promise || right instanceof Promise;\n        if (async) {\n            return Promise.all([left, right]).then(([left, right]) => {\n                return handleIntersectionResults(payload, left, right);\n            });\n        }\n        return handleIntersectionResults(payload, left, right);\n    };\n});\nfunction mergeValues(a, b) {\n    // const aType = parse.t(a);\n    // const bType = parse.t(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    if (a instanceof Date && b instanceof Date && +a === +b) {\n        return { valid: true, data: a };\n    }\n    if (util.isPlainObject(a) && util.isPlainObject(b)) {\n        const bKeys = Object.keys(b);\n        const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return {\n                    valid: false,\n                    mergeErrorPath: [key, ...sharedValue.mergeErrorPath],\n                };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return { valid: false, mergeErrorPath: [] };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return {\n                    valid: false,\n                    mergeErrorPath: [index, ...sharedValue.mergeErrorPath],\n                };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    return { valid: false, mergeErrorPath: [] };\n}\nfunction handleIntersectionResults(result, left, right) {\n    // Track which side(s) report each key as unrecognized\n    const unrecKeys = new Map();\n    let unrecIssue;\n    for (const iss of left.issues) {\n        if (iss.code === \"unrecognized_keys\") {\n            unrecIssue ?? (unrecIssue = iss);\n            for (const k of iss.keys) {\n                if (!unrecKeys.has(k))\n                    unrecKeys.set(k, {});\n                unrecKeys.get(k).l = true;\n            }\n        }\n        else {\n            result.issues.push(iss);\n        }\n    }\n    for (const iss of right.issues) {\n        if (iss.code === \"unrecognized_keys\") {\n            for (const k of iss.keys) {\n                if (!unrecKeys.has(k))\n                    unrecKeys.set(k, {});\n                unrecKeys.get(k).r = true;\n            }\n        }\n        else {\n            result.issues.push(iss);\n        }\n    }\n    // Report only keys unrecognized by BOTH sides\n    const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);\n    if (bothKeys.length && unrecIssue) {\n        result.issues.push({ ...unrecIssue, keys: bothKeys });\n    }\n    if (util.aborted(result))\n        return result;\n    const merged = mergeValues(left.value, right.value);\n    if (!merged.valid) {\n        throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);\n    }\n    result.value = merged.data;\n    return result;\n}\nexport const $ZodTuple = /*@__PURE__*/ core.$constructor(\"$ZodTuple\", (inst, def) => {\n    $ZodType.init(inst, def);\n    const items = def.items;\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        if (!Array.isArray(input)) {\n            payload.issues.push({\n                input,\n                inst,\n                expected: \"tuple\",\n                code: \"invalid_type\",\n            });\n            return payload;\n        }\n        payload.value = [];\n        const proms = [];\n        const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== \"optional\");\n        const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;\n        if (!def.rest) {\n            const tooBig = input.length > items.length;\n            const tooSmall = input.length < optStart - 1;\n            if (tooBig || tooSmall) {\n                payload.issues.push({\n                    ...(tooBig\n                        ? { code: \"too_big\", maximum: items.length, inclusive: true }\n                        : { code: \"too_small\", minimum: items.length }),\n                    input,\n                    inst,\n                    origin: \"array\",\n                });\n                return payload;\n            }\n        }\n        let i = -1;\n        for (const item of items) {\n            i++;\n            if (i >= input.length)\n                if (i >= optStart)\n                    continue;\n            const result = item._zod.run({\n                value: input[i],\n                issues: [],\n            }, ctx);\n            if (result instanceof Promise) {\n                proms.push(result.then((result) => handleTupleResult(result, payload, i)));\n            }\n            else {\n                handleTupleResult(result, payload, i);\n            }\n        }\n        if (def.rest) {\n            const rest = input.slice(items.length);\n            for (const el of rest) {\n                i++;\n                const result = def.rest._zod.run({\n                    value: el,\n                    issues: [],\n                }, ctx);\n                if (result instanceof Promise) {\n                    proms.push(result.then((result) => handleTupleResult(result, payload, i)));\n                }\n                else {\n                    handleTupleResult(result, payload, i);\n                }\n            }\n        }\n        if (proms.length)\n            return Promise.all(proms).then(() => payload);\n        return payload;\n    };\n});\nfunction handleTupleResult(result, final, index) {\n    if (result.issues.length) {\n        final.issues.push(...util.prefixIssues(index, result.issues));\n    }\n    final.value[index] = result.value;\n}\nexport const $ZodRecord = /*@__PURE__*/ core.$constructor(\"$ZodRecord\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        if (!util.isPlainObject(input)) {\n            payload.issues.push({\n                expected: \"record\",\n                code: \"invalid_type\",\n                input,\n                inst,\n            });\n            return payload;\n        }\n        const proms = [];\n        const values = def.keyType._zod.values;\n        if (values) {\n            payload.value = {};\n            const recordKeys = new Set();\n            for (const key of values) {\n                if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"symbol\") {\n                    recordKeys.add(typeof key === \"number\" ? key.toString() : key);\n                    const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);\n                    if (result instanceof Promise) {\n                        proms.push(result.then((result) => {\n                            if (result.issues.length) {\n                                payload.issues.push(...util.prefixIssues(key, result.issues));\n                            }\n                            payload.value[key] = result.value;\n                        }));\n                    }\n                    else {\n                        if (result.issues.length) {\n                            payload.issues.push(...util.prefixIssues(key, result.issues));\n                        }\n                        payload.value[key] = result.value;\n                    }\n                }\n            }\n            let unrecognized;\n            for (const key in input) {\n                if (!recordKeys.has(key)) {\n                    unrecognized = unrecognized ?? [];\n                    unrecognized.push(key);\n                }\n            }\n            if (unrecognized && unrecognized.length > 0) {\n                payload.issues.push({\n                    code: \"unrecognized_keys\",\n                    input,\n                    inst,\n                    keys: unrecognized,\n                });\n            }\n        }\n        else {\n            payload.value = {};\n            for (const key of Reflect.ownKeys(input)) {\n                if (key === \"__proto__\")\n                    continue;\n                let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);\n                if (keyResult instanceof Promise) {\n                    throw new Error(\"Async schemas not supported in object keys currently\");\n                }\n                // Numeric string fallback: if key failed with \"expected number\", retry with Number(key)\n                const checkNumericKey = typeof key === \"string\" &&\n                    regexes.number.test(key) &&\n                    keyResult.issues.length &&\n                    keyResult.issues.some((iss) => iss.code === \"invalid_type\" && iss.expected === \"number\");\n                if (checkNumericKey) {\n                    const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);\n                    if (retryResult instanceof Promise) {\n                        throw new Error(\"Async schemas not supported in object keys currently\");\n                    }\n                    if (retryResult.issues.length === 0) {\n                        keyResult = retryResult;\n                    }\n                }\n                if (keyResult.issues.length) {\n                    if (def.mode === \"loose\") {\n                        // Pass through unchanged\n                        payload.value[key] = input[key];\n                    }\n                    else {\n                        // Default \"strict\" behavior: error on invalid key\n                        payload.issues.push({\n                            code: \"invalid_key\",\n                            origin: \"record\",\n                            issues: keyResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n                            input: key,\n                            path: [key],\n                            inst,\n                        });\n                    }\n                    continue;\n                }\n                const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);\n                if (result instanceof Promise) {\n                    proms.push(result.then((result) => {\n                        if (result.issues.length) {\n                            payload.issues.push(...util.prefixIssues(key, result.issues));\n                        }\n                        payload.value[keyResult.value] = result.value;\n                    }));\n                }\n                else {\n                    if (result.issues.length) {\n                        payload.issues.push(...util.prefixIssues(key, result.issues));\n                    }\n                    payload.value[keyResult.value] = result.value;\n                }\n            }\n        }\n        if (proms.length) {\n            return Promise.all(proms).then(() => payload);\n        }\n        return payload;\n    };\n});\nexport const $ZodMap = /*@__PURE__*/ core.$constructor(\"$ZodMap\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        if (!(input instanceof Map)) {\n            payload.issues.push({\n                expected: \"map\",\n                code: \"invalid_type\",\n                input,\n                inst,\n            });\n            return payload;\n        }\n        const proms = [];\n        payload.value = new Map();\n        for (const [key, value] of input) {\n            const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);\n            const valueResult = def.valueType._zod.run({ value: value, issues: [] }, ctx);\n            if (keyResult instanceof Promise || valueResult instanceof Promise) {\n                proms.push(Promise.all([keyResult, valueResult]).then(([keyResult, valueResult]) => {\n                    handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);\n                }));\n            }\n            else {\n                handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);\n            }\n        }\n        if (proms.length)\n            return Promise.all(proms).then(() => payload);\n        return payload;\n    };\n});\nfunction handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {\n    if (keyResult.issues.length) {\n        if (util.propertyKeyTypes.has(typeof key)) {\n            final.issues.push(...util.prefixIssues(key, keyResult.issues));\n        }\n        else {\n            final.issues.push({\n                code: \"invalid_key\",\n                origin: \"map\",\n                input,\n                inst,\n                issues: keyResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n            });\n        }\n    }\n    if (valueResult.issues.length) {\n        if (util.propertyKeyTypes.has(typeof key)) {\n            final.issues.push(...util.prefixIssues(key, valueResult.issues));\n        }\n        else {\n            final.issues.push({\n                origin: \"map\",\n                code: \"invalid_element\",\n                input,\n                inst,\n                key: key,\n                issues: valueResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n            });\n        }\n    }\n    final.value.set(keyResult.value, valueResult.value);\n}\nexport const $ZodSet = /*@__PURE__*/ core.$constructor(\"$ZodSet\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        if (!(input instanceof Set)) {\n            payload.issues.push({\n                input,\n                inst,\n                expected: \"set\",\n                code: \"invalid_type\",\n            });\n            return payload;\n        }\n        const proms = [];\n        payload.value = new Set();\n        for (const item of input) {\n            const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);\n            if (result instanceof Promise) {\n                proms.push(result.then((result) => handleSetResult(result, payload)));\n            }\n            else\n                handleSetResult(result, payload);\n        }\n        if (proms.length)\n            return Promise.all(proms).then(() => payload);\n        return payload;\n    };\n});\nfunction handleSetResult(result, final) {\n    if (result.issues.length) {\n        final.issues.push(...result.issues);\n    }\n    final.value.add(result.value);\n}\nexport const $ZodEnum = /*@__PURE__*/ core.$constructor(\"$ZodEnum\", (inst, def) => {\n    $ZodType.init(inst, def);\n    const values = util.getEnumValues(def.entries);\n    const valuesSet = new Set(values);\n    inst._zod.values = valuesSet;\n    inst._zod.pattern = new RegExp(`^(${values\n        .filter((k) => util.propertyKeyTypes.has(typeof k))\n        .map((o) => (typeof o === \"string\" ? util.escapeRegex(o) : o.toString()))\n        .join(\"|\")})$`);\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        if (valuesSet.has(input)) {\n            return payload;\n        }\n        payload.issues.push({\n            code: \"invalid_value\",\n            values,\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodLiteral = /*@__PURE__*/ core.$constructor(\"$ZodLiteral\", (inst, def) => {\n    $ZodType.init(inst, def);\n    if (def.values.length === 0) {\n        throw new Error(\"Cannot create literal schema with no valid values\");\n    }\n    const values = new Set(def.values);\n    inst._zod.values = values;\n    inst._zod.pattern = new RegExp(`^(${def.values\n        .map((o) => (typeof o === \"string\" ? util.escapeRegex(o) : o ? util.escapeRegex(o.toString()) : String(o)))\n        .join(\"|\")})$`);\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        if (values.has(input)) {\n            return payload;\n        }\n        payload.issues.push({\n            code: \"invalid_value\",\n            values: def.values,\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodFile = /*@__PURE__*/ core.$constructor(\"$ZodFile\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        // @ts-ignore\n        if (input instanceof File)\n            return payload;\n        payload.issues.push({\n            expected: \"file\",\n            code: \"invalid_type\",\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodTransform = /*@__PURE__*/ core.$constructor(\"$ZodTransform\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            throw new core.$ZodEncodeError(inst.constructor.name);\n        }\n        const _out = def.transform(payload.value, payload);\n        if (ctx.async) {\n            const output = _out instanceof Promise ? _out : Promise.resolve(_out);\n            return output.then((output) => {\n                payload.value = output;\n                return payload;\n            });\n        }\n        if (_out instanceof Promise) {\n            throw new core.$ZodAsyncError();\n        }\n        payload.value = _out;\n        return payload;\n    };\n});\nfunction handleOptionalResult(result, input) {\n    if (result.issues.length && input === undefined) {\n        return { issues: [], value: undefined };\n    }\n    return result;\n}\nexport const $ZodOptional = /*@__PURE__*/ core.$constructor(\"$ZodOptional\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.optin = \"optional\";\n    inst._zod.optout = \"optional\";\n    util.defineLazy(inst._zod, \"values\", () => {\n        return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;\n    });\n    util.defineLazy(inst._zod, \"pattern\", () => {\n        const pattern = def.innerType._zod.pattern;\n        return pattern ? new RegExp(`^(${util.cleanRegex(pattern.source)})?$`) : undefined;\n    });\n    inst._zod.parse = (payload, ctx) => {\n        if (def.innerType._zod.optin === \"optional\") {\n            const result = def.innerType._zod.run(payload, ctx);\n            if (result instanceof Promise)\n                return result.then((r) => handleOptionalResult(r, payload.value));\n            return handleOptionalResult(result, payload.value);\n        }\n        if (payload.value === undefined) {\n            return payload;\n        }\n        return def.innerType._zod.run(payload, ctx);\n    };\n});\nexport const $ZodExactOptional = /*@__PURE__*/ core.$constructor(\"$ZodExactOptional\", (inst, def) => {\n    // Call parent init - inherits optin/optout = \"optional\"\n    $ZodOptional.init(inst, def);\n    // Override values/pattern to NOT add undefined\n    util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n    util.defineLazy(inst._zod, \"pattern\", () => def.innerType._zod.pattern);\n    // Override parse to just delegate (no undefined handling)\n    inst._zod.parse = (payload, ctx) => {\n        return def.innerType._zod.run(payload, ctx);\n    };\n});\nexport const $ZodNullable = /*@__PURE__*/ core.$constructor(\"$ZodNullable\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n    util.defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n    util.defineLazy(inst._zod, \"pattern\", () => {\n        const pattern = def.innerType._zod.pattern;\n        return pattern ? new RegExp(`^(${util.cleanRegex(pattern.source)}|null)$`) : undefined;\n    });\n    util.defineLazy(inst._zod, \"values\", () => {\n        return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;\n    });\n    inst._zod.parse = (payload, ctx) => {\n        // Forward direction (decode): allow null to pass through\n        if (payload.value === null)\n            return payload;\n        return def.innerType._zod.run(payload, ctx);\n    };\n});\nexport const $ZodDefault = /*@__PURE__*/ core.$constructor(\"$ZodDefault\", (inst, def) => {\n    $ZodType.init(inst, def);\n    // inst._zod.qin = \"true\";\n    inst._zod.optin = \"optional\";\n    util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            return def.innerType._zod.run(payload, ctx);\n        }\n        // Forward direction (decode): apply defaults for undefined input\n        if (payload.value === undefined) {\n            payload.value = def.defaultValue;\n            /**\n             * $ZodDefault returns the default value immediately in forward direction.\n             * It doesn't pass the default value into the validator (\"prefault\"). There's no reason to pass the default value through validation. The validity of the default is enforced by TypeScript statically. Otherwise, it's the responsibility of the user to ensure the default is valid. In the case of pipes with divergent in/out types, you can specify the default on the `in` schema of your ZodPipe to set a \"prefault\" for the pipe.   */\n            return payload;\n        }\n        // Forward direction: continue with default handling\n        const result = def.innerType._zod.run(payload, ctx);\n        if (result instanceof Promise) {\n            return result.then((result) => handleDefaultResult(result, def));\n        }\n        return handleDefaultResult(result, def);\n    };\n});\nfunction handleDefaultResult(payload, def) {\n    if (payload.value === undefined) {\n        payload.value = def.defaultValue;\n    }\n    return payload;\n}\nexport const $ZodPrefault = /*@__PURE__*/ core.$constructor(\"$ZodPrefault\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.optin = \"optional\";\n    util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            return def.innerType._zod.run(payload, ctx);\n        }\n        // Forward direction (decode): apply prefault for undefined input\n        if (payload.value === undefined) {\n            payload.value = def.defaultValue;\n        }\n        return def.innerType._zod.run(payload, ctx);\n    };\n});\nexport const $ZodNonOptional = /*@__PURE__*/ core.$constructor(\"$ZodNonOptional\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"values\", () => {\n        const v = def.innerType._zod.values;\n        return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;\n    });\n    inst._zod.parse = (payload, ctx) => {\n        const result = def.innerType._zod.run(payload, ctx);\n        if (result instanceof Promise) {\n            return result.then((result) => handleNonOptionalResult(result, inst));\n        }\n        return handleNonOptionalResult(result, inst);\n    };\n});\nfunction handleNonOptionalResult(payload, inst) {\n    if (!payload.issues.length && payload.value === undefined) {\n        payload.issues.push({\n            code: \"invalid_type\",\n            expected: \"nonoptional\",\n            input: payload.value,\n            inst,\n        });\n    }\n    return payload;\n}\nexport const $ZodSuccess = /*@__PURE__*/ core.$constructor(\"$ZodSuccess\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            throw new core.$ZodEncodeError(\"ZodSuccess\");\n        }\n        const result = def.innerType._zod.run(payload, ctx);\n        if (result instanceof Promise) {\n            return result.then((result) => {\n                payload.value = result.issues.length === 0;\n                return payload;\n            });\n        }\n        payload.value = result.issues.length === 0;\n        return payload;\n    };\n});\nexport const $ZodCatch = /*@__PURE__*/ core.$constructor(\"$ZodCatch\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n    util.defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n    util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            return def.innerType._zod.run(payload, ctx);\n        }\n        // Forward direction (decode): apply catch logic\n        const result = def.innerType._zod.run(payload, ctx);\n        if (result instanceof Promise) {\n            return result.then((result) => {\n                payload.value = result.value;\n                if (result.issues.length) {\n                    payload.value = def.catchValue({\n                        ...payload,\n                        error: {\n                            issues: result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n                        },\n                        input: payload.value,\n                    });\n                    payload.issues = [];\n                }\n                return payload;\n            });\n        }\n        payload.value = result.value;\n        if (result.issues.length) {\n            payload.value = def.catchValue({\n                ...payload,\n                error: {\n                    issues: result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n                },\n                input: payload.value,\n            });\n            payload.issues = [];\n        }\n        return payload;\n    };\n});\nexport const $ZodNaN = /*@__PURE__*/ core.$constructor(\"$ZodNaN\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n        if (typeof payload.value !== \"number\" || !Number.isNaN(payload.value)) {\n            payload.issues.push({\n                input: payload.value,\n                inst,\n                expected: \"nan\",\n                code: \"invalid_type\",\n            });\n            return payload;\n        }\n        return payload;\n    };\n});\nexport const $ZodPipe = /*@__PURE__*/ core.$constructor(\"$ZodPipe\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"values\", () => def.in._zod.values);\n    util.defineLazy(inst._zod, \"optin\", () => def.in._zod.optin);\n    util.defineLazy(inst._zod, \"optout\", () => def.out._zod.optout);\n    util.defineLazy(inst._zod, \"propValues\", () => def.in._zod.propValues);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            const right = def.out._zod.run(payload, ctx);\n            if (right instanceof Promise) {\n                return right.then((right) => handlePipeResult(right, def.in, ctx));\n            }\n            return handlePipeResult(right, def.in, ctx);\n        }\n        const left = def.in._zod.run(payload, ctx);\n        if (left instanceof Promise) {\n            return left.then((left) => handlePipeResult(left, def.out, ctx));\n        }\n        return handlePipeResult(left, def.out, ctx);\n    };\n});\nfunction handlePipeResult(left, next, ctx) {\n    if (left.issues.length) {\n        // prevent further checks\n        left.aborted = true;\n        return left;\n    }\n    return next._zod.run({ value: left.value, issues: left.issues }, ctx);\n}\nexport const $ZodCodec = /*@__PURE__*/ core.$constructor(\"$ZodCodec\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"values\", () => def.in._zod.values);\n    util.defineLazy(inst._zod, \"optin\", () => def.in._zod.optin);\n    util.defineLazy(inst._zod, \"optout\", () => def.out._zod.optout);\n    util.defineLazy(inst._zod, \"propValues\", () => def.in._zod.propValues);\n    inst._zod.parse = (payload, ctx) => {\n        const direction = ctx.direction || \"forward\";\n        if (direction === \"forward\") {\n            const left = def.in._zod.run(payload, ctx);\n            if (left instanceof Promise) {\n                return left.then((left) => handleCodecAResult(left, def, ctx));\n            }\n            return handleCodecAResult(left, def, ctx);\n        }\n        else {\n            const right = def.out._zod.run(payload, ctx);\n            if (right instanceof Promise) {\n                return right.then((right) => handleCodecAResult(right, def, ctx));\n            }\n            return handleCodecAResult(right, def, ctx);\n        }\n    };\n});\nfunction handleCodecAResult(result, def, ctx) {\n    if (result.issues.length) {\n        // prevent further checks\n        result.aborted = true;\n        return result;\n    }\n    const direction = ctx.direction || \"forward\";\n    if (direction === \"forward\") {\n        const transformed = def.transform(result.value, result);\n        if (transformed instanceof Promise) {\n            return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));\n        }\n        return handleCodecTxResult(result, transformed, def.out, ctx);\n    }\n    else {\n        const transformed = def.reverseTransform(result.value, result);\n        if (transformed instanceof Promise) {\n            return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));\n        }\n        return handleCodecTxResult(result, transformed, def.in, ctx);\n    }\n}\nfunction handleCodecTxResult(left, value, nextSchema, ctx) {\n    // Check if transform added any issues\n    if (left.issues.length) {\n        left.aborted = true;\n        return left;\n    }\n    return nextSchema._zod.run({ value, issues: left.issues }, ctx);\n}\nexport const $ZodReadonly = /*@__PURE__*/ core.$constructor(\"$ZodReadonly\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"propValues\", () => def.innerType._zod.propValues);\n    util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n    util.defineLazy(inst._zod, \"optin\", () => def.innerType?._zod?.optin);\n    util.defineLazy(inst._zod, \"optout\", () => def.innerType?._zod?.optout);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            return def.innerType._zod.run(payload, ctx);\n        }\n        const result = def.innerType._zod.run(payload, ctx);\n        if (result instanceof Promise) {\n            return result.then(handleReadonlyResult);\n        }\n        return handleReadonlyResult(result);\n    };\n});\nfunction handleReadonlyResult(payload) {\n    payload.value = Object.freeze(payload.value);\n    return payload;\n}\nexport const $ZodTemplateLiteral = /*@__PURE__*/ core.$constructor(\"$ZodTemplateLiteral\", (inst, def) => {\n    $ZodType.init(inst, def);\n    const regexParts = [];\n    for (const part of def.parts) {\n        if (typeof part === \"object\" && part !== null) {\n            // is Zod schema\n            if (!part._zod.pattern) {\n                // if (!source)\n                throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);\n            }\n            const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;\n            if (!source)\n                throw new Error(`Invalid template literal part: ${part._zod.traits}`);\n            const start = source.startsWith(\"^\") ? 1 : 0;\n            const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n            regexParts.push(source.slice(start, end));\n        }\n        else if (part === null || util.primitiveTypes.has(typeof part)) {\n            regexParts.push(util.escapeRegex(`${part}`));\n        }\n        else {\n            throw new Error(`Invalid template literal part: ${part}`);\n        }\n    }\n    inst._zod.pattern = new RegExp(`^${regexParts.join(\"\")}$`);\n    inst._zod.parse = (payload, _ctx) => {\n        if (typeof payload.value !== \"string\") {\n            payload.issues.push({\n                input: payload.value,\n                inst,\n                expected: \"string\",\n                code: \"invalid_type\",\n            });\n            return payload;\n        }\n        inst._zod.pattern.lastIndex = 0;\n        if (!inst._zod.pattern.test(payload.value)) {\n            payload.issues.push({\n                input: payload.value,\n                inst,\n                code: \"invalid_format\",\n                format: def.format ?? \"template_literal\",\n                pattern: inst._zod.pattern.source,\n            });\n            return payload;\n        }\n        return payload;\n    };\n});\nexport const $ZodFunction = /*@__PURE__*/ core.$constructor(\"$ZodFunction\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._def = def;\n    inst._zod.def = def;\n    inst.implement = (func) => {\n        if (typeof func !== \"function\") {\n            throw new Error(\"implement() must be called with a function\");\n        }\n        return function (...args) {\n            const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;\n            const result = Reflect.apply(func, this, parsedArgs);\n            if (inst._def.output) {\n                return parse(inst._def.output, result);\n            }\n            return result;\n        };\n    };\n    inst.implementAsync = (func) => {\n        if (typeof func !== \"function\") {\n            throw new Error(\"implementAsync() must be called with a function\");\n        }\n        return async function (...args) {\n            const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;\n            const result = await Reflect.apply(func, this, parsedArgs);\n            if (inst._def.output) {\n                return await parseAsync(inst._def.output, result);\n            }\n            return result;\n        };\n    };\n    inst._zod.parse = (payload, _ctx) => {\n        if (typeof payload.value !== \"function\") {\n            payload.issues.push({\n                code: \"invalid_type\",\n                expected: \"function\",\n                input: payload.value,\n                inst,\n            });\n            return payload;\n        }\n        // Check if output is a promise type to determine if we should use async implementation\n        const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === \"promise\";\n        if (hasPromiseOutput) {\n            payload.value = inst.implementAsync(payload.value);\n        }\n        else {\n            payload.value = inst.implement(payload.value);\n        }\n        return payload;\n    };\n    inst.input = (...args) => {\n        const F = inst.constructor;\n        if (Array.isArray(args[0])) {\n            return new F({\n                type: \"function\",\n                input: new $ZodTuple({\n                    type: \"tuple\",\n                    items: args[0],\n                    rest: args[1],\n                }),\n                output: inst._def.output,\n            });\n        }\n        return new F({\n            type: \"function\",\n            input: args[0],\n            output: inst._def.output,\n        });\n    };\n    inst.output = (output) => {\n        const F = inst.constructor;\n        return new F({\n            type: \"function\",\n            input: inst._def.input,\n            output,\n        });\n    };\n    return inst;\n});\nexport const $ZodPromise = /*@__PURE__*/ core.$constructor(\"$ZodPromise\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));\n    };\n});\nexport const $ZodLazy = /*@__PURE__*/ core.$constructor(\"$ZodLazy\", (inst, def) => {\n    $ZodType.init(inst, def);\n    // let _innerType!: any;\n    // util.defineLazy(def, \"getter\", () => {\n    //   if (!_innerType) {\n    //     _innerType = def.getter();\n    //   }\n    //   return () => _innerType;\n    // });\n    util.defineLazy(inst._zod, \"innerType\", () => def.getter());\n    util.defineLazy(inst._zod, \"pattern\", () => inst._zod.innerType?._zod?.pattern);\n    util.defineLazy(inst._zod, \"propValues\", () => inst._zod.innerType?._zod?.propValues);\n    util.defineLazy(inst._zod, \"optin\", () => inst._zod.innerType?._zod?.optin ?? undefined);\n    util.defineLazy(inst._zod, \"optout\", () => inst._zod.innerType?._zod?.optout ?? undefined);\n    inst._zod.parse = (payload, ctx) => {\n        const inner = inst._zod.innerType;\n        return inner._zod.run(payload, ctx);\n    };\n});\nexport const $ZodCustom = /*@__PURE__*/ core.$constructor(\"$ZodCustom\", (inst, def) => {\n    checks.$ZodCheck.init(inst, def);\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _) => {\n        return payload;\n    };\n    inst._zod.check = (payload) => {\n        const input = payload.value;\n        const r = def.fn(input);\n        if (r instanceof Promise) {\n            return r.then((r) => handleRefineResult(r, payload, input, inst));\n        }\n        handleRefineResult(r, payload, input, inst);\n        return;\n    };\n});\nfunction handleRefineResult(result, payload, input, inst) {\n    if (!result) {\n        const _iss = {\n            code: \"custom\",\n            input,\n            inst, // incorporates params.error into issue reporting\n            path: [...(inst._zod.def.path ?? [])], // incorporates params.error into issue reporting\n            continue: !inst._zod.def.abort,\n            // params: inst._zod.def.params,\n        };\n        if (inst._zod.def.params)\n            _iss.params = inst._zod.def.params;\n        payload.issues.push(util.issue(_iss));\n    }\n}\n","import { globalRegistry } from \"./registries.js\";\n// function initializeContext<T extends schemas.$ZodType>(inputs: JSONSchemaGeneratorParams<T>): ToJSONSchemaContext<T> {\n//   return {\n//     processor: inputs.processor,\n//     metadataRegistry: inputs.metadata ?? globalRegistry,\n//     target: inputs.target ?? \"draft-2020-12\",\n//     unrepresentable: inputs.unrepresentable ?? \"throw\",\n//   };\n// }\nexport function initializeContext(params) {\n    // Normalize target: convert old non-hyphenated versions to hyphenated versions\n    let target = params?.target ?? \"draft-2020-12\";\n    if (target === \"draft-4\")\n        target = \"draft-04\";\n    if (target === \"draft-7\")\n        target = \"draft-07\";\n    return {\n        processors: params.processors ?? {},\n        metadataRegistry: params?.metadata ?? globalRegistry,\n        target,\n        unrepresentable: params?.unrepresentable ?? \"throw\",\n        override: params?.override ?? (() => { }),\n        io: params?.io ?? \"output\",\n        counter: 0,\n        seen: new Map(),\n        cycles: params?.cycles ?? \"ref\",\n        reused: params?.reused ?? \"inline\",\n        external: params?.external ?? undefined,\n    };\n}\nexport function process(schema, ctx, _params = { path: [], schemaPath: [] }) {\n    var _a;\n    const def = schema._zod.def;\n    // check for schema in seens\n    const seen = ctx.seen.get(schema);\n    if (seen) {\n        seen.count++;\n        // check if cycle\n        const isCycle = _params.schemaPath.includes(schema);\n        if (isCycle) {\n            seen.cycle = _params.path;\n        }\n        return seen.schema;\n    }\n    // initialize\n    const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };\n    ctx.seen.set(schema, result);\n    // custom method overrides default behavior\n    const overrideSchema = schema._zod.toJSONSchema?.();\n    if (overrideSchema) {\n        result.schema = overrideSchema;\n    }\n    else {\n        const params = {\n            ..._params,\n            schemaPath: [..._params.schemaPath, schema],\n            path: _params.path,\n        };\n        if (schema._zod.processJSONSchema) {\n            schema._zod.processJSONSchema(ctx, result.schema, params);\n        }\n        else {\n            const _json = result.schema;\n            const processor = ctx.processors[def.type];\n            if (!processor) {\n                throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);\n            }\n            processor(schema, ctx, _json, params);\n        }\n        const parent = schema._zod.parent;\n        if (parent) {\n            // Also set ref if processor didn't (for inheritance)\n            if (!result.ref)\n                result.ref = parent;\n            process(parent, ctx, params);\n            ctx.seen.get(parent).isParent = true;\n        }\n    }\n    // metadata\n    const meta = ctx.metadataRegistry.get(schema);\n    if (meta)\n        Object.assign(result.schema, meta);\n    if (ctx.io === \"input\" && isTransforming(schema)) {\n        // examples/defaults only apply to output type of pipe\n        delete result.schema.examples;\n        delete result.schema.default;\n    }\n    // set prefault as default\n    if (ctx.io === \"input\" && result.schema._prefault)\n        (_a = result.schema).default ?? (_a.default = result.schema._prefault);\n    delete result.schema._prefault;\n    // pulling fresh from ctx.seen in case it was overwritten\n    const _result = ctx.seen.get(schema);\n    return _result.schema;\n}\nexport function extractDefs(ctx, schema\n// params: EmitParams\n) {\n    // iterate over seen map;\n    const root = ctx.seen.get(schema);\n    if (!root)\n        throw new Error(\"Unprocessed schema. This is a bug in Zod.\");\n    // Track ids to detect duplicates across different schemas\n    const idToSchema = new Map();\n    for (const entry of ctx.seen.entries()) {\n        const id = ctx.metadataRegistry.get(entry[0])?.id;\n        if (id) {\n            const existing = idToSchema.get(id);\n            if (existing && existing !== entry[0]) {\n                throw new Error(`Duplicate schema id \"${id}\" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);\n            }\n            idToSchema.set(id, entry[0]);\n        }\n    }\n    // returns a ref to the schema\n    // defId will be empty if the ref points to an external schema (or #)\n    const makeURI = (entry) => {\n        // comparing the seen objects because sometimes\n        // multiple schemas map to the same seen object.\n        // e.g. lazy\n        // external is configured\n        const defsSegment = ctx.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n        if (ctx.external) {\n            const externalId = ctx.external.registry.get(entry[0])?.id; // ?? \"__shared\";// `__schema${ctx.counter++}`;\n            // check if schema is in the external registry\n            const uriGenerator = ctx.external.uri ?? ((id) => id);\n            if (externalId) {\n                return { ref: uriGenerator(externalId) };\n            }\n            // otherwise, add to __shared\n            const id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;\n            entry[1].defId = id; // set defId so it will be reused if needed\n            return { defId: id, ref: `${uriGenerator(\"__shared\")}#/${defsSegment}/${id}` };\n        }\n        if (entry[1] === root) {\n            return { ref: \"#\" };\n        }\n        // self-contained schema\n        const uriPrefix = `#`;\n        const defUriPrefix = `${uriPrefix}/${defsSegment}/`;\n        const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;\n        return { defId, ref: defUriPrefix + defId };\n    };\n    // stored cached version in `def` property\n    // remove all properties, set $ref\n    const extractToDef = (entry) => {\n        // if the schema is already a reference, do not extract it\n        if (entry[1].schema.$ref) {\n            return;\n        }\n        const seen = entry[1];\n        const { ref, defId } = makeURI(entry);\n        seen.def = { ...seen.schema };\n        // defId won't be set if the schema is a reference to an external schema\n        // or if the schema is the root schema\n        if (defId)\n            seen.defId = defId;\n        // wipe away all properties except $ref\n        const schema = seen.schema;\n        for (const key in schema) {\n            delete schema[key];\n        }\n        schema.$ref = ref;\n    };\n    // throw on cycles\n    // break cycles\n    if (ctx.cycles === \"throw\") {\n        for (const entry of ctx.seen.entries()) {\n            const seen = entry[1];\n            if (seen.cycle) {\n                throw new Error(\"Cycle detected: \" +\n                    `#/${seen.cycle?.join(\"/\")}/<root>` +\n                    '\\n\\nSet the `cycles` parameter to `\"ref\"` to resolve cyclical schemas with defs.');\n            }\n        }\n    }\n    // extract schemas into $defs\n    for (const entry of ctx.seen.entries()) {\n        const seen = entry[1];\n        // convert root schema to # $ref\n        if (schema === entry[0]) {\n            extractToDef(entry); // this has special handling for the root schema\n            continue;\n        }\n        // extract schemas that are in the external registry\n        if (ctx.external) {\n            const ext = ctx.external.registry.get(entry[0])?.id;\n            if (schema !== entry[0] && ext) {\n                extractToDef(entry);\n                continue;\n            }\n        }\n        // extract schemas with `id` meta\n        const id = ctx.metadataRegistry.get(entry[0])?.id;\n        if (id) {\n            extractToDef(entry);\n            continue;\n        }\n        // break cycles\n        if (seen.cycle) {\n            // any\n            extractToDef(entry);\n            continue;\n        }\n        // extract reused schemas\n        if (seen.count > 1) {\n            if (ctx.reused === \"ref\") {\n                extractToDef(entry);\n                // biome-ignore lint:\n                continue;\n            }\n        }\n    }\n}\nexport function finalize(ctx, schema) {\n    const root = ctx.seen.get(schema);\n    if (!root)\n        throw new Error(\"Unprocessed schema. This is a bug in Zod.\");\n    // flatten refs - inherit properties from parent schemas\n    const flattenRef = (zodSchema) => {\n        const seen = ctx.seen.get(zodSchema);\n        // already processed\n        if (seen.ref === null)\n            return;\n        const schema = seen.def ?? seen.schema;\n        const _cached = { ...schema };\n        const ref = seen.ref;\n        seen.ref = null; // prevent infinite recursion\n        if (ref) {\n            flattenRef(ref);\n            const refSeen = ctx.seen.get(ref);\n            const refSchema = refSeen.schema;\n            // merge referenced schema into current\n            if (refSchema.$ref && (ctx.target === \"draft-07\" || ctx.target === \"draft-04\" || ctx.target === \"openapi-3.0\")) {\n                // older drafts can't combine $ref with other properties\n                schema.allOf = schema.allOf ?? [];\n                schema.allOf.push(refSchema);\n            }\n            else {\n                Object.assign(schema, refSchema);\n            }\n            // restore child's own properties (child wins)\n            Object.assign(schema, _cached);\n            const isParentRef = zodSchema._zod.parent === ref;\n            // For parent chain, child is a refinement - remove parent-only properties\n            if (isParentRef) {\n                for (const key in schema) {\n                    if (key === \"$ref\" || key === \"allOf\")\n                        continue;\n                    if (!(key in _cached)) {\n                        delete schema[key];\n                    }\n                }\n            }\n            // When ref was extracted to $defs, remove properties that match the definition\n            if (refSchema.$ref) {\n                for (const key in schema) {\n                    if (key === \"$ref\" || key === \"allOf\")\n                        continue;\n                    if (key in refSeen.def && JSON.stringify(schema[key]) === JSON.stringify(refSeen.def[key])) {\n                        delete schema[key];\n                    }\n                }\n            }\n        }\n        // If parent was extracted (has $ref), propagate $ref to this schema\n        // This handles cases like: readonly().meta({id}).describe()\n        // where processor sets ref to innerType but parent should be referenced\n        const parent = zodSchema._zod.parent;\n        if (parent && parent !== ref) {\n            // Ensure parent is processed first so its def has inherited properties\n            flattenRef(parent);\n            const parentSeen = ctx.seen.get(parent);\n            if (parentSeen?.schema.$ref) {\n                schema.$ref = parentSeen.schema.$ref;\n                // De-duplicate with parent's definition\n                if (parentSeen.def) {\n                    for (const key in schema) {\n                        if (key === \"$ref\" || key === \"allOf\")\n                            continue;\n                        if (key in parentSeen.def && JSON.stringify(schema[key]) === JSON.stringify(parentSeen.def[key])) {\n                            delete schema[key];\n                        }\n                    }\n                }\n            }\n        }\n        // execute overrides\n        ctx.override({\n            zodSchema: zodSchema,\n            jsonSchema: schema,\n            path: seen.path ?? [],\n        });\n    };\n    for (const entry of [...ctx.seen.entries()].reverse()) {\n        flattenRef(entry[0]);\n    }\n    const result = {};\n    if (ctx.target === \"draft-2020-12\") {\n        result.$schema = \"https://json-schema.org/draft/2020-12/schema\";\n    }\n    else if (ctx.target === \"draft-07\") {\n        result.$schema = \"http://json-schema.org/draft-07/schema#\";\n    }\n    else if (ctx.target === \"draft-04\") {\n        result.$schema = \"http://json-schema.org/draft-04/schema#\";\n    }\n    else if (ctx.target === \"openapi-3.0\") {\n        // OpenAPI 3.0 schema objects should not include a $schema property\n    }\n    else {\n        // Arbitrary string values are allowed but won't have a $schema property set\n    }\n    if (ctx.external?.uri) {\n        const id = ctx.external.registry.get(schema)?.id;\n        if (!id)\n            throw new Error(\"Schema is missing an `id` property\");\n        result.$id = ctx.external.uri(id);\n    }\n    Object.assign(result, root.def ?? root.schema);\n    // build defs object\n    const defs = ctx.external?.defs ?? {};\n    for (const entry of ctx.seen.entries()) {\n        const seen = entry[1];\n        if (seen.def && seen.defId) {\n            defs[seen.defId] = seen.def;\n        }\n    }\n    // set definitions in result\n    if (ctx.external) {\n    }\n    else {\n        if (Object.keys(defs).length > 0) {\n            if (ctx.target === \"draft-2020-12\") {\n                result.$defs = defs;\n            }\n            else {\n                result.definitions = defs;\n            }\n        }\n    }\n    try {\n        // this \"finalizes\" this schema and ensures all cycles are removed\n        // each call to finalize() is functionally independent\n        // though the seen map is shared\n        const finalized = JSON.parse(JSON.stringify(result));\n        Object.defineProperty(finalized, \"~standard\", {\n            value: {\n                ...schema[\"~standard\"],\n                jsonSchema: {\n                    input: createStandardJSONSchemaMethod(schema, \"input\", ctx.processors),\n                    output: createStandardJSONSchemaMethod(schema, \"output\", ctx.processors),\n                },\n            },\n            enumerable: false,\n            writable: false,\n        });\n        return finalized;\n    }\n    catch (_err) {\n        throw new Error(\"Error converting schema to JSON.\");\n    }\n}\nfunction isTransforming(_schema, _ctx) {\n    const ctx = _ctx ?? { seen: new Set() };\n    if (ctx.seen.has(_schema))\n        return false;\n    ctx.seen.add(_schema);\n    const def = _schema._zod.def;\n    if (def.type === \"transform\")\n        return true;\n    if (def.type === \"array\")\n        return isTransforming(def.element, ctx);\n    if (def.type === \"set\")\n        return isTransforming(def.valueType, ctx);\n    if (def.type === \"lazy\")\n        return isTransforming(def.getter(), ctx);\n    if (def.type === \"promise\" ||\n        def.type === \"optional\" ||\n        def.type === \"nonoptional\" ||\n        def.type === \"nullable\" ||\n        def.type === \"readonly\" ||\n        def.type === \"default\" ||\n        def.type === \"prefault\") {\n        return isTransforming(def.innerType, ctx);\n    }\n    if (def.type === \"intersection\") {\n        return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);\n    }\n    if (def.type === \"record\" || def.type === \"map\") {\n        return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n    }\n    if (def.type === \"pipe\") {\n        return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);\n    }\n    if (def.type === \"object\") {\n        for (const key in def.shape) {\n            if (isTransforming(def.shape[key], ctx))\n                return true;\n        }\n        return false;\n    }\n    if (def.type === \"union\") {\n        for (const option of def.options) {\n            if (isTransforming(option, ctx))\n                return true;\n        }\n        return false;\n    }\n    if (def.type === \"tuple\") {\n        for (const item of def.items) {\n            if (isTransforming(item, ctx))\n                return true;\n        }\n        if (def.rest && isTransforming(def.rest, ctx))\n            return true;\n        return false;\n    }\n    return false;\n}\n/**\n * Creates a toJSONSchema method for a schema instance.\n * This encapsulates the logic of initializing context, processing, extracting defs, and finalizing.\n */\nexport const createToJSONSchemaMethod = (schema, processors = {}) => (params) => {\n    const ctx = initializeContext({ ...params, processors });\n    process(schema, ctx);\n    extractDefs(ctx, schema);\n    return finalize(ctx, schema);\n};\nexport const createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {\n    const { libraryOptions, target } = params ?? {};\n    const ctx = initializeContext({ ...(libraryOptions ?? {}), target, io, processors });\n    process(schema, ctx);\n    extractDefs(ctx, schema);\n    return finalize(ctx, schema);\n};\n","// functions\nexport function assertEqual(val) {\n    return val;\n}\nexport function assertNotEqual(val) {\n    return val;\n}\nexport function assertIs(_arg) { }\nexport function assertNever(_x) {\n    throw new Error(\"Unexpected value in exhaustive check\");\n}\nexport function assert(_) { }\nexport function getEnumValues(entries) {\n    const numericValues = Object.values(entries).filter((v) => typeof v === \"number\");\n    const values = Object.entries(entries)\n        .filter(([k, _]) => numericValues.indexOf(+k) === -1)\n        .map(([_, v]) => v);\n    return values;\n}\nexport function joinValues(array, separator = \"|\") {\n    return array.map((val) => stringifyPrimitive(val)).join(separator);\n}\nexport function jsonStringifyReplacer(_, value) {\n    if (typeof value === \"bigint\")\n        return value.toString();\n    return value;\n}\nexport function cached(getter) {\n    const set = false;\n    return {\n        get value() {\n            if (!set) {\n                const value = getter();\n                Object.defineProperty(this, \"value\", { value });\n                return value;\n            }\n            throw new Error(\"cached value already set\");\n        },\n    };\n}\nexport function nullish(input) {\n    return input === null || input === undefined;\n}\nexport function cleanRegex(source) {\n    const start = source.startsWith(\"^\") ? 1 : 0;\n    const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n    return source.slice(start, end);\n}\nexport function floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepString = step.toString();\n    let stepDecCount = (stepString.split(\".\")[1] || \"\").length;\n    if (stepDecCount === 0 && /\\d?e-\\d?/.test(stepString)) {\n        const match = stepString.match(/\\d?e-(\\d?)/);\n        if (match?.[1]) {\n            stepDecCount = Number.parseInt(match[1]);\n        }\n    }\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / 10 ** decCount;\n}\nconst EVALUATING = Symbol(\"evaluating\");\nexport function defineLazy(object, key, getter) {\n    let value = undefined;\n    Object.defineProperty(object, key, {\n        get() {\n            if (value === EVALUATING) {\n                // Circular reference detected, return undefined to break the cycle\n                return undefined;\n            }\n            if (value === undefined) {\n                value = EVALUATING;\n                value = getter();\n            }\n            return value;\n        },\n        set(v) {\n            Object.defineProperty(object, key, {\n                value: v,\n                // configurable: true,\n            });\n            // object[key] = v;\n        },\n        configurable: true,\n    });\n}\nexport function objectClone(obj) {\n    return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));\n}\nexport function assignProp(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true,\n    });\n}\nexport function mergeDefs(...defs) {\n    const mergedDescriptors = {};\n    for (const def of defs) {\n        const descriptors = Object.getOwnPropertyDescriptors(def);\n        Object.assign(mergedDescriptors, descriptors);\n    }\n    return Object.defineProperties({}, mergedDescriptors);\n}\nexport function cloneDef(schema) {\n    return mergeDefs(schema._zod.def);\n}\nexport function getElementAtPath(obj, path) {\n    if (!path)\n        return obj;\n    return path.reduce((acc, key) => acc?.[key], obj);\n}\nexport function promiseAllObject(promisesObj) {\n    const keys = Object.keys(promisesObj);\n    const promises = keys.map((key) => promisesObj[key]);\n    return Promise.all(promises).then((results) => {\n        const resolvedObj = {};\n        for (let i = 0; i < keys.length; i++) {\n            resolvedObj[keys[i]] = results[i];\n        }\n        return resolvedObj;\n    });\n}\nexport function randomString(length = 10) {\n    const chars = \"abcdefghijklmnopqrstuvwxyz\";\n    let str = \"\";\n    for (let i = 0; i < length; i++) {\n        str += chars[Math.floor(Math.random() * chars.length)];\n    }\n    return str;\n}\nexport function esc(str) {\n    return JSON.stringify(str);\n}\nexport function slugify(input) {\n    return input\n        .toLowerCase()\n        .trim()\n        .replace(/[^\\w\\s-]/g, \"\")\n        .replace(/[\\s_-]+/g, \"-\")\n        .replace(/^-+|-+$/g, \"\");\n}\nexport const captureStackTrace = (\"captureStackTrace\" in Error ? Error.captureStackTrace : (..._args) => { });\nexport function isObject(data) {\n    return typeof data === \"object\" && data !== null && !Array.isArray(data);\n}\nexport const allowsEval = cached(() => {\n    // @ts-ignore\n    if (typeof navigator !== \"undefined\" && navigator?.userAgent?.includes(\"Cloudflare\")) {\n        return false;\n    }\n    try {\n        const F = Function;\n        new F(\"\");\n        return true;\n    }\n    catch (_) {\n        return false;\n    }\n});\nexport function isPlainObject(o) {\n    if (isObject(o) === false)\n        return false;\n    // modified constructor\n    const ctor = o.constructor;\n    if (ctor === undefined)\n        return true;\n    if (typeof ctor !== \"function\")\n        return true;\n    // modified prototype\n    const prot = ctor.prototype;\n    if (isObject(prot) === false)\n        return false;\n    // ctor doesn't have static `isPrototypeOf`\n    if (Object.prototype.hasOwnProperty.call(prot, \"isPrototypeOf\") === false) {\n        return false;\n    }\n    return true;\n}\nexport function shallowClone(o) {\n    if (isPlainObject(o))\n        return { ...o };\n    if (Array.isArray(o))\n        return [...o];\n    return o;\n}\nexport function numKeys(data) {\n    let keyCount = 0;\n    for (const key in data) {\n        if (Object.prototype.hasOwnProperty.call(data, key)) {\n            keyCount++;\n        }\n    }\n    return keyCount;\n}\nexport const getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return \"undefined\";\n        case \"string\":\n            return \"string\";\n        case \"number\":\n            return Number.isNaN(data) ? \"nan\" : \"number\";\n        case \"boolean\":\n            return \"boolean\";\n        case \"function\":\n            return \"function\";\n        case \"bigint\":\n            return \"bigint\";\n        case \"symbol\":\n            return \"symbol\";\n        case \"object\":\n            if (Array.isArray(data)) {\n                return \"array\";\n            }\n            if (data === null) {\n                return \"null\";\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return \"promise\";\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return \"map\";\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return \"set\";\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return \"date\";\n            }\n            // @ts-ignore\n            if (typeof File !== \"undefined\" && data instanceof File) {\n                return \"file\";\n            }\n            return \"object\";\n        default:\n            throw new Error(`Unknown data type: ${t}`);\n    }\n};\nexport const propertyKeyTypes = new Set([\"string\", \"number\", \"symbol\"]);\nexport const primitiveTypes = new Set([\"string\", \"number\", \"bigint\", \"boolean\", \"symbol\", \"undefined\"]);\nexport function escapeRegex(str) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n// zod-specific utils\nexport function clone(inst, def, params) {\n    const cl = new inst._zod.constr(def ?? inst._zod.def);\n    if (!def || params?.parent)\n        cl._zod.parent = inst;\n    return cl;\n}\nexport function normalizeParams(_params) {\n    const params = _params;\n    if (!params)\n        return {};\n    if (typeof params === \"string\")\n        return { error: () => params };\n    if (params?.message !== undefined) {\n        if (params?.error !== undefined)\n            throw new Error(\"Cannot specify both `message` and `error` params\");\n        params.error = params.message;\n    }\n    delete params.message;\n    if (typeof params.error === \"string\")\n        return { ...params, error: () => params.error };\n    return params;\n}\nexport function createTransparentProxy(getter) {\n    let target;\n    return new Proxy({}, {\n        get(_, prop, receiver) {\n            target ?? (target = getter());\n            return Reflect.get(target, prop, receiver);\n        },\n        set(_, prop, value, receiver) {\n            target ?? (target = getter());\n            return Reflect.set(target, prop, value, receiver);\n        },\n        has(_, prop) {\n            target ?? (target = getter());\n            return Reflect.has(target, prop);\n        },\n        deleteProperty(_, prop) {\n            target ?? (target = getter());\n            return Reflect.deleteProperty(target, prop);\n        },\n        ownKeys(_) {\n            target ?? (target = getter());\n            return Reflect.ownKeys(target);\n        },\n        getOwnPropertyDescriptor(_, prop) {\n            target ?? (target = getter());\n            return Reflect.getOwnPropertyDescriptor(target, prop);\n        },\n        defineProperty(_, prop, descriptor) {\n            target ?? (target = getter());\n            return Reflect.defineProperty(target, prop, descriptor);\n        },\n    });\n}\nexport function stringifyPrimitive(value) {\n    if (typeof value === \"bigint\")\n        return value.toString() + \"n\";\n    if (typeof value === \"string\")\n        return `\"${value}\"`;\n    return `${value}`;\n}\nexport function optionalKeys(shape) {\n    return Object.keys(shape).filter((k) => {\n        return shape[k]._zod.optin === \"optional\" && shape[k]._zod.optout === \"optional\";\n    });\n}\nexport const NUMBER_FORMAT_RANGES = {\n    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n    int32: [-2147483648, 2147483647],\n    uint32: [0, 4294967295],\n    float32: [-3.4028234663852886e38, 3.4028234663852886e38],\n    float64: [-Number.MAX_VALUE, Number.MAX_VALUE],\n};\nexport const BIGINT_FORMAT_RANGES = {\n    int64: [/* @__PURE__*/ BigInt(\"-9223372036854775808\"), /* @__PURE__*/ BigInt(\"9223372036854775807\")],\n    uint64: [/* @__PURE__*/ BigInt(0), /* @__PURE__*/ BigInt(\"18446744073709551615\")],\n};\nexport function pick(schema, mask) {\n    const currDef = schema._zod.def;\n    const checks = currDef.checks;\n    const hasChecks = checks && checks.length > 0;\n    if (hasChecks) {\n        throw new Error(\".pick() cannot be used on object schemas containing refinements\");\n    }\n    const def = mergeDefs(schema._zod.def, {\n        get shape() {\n            const newShape = {};\n            for (const key in mask) {\n                if (!(key in currDef.shape)) {\n                    throw new Error(`Unrecognized key: \"${key}\"`);\n                }\n                if (!mask[key])\n                    continue;\n                newShape[key] = currDef.shape[key];\n            }\n            assignProp(this, \"shape\", newShape); // self-caching\n            return newShape;\n        },\n        checks: [],\n    });\n    return clone(schema, def);\n}\nexport function omit(schema, mask) {\n    const currDef = schema._zod.def;\n    const checks = currDef.checks;\n    const hasChecks = checks && checks.length > 0;\n    if (hasChecks) {\n        throw new Error(\".omit() cannot be used on object schemas containing refinements\");\n    }\n    const def = mergeDefs(schema._zod.def, {\n        get shape() {\n            const newShape = { ...schema._zod.def.shape };\n            for (const key in mask) {\n                if (!(key in currDef.shape)) {\n                    throw new Error(`Unrecognized key: \"${key}\"`);\n                }\n                if (!mask[key])\n                    continue;\n                delete newShape[key];\n            }\n            assignProp(this, \"shape\", newShape); // self-caching\n            return newShape;\n        },\n        checks: [],\n    });\n    return clone(schema, def);\n}\nexport function extend(schema, shape) {\n    if (!isPlainObject(shape)) {\n        throw new Error(\"Invalid input to extend: expected a plain object\");\n    }\n    const checks = schema._zod.def.checks;\n    const hasChecks = checks && checks.length > 0;\n    if (hasChecks) {\n        // Only throw if new shape overlaps with existing shape\n        // Use getOwnPropertyDescriptor to check key existence without accessing values\n        const existingShape = schema._zod.def.shape;\n        for (const key in shape) {\n            if (Object.getOwnPropertyDescriptor(existingShape, key) !== undefined) {\n                throw new Error(\"Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.\");\n            }\n        }\n    }\n    const def = mergeDefs(schema._zod.def, {\n        get shape() {\n            const _shape = { ...schema._zod.def.shape, ...shape };\n            assignProp(this, \"shape\", _shape); // self-caching\n            return _shape;\n        },\n    });\n    return clone(schema, def);\n}\nexport function safeExtend(schema, shape) {\n    if (!isPlainObject(shape)) {\n        throw new Error(\"Invalid input to safeExtend: expected a plain object\");\n    }\n    const def = mergeDefs(schema._zod.def, {\n        get shape() {\n            const _shape = { ...schema._zod.def.shape, ...shape };\n            assignProp(this, \"shape\", _shape); // self-caching\n            return _shape;\n        },\n    });\n    return clone(schema, def);\n}\nexport function merge(a, b) {\n    const def = mergeDefs(a._zod.def, {\n        get shape() {\n            const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };\n            assignProp(this, \"shape\", _shape); // self-caching\n            return _shape;\n        },\n        get catchall() {\n            return b._zod.def.catchall;\n        },\n        checks: [], // delete existing checks\n    });\n    return clone(a, def);\n}\nexport function partial(Class, schema, mask) {\n    const currDef = schema._zod.def;\n    const checks = currDef.checks;\n    const hasChecks = checks && checks.length > 0;\n    if (hasChecks) {\n        throw new Error(\".partial() cannot be used on object schemas containing refinements\");\n    }\n    const def = mergeDefs(schema._zod.def, {\n        get shape() {\n            const oldShape = schema._zod.def.shape;\n            const shape = { ...oldShape };\n            if (mask) {\n                for (const key in mask) {\n                    if (!(key in oldShape)) {\n                        throw new Error(`Unrecognized key: \"${key}\"`);\n                    }\n                    if (!mask[key])\n                        continue;\n                    // if (oldShape[key]!._zod.optin === \"optional\") continue;\n                    shape[key] = Class\n                        ? new Class({\n                            type: \"optional\",\n                            innerType: oldShape[key],\n                        })\n                        : oldShape[key];\n                }\n            }\n            else {\n                for (const key in oldShape) {\n                    // if (oldShape[key]!._zod.optin === \"optional\") continue;\n                    shape[key] = Class\n                        ? new Class({\n                            type: \"optional\",\n                            innerType: oldShape[key],\n                        })\n                        : oldShape[key];\n                }\n            }\n            assignProp(this, \"shape\", shape); // self-caching\n            return shape;\n        },\n        checks: [],\n    });\n    return clone(schema, def);\n}\nexport function required(Class, schema, mask) {\n    const def = mergeDefs(schema._zod.def, {\n        get shape() {\n            const oldShape = schema._zod.def.shape;\n            const shape = { ...oldShape };\n            if (mask) {\n                for (const key in mask) {\n                    if (!(key in shape)) {\n                        throw new Error(`Unrecognized key: \"${key}\"`);\n                    }\n                    if (!mask[key])\n                        continue;\n                    // overwrite with non-optional\n                    shape[key] = new Class({\n                        type: \"nonoptional\",\n                        innerType: oldShape[key],\n                    });\n                }\n            }\n            else {\n                for (const key in oldShape) {\n                    // overwrite with non-optional\n                    shape[key] = new Class({\n                        type: \"nonoptional\",\n                        innerType: oldShape[key],\n                    });\n                }\n            }\n            assignProp(this, \"shape\", shape); // self-caching\n            return shape;\n        },\n    });\n    return clone(schema, def);\n}\n// invalid_type | too_big | too_small | invalid_format | not_multiple_of | unrecognized_keys | invalid_union | invalid_key | invalid_element | invalid_value | custom\nexport function aborted(x, startIndex = 0) {\n    if (x.aborted === true)\n        return true;\n    for (let i = startIndex; i < x.issues.length; i++) {\n        if (x.issues[i]?.continue !== true) {\n            return true;\n        }\n    }\n    return false;\n}\nexport function prefixIssues(path, issues) {\n    return issues.map((iss) => {\n        var _a;\n        (_a = iss).path ?? (_a.path = []);\n        iss.path.unshift(path);\n        return iss;\n    });\n}\nexport function unwrapMessage(message) {\n    return typeof message === \"string\" ? message : message?.message;\n}\nexport function finalizeIssue(iss, ctx, config) {\n    const full = { ...iss, path: iss.path ?? [] };\n    // for backwards compatibility\n    if (!iss.message) {\n        const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ??\n            unwrapMessage(ctx?.error?.(iss)) ??\n            unwrapMessage(config.customError?.(iss)) ??\n            unwrapMessage(config.localeError?.(iss)) ??\n            \"Invalid input\";\n        full.message = message;\n    }\n    // delete (full as any).def;\n    delete full.inst;\n    delete full.continue;\n    if (!ctx?.reportInput) {\n        delete full.input;\n    }\n    return full;\n}\nexport function getSizableOrigin(input) {\n    if (input instanceof Set)\n        return \"set\";\n    if (input instanceof Map)\n        return \"map\";\n    // @ts-ignore\n    if (input instanceof File)\n        return \"file\";\n    return \"unknown\";\n}\nexport function getLengthableOrigin(input) {\n    if (Array.isArray(input))\n        return \"array\";\n    if (typeof input === \"string\")\n        return \"string\";\n    return \"unknown\";\n}\nexport function parsedType(data) {\n    const t = typeof data;\n    switch (t) {\n        case \"number\": {\n            return Number.isNaN(data) ? \"nan\" : \"number\";\n        }\n        case \"object\": {\n            if (data === null) {\n                return \"null\";\n            }\n            if (Array.isArray(data)) {\n                return \"array\";\n            }\n            const obj = data;\n            if (obj && Object.getPrototypeOf(obj) !== Object.prototype && \"constructor\" in obj && obj.constructor) {\n                return obj.constructor.name;\n            }\n        }\n    }\n    return t;\n}\nexport function issue(...args) {\n    const [iss, input, inst] = args;\n    if (typeof iss === \"string\") {\n        return {\n            message: iss,\n            code: \"custom\",\n            input,\n            inst,\n        };\n    }\n    return { ...iss };\n}\nexport function cleanEnum(obj) {\n    return Object.entries(obj)\n        .filter(([k, _]) => {\n        // return true if NaN, meaning it's not a number, thus a string key\n        return Number.isNaN(Number.parseInt(k, 10));\n    })\n        .map((el) => el[1]);\n}\n// Codec utility functions\nexport function base64ToUint8Array(base64) {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n}\nexport function uint8ArrayToBase64(bytes) {\n    let binaryString = \"\";\n    for (let i = 0; i < bytes.length; i++) {\n        binaryString += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binaryString);\n}\nexport function base64urlToUint8Array(base64url) {\n    const base64 = base64url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const padding = \"=\".repeat((4 - (base64.length % 4)) % 4);\n    return base64ToUint8Array(base64 + padding);\n}\nexport function uint8ArrayToBase64url(bytes) {\n    return uint8ArrayToBase64(bytes).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\nexport function hexToUint8Array(hex) {\n    const cleanHex = hex.replace(/^0x/, \"\");\n    if (cleanHex.length % 2 !== 0) {\n        throw new Error(\"Invalid hex string length\");\n    }\n    const bytes = new Uint8Array(cleanHex.length / 2);\n    for (let i = 0; i < cleanHex.length; i += 2) {\n        bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);\n    }\n    return bytes;\n}\nexport function uint8ArrayToHex(bytes) {\n    return Array.from(bytes)\n        .map((b) => b.toString(16).padStart(2, \"0\"))\n        .join(\"\");\n}\n// instanceof\nexport class Class {\n    constructor(..._args) { }\n}\n","export const version = {\n    major: 4,\n    minor: 3,\n    patch: 5,\n};\n","import z4 from \"./classic/index.js\";\nexport * from \"./classic/index.js\";\nexport default z4;\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \" \" },\n        file: { unit: \"\", verb: \" \" },\n        array: { unit: \"\", verb: \" \" },\n        set: { unit: \"\", verb: \" \" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"\",\n        email: \" \",\n        url: \"\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"   ISO\",\n        date: \"  ISO\",\n        time: \"  ISO\",\n        duration: \"  ISO\",\n        ipv4: \" IPv4\",\n        ipv6: \" IPv6\",\n        cidrv4: \"   IPv4\",\n        cidrv6: \"   IPv6\",\n        base64: \"  base64-encoded\",\n        base64url: \"  base64url-encoded\",\n        json_string: \"   JSON\",\n        e164: \"   E.164\",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `  :   instanceof ${issue.expected}    ${received}`;\n                }\n                return `  :   ${expected}    ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `  :   ${util.stringifyPrimitive(issue.values[0])}`;\n                return `  :     : ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `   :    ${issue.origin ?? \"\"} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n                return `  :    ${issue.origin ?? \"\"} ${adj} ${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `  :   ${issue.origin}   ${adj} ${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `  :   ${issue.origin}   ${adj} ${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `  :     \"${issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `  :     \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `  :    \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `  :     ${_issue.pattern}`;\n                return `${FormatDictionary[_issue.format] ?? issue.format}  `;\n            }\n            case \"not_multiple_of\":\n                return `  :      ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"\" : \"\"} ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \" \")}`;\n            case \"invalid_key\":\n                return `    ${issue.origin}`;\n            case \"invalid_union\":\n                return \"  \";\n            case \"invalid_element\":\n                return `    ${issue.origin}`;\n            default:\n                return \"  \";\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"simvol\", verb: \"olmaldr\" },\n        file: { unit: \"bayt\", verb: \"olmaldr\" },\n        array: { unit: \"element\", verb: \"olmaldr\" },\n        set: { unit: \"element\", verb: \"olmaldr\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"input\",\n        email: \"email address\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO datetime\",\n        date: \"ISO date\",\n        time: \"ISO time\",\n        duration: \"ISO duration\",\n        ipv4: \"IPv4 address\",\n        ipv6: \"IPv6 address\",\n        cidrv4: \"IPv4 range\",\n        cidrv6: \"IPv6 range\",\n        base64: \"base64-encoded string\",\n        base64url: \"base64url-encoded string\",\n        json_string: \"JSON string\",\n        e164: \"E.164 number\",\n        jwt: \"JWT\",\n        template_literal: \"input\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Yanl dyr: gzlniln instanceof ${issue.expected}, daxil olan ${received}`;\n                }\n                return `Yanl dyr: gzlniln ${expected}, daxil olan ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Yanl dyr: gzlniln ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Yanl seim: aadaklardan biri olmaldr: ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `ox byk: gzlniln ${issue.origin ?? \"dyr\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"element\"}`;\n                return `ox byk: gzlniln ${issue.origin ?? \"dyr\"} ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `ox kiik: gzlniln ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                return `ox kiik: gzlniln ${issue.origin} ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Yanl mtn: \"${_issue.prefix}\" il balamaldr`;\n                if (_issue.format === \"ends_with\")\n                    return `Yanl mtn: \"${_issue.suffix}\" il bitmlidir`;\n                if (_issue.format === \"includes\")\n                    return `Yanl mtn: \"${_issue.includes}\" daxil olmaldr`;\n                if (_issue.format === \"regex\")\n                    return `Yanl mtn: ${_issue.pattern} ablonuna uyun olmaldr`;\n                return `Yanl ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Yanl dd: ${issue.divisor} il bln biln olmaldr`;\n            case \"unrecognized_keys\":\n                return `Tannmayan aar${issue.keys.length > 1 ? \"lar\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `${issue.origin} daxilind yanl aar`;\n            case \"invalid_union\":\n                return \"Yanl dyr\";\n            case \"invalid_element\":\n                return `${issue.origin} daxilind yanl dyr`;\n            default:\n                return `Yanl dyr`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nfunction getBelarusianPlural(count, one, few, many) {\n    const absCount = Math.abs(count);\n    const lastDigit = absCount % 10;\n    const lastTwoDigits = absCount % 100;\n    if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {\n        return many;\n    }\n    if (lastDigit === 1) {\n        return one;\n    }\n    if (lastDigit >= 2 && lastDigit <= 4) {\n        return few;\n    }\n    return many;\n}\nconst error = () => {\n    const Sizable = {\n        string: {\n            unit: {\n                one: \"\",\n                few: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n        array: {\n            unit: {\n                one: \"\",\n                few: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n        set: {\n            unit: {\n                one: \"\",\n                few: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n        file: {\n            unit: {\n                one: \"\",\n                few: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"\",\n        email: \"email \",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO   \",\n        date: \"ISO \",\n        time: \"ISO \",\n        duration: \"ISO \",\n        ipv4: \"IPv4 \",\n        ipv6: \"IPv6 \",\n        cidrv4: \"IPv4 \",\n        cidrv6: \"IPv6 \",\n        base64: \"   base64\",\n        base64url: \"   base64url\",\n        json_string: \"JSON \",\n        e164: \" E.164\",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"\",\n        array: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return ` :  instanceof ${issue.expected},  ${received}`;\n                }\n                return ` :  ${expected},  ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return ` :  ${util.stringifyPrimitive(issue.values[0])}`;\n                return ` :    ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    const maxValue = Number(issue.maximum);\n                    const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n                    return ` : ,  ${issue.origin ?? \"\"}  ${sizing.verb} ${adj}${issue.maximum.toString()} ${unit}`;\n                }\n                return ` : ,  ${issue.origin ?? \"\"}   ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    const minValue = Number(issue.minimum);\n                    const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n                    return ` : ,  ${issue.origin}  ${sizing.verb} ${adj}${issue.minimum.toString()} ${unit}`;\n                }\n                return ` : ,  ${issue.origin}   ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return ` :    \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return ` :    \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return ` :   \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return ` :    ${_issue.pattern}`;\n                return ` ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` :    ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return ` ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `   ${issue.origin}`;\n            case \"invalid_union\":\n                return \" \";\n            case \"invalid_element\":\n                return `   ${issue.origin}`;\n            default:\n                return ` `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \" \" },\n        file: { unit: \"\", verb: \" \" },\n        array: { unit: \"\", verb: \" \" },\n        set: { unit: \"\", verb: \" \" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"\",\n        email: \" \",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO \",\n        date: \"ISO \",\n        time: \"ISO \",\n        duration: \"ISO \",\n        ipv4: \"IPv4 \",\n        ipv6: \"IPv6 \",\n        cidrv4: \"IPv4 \",\n        cidrv6: \"IPv6 \",\n        base64: \"base64- \",\n        base64url: \"base64url- \",\n        json_string: \"JSON \",\n        e164: \"E.164 \",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"\",\n        array: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return ` :  instanceof ${issue.expected},  ${received}`;\n                }\n                return ` :  ${expected},  ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return ` :  ${util.stringifyPrimitive(issue.values[0])}`;\n                return ` :    ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return ` :   ${issue.origin ?? \"\"}   ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n                return ` :   ${issue.origin ?? \"\"}   ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` :   ${issue.origin}   ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return ` :   ${issue.origin}   ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return ` :     \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return ` :     \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return ` :    \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return ` :     ${_issue.pattern}`;\n                let invalid_adj = \"\";\n                if (_issue.format === \"emoji\")\n                    invalid_adj = \"\";\n                if (_issue.format === \"datetime\")\n                    invalid_adj = \"\";\n                if (_issue.format === \"date\")\n                    invalid_adj = \"\";\n                if (_issue.format === \"time\")\n                    invalid_adj = \"\";\n                if (_issue.format === \"duration\")\n                    invalid_adj = \"\";\n                return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` :      ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"\" : \"\"} ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `   ${issue.origin}`;\n            case \"invalid_union\":\n                return \" \";\n            case \"invalid_element\":\n                return `   ${issue.origin}`;\n            default:\n                return ` `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"carcters\", verb: \"contenir\" },\n        file: { unit: \"bytes\", verb: \"contenir\" },\n        array: { unit: \"elements\", verb: \"contenir\" },\n        set: { unit: \"elements\", verb: \"contenir\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"entrada\",\n        email: \"adrea electrnica\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"data i hora ISO\",\n        date: \"data ISO\",\n        time: \"hora ISO\",\n        duration: \"durada ISO\",\n        ipv4: \"adrea IPv4\",\n        ipv6: \"adrea IPv6\",\n        cidrv4: \"rang IPv4\",\n        cidrv6: \"rang IPv6\",\n        base64: \"cadena codificada en base64\",\n        base64url: \"cadena codificada en base64url\",\n        json_string: \"cadena JSON\",\n        e164: \"nmero E.164\",\n        jwt: \"JWT\",\n        template_literal: \"entrada\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Tipus invlid: s'esperava instanceof ${issue.expected}, s'ha rebut ${received}`;\n                }\n                return `Tipus invlid: s'esperava ${expected}, s'ha rebut ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Valor invlid: s'esperava ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Opci invlida: s'esperava una de ${util.joinValues(issue.values, \" o \")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"com a mxim\" : \"menys de\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Massa gran: s'esperava que ${issue.origin ?? \"el valor\"} contingus ${adj} ${issue.maximum.toString()} ${sizing.unit ?? \"elements\"}`;\n                return `Massa gran: s'esperava que ${issue.origin ?? \"el valor\"} fos ${adj} ${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \"com a mnim\" : \"ms de\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Massa petit: s'esperava que ${issue.origin} contingus ${adj} ${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Massa petit: s'esperava que ${issue.origin} fos ${adj} ${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `Format invlid: ha de comenar amb \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `Format invlid: ha d'acabar amb \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Format invlid: ha d'incloure \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Format invlid: ha de coincidir amb el patr ${_issue.pattern}`;\n                return `Format invlid per a ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Nmero invlid: ha de ser mltiple de ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Clau${issue.keys.length > 1 ? \"s\" : \"\"} no reconeguda${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Clau invlida a ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Entrada invlida\"; // Could also be \"Tipus d'uni invlid\" but \"Entrada invlida\" is more general\n            case \"invalid_element\":\n                return `Element invlid a ${issue.origin}`;\n            default:\n                return `Entrada invlida`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"znak\", verb: \"mt\" },\n        file: { unit: \"bajt\", verb: \"mt\" },\n        array: { unit: \"prvk\", verb: \"mt\" },\n        set: { unit: \"prvk\", verb: \"mt\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"regulrn vraz\",\n        email: \"e-mailov adresa\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"datum a as ve formtu ISO\",\n        date: \"datum ve formtu ISO\",\n        time: \"as ve formtu ISO\",\n        duration: \"doba trvn ISO\",\n        ipv4: \"IPv4 adresa\",\n        ipv6: \"IPv6 adresa\",\n        cidrv4: \"rozsah IPv4\",\n        cidrv6: \"rozsah IPv6\",\n        base64: \"etzec zakdovan ve formtu base64\",\n        base64url: \"etzec zakdovan ve formtu base64url\",\n        json_string: \"etzec ve formtu JSON\",\n        e164: \"slo E.164\",\n        jwt: \"JWT\",\n        template_literal: \"vstup\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"slo\",\n        string: \"etzec\",\n        function: \"funkce\",\n        array: \"pole\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Neplatn vstup: oekvno instanceof ${issue.expected}, obdreno ${received}`;\n                }\n                return `Neplatn vstup: oekvno ${expected}, obdreno ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Neplatn vstup: oekvno ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Neplatn monost: oekvna jedna z hodnot ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Hodnota je pli velk: ${issue.origin ?? \"hodnota\"} mus mt ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"prvk\"}`;\n                }\n                return `Hodnota je pli velk: ${issue.origin ?? \"hodnota\"} mus bt ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Hodnota je pli mal: ${issue.origin ?? \"hodnota\"} mus mt ${adj}${issue.minimum.toString()} ${sizing.unit ?? \"prvk\"}`;\n                }\n                return `Hodnota je pli mal: ${issue.origin ?? \"hodnota\"} mus bt ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Neplatn etzec: mus zanat na \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Neplatn etzec: mus konit na \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Neplatn etzec: mus obsahovat \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Neplatn etzec: mus odpovdat vzoru ${_issue.pattern}`;\n                return `Neplatn formt ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Neplatn slo: mus bt nsobkem ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Neznm kle: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Neplatn kl v ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Neplatn vstup\";\n            case \"invalid_element\":\n                return `Neplatn hodnota v ${issue.origin}`;\n            default:\n                return `Neplatn vstup`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"tegn\", verb: \"havde\" },\n        file: { unit: \"bytes\", verb: \"havde\" },\n        array: { unit: \"elementer\", verb: \"indeholdt\" },\n        set: { unit: \"elementer\", verb: \"indeholdt\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"input\",\n        email: \"e-mailadresse\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO dato- og klokkeslt\",\n        date: \"ISO-dato\",\n        time: \"ISO-klokkeslt\",\n        duration: \"ISO-varighed\",\n        ipv4: \"IPv4-omrde\",\n        ipv6: \"IPv6-omrde\",\n        cidrv4: \"IPv4-spektrum\",\n        cidrv6: \"IPv6-spektrum\",\n        base64: \"base64-kodet streng\",\n        base64url: \"base64url-kodet streng\",\n        json_string: \"JSON-streng\",\n        e164: \"E.164-nummer\",\n        jwt: \"JWT\",\n        template_literal: \"input\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        string: \"streng\",\n        number: \"tal\",\n        boolean: \"boolean\",\n        array: \"liste\",\n        object: \"objekt\",\n        set: \"st\",\n        file: \"fil\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Ugyldigt input: forventede instanceof ${issue.expected}, fik ${received}`;\n                }\n                return `Ugyldigt input: forventede ${expected}, fik ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Ugyldig vrdi: forventede ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Ugyldigt valg: forventede en af flgende ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                const origin = TypeDictionary[issue.origin] ?? issue.origin;\n                if (sizing)\n                    return `For stor: forventede ${origin ?? \"value\"} ${sizing.verb} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? \"elementer\"}`;\n                return `For stor: forventede ${origin ?? \"value\"} havde ${adj} ${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                const origin = TypeDictionary[issue.origin] ?? issue.origin;\n                if (sizing) {\n                    return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `For lille: forventede ${origin} havde ${adj} ${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Ugyldig streng: skal starte med \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Ugyldig streng: skal ende med \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Ugyldig streng: skal indeholde \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Ugyldig streng: skal matche mnsteret ${_issue.pattern}`;\n                return `Ugyldig ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Ugyldigt tal: skal vre deleligt med ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"Ukendte ngler\" : \"Ukendt ngle\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Ugyldig ngle i ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Ugyldigt input: matcher ingen af de tilladte typer\";\n            case \"invalid_element\":\n                return `Ugyldig vrdi i ${issue.origin}`;\n            default:\n                return `Ugyldigt input`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"Zeichen\", verb: \"zu haben\" },\n        file: { unit: \"Bytes\", verb: \"zu haben\" },\n        array: { unit: \"Elemente\", verb: \"zu haben\" },\n        set: { unit: \"Elemente\", verb: \"zu haben\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"Eingabe\",\n        email: \"E-Mail-Adresse\",\n        url: \"URL\",\n        emoji: \"Emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO-Datum und -Uhrzeit\",\n        date: \"ISO-Datum\",\n        time: \"ISO-Uhrzeit\",\n        duration: \"ISO-Dauer\",\n        ipv4: \"IPv4-Adresse\",\n        ipv6: \"IPv6-Adresse\",\n        cidrv4: \"IPv4-Bereich\",\n        cidrv6: \"IPv6-Bereich\",\n        base64: \"Base64-codierter String\",\n        base64url: \"Base64-URL-codierter String\",\n        json_string: \"JSON-String\",\n        e164: \"E.164-Nummer\",\n        jwt: \"JWT\",\n        template_literal: \"Eingabe\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"Zahl\",\n        array: \"Array\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Ungltige Eingabe: erwartet instanceof ${issue.expected}, erhalten ${received}`;\n                }\n                return `Ungltige Eingabe: erwartet ${expected}, erhalten ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Ungltige Eingabe: erwartet ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Ungltige Option: erwartet eine von ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Zu gro: erwartet, dass ${issue.origin ?? \"Wert\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"Elemente\"} hat`;\n                return `Zu gro: erwartet, dass ${issue.origin ?? \"Wert\"} ${adj}${issue.maximum.toString()} ist`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Zu klein: erwartet, dass ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} hat`;\n                }\n                return `Zu klein: erwartet, dass ${issue.origin} ${adj}${issue.minimum.toString()} ist`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Ungltiger String: muss mit \"${_issue.prefix}\" beginnen`;\n                if (_issue.format === \"ends_with\")\n                    return `Ungltiger String: muss mit \"${_issue.suffix}\" enden`;\n                if (_issue.format === \"includes\")\n                    return `Ungltiger String: muss \"${_issue.includes}\" enthalten`;\n                if (_issue.format === \"regex\")\n                    return `Ungltiger String: muss dem Muster ${_issue.pattern} entsprechen`;\n                return `Ungltig: ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Ungltige Zahl: muss ein Vielfaches von ${issue.divisor} sein`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"Unbekannte Schlssel\" : \"Unbekannter Schlssel\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Ungltiger Schlssel in ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Ungltige Eingabe\";\n            case \"invalid_element\":\n                return `Ungltiger Wert in ${issue.origin}`;\n            default:\n                return `Ungltige Eingabe`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"characters\", verb: \"to have\" },\n        file: { unit: \"bytes\", verb: \"to have\" },\n        array: { unit: \"items\", verb: \"to have\" },\n        set: { unit: \"items\", verb: \"to have\" },\n        map: { unit: \"entries\", verb: \"to have\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"input\",\n        email: \"email address\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO datetime\",\n        date: \"ISO date\",\n        time: \"ISO time\",\n        duration: \"ISO duration\",\n        ipv4: \"IPv4 address\",\n        ipv6: \"IPv6 address\",\n        mac: \"MAC address\",\n        cidrv4: \"IPv4 range\",\n        cidrv6: \"IPv6 range\",\n        base64: \"base64-encoded string\",\n        base64url: \"base64url-encoded string\",\n        json_string: \"JSON string\",\n        e164: \"E.164 number\",\n        jwt: \"JWT\",\n        template_literal: \"input\",\n    };\n    // type names: missing keys = do not translate (use raw value via ?? fallback)\n    const TypeDictionary = {\n        // Compatibility: \"nan\" -> \"NaN\" for display\n        nan: \"NaN\",\n        // All other type names omitted - they fall back to raw values via ?? operator\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                return `Invalid input: expected ${expected}, received ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Invalid input: expected ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Invalid option: expected one of ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Too big: expected ${issue.origin ?? \"value\"} to have ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elements\"}`;\n                return `Too big: expected ${issue.origin ?? \"value\"} to be ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Too small: expected ${issue.origin} to have ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Too small: expected ${issue.origin} to be ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `Invalid string: must start with \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `Invalid string: must end with \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Invalid string: must include \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Invalid string: must match pattern ${_issue.pattern}`;\n                return `Invalid ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Invalid number: must be a multiple of ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Unrecognized key${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Invalid key in ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Invalid input\";\n            case \"invalid_element\":\n                return `Invalid value in ${issue.origin}`;\n            default:\n                return `Invalid input`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"karaktrojn\", verb: \"havi\" },\n        file: { unit: \"bajtojn\", verb: \"havi\" },\n        array: { unit: \"elementojn\", verb: \"havi\" },\n        set: { unit: \"elementojn\", verb: \"havi\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"enigo\",\n        email: \"retadreso\",\n        url: \"URL\",\n        emoji: \"emoio\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO-datotempo\",\n        date: \"ISO-dato\",\n        time: \"ISO-tempo\",\n        duration: \"ISO-daro\",\n        ipv4: \"IPv4-adreso\",\n        ipv6: \"IPv6-adreso\",\n        cidrv4: \"IPv4-rango\",\n        cidrv6: \"IPv6-rango\",\n        base64: \"64-ume kodita karaktraro\",\n        base64url: \"URL-64-ume kodita karaktraro\",\n        json_string: \"JSON-karaktraro\",\n        e164: \"E.164-nombro\",\n        jwt: \"JWT\",\n        template_literal: \"enigo\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"nombro\",\n        array: \"tabelo\",\n        null: \"senvalora\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Nevalida enigo: atendiis instanceof ${issue.expected}, riceviis ${received}`;\n                }\n                return `Nevalida enigo: atendiis ${expected}, riceviis ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Nevalida enigo: atendiis ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Nevalida opcio: atendiis unu el ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Tro granda: atendiis ke ${issue.origin ?? \"valoro\"} havu ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementojn\"}`;\n                return `Tro granda: atendiis ke ${issue.origin ?? \"valoro\"} havu ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Tro malgranda: atendiis ke ${issue.origin} havu ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Tro malgranda: atendiis ke ${issue.origin} estu ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Nevalida karaktraro: devas komencii per \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Nevalida karaktraro: devas finii per \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Nevalida karaktraro: devas inkluzivi \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;\n                return `Nevalida ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Nevalida nombro: devas esti oblo de ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Nekonata${issue.keys.length > 1 ? \"j\" : \"\"} losilo${issue.keys.length > 1 ? \"j\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Nevalida losilo en ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Nevalida enigo\";\n            case \"invalid_element\":\n                return `Nevalida valoro en ${issue.origin}`;\n            default:\n                return `Nevalida enigo`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"caracteres\", verb: \"tener\" },\n        file: { unit: \"bytes\", verb: \"tener\" },\n        array: { unit: \"elementos\", verb: \"tener\" },\n        set: { unit: \"elementos\", verb: \"tener\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"entrada\",\n        email: \"direccin de correo electrnico\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"fecha y hora ISO\",\n        date: \"fecha ISO\",\n        time: \"hora ISO\",\n        duration: \"duracin ISO\",\n        ipv4: \"direccin IPv4\",\n        ipv6: \"direccin IPv6\",\n        cidrv4: \"rango IPv4\",\n        cidrv6: \"rango IPv6\",\n        base64: \"cadena codificada en base64\",\n        base64url: \"URL codificada en base64\",\n        json_string: \"cadena JSON\",\n        e164: \"nmero E.164\",\n        jwt: \"JWT\",\n        template_literal: \"entrada\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        string: \"texto\",\n        number: \"nmero\",\n        boolean: \"booleano\",\n        array: \"arreglo\",\n        object: \"objeto\",\n        set: \"conjunto\",\n        file: \"archivo\",\n        date: \"fecha\",\n        bigint: \"nmero grande\",\n        symbol: \"smbolo\",\n        undefined: \"indefinido\",\n        null: \"nulo\",\n        function: \"funcin\",\n        map: \"mapa\",\n        record: \"registro\",\n        tuple: \"tupla\",\n        enum: \"enumeracin\",\n        union: \"unin\",\n        literal: \"literal\",\n        promise: \"promesa\",\n        void: \"vaco\",\n        never: \"nunca\",\n        unknown: \"desconocido\",\n        any: \"cualquiera\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Entrada invlida: se esperaba instanceof ${issue.expected}, recibido ${received}`;\n                }\n                return `Entrada invlida: se esperaba ${expected}, recibido ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Entrada invlida: se esperaba ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Opcin invlida: se esperaba una de ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                const origin = TypeDictionary[issue.origin] ?? issue.origin;\n                if (sizing)\n                    return `Demasiado grande: se esperaba que ${origin ?? \"valor\"} tuviera ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementos\"}`;\n                return `Demasiado grande: se esperaba que ${origin ?? \"valor\"} fuera ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                const origin = TypeDictionary[issue.origin] ?? issue.origin;\n                if (sizing) {\n                    return `Demasiado pequeo: se esperaba que ${origin} tuviera ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Demasiado pequeo: se esperaba que ${origin} fuera ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Cadena invlida: debe comenzar con \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Cadena invlida: debe terminar en \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Cadena invlida: debe incluir \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Cadena invlida: debe coincidir con el patrn ${_issue.pattern}`;\n                return `Invlido ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Nmero invlido: debe ser mltiplo de ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Llave${issue.keys.length > 1 ? \"s\" : \"\"} desconocida${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Llave invlida en ${TypeDictionary[issue.origin] ?? issue.origin}`;\n            case \"invalid_union\":\n                return \"Entrada invlida\";\n            case \"invalid_element\":\n                return `Valor invlido en ${TypeDictionary[issue.origin] ?? issue.origin}`;\n            default:\n                return `Entrada invlida`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \" \" },\n        file: { unit: \"\", verb: \" \" },\n        array: { unit: \"\", verb: \" \" },\n        set: { unit: \"\", verb: \" \" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"\",\n        email: \" \",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"   \",\n        date: \" \",\n        time: \" \",\n        duration: \"  \",\n        ipv4: \"IPv4 \",\n        ipv6: \"IPv6 \",\n        cidrv4: \"IPv4 \",\n        cidrv6: \"IPv6 \",\n        base64: \"base64-encoded \",\n        base64url: \"base64url-encoded \",\n        json_string: \"JSON \",\n        e164: \"E.164 \",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"\",\n        array: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return ` :  instanceof ${issue.expected}  ${received}  `;\n                }\n                return ` :  ${expected}  ${received}  `;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1) {\n                    return ` :  ${util.stringifyPrimitive(issue.values[0])} `;\n                }\n                return ` :    ${util.joinValues(issue.values, \"|\")} `;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` : ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"} `;\n                }\n                return ` : ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()} `;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` : ${issue.origin}  ${adj}${issue.minimum.toString()} ${sizing.unit} `;\n                }\n                return ` : ${issue.origin}  ${adj}${issue.minimum.toString()} `;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return ` :   \"${_issue.prefix}\"  `;\n                }\n                if (_issue.format === \"ends_with\") {\n                    return ` :   \"${_issue.suffix}\"  `;\n                }\n                if (_issue.format === \"includes\") {\n                    return ` :   \"${_issue.includes}\" `;\n                }\n                if (_issue.format === \"regex\") {\n                    return ` :    ${_issue.pattern}   `;\n                }\n                return `${FormatDictionary[_issue.format] ?? issue.format} `;\n            }\n            case \"not_multiple_of\":\n                return ` :   ${issue.divisor} `;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"\" : \"\"} : ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `   ${issue.origin}`;\n            case \"invalid_union\":\n                return ` `;\n            case \"invalid_element\":\n                return `   ${issue.origin}`;\n            default:\n                return ` `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"merkki\", subject: \"merkkijonon\" },\n        file: { unit: \"tavua\", subject: \"tiedoston\" },\n        array: { unit: \"alkiota\", subject: \"listan\" },\n        set: { unit: \"alkiota\", subject: \"joukon\" },\n        number: { unit: \"\", subject: \"luvun\" },\n        bigint: { unit: \"\", subject: \"suuren kokonaisluvun\" },\n        int: { unit: \"\", subject: \"kokonaisluvun\" },\n        date: { unit: \"\", subject: \"pivmrn\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"snnllinen lauseke\",\n        email: \"shkpostiosoite\",\n        url: \"URL-osoite\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO-aikaleima\",\n        date: \"ISO-pivmr\",\n        time: \"ISO-aika\",\n        duration: \"ISO-kesto\",\n        ipv4: \"IPv4-osoite\",\n        ipv6: \"IPv6-osoite\",\n        cidrv4: \"IPv4-alue\",\n        cidrv6: \"IPv6-alue\",\n        base64: \"base64-koodattu merkkijono\",\n        base64url: \"base64url-koodattu merkkijono\",\n        json_string: \"JSON-merkkijono\",\n        e164: \"E.164-luku\",\n        jwt: \"JWT\",\n        template_literal: \"templaattimerkkijono\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Virheellinen tyyppi: odotettiin instanceof ${issue.expected}, oli ${received}`;\n                }\n                return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Virheellinen syte: tytyy olla ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Virheellinen valinta: tytyy olla yksi seuraavista: ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Liian suuri: ${sizing.subject} tytyy olla ${adj}${issue.maximum.toString()} ${sizing.unit}`.trim();\n                }\n                return `Liian suuri: arvon tytyy olla ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Liian pieni: ${sizing.subject} tytyy olla ${adj}${issue.minimum.toString()} ${sizing.unit}`.trim();\n                }\n                return `Liian pieni: arvon tytyy olla ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Virheellinen syte: tytyy alkaa \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Virheellinen syte: tytyy loppua \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Virheellinen syte: tytyy sislt \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\") {\n                    return `Virheellinen syte: tytyy vastata snnllist lauseketta ${_issue.pattern}`;\n                }\n                return `Virheellinen ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Virheellinen luku: tytyy olla luvun ${issue.divisor} monikerta`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"Tuntemattomat avaimet\" : \"Tuntematon avain\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return \"Virheellinen avain tietueessa\";\n            case \"invalid_union\":\n                return \"Virheellinen unioni\";\n            case \"invalid_element\":\n                return \"Virheellinen arvo joukossa\";\n            default:\n                return `Virheellinen syte`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"caractres\", verb: \"avoir\" },\n        file: { unit: \"octets\", verb: \"avoir\" },\n        array: { unit: \"lments\", verb: \"avoir\" },\n        set: { unit: \"lments\", verb: \"avoir\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"entre\",\n        email: \"adresse courriel\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"date-heure ISO\",\n        date: \"date ISO\",\n        time: \"heure ISO\",\n        duration: \"dure ISO\",\n        ipv4: \"adresse IPv4\",\n        ipv6: \"adresse IPv6\",\n        cidrv4: \"plage IPv4\",\n        cidrv6: \"plage IPv6\",\n        base64: \"chane encode en base64\",\n        base64url: \"chane encode en base64url\",\n        json_string: \"chane JSON\",\n        e164: \"numro E.164\",\n        jwt: \"JWT\",\n        template_literal: \"entre\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Entre invalide : attendu instanceof ${issue.expected}, reu ${received}`;\n                }\n                return `Entre invalide : attendu ${expected}, reu ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Entre invalide : attendu ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Option invalide : attendu l'une des valeurs suivantes ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Trop grand : attendu que ${issue.origin ?? \"la valeur\"} ait ${adj}${issue.maximum.toString()} ${sizing.unit}`;\n                return `Trop grand : attendu que ${issue.origin ?? \"la valeur\"} soit ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \"\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Trop petit : attendu que ${issue.origin} ait ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Trop petit : attendu que ${issue.origin} soit ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `Chane invalide : doit commencer par \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `Chane invalide : doit se terminer par \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Chane invalide : doit inclure \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Chane invalide : doit correspondre au motif ${_issue.pattern}`;\n                return `${FormatDictionary[_issue.format] ?? issue.format} invalide`;\n            }\n            case \"not_multiple_of\":\n                return `Nombre invalide : doit tre un multiple de ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Cl${issue.keys.length > 1 ? \"s\" : \"\"} non reconnue${issue.keys.length > 1 ? \"s\" : \"\"} : ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Cl invalide dans ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Entre invalide\";\n            case \"invalid_element\":\n                return `Valeur invalide dans ${issue.origin}`;\n            default:\n                return `Entre invalide`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"caractres\", verb: \"avoir\" },\n        file: { unit: \"octets\", verb: \"avoir\" },\n        array: { unit: \"lments\", verb: \"avoir\" },\n        set: { unit: \"lments\", verb: \"avoir\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"entre\",\n        email: \"adresse e-mail\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"date et heure ISO\",\n        date: \"date ISO\",\n        time: \"heure ISO\",\n        duration: \"dure ISO\",\n        ipv4: \"adresse IPv4\",\n        ipv6: \"adresse IPv6\",\n        cidrv4: \"plage IPv4\",\n        cidrv6: \"plage IPv6\",\n        base64: \"chane encode en base64\",\n        base64url: \"chane encode en base64url\",\n        json_string: \"chane JSON\",\n        e164: \"numro E.164\",\n        jwt: \"JWT\",\n        template_literal: \"entre\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"nombre\",\n        array: \"tableau\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Entre invalide : instanceof ${issue.expected} attendu, ${received} reu`;\n                }\n                return `Entre invalide : ${expected} attendu, ${received} reu`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Entre invalide : ${util.stringifyPrimitive(issue.values[0])} attendu`;\n                return `Option invalide : une valeur parmi ${util.joinValues(issue.values, \"|\")} attendue`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Trop grand : ${issue.origin ?? \"valeur\"} doit ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"lment(s)\"}`;\n                return `Trop grand : ${issue.origin ?? \"valeur\"} doit tre ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Trop petit : ${issue.origin} doit ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Trop petit : ${issue.origin} doit tre ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Chane invalide : doit commencer par \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Chane invalide : doit se terminer par \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Chane invalide : doit inclure \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Chane invalide : doit correspondre au modle ${_issue.pattern}`;\n                return `${FormatDictionary[_issue.format] ?? issue.format} invalide`;\n            }\n            case \"not_multiple_of\":\n                return `Nombre invalide : doit tre un multiple de ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Cl${issue.keys.length > 1 ? \"s\" : \"\"} non reconnue${issue.keys.length > 1 ? \"s\" : \"\"} : ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Cl invalide dans ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Entre invalide\";\n            case \"invalid_element\":\n                return `Valeur invalide dans ${issue.origin}`;\n            default:\n                return `Entre invalide`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    // Hebrew labels + grammatical gender\n    const TypeNames = {\n        string: { label: \"\", gender: \"f\" },\n        number: { label: \"\", gender: \"m\" },\n        boolean: { label: \" \", gender: \"m\" },\n        bigint: { label: \"BigInt\", gender: \"m\" },\n        date: { label: \"\", gender: \"m\" },\n        array: { label: \"\", gender: \"m\" },\n        object: { label: \"\", gender: \"m\" },\n        null: { label: \"  (null)\", gender: \"m\" },\n        undefined: { label: \"   (undefined)\", gender: \"m\" },\n        symbol: { label: \" (Symbol)\", gender: \"m\" },\n        function: { label: \"\", gender: \"f\" },\n        map: { label: \" (Map)\", gender: \"f\" },\n        set: { label: \" (Set)\", gender: \"f\" },\n        file: { label: \"\", gender: \"m\" },\n        promise: { label: \"Promise\", gender: \"m\" },\n        NaN: { label: \"NaN\", gender: \"m\" },\n        unknown: { label: \"  \", gender: \"m\" },\n        value: { label: \"\", gender: \"m\" },\n    };\n    // Sizing units for size-related messages + localized origin labels\n    const Sizable = {\n        string: { unit: \"\", shortLabel: \"\", longLabel: \"\" },\n        file: { unit: \"\", shortLabel: \"\", longLabel: \"\" },\n        array: { unit: \"\", shortLabel: \"\", longLabel: \"\" },\n        set: { unit: \"\", shortLabel: \"\", longLabel: \"\" },\n        number: { unit: \"\", shortLabel: \"\", longLabel: \"\" }, // no unit\n    };\n    // Helpers  labels, articles, and verbs\n    const typeEntry = (t) => (t ? TypeNames[t] : undefined);\n    const typeLabel = (t) => {\n        const e = typeEntry(t);\n        if (e)\n            return e.label;\n        // fallback: show raw string if unknown\n        return t ?? TypeNames.unknown.label;\n    };\n    const withDefinite = (t) => `${typeLabel(t)}`;\n    const verbFor = (t) => {\n        const e = typeEntry(t);\n        const gender = e?.gender ?? \"m\";\n        return gender === \"f\" ? \" \" : \" \";\n    };\n    const getSizing = (origin) => {\n        if (!origin)\n            return null;\n        return Sizable[origin] ?? null;\n    };\n    const FormatDictionary = {\n        regex: { label: \"\", gender: \"m\" },\n        email: { label: \" \", gender: \"f\" },\n        url: { label: \" \", gender: \"f\" },\n        emoji: { label: \"'\", gender: \"m\" },\n        uuid: { label: \"UUID\", gender: \"m\" },\n        nanoid: { label: \"nanoid\", gender: \"m\" },\n        guid: { label: \"GUID\", gender: \"m\" },\n        cuid: { label: \"cuid\", gender: \"m\" },\n        cuid2: { label: \"cuid2\", gender: \"m\" },\n        ulid: { label: \"ULID\", gender: \"m\" },\n        xid: { label: \"XID\", gender: \"m\" },\n        ksuid: { label: \"KSUID\", gender: \"m\" },\n        datetime: { label: \"  ISO\", gender: \"m\" },\n        date: { label: \" ISO\", gender: \"m\" },\n        time: { label: \" ISO\", gender: \"m\" },\n        duration: { label: \"  ISO\", gender: \"m\" },\n        ipv4: { label: \" IPv4\", gender: \"f\" },\n        ipv6: { label: \" IPv6\", gender: \"f\" },\n        cidrv4: { label: \" IPv4\", gender: \"m\" },\n        cidrv6: { label: \" IPv6\", gender: \"m\" },\n        base64: { label: \"  64\", gender: \"f\" },\n        base64url: { label: \"  64  \", gender: \"f\" },\n        json_string: { label: \" JSON\", gender: \"f\" },\n        e164: { label: \" E.164\", gender: \"m\" },\n        jwt: { label: \"JWT\", gender: \"m\" },\n        ends_with: { label: \"\", gender: \"m\" },\n        includes: { label: \"\", gender: \"m\" },\n        lowercase: { label: \"\", gender: \"m\" },\n        starts_with: { label: \"\", gender: \"m\" },\n        uppercase: { label: \"\", gender: \"m\" },\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                // Expected type: show without definite article for clearer Hebrew\n                const expectedKey = issue.expected;\n                const expected = TypeDictionary[expectedKey ?? \"\"] ?? typeLabel(expectedKey);\n                // Received: show localized label if known, otherwise constructor/raw\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `  :   instanceof ${issue.expected},  ${received}`;\n                }\n                return `  :   ${expected},  ${received}`;\n            }\n            case \"invalid_value\": {\n                if (issue.values.length === 1) {\n                    return `  :    ${util.stringifyPrimitive(issue.values[0])}`;\n                }\n                // Join values with proper Hebrew formatting\n                const stringified = issue.values.map((v) => util.stringifyPrimitive(v));\n                if (issue.values.length === 2) {\n                    return `  :    ${stringified[0]}  ${stringified[1]}`;\n                }\n                // For 3+ values: \"a\", \"b\"  \"c\"\n                const lastValue = stringified[stringified.length - 1];\n                const restValues = stringified.slice(0, -1).join(\", \");\n                return `  :    ${restValues}  ${lastValue}`;\n            }\n            case \"too_big\": {\n                const sizing = getSizing(issue.origin);\n                const subject = withDefinite(issue.origin ?? \"value\");\n                if (issue.origin === \"string\") {\n                    // Special handling for strings - more natural Hebrew\n                    return `${sizing?.longLabel ?? \"\"} : ${subject}   ${issue.maximum.toString()} ${sizing?.unit ?? \"\"} ${issue.inclusive ? \" \" : \" \"}`.trim();\n                }\n                if (issue.origin === \"number\") {\n                    // Natural Hebrew for numbers\n                    const comparison = issue.inclusive ? `   -${issue.maximum}` : ` -${issue.maximum}`;\n                    return ` : ${subject}   ${comparison}`;\n                }\n                if (issue.origin === \"array\" || issue.origin === \"set\") {\n                    // Natural Hebrew for arrays and sets\n                    const verb = issue.origin === \"set\" ? \"\" : \"\";\n                    const comparison = issue.inclusive\n                        ? `${issue.maximum} ${sizing?.unit ?? \"\"}  `\n                        : ` -${issue.maximum} ${sizing?.unit ?? \"\"}`;\n                    return ` : ${subject} ${verb}  ${comparison}`.trim();\n                }\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const be = verbFor(issue.origin ?? \"value\");\n                if (sizing?.unit) {\n                    return `${sizing.longLabel} : ${subject} ${be} ${adj}${issue.maximum.toString()} ${sizing.unit}`;\n                }\n                return `${sizing?.longLabel ?? \"\"} : ${subject} ${be} ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const sizing = getSizing(issue.origin);\n                const subject = withDefinite(issue.origin ?? \"value\");\n                if (issue.origin === \"string\") {\n                    // Special handling for strings - more natural Hebrew\n                    return `${sizing?.shortLabel ?? \"\"} : ${subject}   ${issue.minimum.toString()} ${sizing?.unit ?? \"\"} ${issue.inclusive ? \" \" : \"\"}`.trim();\n                }\n                if (issue.origin === \"number\") {\n                    // Natural Hebrew for numbers\n                    const comparison = issue.inclusive ? `   -${issue.minimum}` : ` -${issue.minimum}`;\n                    return ` : ${subject}   ${comparison}`;\n                }\n                if (issue.origin === \"array\" || issue.origin === \"set\") {\n                    // Natural Hebrew for arrays and sets\n                    const verb = issue.origin === \"set\" ? \"\" : \"\";\n                    // Special case for singular (minimum === 1)\n                    if (issue.minimum === 1 && issue.inclusive) {\n                        const singularPhrase = issue.origin === \"set\" ? \"  \" : \"  \";\n                        return ` : ${subject} ${verb}  ${singularPhrase}`;\n                    }\n                    const comparison = issue.inclusive\n                        ? `${issue.minimum} ${sizing?.unit ?? \"\"}  `\n                        : ` -${issue.minimum} ${sizing?.unit ?? \"\"}`;\n                    return ` : ${subject} ${verb}  ${comparison}`.trim();\n                }\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const be = verbFor(issue.origin ?? \"value\");\n                if (sizing?.unit) {\n                    return `${sizing.shortLabel} : ${subject} ${be} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `${sizing?.shortLabel ?? \"\"} : ${subject} ${be} ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                // These apply to strings  use feminine grammar +  \n                if (_issue.format === \"starts_with\")\n                    return `    \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `    \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `   \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `    ${_issue.pattern}`;\n                // Handle gender agreement for formats\n                const nounEntry = FormatDictionary[_issue.format];\n                const noun = nounEntry?.label ?? _issue.format;\n                const gender = nounEntry?.gender ?? \"m\";\n                const adjective = gender === \"f\" ? \"\" : \"\";\n                return `${noun}  ${adjective}`;\n            }\n            case \"not_multiple_of\":\n                return `  :     ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"\" : \"\"}  ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\": {\n                return `   `;\n            }\n            case \"invalid_union\":\n                return \"  \";\n            case \"invalid_element\": {\n                const place = withDefinite(issue.origin ?? \"array\");\n                return `   ${place}`;\n            }\n            default:\n                return `  `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"karakter\", verb: \"legyen\" },\n        file: { unit: \"byte\", verb: \"legyen\" },\n        array: { unit: \"elem\", verb: \"legyen\" },\n        set: { unit: \"elem\", verb: \"legyen\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"bemenet\",\n        email: \"email cm\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO idblyeg\",\n        date: \"ISO dtum\",\n        time: \"ISO id\",\n        duration: \"ISO idintervallum\",\n        ipv4: \"IPv4 cm\",\n        ipv6: \"IPv6 cm\",\n        cidrv4: \"IPv4 tartomny\",\n        cidrv6: \"IPv6 tartomny\",\n        base64: \"base64-kdolt string\",\n        base64url: \"base64url-kdolt string\",\n        json_string: \"JSON string\",\n        e164: \"E.164 szm\",\n        jwt: \"JWT\",\n        template_literal: \"bemenet\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"szm\",\n        array: \"tmb\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `rvnytelen bemenet: a vrt rtk instanceof ${issue.expected}, a kapott rtk ${received}`;\n                }\n                return `rvnytelen bemenet: a vrt rtk ${expected}, a kapott rtk ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `rvnytelen bemenet: a vrt rtk ${util.stringifyPrimitive(issue.values[0])}`;\n                return `rvnytelen opci: valamelyik rtk vrt ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Tl nagy: ${issue.origin ?? \"rtk\"} mrete tl nagy ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elem\"}`;\n                return `Tl nagy: a bemeneti rtk ${issue.origin ?? \"rtk\"} tl nagy: ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Tl kicsi: a bemeneti rtk ${issue.origin} mrete tl kicsi ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Tl kicsi: a bemeneti rtk ${issue.origin} tl kicsi ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `rvnytelen string: \"${_issue.prefix}\" rtkkel kell kezddnie`;\n                if (_issue.format === \"ends_with\")\n                    return `rvnytelen string: \"${_issue.suffix}\" rtkkel kell vgzdnie`;\n                if (_issue.format === \"includes\")\n                    return `rvnytelen string: \"${_issue.includes}\" rtket kell tartalmaznia`;\n                if (_issue.format === \"regex\")\n                    return `rvnytelen string: ${_issue.pattern} mintnak kell megfelelnie`;\n                return `rvnytelen ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `rvnytelen szm: ${issue.divisor} tbbszrsnek kell lennie`;\n            case \"unrecognized_keys\":\n                return `Ismeretlen kulcs${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `rvnytelen kulcs ${issue.origin}`;\n            case \"invalid_union\":\n                return \"rvnytelen bemenet\";\n            case \"invalid_element\":\n                return `rvnytelen rtk: ${issue.origin}`;\n            default:\n                return `rvnytelen bemenet`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nfunction getArmenianPlural(count, one, many) {\n    return Math.abs(count) === 1 ? one : many;\n}\nfunction withDefiniteArticle(word) {\n    if (!word)\n        return \"\";\n    const vowels = [\"\", \"\", \"\", \"\", \"\", \"\", \"\"];\n    const lastChar = word[word.length - 1];\n    return word + (vowels.includes(lastChar) ? \"\" : \"\");\n}\nconst error = () => {\n    const Sizable = {\n        string: {\n            unit: {\n                one: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n        file: {\n            unit: {\n                one: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n        array: {\n            unit: {\n                one: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n        set: {\n            unit: {\n                one: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"\",\n        email: \". \",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO   \",\n        date: \"ISO \",\n        time: \"ISO \",\n        duration: \"ISO \",\n        ipv4: \"IPv4 \",\n        ipv6: \"IPv6 \",\n        cidrv4: \"IPv4 \",\n        cidrv6: \"IPv6 \",\n        base64: \"base64  \",\n        base64url: \"base64url  \",\n        json_string: \"JSON \",\n        e164: \"E.164 \",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"\",\n        array: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `    instanceof ${issue.expected},   ${received}`;\n                }\n                return `    ${expected},   ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `    ${util.stringifyPrimitive(issue.values[1])}`;\n                return `      ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    const maxValue = Number(issue.maximum);\n                    const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);\n                    return `    ,  ${withDefiniteArticle(issue.origin ?? \"\")}  ${adj}${issue.maximum.toString()} ${unit}`;\n                }\n                return `    ,  ${withDefiniteArticle(issue.origin ?? \"\")}  ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    const minValue = Number(issue.minimum);\n                    const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);\n                    return `    ,  ${withDefiniteArticle(issue.origin)}  ${adj}${issue.minimum.toString()} ${unit}`;\n                }\n                return `    ,  ${withDefiniteArticle(issue.origin)}  ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `     \"${_issue.prefix}\"-`;\n                if (_issue.format === \"ends_with\")\n                    return `     \"${_issue.suffix}\"-`;\n                if (_issue.format === \"includes\")\n                    return `     \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `     ${_issue.pattern} `;\n                return ` ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `      ${issue.divisor}-`;\n            case \"unrecognized_keys\":\n                return ` ${issue.keys.length > 1 ? \"\" : \"\"}. ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `  ${withDefiniteArticle(issue.origin)}-`;\n            case \"invalid_union\":\n                return \" \";\n            case \"invalid_element\":\n                return `  ${withDefiniteArticle(issue.origin)}-`;\n            default:\n                return ` `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"karakter\", verb: \"memiliki\" },\n        file: { unit: \"byte\", verb: \"memiliki\" },\n        array: { unit: \"item\", verb: \"memiliki\" },\n        set: { unit: \"item\", verb: \"memiliki\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"input\",\n        email: \"alamat email\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"tanggal dan waktu format ISO\",\n        date: \"tanggal format ISO\",\n        time: \"jam format ISO\",\n        duration: \"durasi format ISO\",\n        ipv4: \"alamat IPv4\",\n        ipv6: \"alamat IPv6\",\n        cidrv4: \"rentang alamat IPv4\",\n        cidrv6: \"rentang alamat IPv6\",\n        base64: \"string dengan enkode base64\",\n        base64url: \"string dengan enkode base64url\",\n        json_string: \"string JSON\",\n        e164: \"angka E.164\",\n        jwt: \"JWT\",\n        template_literal: \"input\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Input tidak valid: diharapkan instanceof ${issue.expected}, diterima ${received}`;\n                }\n                return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Input tidak valid: diharapkan ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Pilihan tidak valid: diharapkan salah satu dari ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Terlalu besar: diharapkan ${issue.origin ?? \"value\"} memiliki ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elemen\"}`;\n                return `Terlalu besar: diharapkan ${issue.origin ?? \"value\"} menjadi ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Terlalu kecil: diharapkan ${issue.origin} memiliki ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Terlalu kecil: diharapkan ${issue.origin} menjadi ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `String tidak valid: harus dimulai dengan \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `String tidak valid: harus berakhir dengan \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `String tidak valid: harus menyertakan \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `String tidak valid: harus sesuai pola ${_issue.pattern}`;\n                return `${FormatDictionary[_issue.format] ?? issue.format} tidak valid`;\n            }\n            case \"not_multiple_of\":\n                return `Angka tidak valid: harus kelipatan dari ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Kunci tidak dikenali ${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Kunci tidak valid di ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Input tidak valid\";\n            case \"invalid_element\":\n                return `Nilai tidak valid di ${issue.origin}`;\n            default:\n                return `Input tidak valid`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","export { default as ar } from \"./ar.js\";\nexport { default as az } from \"./az.js\";\nexport { default as be } from \"./be.js\";\nexport { default as bg } from \"./bg.js\";\nexport { default as ca } from \"./ca.js\";\nexport { default as cs } from \"./cs.js\";\nexport { default as da } from \"./da.js\";\nexport { default as de } from \"./de.js\";\nexport { default as en } from \"./en.js\";\nexport { default as eo } from \"./eo.js\";\nexport { default as es } from \"./es.js\";\nexport { default as fa } from \"./fa.js\";\nexport { default as fi } from \"./fi.js\";\nexport { default as fr } from \"./fr.js\";\nexport { default as frCA } from \"./fr-CA.js\";\nexport { default as he } from \"./he.js\";\nexport { default as hu } from \"./hu.js\";\nexport { default as hy } from \"./hy.js\";\nexport { default as id } from \"./id.js\";\nexport { default as is } from \"./is.js\";\nexport { default as it } from \"./it.js\";\nexport { default as ja } from \"./ja.js\";\nexport { default as ka } from \"./ka.js\";\nexport { default as kh } from \"./kh.js\";\nexport { default as km } from \"./km.js\";\nexport { default as ko } from \"./ko.js\";\nexport { default as lt } from \"./lt.js\";\nexport { default as mk } from \"./mk.js\";\nexport { default as ms } from \"./ms.js\";\nexport { default as nl } from \"./nl.js\";\nexport { default as no } from \"./no.js\";\nexport { default as ota } from \"./ota.js\";\nexport { default as ps } from \"./ps.js\";\nexport { default as pl } from \"./pl.js\";\nexport { default as pt } from \"./pt.js\";\nexport { default as ru } from \"./ru.js\";\nexport { default as sl } from \"./sl.js\";\nexport { default as sv } from \"./sv.js\";\nexport { default as ta } from \"./ta.js\";\nexport { default as th } from \"./th.js\";\nexport { default as tr } from \"./tr.js\";\nexport { default as ua } from \"./ua.js\";\nexport { default as uk } from \"./uk.js\";\nexport { default as ur } from \"./ur.js\";\nexport { default as uz } from \"./uz.js\";\nexport { default as vi } from \"./vi.js\";\nexport { default as zhCN } from \"./zh-CN.js\";\nexport { default as zhTW } from \"./zh-TW.js\";\nexport { default as yo } from \"./yo.js\";\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"stafi\", verb: \"a hafa\" },\n        file: { unit: \"bti\", verb: \"a hafa\" },\n        array: { unit: \"hluti\", verb: \"a hafa\" },\n        set: { unit: \"hluti\", verb: \"a hafa\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"gildi\",\n        email: \"netfang\",\n        url: \"vefsl\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO dagsetning og tmi\",\n        date: \"ISO dagsetning\",\n        time: \"ISO tmi\",\n        duration: \"ISO tmalengd\",\n        ipv4: \"IPv4 address\",\n        ipv6: \"IPv6 address\",\n        cidrv4: \"IPv4 range\",\n        cidrv6: \"IPv6 range\",\n        base64: \"base64-encoded strengur\",\n        base64url: \"base64url-encoded strengur\",\n        json_string: \"JSON strengur\",\n        e164: \"E.164 tlugildi\",\n        jwt: \"JWT\",\n        template_literal: \"gildi\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"nmer\",\n        array: \"fylki\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Rangt gildi:  slst inn ${received} ar sem  a vera instanceof ${issue.expected}`;\n                }\n                return `Rangt gildi:  slst inn ${received} ar sem  a vera ${expected}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Rangt gildi: gert r fyrir ${util.stringifyPrimitive(issue.values[0])}`;\n                return `gilt val: m vera eitt af eftirfarandi ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Of strt: gert er r fyrir a ${issue.origin ?? \"gildi\"} hafi ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"hluti\"}`;\n                return `Of strt: gert er r fyrir a ${issue.origin ?? \"gildi\"} s ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Of lti: gert er r fyrir a ${issue.origin} hafi ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Of lti: gert er r fyrir a ${issue.origin} s ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `gildur strengur: verur a byrja  \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `gildur strengur: verur a enda  \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `gildur strengur: verur a innihalda \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `gildur strengur: verur a fylgja mynstri ${_issue.pattern}`;\n                return `Rangt ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Rng tala: verur a vera margfeldi af ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `ekkt ${issue.keys.length > 1 ? \"ir lyklar\" : \"ur lykill\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Rangur lykill  ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Rangt gildi\";\n            case \"invalid_element\":\n                return `Rangt gildi  ${issue.origin}`;\n            default:\n                return `Rangt gildi`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"caratteri\", verb: \"avere\" },\n        file: { unit: \"byte\", verb: \"avere\" },\n        array: { unit: \"elementi\", verb: \"avere\" },\n        set: { unit: \"elementi\", verb: \"avere\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"input\",\n        email: \"indirizzo email\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"data e ora ISO\",\n        date: \"data ISO\",\n        time: \"ora ISO\",\n        duration: \"durata ISO\",\n        ipv4: \"indirizzo IPv4\",\n        ipv6: \"indirizzo IPv6\",\n        cidrv4: \"intervallo IPv4\",\n        cidrv6: \"intervallo IPv6\",\n        base64: \"stringa codificata in base64\",\n        base64url: \"URL codificata in base64\",\n        json_string: \"stringa JSON\",\n        e164: \"numero E.164\",\n        jwt: \"JWT\",\n        template_literal: \"input\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"numero\",\n        array: \"vettore\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Input non valido: atteso instanceof ${issue.expected}, ricevuto ${received}`;\n                }\n                return `Input non valido: atteso ${expected}, ricevuto ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Input non valido: atteso ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Opzione non valida: atteso uno tra ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Troppo grande: ${issue.origin ?? \"valore\"} deve avere ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementi\"}`;\n                return `Troppo grande: ${issue.origin ?? \"valore\"} deve essere ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Troppo piccolo: ${issue.origin} deve avere ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Troppo piccolo: ${issue.origin} deve essere ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Stringa non valida: deve iniziare con \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Stringa non valida: deve terminare con \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Stringa non valida: deve includere \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;\n                return `Invalid ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Numero non valido: deve essere un multiplo di ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Chiav${issue.keys.length > 1 ? \"i\" : \"e\"} non riconosciut${issue.keys.length > 1 ? \"e\" : \"a\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Chiave non valida in ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Input non valido\";\n            case \"invalid_element\":\n                return `Valore non valido in ${issue.origin}`;\n            default:\n                return `Input non valido`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \"\" },\n        file: { unit: \"\", verb: \"\" },\n        array: { unit: \"\", verb: \"\" },\n        set: { unit: \"\", verb: \"\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"\",\n        email: \"\",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO\",\n        date: \"ISO\",\n        time: \"ISO\",\n        duration: \"ISO\",\n        ipv4: \"IPv4\",\n        ipv6: \"IPv6\",\n        cidrv4: \"IPv4\",\n        cidrv6: \"IPv6\",\n        base64: \"base64\",\n        base64url: \"base64url\",\n        json_string: \"JSON\",\n        e164: \"E.164\",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"\",\n        array: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `: instanceof ${issue.expected}${received}`;\n                }\n                return `: ${expected}${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `: ${util.stringifyPrimitive(issue.values[0])}`;\n                return `: ${util.joinValues(issue.values, \"\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"\" : \"\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `: ${issue.origin ?? \"\"}${issue.maximum.toString()}${sizing.unit ?? \"\"}${adj}`;\n                return `: ${issue.origin ?? \"\"}${issue.maximum.toString()}${adj}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \"\" : \"\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `: ${issue.origin}${issue.minimum.toString()}${sizing.unit}${adj}`;\n                return `: ${issue.origin}${issue.minimum.toString()}${adj}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `: \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `: \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `: \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `: ${_issue.pattern}`;\n                return `${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `: ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \"\")}`;\n            case \"invalid_key\":\n                return `${issue.origin}`;\n            case \"invalid_union\":\n                return \"\";\n            case \"invalid_element\":\n                return `${issue.origin}`;\n            default:\n                return ``;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \" \" },\n        file: { unit: \"\", verb: \" \" },\n        array: { unit: \"\", verb: \" \" },\n        set: { unit: \"\", verb: \" \" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"\",\n        email: \"- \",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"-\",\n        date: \"\",\n        time: \"\",\n        duration: \"\",\n        ipv4: \"IPv4 \",\n        ipv6: \"IPv6 \",\n        cidrv4: \"IPv4 \",\n        cidrv6: \"IPv6 \",\n        base64: \"base64- \",\n        base64url: \"base64url- \",\n        json_string: \"JSON \",\n        e164: \"E.164 \",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"\",\n        string: \"\",\n        boolean: \"\",\n        function: \"\",\n        array: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return ` :  instanceof ${issue.expected},  ${received}`;\n                }\n                return ` :  ${expected},  ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return ` :  ${util.stringifyPrimitive(issue.values[0])}`;\n                return ` :  - ${util.joinValues(issue.values, \"|\")}-`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return ` :  ${issue.origin ?? \"\"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit}`;\n                return ` :  ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` :  ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return ` :  ${issue.origin}  ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return ` :   \"${_issue.prefix}\"-`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return ` :   \"${_issue.suffix}\"-`;\n                if (_issue.format === \"includes\")\n                    return ` :   \"${_issue.includes}\"-`;\n                if (_issue.format === \"regex\")\n                    return ` :    ${_issue.pattern}`;\n                return ` ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` :   ${issue.divisor}- `;\n            case \"unrecognized_keys\":\n                return ` ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `  ${issue.origin}-`;\n            case \"invalid_union\":\n                return \" \";\n            case \"invalid_element\":\n                return `  ${issue.origin}-`;\n            default:\n                return ` `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import km from \"./km.js\";\n/** @deprecated Use `km` instead. */\nexport default function () {\n    return km();\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \"\" },\n        file: { unit: \"\", verb: \"\" },\n        array: { unit: \"\", verb: \"\" },\n        set: { unit: \"\", verb: \"\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"\",\n        email: \"\",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"  ISO\",\n        date: \" ISO\",\n        time: \" ISO\",\n        duration: \" ISO\",\n        ipv4: \" IPv4\",\n        ipv6: \" IPv6\",\n        cidrv4: \" IPv4\",\n        cidrv6: \" IPv6\",\n        base64: \" base64\",\n        base64url: \" base64url\",\n        json_string: \" JSON\",\n        e164: \" E.164\",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"\",\n        array: \" (Array)\",\n        null: \" (null)\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `  instanceof ${issue.expected}  ${received}`;\n                }\n                return `  ${expected}  ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `  ${util.stringifyPrimitive(issue.values[0])}`;\n                return `  ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `  ${issue.origin ?? \"\"} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n                return `  ${issue.origin ?? \"\"} ${adj} ${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `  ${issue.origin} ${adj} ${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `  ${issue.origin} ${adj} ${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `  \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `  \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `  \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `  ${_issue.pattern}`;\n                return ` ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `  ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return ` ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return ` ${issue.origin}`;\n            case \"invalid_union\":\n                return ``;\n            case \"invalid_element\":\n                return ` ${issue.origin}`;\n            default:\n                return ``;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \"to have\" },\n        file: { unit: \"\", verb: \"to have\" },\n        array: { unit: \"\", verb: \"to have\" },\n        set: { unit: \"\", verb: \"to have\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"\",\n        email: \" \",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO \",\n        date: \"ISO \",\n        time: \"ISO \",\n        duration: \"ISO \",\n        ipv4: \"IPv4 \",\n        ipv6: \"IPv6 \",\n        cidrv4: \"IPv4 \",\n        cidrv6: \"IPv6 \",\n        base64: \"base64  \",\n        base64url: \"base64url  \",\n        json_string: \"JSON \",\n        e164: \"E.164 \",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return ` :   instanceof ${issue.expected},   ${received}`;\n                }\n                return ` :   ${expected},   ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return ` :  ${util.stringifyPrimitive(issue.values[0])}  `;\n                return ` : ${util.joinValues(issue.values, \" \")}   `;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"\" : \"\";\n                const suffix = adj === \"\" ? \" \" : \" \";\n                const sizing = getSizing(issue.origin);\n                const unit = sizing?.unit ?? \"\";\n                if (sizing)\n                    return `${issue.origin ?? \"\"}  : ${issue.maximum.toString()}${unit} ${adj}${suffix}`;\n                return `${issue.origin ?? \"\"}  : ${issue.maximum.toString()} ${adj}${suffix}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \"\" : \"\";\n                const suffix = adj === \"\" ? \" \" : \" \";\n                const sizing = getSizing(issue.origin);\n                const unit = sizing?.unit ?? \"\";\n                if (sizing) {\n                    return `${issue.origin ?? \"\"}  : ${issue.minimum.toString()}${unit} ${adj}${suffix}`;\n                }\n                return `${issue.origin ?? \"\"}  : ${issue.minimum.toString()} ${adj}${suffix}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return ` : \"${_issue.prefix}\"()  `;\n                }\n                if (_issue.format === \"ends_with\")\n                    return ` : \"${_issue.suffix}\"()  `;\n                if (_issue.format === \"includes\")\n                    return ` : \"${_issue.includes}\"()  `;\n                if (_issue.format === \"regex\")\n                    return ` :  ${_issue.pattern}   `;\n                return ` ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` : ${issue.divisor}  `;\n            case \"unrecognized_keys\":\n                return `   : ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return ` : ${issue.origin}`;\n            case \"invalid_union\":\n                return ` `;\n            case \"invalid_element\":\n                return ` : ${issue.origin}`;\n            default:\n                return ` `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst capitalizeFirstCharacter = (text) => {\n    return text.charAt(0).toUpperCase() + text.slice(1);\n};\nfunction getUnitTypeFromNumber(number) {\n    const abs = Math.abs(number);\n    const last = abs % 10;\n    const last2 = abs % 100;\n    if ((last2 >= 11 && last2 <= 19) || last === 0)\n        return \"many\";\n    if (last === 1)\n        return \"one\";\n    return \"few\";\n}\nconst error = () => {\n    const Sizable = {\n        string: {\n            unit: {\n                one: \"simbolis\",\n                few: \"simboliai\",\n                many: \"simboli\",\n            },\n            verb: {\n                smaller: {\n                    inclusive: \"turi bti ne ilgesn kaip\",\n                    notInclusive: \"turi bti trumpesn kaip\",\n                },\n                bigger: {\n                    inclusive: \"turi bti ne trumpesn kaip\",\n                    notInclusive: \"turi bti ilgesn kaip\",\n                },\n            },\n        },\n        file: {\n            unit: {\n                one: \"baitas\",\n                few: \"baitai\",\n                many: \"bait\",\n            },\n            verb: {\n                smaller: {\n                    inclusive: \"turi bti ne didesnis kaip\",\n                    notInclusive: \"turi bti maesnis kaip\",\n                },\n                bigger: {\n                    inclusive: \"turi bti ne maesnis kaip\",\n                    notInclusive: \"turi bti didesnis kaip\",\n                },\n            },\n        },\n        array: {\n            unit: {\n                one: \"element\",\n                few: \"elementus\",\n                many: \"element\",\n            },\n            verb: {\n                smaller: {\n                    inclusive: \"turi turti ne daugiau kaip\",\n                    notInclusive: \"turi turti maiau kaip\",\n                },\n                bigger: {\n                    inclusive: \"turi turti ne maiau kaip\",\n                    notInclusive: \"turi turti daugiau kaip\",\n                },\n            },\n        },\n        set: {\n            unit: {\n                one: \"element\",\n                few: \"elementus\",\n                many: \"element\",\n            },\n            verb: {\n                smaller: {\n                    inclusive: \"turi turti ne daugiau kaip\",\n                    notInclusive: \"turi turti maiau kaip\",\n                },\n                bigger: {\n                    inclusive: \"turi turti ne maiau kaip\",\n                    notInclusive: \"turi turti daugiau kaip\",\n                },\n            },\n        },\n    };\n    function getSizing(origin, unitType, inclusive, targetShouldBe) {\n        const result = Sizable[origin] ?? null;\n        if (result === null)\n            return result;\n        return {\n            unit: result.unit[unitType],\n            verb: result.verb[targetShouldBe][inclusive ? \"inclusive\" : \"notInclusive\"],\n        };\n    }\n    const FormatDictionary = {\n        regex: \"vestis\",\n        email: \"el. pato adresas\",\n        url: \"URL\",\n        emoji: \"jaustukas\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO data ir laikas\",\n        date: \"ISO data\",\n        time: \"ISO laikas\",\n        duration: \"ISO trukm\",\n        ipv4: \"IPv4 adresas\",\n        ipv6: \"IPv6 adresas\",\n        cidrv4: \"IPv4 tinklo prefiksas (CIDR)\",\n        cidrv6: \"IPv6 tinklo prefiksas (CIDR)\",\n        base64: \"base64 ukoduota eilut\",\n        base64url: \"base64url ukoduota eilut\",\n        json_string: \"JSON eilut\",\n        e164: \"E.164 numeris\",\n        jwt: \"JWT\",\n        template_literal: \"vestis\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"skaiius\",\n        bigint: \"sveikasis skaiius\",\n        string: \"eilut\",\n        boolean: \"login reikm\",\n        undefined: \"neapibrta reikm\",\n        function: \"funkcija\",\n        symbol: \"simbolis\",\n        array: \"masyvas\",\n        object: \"objektas\",\n        null: \"nulin reikm\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Gautas tipas ${received}, o tiktasi - instanceof ${issue.expected}`;\n                }\n                return `Gautas tipas ${received}, o tiktasi - ${expected}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Privalo bti ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Privalo bti vienas i ${util.joinValues(issue.values, \"|\")} pasirinkim`;\n            case \"too_big\": {\n                const origin = TypeDictionary[issue.origin] ?? issue.origin;\n                const sizing = getSizing(issue.origin, getUnitTypeFromNumber(Number(issue.maximum)), issue.inclusive ?? false, \"smaller\");\n                if (sizing?.verb)\n                    return `${capitalizeFirstCharacter(origin ?? issue.origin ?? \"reikm\")} ${sizing.verb} ${issue.maximum.toString()} ${sizing.unit ?? \"element\"}`;\n                const adj = issue.inclusive ? \"ne didesnis kaip\" : \"maesnis kaip\";\n                return `${capitalizeFirstCharacter(origin ?? issue.origin ?? \"reikm\")} turi bti ${adj} ${issue.maximum.toString()} ${sizing?.unit}`;\n            }\n            case \"too_small\": {\n                const origin = TypeDictionary[issue.origin] ?? issue.origin;\n                const sizing = getSizing(issue.origin, getUnitTypeFromNumber(Number(issue.minimum)), issue.inclusive ?? false, \"bigger\");\n                if (sizing?.verb)\n                    return `${capitalizeFirstCharacter(origin ?? issue.origin ?? \"reikm\")} ${sizing.verb} ${issue.minimum.toString()} ${sizing.unit ?? \"element\"}`;\n                const adj = issue.inclusive ? \"ne maesnis kaip\" : \"didesnis kaip\";\n                return `${capitalizeFirstCharacter(origin ?? issue.origin ?? \"reikm\")} turi bti ${adj} ${issue.minimum.toString()} ${sizing?.unit}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `Eilut privalo prasidti \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `Eilut privalo pasibaigti \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Eilut privalo traukti \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Eilut privalo atitikti ${_issue.pattern}`;\n                return `Neteisingas ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Skaiius privalo bti ${issue.divisor} kartotinis.`;\n            case \"unrecognized_keys\":\n                return `Neatpaint${issue.keys.length > 1 ? \"i\" : \"as\"} rakt${issue.keys.length > 1 ? \"ai\" : \"as\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return \"Rastas klaidingas raktas\";\n            case \"invalid_union\":\n                return \"Klaidinga vestis\";\n            case \"invalid_element\": {\n                const origin = TypeDictionary[issue.origin] ?? issue.origin;\n                return `${capitalizeFirstCharacter(origin ?? issue.origin ?? \"reikm\")} turi klaiding vest`;\n            }\n            default:\n                return \"Klaidinga vestis\";\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \" \" },\n        file: { unit: \"\", verb: \" \" },\n        array: { unit: \"\", verb: \" \" },\n        set: { unit: \"\", verb: \" \" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"\",\n        email: \"  -\",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO   \",\n        date: \"ISO \",\n        time: \"ISO \",\n        duration: \"ISO \",\n        ipv4: \"IPv4 \",\n        ipv6: \"IPv6 \",\n        cidrv4: \"IPv4 \",\n        cidrv6: \"IPv6 \",\n        base64: \"base64- \",\n        base64url: \"base64url- \",\n        json_string: \"JSON \",\n        e164: \"E.164 \",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"\",\n        array: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return ` :   instanceof ${issue.expected},  ${received}`;\n                }\n                return ` :   ${expected},  ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Invalid input: expected ${util.stringifyPrimitive(issue.values[0])}`;\n                return ` :    ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return ` :   ${issue.origin ?? \"\"}   ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n                return ` :   ${issue.origin ?? \"\"}   ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` :   ${issue.origin}   ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return ` :   ${issue.origin}   ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return ` :     \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return ` :     \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return ` :    \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return ` :      ${_issue.pattern}`;\n                return `Invalid ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` :      ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \" \" : \" \"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `   ${issue.origin}`;\n            case \"invalid_union\":\n                return \" \";\n            case \"invalid_element\":\n                return `   ${issue.origin}`;\n            default:\n                return ` `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"aksara\", verb: \"mempunyai\" },\n        file: { unit: \"bait\", verb: \"mempunyai\" },\n        array: { unit: \"elemen\", verb: \"mempunyai\" },\n        set: { unit: \"elemen\", verb: \"mempunyai\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"input\",\n        email: \"alamat e-mel\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"tarikh masa ISO\",\n        date: \"tarikh ISO\",\n        time: \"masa ISO\",\n        duration: \"tempoh ISO\",\n        ipv4: \"alamat IPv4\",\n        ipv6: \"alamat IPv6\",\n        cidrv4: \"julat IPv4\",\n        cidrv6: \"julat IPv6\",\n        base64: \"string dikodkan base64\",\n        base64url: \"string dikodkan base64url\",\n        json_string: \"string JSON\",\n        e164: \"nombor E.164\",\n        jwt: \"JWT\",\n        template_literal: \"input\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"nombor\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Input tidak sah: dijangka instanceof ${issue.expected}, diterima ${received}`;\n                }\n                return `Input tidak sah: dijangka ${expected}, diterima ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Input tidak sah: dijangka ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Pilihan tidak sah: dijangka salah satu daripada ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Terlalu besar: dijangka ${issue.origin ?? \"nilai\"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elemen\"}`;\n                return `Terlalu besar: dijangka ${issue.origin ?? \"nilai\"} adalah ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Terlalu kecil: dijangka ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Terlalu kecil: dijangka ${issue.origin} adalah ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `String tidak sah: mesti bermula dengan \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `String tidak sah: mesti berakhir dengan \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `String tidak sah: mesti mengandungi \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;\n                return `${FormatDictionary[_issue.format] ?? issue.format} tidak sah`;\n            }\n            case \"not_multiple_of\":\n                return `Nombor tidak sah: perlu gandaan ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Kunci tidak dikenali: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Kunci tidak sah dalam ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Input tidak sah\";\n            case \"invalid_element\":\n                return `Nilai tidak sah dalam ${issue.origin}`;\n            default:\n                return `Input tidak sah`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"tekens\", verb: \"heeft\" },\n        file: { unit: \"bytes\", verb: \"heeft\" },\n        array: { unit: \"elementen\", verb: \"heeft\" },\n        set: { unit: \"elementen\", verb: \"heeft\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"invoer\",\n        email: \"emailadres\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO datum en tijd\",\n        date: \"ISO datum\",\n        time: \"ISO tijd\",\n        duration: \"ISO duur\",\n        ipv4: \"IPv4-adres\",\n        ipv6: \"IPv6-adres\",\n        cidrv4: \"IPv4-bereik\",\n        cidrv6: \"IPv6-bereik\",\n        base64: \"base64-gecodeerde tekst\",\n        base64url: \"base64 URL-gecodeerde tekst\",\n        json_string: \"JSON string\",\n        e164: \"E.164-nummer\",\n        jwt: \"JWT\",\n        template_literal: \"invoer\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"getal\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Ongeldige invoer: verwacht instanceof ${issue.expected}, ontving ${received}`;\n                }\n                return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Ongeldige invoer: verwacht ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Ongeldige optie: verwacht n van ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                const longName = issue.origin === \"date\" ? \"laat\" : issue.origin === \"string\" ? \"lang\" : \"groot\";\n                if (sizing)\n                    return `Te ${longName}: verwacht dat ${issue.origin ?? \"waarde\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementen\"} ${sizing.verb}`;\n                return `Te ${longName}: verwacht dat ${issue.origin ?? \"waarde\"} ${adj}${issue.maximum.toString()} is`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                const shortName = issue.origin === \"date\" ? \"vroeg\" : issue.origin === \"string\" ? \"kort\" : \"klein\";\n                if (sizing) {\n                    return `Te ${shortName}: verwacht dat ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} ${sizing.verb}`;\n                }\n                return `Te ${shortName}: verwacht dat ${issue.origin} ${adj}${issue.minimum.toString()} is`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `Ongeldige tekst: moet met \"${_issue.prefix}\" beginnen`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `Ongeldige tekst: moet op \"${_issue.suffix}\" eindigen`;\n                if (_issue.format === \"includes\")\n                    return `Ongeldige tekst: moet \"${_issue.includes}\" bevatten`;\n                if (_issue.format === \"regex\")\n                    return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;\n                return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Ongeldig getal: moet een veelvoud van ${issue.divisor} zijn`;\n            case \"unrecognized_keys\":\n                return `Onbekende key${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Ongeldige key in ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Ongeldige invoer\";\n            case \"invalid_element\":\n                return `Ongeldige waarde in ${issue.origin}`;\n            default:\n                return `Ongeldige invoer`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"tegn\", verb: \" ha\" },\n        file: { unit: \"bytes\", verb: \" ha\" },\n        array: { unit: \"elementer\", verb: \" inneholde\" },\n        set: { unit: \"elementer\", verb: \" inneholde\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"input\",\n        email: \"e-postadresse\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO dato- og klokkeslett\",\n        date: \"ISO-dato\",\n        time: \"ISO-klokkeslett\",\n        duration: \"ISO-varighet\",\n        ipv4: \"IPv4-omrde\",\n        ipv6: \"IPv6-omrde\",\n        cidrv4: \"IPv4-spekter\",\n        cidrv6: \"IPv6-spekter\",\n        base64: \"base64-enkodet streng\",\n        base64url: \"base64url-enkodet streng\",\n        json_string: \"JSON-streng\",\n        e164: \"E.164-nummer\",\n        jwt: \"JWT\",\n        template_literal: \"input\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"tall\",\n        array: \"liste\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Ugyldig input: forventet instanceof ${issue.expected}, fikk ${received}`;\n                }\n                return `Ugyldig input: forventet ${expected}, fikk ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Ugyldig verdi: forventet ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Ugyldig valg: forventet en av ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `For stor(t): forventet ${issue.origin ?? \"value\"} til  ha ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementer\"}`;\n                return `For stor(t): forventet ${issue.origin ?? \"value\"} til  ha ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `For lite(n): forventet ${issue.origin} til  ha ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `For lite(n): forventet ${issue.origin} til  ha ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Ugyldig streng: m starte med \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Ugyldig streng: m ende med \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Ugyldig streng: m inneholde \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Ugyldig streng: m matche mnsteret ${_issue.pattern}`;\n                return `Ugyldig ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Ugyldig tall: m vre et multiplum av ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"Ukjente nkler\" : \"Ukjent nkkel\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Ugyldig nkkel i ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Ugyldig input\";\n            case \"invalid_element\":\n                return `Ugyldig verdi i ${issue.origin}`;\n            default:\n                return `Ugyldig input`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"harf\", verb: \"olmaldr\" },\n        file: { unit: \"bayt\", verb: \"olmaldr\" },\n        array: { unit: \"unsur\", verb: \"olmaldr\" },\n        set: { unit: \"unsur\", verb: \"olmaldr\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"giren\",\n        email: \"epostagh\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO hengm\",\n        date: \"ISO tarihi\",\n        time: \"ISO zaman\",\n        duration: \"ISO mddeti\",\n        ipv4: \"IPv4 nin\",\n        ipv6: \"IPv6 nin\",\n        cidrv4: \"IPv4 menzili\",\n        cidrv6: \"IPv6 menzili\",\n        base64: \"base64-ifreli metin\",\n        base64url: \"base64url-ifreli metin\",\n        json_string: \"JSON metin\",\n        e164: \"E.164 says\",\n        jwt: \"JWT\",\n        template_literal: \"giren\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"numara\",\n        array: \"saf\",\n        null: \"gayb\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Fsit giren: umulan instanceof ${issue.expected}, alnan ${received}`;\n                }\n                return `Fsit giren: umulan ${expected}, alnan ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Fsit giren: umulan ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Fsit tercih: mteberler ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Fazla byk: ${issue.origin ?? \"value\"}, ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elements\"} sahip olmalyd.`;\n                return `Fazla byk: ${issue.origin ?? \"value\"}, ${adj}${issue.maximum.toString()} olmalyd.`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Fazla kk: ${issue.origin}, ${adj}${issue.minimum.toString()} ${sizing.unit} sahip olmalyd.`;\n                }\n                return `Fazla kk: ${issue.origin}, ${adj}${issue.minimum.toString()} olmalyd.`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Fsit metin: \"${_issue.prefix}\" ile balamal.`;\n                if (_issue.format === \"ends_with\")\n                    return `Fsit metin: \"${_issue.suffix}\" ile bitmeli.`;\n                if (_issue.format === \"includes\")\n                    return `Fsit metin: \"${_issue.includes}\" ihtiv etmeli.`;\n                if (_issue.format === \"regex\")\n                    return `Fsit metin: ${_issue.pattern} nakna uymal.`;\n                return `Fsit ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Fsit say: ${issue.divisor} kat olmalyd.`;\n            case \"unrecognized_keys\":\n                return `Tannmayan anahtar ${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `${issue.origin} iin tannmayan anahtar var.`;\n            case \"invalid_union\":\n                return \"Giren tannamad.\";\n            case \"invalid_element\":\n                return `${issue.origin} iin tannmayan kymet var.`;\n            default:\n                return `Kymet tannamad.`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"znakw\", verb: \"mie\" },\n        file: { unit: \"bajtw\", verb: \"mie\" },\n        array: { unit: \"elementw\", verb: \"mie\" },\n        set: { unit: \"elementw\", verb: \"mie\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"wyraenie\",\n        email: \"adres email\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"data i godzina w formacie ISO\",\n        date: \"data w formacie ISO\",\n        time: \"godzina w formacie ISO\",\n        duration: \"czas trwania ISO\",\n        ipv4: \"adres IPv4\",\n        ipv6: \"adres IPv6\",\n        cidrv4: \"zakres IPv4\",\n        cidrv6: \"zakres IPv6\",\n        base64: \"cig znakw zakodowany w formacie base64\",\n        base64url: \"cig znakw zakodowany w formacie base64url\",\n        json_string: \"cig znakw w formacie JSON\",\n        e164: \"liczba E.164\",\n        jwt: \"JWT\",\n        template_literal: \"wejcie\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"liczba\",\n        array: \"tablica\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Nieprawidowe dane wejciowe: oczekiwano instanceof ${issue.expected}, otrzymano ${received}`;\n                }\n                return `Nieprawidowe dane wejciowe: oczekiwano ${expected}, otrzymano ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Nieprawidowe dane wejciowe: oczekiwano ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Za dua warto: oczekiwano, e ${issue.origin ?? \"warto\"} bdzie mie ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementw\"}`;\n                }\n                return `Zbyt du(y/a/e): oczekiwano, e ${issue.origin ?? \"warto\"} bdzie wynosi ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Za maa warto: oczekiwano, e ${issue.origin ?? \"warto\"} bdzie mie ${adj}${issue.minimum.toString()} ${sizing.unit ?? \"elementw\"}`;\n                }\n                return `Zbyt ma(y/a/e): oczekiwano, e ${issue.origin ?? \"warto\"} bdzie wynosi ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Nieprawidowy cig znakw: musi zaczyna si od \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Nieprawidowy cig znakw: musi koczy si na \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Nieprawidowy cig znakw: musi zawiera \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${_issue.pattern}`;\n                return `Nieprawidow(y/a/e) ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Nieprawidowa liczba: musi by wielokrotnoci ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Nierozpoznane klucze${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Nieprawidowy klucz w ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Nieprawidowe dane wejciowe\";\n            case \"invalid_element\":\n                return `Nieprawidowa warto w ${issue.origin}`;\n            default:\n                return `Nieprawidowe dane wejciowe`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \"\" },\n        file: { unit: \"\", verb: \"\" },\n        array: { unit: \"\", verb: \"\" },\n        set: { unit: \"\", verb: \"\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"\",\n        email: \"\",\n        url: \"  \",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"  \",\n        date: \"\",\n        time: \"\",\n        duration: \"\",\n        ipv4: \" IPv4 \",\n        ipv6: \" IPv6 \",\n        cidrv4: \" IPv4 \",\n        cidrv6: \" IPv6 \",\n        base64: \"base64-encoded \",\n        base64url: \"base64url-encoded \",\n        json_string: \"JSON \",\n        e164: \" E.164 \",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"\",\n        array: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return ` :  instanceof ${issue.expected} ,  ${received}  `;\n                }\n                return ` :  ${expected} ,  ${received}  `;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1) {\n                    return ` :  ${util.stringifyPrimitive(issue.values[0])} `;\n                }\n                return ` :    ${util.joinValues(issue.values, \"|\")}  `;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` : ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"} `;\n                }\n                return ` : ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()} `;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` : ${issue.origin}  ${adj}${issue.minimum.toString()} ${sizing.unit} `;\n                }\n                return ` : ${issue.origin}  ${adj}${issue.minimum.toString()} `;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return ` :   \"${_issue.prefix}\"   `;\n                }\n                if (_issue.format === \"ends_with\") {\n                    return ` :   \"${_issue.suffix}\"    `;\n                }\n                if (_issue.format === \"includes\") {\n                    return ` :  \"${_issue.includes}\" `;\n                }\n                if (_issue.format === \"regex\") {\n                    return ` :   ${_issue.pattern}   `;\n                }\n                return `${FormatDictionary[_issue.format] ?? issue.format}  `;\n            }\n            case \"not_multiple_of\":\n                return ` :   ${issue.divisor}  `;\n            case \"unrecognized_keys\":\n                return ` ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `   ${issue.origin} `;\n            case \"invalid_union\":\n                return ` `;\n            case \"invalid_element\":\n                return `   ${issue.origin} `;\n            default:\n                return ` `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"caracteres\", verb: \"ter\" },\n        file: { unit: \"bytes\", verb: \"ter\" },\n        array: { unit: \"itens\", verb: \"ter\" },\n        set: { unit: \"itens\", verb: \"ter\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"padro\",\n        email: \"endereo de e-mail\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"data e hora ISO\",\n        date: \"data ISO\",\n        time: \"hora ISO\",\n        duration: \"durao ISO\",\n        ipv4: \"endereo IPv4\",\n        ipv6: \"endereo IPv6\",\n        cidrv4: \"faixa de IPv4\",\n        cidrv6: \"faixa de IPv6\",\n        base64: \"texto codificado em base64\",\n        base64url: \"URL codificada em base64\",\n        json_string: \"texto JSON\",\n        e164: \"nmero E.164\",\n        jwt: \"JWT\",\n        template_literal: \"entrada\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"nmero\",\n        null: \"nulo\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Tipo invlido: esperado instanceof ${issue.expected}, recebido ${received}`;\n                }\n                return `Tipo invlido: esperado ${expected}, recebido ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Entrada invlida: esperado ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Opo invlida: esperada uma das ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Muito grande: esperado que ${issue.origin ?? \"valor\"} tivesse ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementos\"}`;\n                return `Muito grande: esperado que ${issue.origin ?? \"valor\"} fosse ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Muito pequeno: esperado que ${issue.origin} tivesse ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Muito pequeno: esperado que ${issue.origin} fosse ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Texto invlido: deve comear com \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Texto invlido: deve terminar com \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Texto invlido: deve incluir \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Texto invlido: deve corresponder ao padro ${_issue.pattern}`;\n                return `${FormatDictionary[_issue.format] ?? issue.format} invlido`;\n            }\n            case \"not_multiple_of\":\n                return `Nmero invlido: deve ser mltiplo de ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Chave${issue.keys.length > 1 ? \"s\" : \"\"} desconhecida${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Chave invlida em ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Entrada invlida\";\n            case \"invalid_element\":\n                return `Valor invlido em ${issue.origin}`;\n            default:\n                return `Campo invlido`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nfunction getRussianPlural(count, one, few, many) {\n    const absCount = Math.abs(count);\n    const lastDigit = absCount % 10;\n    const lastTwoDigits = absCount % 100;\n    if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {\n        return many;\n    }\n    if (lastDigit === 1) {\n        return one;\n    }\n    if (lastDigit >= 2 && lastDigit <= 4) {\n        return few;\n    }\n    return many;\n}\nconst error = () => {\n    const Sizable = {\n        string: {\n            unit: {\n                one: \"\",\n                few: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n        file: {\n            unit: {\n                one: \"\",\n                few: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n        array: {\n            unit: {\n                one: \"\",\n                few: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n        set: {\n            unit: {\n                one: \"\",\n                few: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"\",\n        email: \"email \",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO   \",\n        date: \"ISO \",\n        time: \"ISO \",\n        duration: \"ISO \",\n        ipv4: \"IPv4 \",\n        ipv6: \"IPv6 \",\n        cidrv4: \"IPv4 \",\n        cidrv6: \"IPv6 \",\n        base64: \"   base64\",\n        base64url: \"   base64url\",\n        json_string: \"JSON \",\n        e164: \" E.164\",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"\",\n        array: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return ` :  instanceof ${issue.expected},  ${received}`;\n                }\n                return ` :  ${expected},  ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return ` :  ${util.stringifyPrimitive(issue.values[0])}`;\n                return ` :    ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    const maxValue = Number(issue.maximum);\n                    const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n                    return `  : ,  ${issue.origin ?? \"\"}   ${adj}${issue.maximum.toString()} ${unit}`;\n                }\n                return `  : ,  ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    const minValue = Number(issue.minimum);\n                    const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n                    return `  : ,  ${issue.origin}   ${adj}${issue.minimum.toString()} ${unit}`;\n                }\n                return `  : ,  ${issue.origin}  ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return ` :    \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return ` :    \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return ` :   \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return ` :    ${_issue.pattern}`;\n                return ` ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` :    ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"\" : \"\"} ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `   ${issue.origin}`;\n            case \"invalid_union\":\n                return \"  \";\n            case \"invalid_element\":\n                return `   ${issue.origin}`;\n            default:\n                return `  `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"znakov\", verb: \"imeti\" },\n        file: { unit: \"bajtov\", verb: \"imeti\" },\n        array: { unit: \"elementov\", verb: \"imeti\" },\n        set: { unit: \"elementov\", verb: \"imeti\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"vnos\",\n        email: \"e-potni naslov\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO datum in as\",\n        date: \"ISO datum\",\n        time: \"ISO as\",\n        duration: \"ISO trajanje\",\n        ipv4: \"IPv4 naslov\",\n        ipv6: \"IPv6 naslov\",\n        cidrv4: \"obseg IPv4\",\n        cidrv6: \"obseg IPv6\",\n        base64: \"base64 kodiran niz\",\n        base64url: \"base64url kodiran niz\",\n        json_string: \"JSON niz\",\n        e164: \"E.164 tevilka\",\n        jwt: \"JWT\",\n        template_literal: \"vnos\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"tevilo\",\n        array: \"tabela\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Neveljaven vnos: priakovano instanceof ${issue.expected}, prejeto ${received}`;\n                }\n                return `Neveljaven vnos: priakovano ${expected}, prejeto ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Neveljaven vnos: priakovano ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Neveljavna monost: priakovano eno izmed ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Preveliko: priakovano, da bo ${issue.origin ?? \"vrednost\"} imelo ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementov\"}`;\n                return `Preveliko: priakovano, da bo ${issue.origin ?? \"vrednost\"} ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Premajhno: priakovano, da bo ${issue.origin} imelo ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Premajhno: priakovano, da bo ${issue.origin} ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `Neveljaven niz: mora se zaeti z \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `Neveljaven niz: mora se konati z \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Neveljaven niz: mora vsebovati \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;\n                return `Neveljaven ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Neveljavno tevilo: mora biti vekratnik ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Neprepoznan${issue.keys.length > 1 ? \"i kljui\" : \" klju\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Neveljaven klju v ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Neveljaven vnos\";\n            case \"invalid_element\":\n                return `Neveljavna vrednost v ${issue.origin}`;\n            default:\n                return \"Neveljaven vnos\";\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"tecken\", verb: \"att ha\" },\n        file: { unit: \"bytes\", verb: \"att ha\" },\n        array: { unit: \"objekt\", verb: \"att innehlla\" },\n        set: { unit: \"objekt\", verb: \"att innehlla\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"reguljrt uttryck\",\n        email: \"e-postadress\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO-datum och tid\",\n        date: \"ISO-datum\",\n        time: \"ISO-tid\",\n        duration: \"ISO-varaktighet\",\n        ipv4: \"IPv4-intervall\",\n        ipv6: \"IPv6-intervall\",\n        cidrv4: \"IPv4-spektrum\",\n        cidrv6: \"IPv6-spektrum\",\n        base64: \"base64-kodad strng\",\n        base64url: \"base64url-kodad strng\",\n        json_string: \"JSON-strng\",\n        e164: \"E.164-nummer\",\n        jwt: \"JWT\",\n        template_literal: \"mall-literal\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"antal\",\n        array: \"lista\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Ogiltig inmatning: frvntat instanceof ${issue.expected}, fick ${received}`;\n                }\n                return `Ogiltig inmatning: frvntat ${expected}, fick ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Ogiltig inmatning: frvntat ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Ogiltigt val: frvntade en av ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Fr stor(t): frvntade ${issue.origin ?? \"vrdet\"} att ha ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"element\"}`;\n                }\n                return `Fr stor(t): frvntat ${issue.origin ?? \"vrdet\"} att ha ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Fr lite(t): frvntade ${issue.origin ?? \"vrdet\"} att ha ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Fr lite(t): frvntade ${issue.origin ?? \"vrdet\"} att ha ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `Ogiltig strng: mste brja med \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `Ogiltig strng: mste sluta med \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Ogiltig strng: mste innehlla \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Ogiltig strng: mste matcha mnstret \"${_issue.pattern}\"`;\n                return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Ogiltigt tal: mste vara en multipel av ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"Oknda nycklar\" : \"Oknd nyckel\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Ogiltig nyckel i ${issue.origin ?? \"vrdet\"}`;\n            case \"invalid_union\":\n                return \"Ogiltig input\";\n            case \"invalid_element\":\n                return `Ogiltigt vrde i ${issue.origin ?? \"vrdet\"}`;\n            default:\n                return `Ogiltig input`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \" \" },\n        file: { unit: \"\", verb: \" \" },\n        array: { unit: \"\", verb: \" \" },\n        set: { unit: \"\", verb: \" \" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"\",\n        email: \" \",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO  \",\n        date: \"ISO \",\n        time: \"ISO \",\n        duration: \"ISO  \",\n        ipv4: \"IPv4 \",\n        ipv6: \"IPv6 \",\n        cidrv4: \"IPv4 \",\n        cidrv6: \"IPv6 \",\n        base64: \"base64-encoded \",\n        base64url: \"base64url-encoded \",\n        json_string: \"JSON \",\n        e164: \"E.164 \",\n        jwt: \"JWT\",\n        template_literal: \"input\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"\",\n        array: \"\",\n        null: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return ` :  instanceof ${issue.expected},  ${received}`;\n                }\n                return ` :  ${expected},  ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return ` :  ${util.stringifyPrimitive(issue.values[0])}`;\n                return ` :  ${util.joinValues(issue.values, \"|\")}  `;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` :  ${issue.origin ?? \"\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}   `;\n                }\n                return ` :  ${issue.origin ?? \"\"} ${adj}${issue.maximum.toString()}   `;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` :  ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}   `; //\n                }\n                return ` :  ${issue.origin} ${adj}${issue.minimum.toString()}   `;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return ` : \"${_issue.prefix}\"   `;\n                if (_issue.format === \"ends_with\")\n                    return ` : \"${_issue.suffix}\"   `;\n                if (_issue.format === \"includes\")\n                    return ` : \"${_issue.includes}\"   `;\n                if (_issue.format === \"regex\")\n                    return ` : ${_issue.pattern}   `;\n                return ` ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` : ${issue.divisor}    `;\n            case \"unrecognized_keys\":\n                return `  ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `${issue.origin}   `;\n            case \"invalid_union\":\n                return \" \";\n            case \"invalid_element\":\n                return `${issue.origin}   `;\n            default:\n                return ` `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \"\" },\n        file: { unit: \"\", verb: \"\" },\n        array: { unit: \"\", verb: \"\" },\n        set: { unit: \"\", verb: \"\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"\",\n        email: \"\",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \" ISO\",\n        date: \" ISO\",\n        time: \" ISO\",\n        duration: \" ISO\",\n        ipv4: \" IPv4\",\n        ipv6: \" IPv6\",\n        cidrv4: \" IP  IPv4\",\n        cidrv6: \" IP  IPv6\",\n        base64: \" Base64\",\n        base64url: \" Base64  URL\",\n        json_string: \" JSON\",\n        e164: \" (E.164)\",\n        jwt: \" JWT\",\n        template_literal: \"\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"\",\n        array: \" (Array)\",\n        null: \" (null)\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `:  instanceof ${issue.expected}  ${received}`;\n                }\n                return `:  ${expected}  ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `:  ${util.stringifyPrimitive(issue.values[0])}`;\n                return `:  ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"\" : \"\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `: ${issue.origin ?? \"\"} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n                return `: ${issue.origin ?? \"\"} ${adj} ${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \"\" : \"\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `: ${issue.origin} ${adj} ${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `: ${issue.origin} ${adj} ${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `:  \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `:  \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `:  \"${_issue.includes}\" `;\n                if (_issue.format === \"regex\")\n                    return `:  ${_issue.pattern}`;\n                return `: ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `:  ${issue.divisor} `;\n            case \"unrecognized_keys\":\n                return `: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return ` ${issue.origin}`;\n            case \"invalid_union\":\n                return \": \";\n            case \"invalid_element\":\n                return ` ${issue.origin}`;\n            default:\n                return ``;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"karakter\", verb: \"olmal\" },\n        file: { unit: \"bayt\", verb: \"olmal\" },\n        array: { unit: \"e\", verb: \"olmal\" },\n        set: { unit: \"e\", verb: \"olmal\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"girdi\",\n        email: \"e-posta adresi\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO tarih ve saat\",\n        date: \"ISO tarih\",\n        time: \"ISO saat\",\n        duration: \"ISO sre\",\n        ipv4: \"IPv4 adresi\",\n        ipv6: \"IPv6 adresi\",\n        cidrv4: \"IPv4 aral\",\n        cidrv6: \"IPv6 aral\",\n        base64: \"base64 ile ifrelenmi metin\",\n        base64url: \"base64url ile ifrelenmi metin\",\n        json_string: \"JSON dizesi\",\n        e164: \"E.164 says\",\n        jwt: \"JWT\",\n        template_literal: \"ablon dizesi\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Geersiz deer: beklenen instanceof ${issue.expected}, alnan ${received}`;\n                }\n                return `Geersiz deer: beklenen ${expected}, alnan ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Geersiz deer: beklenen ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Geersiz seenek: aadakilerden biri olmal: ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `ok byk: beklenen ${issue.origin ?? \"deer\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"e\"}`;\n                return `ok byk: beklenen ${issue.origin ?? \"deer\"} ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `ok kk: beklenen ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                return `ok kk: beklenen ${issue.origin} ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Geersiz metin: \"${_issue.prefix}\" ile balamal`;\n                if (_issue.format === \"ends_with\")\n                    return `Geersiz metin: \"${_issue.suffix}\" ile bitmeli`;\n                if (_issue.format === \"includes\")\n                    return `Geersiz metin: \"${_issue.includes}\" iermeli`;\n                if (_issue.format === \"regex\")\n                    return `Geersiz metin: ${_issue.pattern} desenine uymal`;\n                return `Geersiz ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Geersiz say: ${issue.divisor} ile tam blnebilmeli`;\n            case \"unrecognized_keys\":\n                return `Tannmayan anahtar${issue.keys.length > 1 ? \"lar\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `${issue.origin} iinde geersiz anahtar`;\n            case \"invalid_union\":\n                return \"Geersiz deer\";\n            case \"invalid_element\":\n                return `${issue.origin} iinde geersiz deer`;\n            default:\n                return `Geersiz deer`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import uk from \"./uk.js\";\n/** @deprecated Use `uk` instead. */\nexport default function () {\n    return uk();\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \"\" },\n        file: { unit: \"\", verb: \"\" },\n        array: { unit: \"\", verb: \"\" },\n        set: { unit: \"\", verb: \"\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \" \",\n        email: \"  \",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"   ISO\",\n        date: \" ISO\",\n        time: \" ISO\",\n        duration: \" ISO\",\n        ipv4: \" IPv4\",\n        ipv6: \" IPv6\",\n        cidrv4: \" IPv4\",\n        cidrv6: \" IPv6\",\n        base64: \"   base64\",\n        base64url: \"   base64url\",\n        json_string: \" JSON\",\n        e164: \" E.164\",\n        jwt: \"JWT\",\n        template_literal: \" \",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"\",\n        array: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `  :  instanceof ${issue.expected},  ${received}`;\n                }\n                return `  :  ${expected},  ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `  :  ${util.stringifyPrimitive(issue.values[0])}`;\n                return ` :    ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return ` : ,  ${issue.origin ?? \"\"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n                return ` : ,  ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` : ,  ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return ` : ,  ${issue.origin}  ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return ` :    \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return ` :    \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return ` :   \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return ` :    ${_issue.pattern}`;\n                return ` ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` :    ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return ` ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `   ${issue.origin}`;\n            case \"invalid_union\":\n                return \"  \";\n            case \"invalid_element\":\n                return `   ${issue.origin}`;\n            default:\n                return `  `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \"\" },\n        file: { unit: \"\", verb: \"\" },\n        array: { unit: \"\", verb: \"\" },\n        set: { unit: \"\", verb: \"\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \" \",\n        email: \"  \",\n        url: \"  \",\n        emoji: \"\",\n        uuid: \"   \",\n        uuidv4: \"     4\",\n        uuidv6: \"     6\",\n        nanoid: \"  \",\n        guid: \"   \",\n        cuid: \"   \",\n        cuid2: \"    2\",\n        ulid: \"   \",\n        xid: \"  \",\n        ksuid: \"    \",\n        datetime: \"    \",\n        date: \"   \",\n        time: \"   \",\n        duration: \"   \",\n        ipv4: \"   4 \",\n        ipv6: \"   6 \",\n        cidrv4: \"   4 \",\n        cidrv6: \"   6 \",\n        base64: \" 64   \",\n        base64url: \" 64      \",\n        json_string: \"    \",\n        e164: \" 164 \",\n        jwt: \"  \",\n        template_literal: \" \",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"\",\n        array: \"\",\n        null: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `  : instanceof ${issue.expected}   ${received}  `;\n                }\n                return `  : ${expected}   ${received}  `;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `  : ${util.stringifyPrimitive(issue.values[0])}  `;\n                return ` : ${util.joinValues(issue.values, \"|\")}     `;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return ` : ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}   `;\n                return ` : ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()}   `;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` : ${issue.origin}  ${adj}${issue.minimum.toString()} ${sizing.unit}   `;\n                }\n                return ` : ${issue.origin}  ${adj}${issue.minimum.toString()}   `;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return ` : \"${_issue.prefix}\"    `;\n                }\n                if (_issue.format === \"ends_with\")\n                    return ` : \"${_issue.suffix}\"    `;\n                if (_issue.format === \"includes\")\n                    return ` : \"${_issue.includes}\"   `;\n                if (_issue.format === \"regex\")\n                    return ` :  ${_issue.pattern}    `;\n                return ` ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` : ${issue.divisor}    `;\n            case \"unrecognized_keys\":\n                return `   ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \" \")}`;\n            case \"invalid_key\":\n                return `${issue.origin}   `;\n            case \"invalid_union\":\n                return \"  \";\n            case \"invalid_element\":\n                return `${issue.origin}   `;\n            default:\n                return `  `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"belgi\", verb: \"bolishi kerak\" },\n        file: { unit: \"bayt\", verb: \"bolishi kerak\" },\n        array: { unit: \"element\", verb: \"bolishi kerak\" },\n        set: { unit: \"element\", verb: \"bolishi kerak\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"kirish\",\n        email: \"elektron pochta manzili\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO sana va vaqti\",\n        date: \"ISO sana\",\n        time: \"ISO vaqt\",\n        duration: \"ISO davomiylik\",\n        ipv4: \"IPv4 manzil\",\n        ipv6: \"IPv6 manzil\",\n        mac: \"MAC manzil\",\n        cidrv4: \"IPv4 diapazon\",\n        cidrv6: \"IPv6 diapazon\",\n        base64: \"base64 kodlangan satr\",\n        base64url: \"base64url kodlangan satr\",\n        json_string: \"JSON satr\",\n        e164: \"E.164 raqam\",\n        jwt: \"JWT\",\n        template_literal: \"kirish\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"raqam\",\n        array: \"massiv\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `Notogri kirish: kutilgan instanceof ${issue.expected}, qabul qilingan ${received}`;\n                }\n                return `Notogri kirish: kutilgan ${expected}, qabul qilingan ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Notogri kirish: kutilgan ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Notogri variant: quyidagilardan biri kutilgan ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Juda katta: kutilgan ${issue.origin ?? \"qiymat\"} ${adj}${issue.maximum.toString()} ${sizing.unit} ${sizing.verb}`;\n                return `Juda katta: kutilgan ${issue.origin ?? \"qiymat\"} ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Juda kichik: kutilgan ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} ${sizing.verb}`;\n                }\n                return `Juda kichik: kutilgan ${issue.origin} ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Notogri satr: \"${_issue.prefix}\" bilan boshlanishi kerak`;\n                if (_issue.format === \"ends_with\")\n                    return `Notogri satr: \"${_issue.suffix}\" bilan tugashi kerak`;\n                if (_issue.format === \"includes\")\n                    return `Notogri satr: \"${_issue.includes}\" ni oz ichiga olishi kerak`;\n                if (_issue.format === \"regex\")\n                    return `Notogri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;\n                return `Notogri ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Notogri raqam: ${issue.divisor} ning karralisi bolishi kerak`;\n            case \"unrecognized_keys\":\n                return `Nomalum kalit${issue.keys.length > 1 ? \"lar\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `${issue.origin} dagi kalit notogri`;\n            case \"invalid_union\":\n                return \"Notogri kirish\";\n            case \"invalid_element\":\n                return `${issue.origin} da notogri qiymat`;\n            default:\n                return `Notogri kirish`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"k t\", verb: \"c\" },\n        file: { unit: \"byte\", verb: \"c\" },\n        array: { unit: \"phn t\", verb: \"c\" },\n        set: { unit: \"phn t\", verb: \"c\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"u vo\",\n        email: \"a ch email\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ngy gi ISO\",\n        date: \"ngy ISO\",\n        time: \"gi ISO\",\n        duration: \"khong thi gian ISO\",\n        ipv4: \"a ch IPv4\",\n        ipv6: \"a ch IPv6\",\n        cidrv4: \"di IPv4\",\n        cidrv6: \"di IPv6\",\n        base64: \"chui m ha base64\",\n        base64url: \"chui m ha base64url\",\n        json_string: \"chui JSON\",\n        e164: \"s E.164\",\n        jwt: \"JWT\",\n        template_literal: \"u vo\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"s\",\n        array: \"mng\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `u vo khng hp l: mong i instanceof ${issue.expected}, nhn c ${received}`;\n                }\n                return `u vo khng hp l: mong i ${expected}, nhn c ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `u vo khng hp l: mong i ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Ty chn khng hp l: mong i mt trong cc gi tr ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Qu ln: mong i ${issue.origin ?? \"gi tr\"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"phn t\"}`;\n                return `Qu ln: mong i ${issue.origin ?? \"gi tr\"} ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Qu nh: mong i ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Qu nh: mong i ${issue.origin} ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Chui khng hp l: phi bt u bng \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Chui khng hp l: phi kt thc bng \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Chui khng hp l: phi bao gm \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Chui khng hp l: phi khp vi mu ${_issue.pattern}`;\n                return `${FormatDictionary[_issue.format] ?? issue.format} khng hp l`;\n            }\n            case \"not_multiple_of\":\n                return `S khng hp l: phi l bi s ca ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Kha khng c nhn dng: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Kha khng hp l trong ${issue.origin}`;\n            case \"invalid_union\":\n                return \"u vo khng hp l\";\n            case \"invalid_element\":\n                return `Gi tr khng hp l trong ${issue.origin}`;\n            default:\n                return `u vo khng hp l`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"mi\", verb: \"n\" },\n        file: { unit: \"bytes\", verb: \"n\" },\n        array: { unit: \"nkan\", verb: \"n\" },\n        set: { unit: \"nkan\", verb: \"n\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"r bwl\",\n        email: \"drs ml\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"kk ISO\",\n        date: \"j ISO\",\n        time: \"kk ISO\",\n        duration: \"kk t p ISO\",\n        ipv4: \"drs IPv4\",\n        ipv6: \"drs IPv6\",\n        cidrv4: \"gbgb IPv4\",\n        cidrv6: \"gbgb IPv6\",\n        base64: \"r t a k n base64\",\n        base64url: \"r base64url\",\n        json_string: \"r JSON\",\n        e164: \"nmb E.164\",\n        jwt: \"JWT\",\n        template_literal: \"r bwl\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"nmb\",\n        array: \"akop\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return `bwl ae: a n lti fi instanceof ${issue.expected}, m a r ${received}`;\n                }\n                return `bwl ae: a n lti fi ${expected}, m a r ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `bwl ae: a n lti fi ${util.stringifyPrimitive(issue.values[0])}`;\n                return `yn ae: yan kan lra ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `T p j: a n lti j p ${issue.origin ?? \"iye\"} ${sizing.verb} ${adj}${issue.maximum} ${sizing.unit}`;\n                return `T p j: a n lti j ${adj}${issue.maximum}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Kr ju: a n lti j p ${issue.origin} ${sizing.verb} ${adj}${issue.minimum} ${sizing.unit}`;\n                return `Kr ju: a n lti j ${adj}${issue.minimum}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `r ae: gbd br pl \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `r ae: gbd par pl \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `r ae: gbd n \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `r ae: gbd b pr mu ${_issue.pattern}`;\n                return `Ae: ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Nmb ae: gbd j y ppn ti ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Btn m: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Btn ae nn ${issue.origin}`;\n            case \"invalid_union\":\n                return \"bwl ae\";\n            case \"invalid_element\":\n                return `Iye ae nn ${issue.origin}`;\n            default:\n                return \"bwl ae\";\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \"\" },\n        file: { unit: \"\", verb: \"\" },\n        array: { unit: \"\", verb: \"\" },\n        set: { unit: \"\", verb: \"\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"\",\n        email: \"\",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO\",\n        date: \"ISO\",\n        time: \"ISO\",\n        duration: \"ISO\",\n        ipv4: \"IPv4\",\n        ipv6: \"IPv6\",\n        cidrv4: \"IPv4\",\n        cidrv6: \"IPv6\",\n        base64: \"base64\",\n        base64url: \"base64url\",\n        json_string: \"JSON\",\n        e164: \"E.164\",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n        number: \"\",\n        array: \"\",\n        null: \"(null)\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return ` instanceof ${issue.expected} ${received}`;\n                }\n                return ` ${expected} ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return ` ${util.stringifyPrimitive(issue.values[0])}`;\n                return ` ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return ` ${issue.origin ?? \"\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n                return ` ${issue.origin ?? \"\"} ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return ` ${issue.origin} ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return ` \"${_issue.prefix}\" `;\n                if (_issue.format === \"ends_with\")\n                    return ` \"${_issue.suffix}\" `;\n                if (_issue.format === \"includes\")\n                    return ` \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return ` ${_issue.pattern}`;\n                return `${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` ${issue.divisor} `;\n            case \"unrecognized_keys\":\n                return `(key): ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `${issue.origin} (key)`;\n            case \"invalid_union\":\n                return \"\";\n            case \"invalid_element\":\n                return `${issue.origin} (value)`;\n            default:\n                return ``;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \"\" },\n        file: { unit: \"\", verb: \"\" },\n        array: { unit: \"\", verb: \"\" },\n        set: { unit: \"\", verb: \"\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const FormatDictionary = {\n        regex: \"\",\n        email: \"\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO \",\n        date: \"ISO \",\n        time: \"ISO \",\n        duration: \"ISO \",\n        ipv4: \"IPv4 \",\n        ipv6: \"IPv6 \",\n        cidrv4: \"IPv4 \",\n        cidrv6: \"IPv6 \",\n        base64: \"base64 \",\n        base64url: \"base64url \",\n        json_string: \"JSON \",\n        e164: \"E.164 \",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    const TypeDictionary = {\n        nan: \"NaN\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                const expected = TypeDictionary[issue.expected] ?? issue.expected;\n                const receivedType = util.parsedType(issue.input);\n                const received = TypeDictionary[receivedType] ?? receivedType;\n                if (/^[A-Z]/.test(issue.expected)) {\n                    return ` instanceof ${issue.expected} ${received}`;\n                }\n                return ` ${expected} ${received}`;\n            }\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return ` ${util.stringifyPrimitive(issue.values[0])}`;\n                return ` ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return ` ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n                return ` ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` ${issue.origin}  ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return ` ${issue.origin}  ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return ` \"${_issue.prefix}\" `;\n                }\n                if (_issue.format === \"ends_with\")\n                    return ` \"${_issue.suffix}\" `;\n                if (_issue.format === \"includes\")\n                    return ` \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return ` ${_issue.pattern}`;\n                return ` ${FormatDictionary[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` ${issue.divisor} `;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"\" : \"\"}${util.joinValues(issue.keys, \"\")}`;\n            case \"invalid_key\":\n                return `${issue.origin} `;\n            case \"invalid_union\":\n                return \"\";\n            case \"invalid_element\":\n                return `${issue.origin} `;\n            default:\n                return ``;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","export { _lt as lt, _lte as lte, _lte as maximum, _gt as gt, _gte as gte, _gte as minimum, _positive as positive, _negative as negative, _nonpositive as nonpositive, _nonnegative as nonnegative, _multipleOf as multipleOf, _maxSize as maxSize, _minSize as minSize, _size as size, _maxLength as maxLength, _minLength as minLength, _length as length, _regex as regex, _lowercase as lowercase, _uppercase as uppercase, _includes as includes, _startsWith as startsWith, _endsWith as endsWith, _property as property, _mime as mime, _overwrite as overwrite, _normalize as normalize, _trim as trim, _toLowerCase as toLowerCase, _toUpperCase as toUpperCase, } from \"../core/index.js\";\n","import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\n// @__NO_SIDE_EFFECTS__\nexport function string(params) {\n    return core._coercedString(schemas.ZodMiniString, params);\n}\n// @__NO_SIDE_EFFECTS__\nexport function number(params) {\n    return core._coercedNumber(schemas.ZodMiniNumber, params);\n}\n// @__NO_SIDE_EFFECTS__\nexport function boolean(params) {\n    return core._coercedBoolean(schemas.ZodMiniBoolean, params);\n}\n// @__NO_SIDE_EFFECTS__\nexport function bigint(params) {\n    return core._coercedBigint(schemas.ZodMiniBigInt, params);\n}\n// @__NO_SIDE_EFFECTS__\nexport function date(params) {\n    return core._coercedDate(schemas.ZodMiniDate, params);\n}\n","export * as core from \"../core/index.js\";\nexport * from \"./parse.js\";\nexport * from \"./schemas.js\";\nexport * from \"./checks.js\";\nexport { globalRegistry, registry, config, $output, $input, $brand, clone, regexes, treeifyError, prettifyError, formatError, flattenError, TimePrecision, util, NEVER, } from \"../core/index.js\";\nexport { toJSONSchema } from \"../core/json-schema-processors.js\";\nexport * as locales from \"../locales/index.js\";\n/** A special constant with type `never` */\n// export const NEVER = {} as never;\n// iso\nexport * as iso from \"./iso.js\";\nexport { ZodMiniISODateTime, ZodMiniISODate, ZodMiniISOTime, ZodMiniISODuration, } from \"./iso.js\";\n// coerce\nexport * as coerce from \"./coerce.js\";\n","import * as z from \"./external.js\";\nexport * from \"./external.js\";\nexport { z };\n","import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\nexport const ZodMiniISODateTime = /*@__PURE__*/ core.$constructor(\"ZodMiniISODateTime\", (inst, def) => {\n    core.$ZodISODateTime.init(inst, def);\n    schemas.ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function datetime(params) {\n    return core._isoDateTime(ZodMiniISODateTime, params);\n}\nexport const ZodMiniISODate = /*@__PURE__*/ core.$constructor(\"ZodMiniISODate\", (inst, def) => {\n    core.$ZodISODate.init(inst, def);\n    schemas.ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function date(params) {\n    return core._isoDate(ZodMiniISODate, params);\n}\nexport const ZodMiniISOTime = /*@__PURE__*/ core.$constructor(\"ZodMiniISOTime\", (inst, def) => {\n    core.$ZodISOTime.init(inst, def);\n    schemas.ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function time(params) {\n    return core._isoTime(ZodMiniISOTime, params);\n}\nexport const ZodMiniISODuration = /*@__PURE__*/ core.$constructor(\"ZodMiniISODuration\", (inst, def) => {\n    core.$ZodISODuration.init(inst, def);\n    schemas.ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function duration(params) {\n    return core._isoDuration(ZodMiniISODuration, params);\n}\n","export { parse, safeParse, parseAsync, safeParseAsync, encode, decode, encodeAsync, decodeAsync, safeEncode, safeDecode, safeEncodeAsync, safeDecodeAsync, } from \"../core/index.js\";\n","import * as core from \"../core/index.js\";\nimport * as util from \"../core/util.js\";\nimport * as parse from \"./parse.js\";\nexport const ZodMiniType = /*@__PURE__*/ core.$constructor(\"ZodMiniType\", (inst, def) => {\n    if (!inst._zod)\n        throw new Error(\"Uninitialized schema in ZodMiniType.\");\n    core.$ZodType.init(inst, def);\n    inst.def = def;\n    inst.type = def.type;\n    inst.parse = (data, params) => parse.parse(inst, data, params, { callee: inst.parse });\n    inst.safeParse = (data, params) => parse.safeParse(inst, data, params);\n    inst.parseAsync = async (data, params) => parse.parseAsync(inst, data, params, { callee: inst.parseAsync });\n    inst.safeParseAsync = async (data, params) => parse.safeParseAsync(inst, data, params);\n    inst.check = (...checks) => {\n        return inst.clone({\n            ...def,\n            checks: [\n                ...(def.checks ?? []),\n                ...checks.map((ch) => typeof ch === \"function\" ? { _zod: { check: ch, def: { check: \"custom\" }, onattach: [] } } : ch),\n            ],\n        }, { parent: true });\n    };\n    inst.with = inst.check;\n    inst.clone = (_def, params) => core.clone(inst, _def, params);\n    inst.brand = () => inst;\n    inst.register = ((reg, meta) => {\n        reg.add(inst, meta);\n        return inst;\n    });\n    inst.apply = (fn) => fn(inst);\n});\nexport const ZodMiniString = /*@__PURE__*/ core.$constructor(\"ZodMiniString\", (inst, def) => {\n    core.$ZodString.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function string(params) {\n    return core._string(ZodMiniString, params);\n}\nexport const ZodMiniStringFormat = /*@__PURE__*/ core.$constructor(\"ZodMiniStringFormat\", (inst, def) => {\n    core.$ZodStringFormat.init(inst, def);\n    ZodMiniString.init(inst, def);\n});\nexport const ZodMiniEmail = /*@__PURE__*/ core.$constructor(\"ZodMiniEmail\", (inst, def) => {\n    core.$ZodEmail.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function email(params) {\n    return core._email(ZodMiniEmail, params);\n}\nexport const ZodMiniGUID = /*@__PURE__*/ core.$constructor(\"ZodMiniGUID\", (inst, def) => {\n    core.$ZodGUID.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function guid(params) {\n    return core._guid(ZodMiniGUID, params);\n}\nexport const ZodMiniUUID = /*@__PURE__*/ core.$constructor(\"ZodMiniUUID\", (inst, def) => {\n    core.$ZodUUID.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function uuid(params) {\n    return core._uuid(ZodMiniUUID, params);\n}\n// @__NO_SIDE_EFFECTS__\nexport function uuidv4(params) {\n    return core._uuidv4(ZodMiniUUID, params);\n}\n// ZodMiniUUIDv6\n// @__NO_SIDE_EFFECTS__\nexport function uuidv6(params) {\n    return core._uuidv6(ZodMiniUUID, params);\n}\n// ZodMiniUUIDv7\n// @__NO_SIDE_EFFECTS__\nexport function uuidv7(params) {\n    return core._uuidv7(ZodMiniUUID, params);\n}\nexport const ZodMiniURL = /*@__PURE__*/ core.$constructor(\"ZodMiniURL\", (inst, def) => {\n    core.$ZodURL.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function url(params) {\n    return core._url(ZodMiniURL, params);\n}\n// @__NO_SIDE_EFFECTS__\nexport function httpUrl(params) {\n    return core._url(ZodMiniURL, {\n        protocol: /^https?$/,\n        hostname: core.regexes.domain,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodMiniEmoji = /*@__PURE__*/ core.$constructor(\"ZodMiniEmoji\", (inst, def) => {\n    core.$ZodEmoji.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function emoji(params) {\n    return core._emoji(ZodMiniEmoji, params);\n}\nexport const ZodMiniNanoID = /*@__PURE__*/ core.$constructor(\"ZodMiniNanoID\", (inst, def) => {\n    core.$ZodNanoID.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function nanoid(params) {\n    return core._nanoid(ZodMiniNanoID, params);\n}\nexport const ZodMiniCUID = /*@__PURE__*/ core.$constructor(\"ZodMiniCUID\", (inst, def) => {\n    core.$ZodCUID.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function cuid(params) {\n    return core._cuid(ZodMiniCUID, params);\n}\nexport const ZodMiniCUID2 = /*@__PURE__*/ core.$constructor(\"ZodMiniCUID2\", (inst, def) => {\n    core.$ZodCUID2.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function cuid2(params) {\n    return core._cuid2(ZodMiniCUID2, params);\n}\nexport const ZodMiniULID = /*@__PURE__*/ core.$constructor(\"ZodMiniULID\", (inst, def) => {\n    core.$ZodULID.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function ulid(params) {\n    return core._ulid(ZodMiniULID, params);\n}\nexport const ZodMiniXID = /*@__PURE__*/ core.$constructor(\"ZodMiniXID\", (inst, def) => {\n    core.$ZodXID.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function xid(params) {\n    return core._xid(ZodMiniXID, params);\n}\nexport const ZodMiniKSUID = /*@__PURE__*/ core.$constructor(\"ZodMiniKSUID\", (inst, def) => {\n    core.$ZodKSUID.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function ksuid(params) {\n    return core._ksuid(ZodMiniKSUID, params);\n}\nexport const ZodMiniIPv4 = /*@__PURE__*/ core.$constructor(\"ZodMiniIPv4\", (inst, def) => {\n    core.$ZodIPv4.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function ipv4(params) {\n    return core._ipv4(ZodMiniIPv4, params);\n}\nexport const ZodMiniIPv6 = /*@__PURE__*/ core.$constructor(\"ZodMiniIPv6\", (inst, def) => {\n    core.$ZodIPv6.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function ipv6(params) {\n    return core._ipv6(ZodMiniIPv6, params);\n}\nexport const ZodMiniCIDRv4 = /*@__PURE__*/ core.$constructor(\"ZodMiniCIDRv4\", (inst, def) => {\n    core.$ZodCIDRv4.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function cidrv4(params) {\n    return core._cidrv4(ZodMiniCIDRv4, params);\n}\nexport const ZodMiniCIDRv6 = /*@__PURE__*/ core.$constructor(\"ZodMiniCIDRv6\", (inst, def) => {\n    core.$ZodCIDRv6.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function cidrv6(params) {\n    return core._cidrv6(ZodMiniCIDRv6, params);\n}\nexport const ZodMiniMAC = /*@__PURE__*/ core.$constructor(\"ZodMiniMAC\", (inst, def) => {\n    core.$ZodMAC.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function mac(params) {\n    return core._mac(ZodMiniMAC, params);\n}\nexport const ZodMiniBase64 = /*@__PURE__*/ core.$constructor(\"ZodMiniBase64\", (inst, def) => {\n    core.$ZodBase64.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function base64(params) {\n    return core._base64(ZodMiniBase64, params);\n}\nexport const ZodMiniBase64URL = /*@__PURE__*/ core.$constructor(\"ZodMiniBase64URL\", (inst, def) => {\n    core.$ZodBase64URL.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function base64url(params) {\n    return core._base64url(ZodMiniBase64URL, params);\n}\nexport const ZodMiniE164 = /*@__PURE__*/ core.$constructor(\"ZodMiniE164\", (inst, def) => {\n    core.$ZodE164.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function e164(params) {\n    return core._e164(ZodMiniE164, params);\n}\nexport const ZodMiniJWT = /*@__PURE__*/ core.$constructor(\"ZodMiniJWT\", (inst, def) => {\n    core.$ZodJWT.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function jwt(params) {\n    return core._jwt(ZodMiniJWT, params);\n}\nexport const ZodMiniCustomStringFormat = /*@__PURE__*/ core.$constructor(\"ZodMiniCustomStringFormat\", (inst, def) => {\n    core.$ZodCustomStringFormat.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function stringFormat(format, fnOrRegex, _params = {}) {\n    return core._stringFormat(ZodMiniCustomStringFormat, format, fnOrRegex, _params);\n}\n// @__NO_SIDE_EFFECTS__\nexport function hostname(_params) {\n    return core._stringFormat(ZodMiniCustomStringFormat, \"hostname\", core.regexes.hostname, _params);\n}\n// @__NO_SIDE_EFFECTS__\nexport function hex(_params) {\n    return core._stringFormat(ZodMiniCustomStringFormat, \"hex\", core.regexes.hex, _params);\n}\n// @__NO_SIDE_EFFECTS__\nexport function hash(alg, params) {\n    const enc = params?.enc ?? \"hex\";\n    const format = `${alg}_${enc}`;\n    const regex = core.regexes[format];\n    // check for unrecognized format\n    if (!regex)\n        throw new Error(`Unrecognized hash format: ${format}`);\n    return core._stringFormat(ZodMiniCustomStringFormat, format, regex, params);\n}\nexport const ZodMiniNumber = /*@__PURE__*/ core.$constructor(\"ZodMiniNumber\", (inst, def) => {\n    core.$ZodNumber.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function number(params) {\n    return core._number(ZodMiniNumber, params);\n}\nexport const ZodMiniNumberFormat = /*@__PURE__*/ core.$constructor(\"ZodMiniNumberFormat\", (inst, def) => {\n    core.$ZodNumberFormat.init(inst, def);\n    ZodMiniNumber.init(inst, def);\n});\n// int\n// @__NO_SIDE_EFFECTS__\nexport function int(params) {\n    return core._int(ZodMiniNumberFormat, params);\n}\n// float32\n// @__NO_SIDE_EFFECTS__\nexport function float32(params) {\n    return core._float32(ZodMiniNumberFormat, params);\n}\n// float64\n// @__NO_SIDE_EFFECTS__\nexport function float64(params) {\n    return core._float64(ZodMiniNumberFormat, params);\n}\n// int32\n// @__NO_SIDE_EFFECTS__\nexport function int32(params) {\n    return core._int32(ZodMiniNumberFormat, params);\n}\n// uint32\n// @__NO_SIDE_EFFECTS__\nexport function uint32(params) {\n    return core._uint32(ZodMiniNumberFormat, params);\n}\nexport const ZodMiniBoolean = /*@__PURE__*/ core.$constructor(\"ZodMiniBoolean\", (inst, def) => {\n    core.$ZodBoolean.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function boolean(params) {\n    return core._boolean(ZodMiniBoolean, params);\n}\nexport const ZodMiniBigInt = /*@__PURE__*/ core.$constructor(\"ZodMiniBigInt\", (inst, def) => {\n    core.$ZodBigInt.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function bigint(params) {\n    return core._bigint(ZodMiniBigInt, params);\n}\nexport const ZodMiniBigIntFormat = /*@__PURE__*/ core.$constructor(\"ZodMiniBigIntFormat\", (inst, def) => {\n    core.$ZodBigIntFormat.init(inst, def);\n    ZodMiniBigInt.init(inst, def);\n});\n// int64\n// @__NO_SIDE_EFFECTS__\nexport function int64(params) {\n    return core._int64(ZodMiniBigIntFormat, params);\n}\n// uint64\n// @__NO_SIDE_EFFECTS__\nexport function uint64(params) {\n    return core._uint64(ZodMiniBigIntFormat, params);\n}\nexport const ZodMiniSymbol = /*@__PURE__*/ core.$constructor(\"ZodMiniSymbol\", (inst, def) => {\n    core.$ZodSymbol.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function symbol(params) {\n    return core._symbol(ZodMiniSymbol, params);\n}\nexport const ZodMiniUndefined = /*@__PURE__*/ core.$constructor(\"ZodMiniUndefined\", (inst, def) => {\n    core.$ZodUndefined.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nfunction _undefined(params) {\n    return core._undefined(ZodMiniUndefined, params);\n}\nexport { _undefined as undefined };\nexport const ZodMiniNull = /*@__PURE__*/ core.$constructor(\"ZodMiniNull\", (inst, def) => {\n    core.$ZodNull.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nfunction _null(params) {\n    return core._null(ZodMiniNull, params);\n}\nexport { _null as null };\nexport const ZodMiniAny = /*@__PURE__*/ core.$constructor(\"ZodMiniAny\", (inst, def) => {\n    core.$ZodAny.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function any() {\n    return core._any(ZodMiniAny);\n}\nexport const ZodMiniUnknown = /*@__PURE__*/ core.$constructor(\"ZodMiniUnknown\", (inst, def) => {\n    core.$ZodUnknown.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function unknown() {\n    return core._unknown(ZodMiniUnknown);\n}\nexport const ZodMiniNever = /*@__PURE__*/ core.$constructor(\"ZodMiniNever\", (inst, def) => {\n    core.$ZodNever.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function never(params) {\n    return core._never(ZodMiniNever, params);\n}\nexport const ZodMiniVoid = /*@__PURE__*/ core.$constructor(\"ZodMiniVoid\", (inst, def) => {\n    core.$ZodVoid.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nfunction _void(params) {\n    return core._void(ZodMiniVoid, params);\n}\nexport { _void as void };\nexport const ZodMiniDate = /*@__PURE__*/ core.$constructor(\"ZodMiniDate\", (inst, def) => {\n    core.$ZodDate.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function date(params) {\n    return core._date(ZodMiniDate, params);\n}\nexport const ZodMiniArray = /*@__PURE__*/ core.$constructor(\"ZodMiniArray\", (inst, def) => {\n    core.$ZodArray.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function array(element, params) {\n    return new ZodMiniArray({\n        type: \"array\",\n        element: element,\n        ...util.normalizeParams(params),\n    });\n}\n// .keyof\n// @__NO_SIDE_EFFECTS__\nexport function keyof(schema) {\n    const shape = schema._zod.def.shape;\n    return _enum(Object.keys(shape));\n}\nexport const ZodMiniObject = /*@__PURE__*/ core.$constructor(\"ZodMiniObject\", (inst, def) => {\n    core.$ZodObject.init(inst, def);\n    ZodMiniType.init(inst, def);\n    util.defineLazy(inst, \"shape\", () => def.shape);\n});\n// @__NO_SIDE_EFFECTS__\nexport function object(shape, params) {\n    const def = {\n        type: \"object\",\n        shape: shape ?? {},\n        ...util.normalizeParams(params),\n    };\n    return new ZodMiniObject(def);\n}\n// strictObject\n// @__NO_SIDE_EFFECTS__\nexport function strictObject(shape, params) {\n    return new ZodMiniObject({\n        type: \"object\",\n        shape,\n        catchall: never(),\n        ...util.normalizeParams(params),\n    });\n}\n// looseObject\n// @__NO_SIDE_EFFECTS__\nexport function looseObject(shape, params) {\n    return new ZodMiniObject({\n        type: \"object\",\n        shape,\n        catchall: unknown(),\n        ...util.normalizeParams(params),\n    });\n}\n// object methods\n// @__NO_SIDE_EFFECTS__\nexport function extend(schema, shape) {\n    return util.extend(schema, shape);\n}\n// @__NO_SIDE_EFFECTS__\nexport function safeExtend(schema, shape) {\n    return util.safeExtend(schema, shape);\n}\n// @__NO_SIDE_EFFECTS__\nexport function merge(schema, shape) {\n    return util.extend(schema, shape);\n}\n// @__NO_SIDE_EFFECTS__\nexport function pick(schema, mask) {\n    return util.pick(schema, mask);\n}\n// .omit\n// @__NO_SIDE_EFFECTS__\nexport function omit(schema, mask) {\n    return util.omit(schema, mask);\n}\n// @__NO_SIDE_EFFECTS__\nexport function partial(schema, mask) {\n    return util.partial(ZodMiniOptional, schema, mask);\n}\n// @__NO_SIDE_EFFECTS__\nexport function required(schema, mask) {\n    return util.required(ZodMiniNonOptional, schema, mask);\n}\n// @__NO_SIDE_EFFECTS__\nexport function catchall(inst, catchall) {\n    return inst.clone({ ...inst._zod.def, catchall: catchall });\n}\nexport const ZodMiniUnion = /*@__PURE__*/ core.$constructor(\"ZodMiniUnion\", (inst, def) => {\n    core.$ZodUnion.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function union(options, params) {\n    return new ZodMiniUnion({\n        type: \"union\",\n        options: options,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodMiniXor = /*@__PURE__*/ core.$constructor(\"ZodMiniXor\", (inst, def) => {\n    ZodMiniUnion.init(inst, def);\n    core.$ZodXor.init(inst, def);\n});\n/** Creates an exclusive union (XOR) where exactly one option must match.\n * Unlike regular unions that succeed when any option matches, xor fails if\n * zero or more than one option matches the input. */\nexport function xor(options, params) {\n    return new ZodMiniXor({\n        type: \"union\",\n        options: options,\n        inclusive: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodMiniDiscriminatedUnion = /*@__PURE__*/ core.$constructor(\"ZodMiniDiscriminatedUnion\", (inst, def) => {\n    core.$ZodDiscriminatedUnion.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function discriminatedUnion(discriminator, options, params) {\n    return new ZodMiniDiscriminatedUnion({\n        type: \"union\",\n        options,\n        discriminator,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodMiniIntersection = /*@__PURE__*/ core.$constructor(\"ZodMiniIntersection\", (inst, def) => {\n    core.$ZodIntersection.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function intersection(left, right) {\n    return new ZodMiniIntersection({\n        type: \"intersection\",\n        left: left,\n        right: right,\n    });\n}\nexport const ZodMiniTuple = /*@__PURE__*/ core.$constructor(\"ZodMiniTuple\", (inst, def) => {\n    core.$ZodTuple.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function tuple(items, _paramsOrRest, _params) {\n    const hasRest = _paramsOrRest instanceof core.$ZodType;\n    const params = hasRest ? _params : _paramsOrRest;\n    const rest = hasRest ? _paramsOrRest : null;\n    return new ZodMiniTuple({\n        type: \"tuple\",\n        items: items,\n        rest,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodMiniRecord = /*@__PURE__*/ core.$constructor(\"ZodMiniRecord\", (inst, def) => {\n    core.$ZodRecord.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function record(keyType, valueType, params) {\n    return new ZodMiniRecord({\n        type: \"record\",\n        keyType,\n        valueType: valueType,\n        ...util.normalizeParams(params),\n    });\n}\n// @__NO_SIDE_EFFECTS__\nexport function partialRecord(keyType, valueType, params) {\n    const k = core.clone(keyType);\n    k._zod.values = undefined;\n    return new ZodMiniRecord({\n        type: \"record\",\n        keyType: k,\n        valueType: valueType,\n        ...util.normalizeParams(params),\n    });\n}\nexport function looseRecord(keyType, valueType, params) {\n    return new ZodMiniRecord({\n        type: \"record\",\n        keyType,\n        valueType: valueType,\n        mode: \"loose\",\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodMiniMap = /*@__PURE__*/ core.$constructor(\"ZodMiniMap\", (inst, def) => {\n    core.$ZodMap.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function map(keyType, valueType, params) {\n    return new ZodMiniMap({\n        type: \"map\",\n        keyType: keyType,\n        valueType: valueType,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodMiniSet = /*@__PURE__*/ core.$constructor(\"ZodMiniSet\", (inst, def) => {\n    core.$ZodSet.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function set(valueType, params) {\n    return new ZodMiniSet({\n        type: \"set\",\n        valueType: valueType,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodMiniEnum = /*@__PURE__*/ core.$constructor(\"ZodMiniEnum\", (inst, def) => {\n    core.$ZodEnum.init(inst, def);\n    ZodMiniType.init(inst, def);\n    inst.options = Object.values(def.entries);\n});\n// @__NO_SIDE_EFFECTS__\nfunction _enum(values, params) {\n    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n    return new ZodMiniEnum({\n        type: \"enum\",\n        entries,\n        ...util.normalizeParams(params),\n    });\n}\nexport { _enum as enum };\n// @__NO_SIDE_EFFECTS__\n/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.\n *\n * ```ts\n * enum Colors { red, green, blue }\n * z.enum(Colors);\n * ```\n */\nexport function nativeEnum(entries, params) {\n    return new ZodMiniEnum({\n        type: \"enum\",\n        entries,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodMiniLiteral = /*@__PURE__*/ core.$constructor(\"ZodMiniLiteral\", (inst, def) => {\n    core.$ZodLiteral.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function literal(value, params) {\n    return new ZodMiniLiteral({\n        type: \"literal\",\n        values: Array.isArray(value) ? value : [value],\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodMiniFile = /*@__PURE__*/ core.$constructor(\"ZodMiniFile\", (inst, def) => {\n    core.$ZodFile.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function file(params) {\n    return core._file(ZodMiniFile, params);\n}\nexport const ZodMiniTransform = /*@__PURE__*/ core.$constructor(\"ZodMiniTransform\", (inst, def) => {\n    core.$ZodTransform.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function transform(fn) {\n    return new ZodMiniTransform({\n        type: \"transform\",\n        transform: fn,\n    });\n}\nexport const ZodMiniOptional = /*@__PURE__*/ core.$constructor(\"ZodMiniOptional\", (inst, def) => {\n    core.$ZodOptional.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function optional(innerType) {\n    return new ZodMiniOptional({\n        type: \"optional\",\n        innerType: innerType,\n    });\n}\nexport const ZodMiniExactOptional = /*@__PURE__*/ core.$constructor(\"ZodMiniExactOptional\", (inst, def) => {\n    core.$ZodExactOptional.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function exactOptional(innerType) {\n    return new ZodMiniExactOptional({\n        type: \"optional\",\n        innerType: innerType,\n    });\n}\nexport const ZodMiniNullable = /*@__PURE__*/ core.$constructor(\"ZodMiniNullable\", (inst, def) => {\n    core.$ZodNullable.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function nullable(innerType) {\n    return new ZodMiniNullable({\n        type: \"nullable\",\n        innerType: innerType,\n    });\n}\n// nullish\n// @__NO_SIDE_EFFECTS__\nexport function nullish(innerType) {\n    return optional(nullable(innerType));\n}\nexport const ZodMiniDefault = /*@__PURE__*/ core.$constructor(\"ZodMiniDefault\", (inst, def) => {\n    core.$ZodDefault.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function _default(innerType, defaultValue) {\n    return new ZodMiniDefault({\n        type: \"default\",\n        innerType: innerType,\n        get defaultValue() {\n            return typeof defaultValue === \"function\" ? defaultValue() : util.shallowClone(defaultValue);\n        },\n    });\n}\nexport const ZodMiniPrefault = /*@__PURE__*/ core.$constructor(\"ZodMiniPrefault\", (inst, def) => {\n    core.$ZodPrefault.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function prefault(innerType, defaultValue) {\n    return new ZodMiniPrefault({\n        type: \"prefault\",\n        innerType: innerType,\n        get defaultValue() {\n            return typeof defaultValue === \"function\" ? defaultValue() : util.shallowClone(defaultValue);\n        },\n    });\n}\nexport const ZodMiniNonOptional = /*@__PURE__*/ core.$constructor(\"ZodMiniNonOptional\", (inst, def) => {\n    core.$ZodNonOptional.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function nonoptional(innerType, params) {\n    return new ZodMiniNonOptional({\n        type: \"nonoptional\",\n        innerType: innerType,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodMiniSuccess = /*@__PURE__*/ core.$constructor(\"ZodMiniSuccess\", (inst, def) => {\n    core.$ZodSuccess.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function success(innerType) {\n    return new ZodMiniSuccess({\n        type: \"success\",\n        innerType: innerType,\n    });\n}\nexport const ZodMiniCatch = /*@__PURE__*/ core.$constructor(\"ZodMiniCatch\", (inst, def) => {\n    core.$ZodCatch.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nfunction _catch(innerType, catchValue) {\n    return new ZodMiniCatch({\n        type: \"catch\",\n        innerType: innerType,\n        catchValue: (typeof catchValue === \"function\" ? catchValue : () => catchValue),\n    });\n}\nexport { _catch as catch };\nexport const ZodMiniNaN = /*@__PURE__*/ core.$constructor(\"ZodMiniNaN\", (inst, def) => {\n    core.$ZodNaN.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function nan(params) {\n    return core._nan(ZodMiniNaN, params);\n}\nexport const ZodMiniPipe = /*@__PURE__*/ core.$constructor(\"ZodMiniPipe\", (inst, def) => {\n    core.$ZodPipe.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function pipe(in_, out) {\n    return new ZodMiniPipe({\n        type: \"pipe\",\n        in: in_,\n        out: out,\n    });\n}\nexport const ZodMiniCodec = /*@__PURE__*/ core.$constructor(\"ZodMiniCodec\", (inst, def) => {\n    ZodMiniPipe.init(inst, def);\n    core.$ZodCodec.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function codec(in_, out, params) {\n    return new ZodMiniCodec({\n        type: \"pipe\",\n        in: in_,\n        out: out,\n        transform: params.decode,\n        reverseTransform: params.encode,\n    });\n}\nexport const ZodMiniReadonly = /*@__PURE__*/ core.$constructor(\"ZodMiniReadonly\", (inst, def) => {\n    core.$ZodReadonly.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function readonly(innerType) {\n    return new ZodMiniReadonly({\n        type: \"readonly\",\n        innerType: innerType,\n    });\n}\nexport const ZodMiniTemplateLiteral = /*@__PURE__*/ core.$constructor(\"ZodMiniTemplateLiteral\", (inst, def) => {\n    core.$ZodTemplateLiteral.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function templateLiteral(parts, params) {\n    return new ZodMiniTemplateLiteral({\n        type: \"template_literal\",\n        parts,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodMiniLazy = /*@__PURE__*/ core.$constructor(\"ZodMiniLazy\", (inst, def) => {\n    core.$ZodLazy.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// export function lazy<T extends object>(getter: () => T): T {\n//   return util.createTransparentProxy<T>(getter);\n// }\n// @__NO_SIDE_EFFECTS__\nfunction _lazy(getter) {\n    return new ZodMiniLazy({\n        type: \"lazy\",\n        getter: getter,\n    });\n}\nexport { _lazy as lazy };\nexport const ZodMiniPromise = /*@__PURE__*/ core.$constructor(\"ZodMiniPromise\", (inst, def) => {\n    core.$ZodPromise.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function promise(innerType) {\n    return new ZodMiniPromise({\n        type: \"promise\",\n        innerType: innerType,\n    });\n}\nexport const ZodMiniCustom = /*@__PURE__*/ core.$constructor(\"ZodMiniCustom\", (inst, def) => {\n    core.$ZodCustom.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// custom checks\n// @__NO_SIDE_EFFECTS__\nexport function check(fn, params) {\n    const ch = new core.$ZodCheck({\n        check: \"custom\",\n        ...util.normalizeParams(params),\n    });\n    ch._zod.check = fn;\n    return ch;\n}\n// ZodCustom\n// custom schema\n// @__NO_SIDE_EFFECTS__\nexport function custom(fn, _params) {\n    return core._custom(ZodMiniCustom, fn ?? (() => true), _params);\n}\n// refine\n// @__NO_SIDE_EFFECTS__\nexport function refine(fn, _params = {}) {\n    return core._refine(ZodMiniCustom, fn, _params);\n}\n// superRefine\n// @__NO_SIDE_EFFECTS__\nexport function superRefine(fn) {\n    return core._superRefine(fn);\n}\n// Re-export describe and meta from core\nexport const describe = core.describe;\nexport const meta = core.meta;\n// instanceof\nclass Class {\n    constructor(..._args) { }\n}\n// @__NO_SIDE_EFFECTS__\nfunction _instanceof(cls, params = {}) {\n    const inst = custom((data) => data instanceof cls, params);\n    inst._zod.bag.Class = cls;\n    // Override check to emit invalid_type instead of custom\n    inst._zod.check = (payload) => {\n        if (!(payload.value instanceof cls)) {\n            payload.issues.push({\n                code: \"invalid_type\",\n                expected: cls.name,\n                input: payload.value,\n                inst,\n                path: [...(inst._zod.def.path ?? [])],\n            });\n        }\n    };\n    return inst;\n}\nexport { _instanceof as instanceof };\n// stringbool\nexport const stringbool = (...args) => core._stringbool({\n    Codec: ZodMiniCodec,\n    Boolean: ZodMiniBoolean,\n    String: ZodMiniString,\n}, ...args);\n// @__NO_SIDE_EFFECTS__\nexport function json() {\n    const jsonSchema = _lazy(() => {\n        return union([string(), number(), boolean(), _null(), array(jsonSchema), record(string(), jsonSchema)]);\n    });\n    return jsonSchema;\n}\nexport const ZodMiniFunction = /*@__PURE__*/ core.$constructor(\"ZodMiniFunction\", (inst, def) => {\n    core.$ZodFunction.init(inst, def);\n    ZodMiniType.init(inst, def);\n});\n// @__NO_SIDE_EFFECTS__\nexport function _function(params) {\n    return new ZodMiniFunction({\n        type: \"function\",\n        input: Array.isArray(params?.input) ? tuple(params?.input) : (params?.input ?? array(unknown())),\n        output: params?.output ?? unknown(),\n    });\n}\nexport { _function as function };\n","/**\n * WordPress dependencies\n */\nimport { SVG, Path } from '@wordpress/primitives';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst check = /*#__PURE__*/_jsx(SVG, {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  viewBox: \"0 0 24 24\",\n  children: /*#__PURE__*/_jsx(Path, {\n    d: \"M16.7 7.1l-6.3 8.5-3.3-2.5-.9 1.2 4.5 3.4L17.9 8z\"\n  })\n});\nexport default check;\n//# sourceMappingURL=check.js.map","/**\n * WordPress dependencies\n */\nimport { SVG, Path } from '@wordpress/primitives';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst closeSmall = /*#__PURE__*/_jsx(SVG, {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  viewBox: \"0 0 24 24\",\n  children: /*#__PURE__*/_jsx(Path, {\n    d: \"M12 13.06l3.712 3.713 1.061-1.06L13.061 12l3.712-3.712-1.06-1.06L12 10.938 8.288 7.227l-1.061 1.06L10.939 12l-3.712 3.712 1.06 1.061L12 13.061z\"\n  })\n});\nexport default closeSmall;\n//# sourceMappingURL=close-small.js.map","/**\n * WordPress dependencies\n */\nimport { SVG, Path } from '@wordpress/primitives';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst starEmpty = /*#__PURE__*/_jsx(SVG, {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  viewBox: \"0 0 24 24\",\n  children: /*#__PURE__*/_jsx(Path, {\n    fillRule: \"evenodd\",\n    d: \"M9.706 8.646a.25.25 0 01-.188.137l-4.626.672a.25.25 0 00-.139.427l3.348 3.262a.25.25 0 01.072.222l-.79 4.607a.25.25 0 00.362.264l4.138-2.176a.25.25 0 01.233 0l4.137 2.175a.25.25 0 00.363-.263l-.79-4.607a.25.25 0 01.072-.222l3.347-3.262a.25.25 0 00-.139-.427l-4.626-.672a.25.25 0 01-.188-.137l-2.069-4.192a.25.25 0 00-.448 0L9.706 8.646zM12 7.39l-.948 1.921a1.75 1.75 0 01-1.317.957l-2.12.308 1.534 1.495c.412.402.6.982.503 1.55l-.362 2.11 1.896-.997a1.75 1.75 0 011.629 0l1.895.997-.362-2.11a1.75 1.75 0 01.504-1.55l1.533-1.495-2.12-.308a1.75 1.75 0 01-1.317-.957L12 7.39z\",\n    clipRule: \"evenodd\"\n  })\n});\nexport default starEmpty;\n//# sourceMappingURL=star-empty.js.map","/**\n * WordPress dependencies\n */\nimport { SVG, Path } from '@wordpress/primitives';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst starFilled = /*#__PURE__*/_jsx(SVG, {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  viewBox: \"0 0 24 24\",\n  children: /*#__PURE__*/_jsx(Path, {\n    d: \"M11.776 4.454a.25.25 0 01.448 0l2.069 4.192a.25.25 0 00.188.137l4.626.672a.25.25 0 01.139.426l-3.348 3.263a.25.25 0 00-.072.222l.79 4.607a.25.25 0 01-.362.263l-4.138-2.175a.25.25 0 00-.232 0l-4.138 2.175a.25.25 0 01-.363-.263l.79-4.607a.25.25 0 00-.071-.222L4.754 9.881a.25.25 0 01.139-.426l4.626-.672a.25.25 0 00.188-.137l2.069-4.192z\"\n  })\n});\nexport default starFilled;\n//# sourceMappingURL=star-filled.js.map","/**\n * WordPress dependencies\n */\nimport { ButtonGroup, Button, Slot, Fill } from '@wordpress/components';\nimport { Children } from '@wordpress/element';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst noop = () => {};\nfunction ActionItemSlot({\n  name,\n  as: Component = ButtonGroup,\n  fillProps = {},\n  bubblesVirtually,\n  ...props\n}) {\n  return /*#__PURE__*/_jsx(Slot, {\n    name: name,\n    bubblesVirtually: bubblesVirtually,\n    fillProps: fillProps,\n    children: fills => {\n      if (!Children.toArray(fills).length) {\n        return null;\n      }\n\n      // Special handling exists for backward compatibility.\n      // It ensures that menu items created by plugin authors aren't\n      // duplicated with automatically injected menu items coming\n      // from pinnable plugin sidebars.\n      // @see https://github.com/WordPress/gutenberg/issues/14457\n      const initializedByPlugins = [];\n      Children.forEach(fills, ({\n        props: {\n          __unstableExplicitMenuItem,\n          __unstableTarget\n        }\n      }) => {\n        if (__unstableTarget && __unstableExplicitMenuItem) {\n          initializedByPlugins.push(__unstableTarget);\n        }\n      });\n      const children = Children.map(fills, child => {\n        if (!child.props.__unstableExplicitMenuItem && initializedByPlugins.includes(child.props.__unstableTarget)) {\n          return null;\n        }\n        return child;\n      });\n      return /*#__PURE__*/_jsx(Component, {\n        ...props,\n        children: children\n      });\n    }\n  });\n}\nfunction ActionItem({\n  name,\n  as: Component = Button,\n  onClick,\n  ...props\n}) {\n  return /*#__PURE__*/_jsx(Fill, {\n    name: name,\n    children: ({\n      onClick: fpOnClick\n    }) => {\n      return /*#__PURE__*/_jsx(Component, {\n        onClick: onClick || fpOnClick ? (...args) => {\n          (onClick || noop)(...args);\n          (fpOnClick || noop)(...args);\n        } : undefined,\n        ...props\n      });\n    }\n  });\n}\nActionItem.Slot = ActionItemSlot;\nexport default ActionItem;\n//# sourceMappingURL=index.js.map","/**\n * WordPress dependencies\n */\nimport { withPluginContext } from '@wordpress/plugins';\nexport default withPluginContext((context, ownProps) => {\n  return {\n    icon: ownProps.icon || context.icon,\n    identifier: ownProps.identifier || `${context.name}/${ownProps.name}`\n  };\n});\n//# sourceMappingURL=index.js.map","/**\n * External dependencies\n */\nimport clsx from 'clsx';\n\n/**\n * WordPress dependencies\n */\nimport { closeSmall } from '@wordpress/icons';\n\n/**\n * Internal dependencies\n */\nimport ComplementaryAreaToggle from '../complementary-area-toggle';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nconst ComplementaryAreaHeader = ({\n  smallScreenTitle,\n  children,\n  className,\n  toggleButtonProps\n}) => {\n  const toggleButton = /*#__PURE__*/_jsx(ComplementaryAreaToggle, {\n    icon: closeSmall,\n    ...toggleButtonProps\n  });\n  return /*#__PURE__*/_jsxs(_Fragment, {\n    children: [/*#__PURE__*/_jsxs(\"div\", {\n      className: \"components-panel__header interface-complementary-area-header__small\",\n      children: [smallScreenTitle && /*#__PURE__*/_jsx(\"h2\", {\n        className: \"interface-complementary-area-header__small-title\",\n        children: smallScreenTitle\n      }), toggleButton]\n    }), /*#__PURE__*/_jsxs(\"div\", {\n      className: clsx('components-panel__header', 'interface-complementary-area-header', className),\n      tabIndex: -1,\n      children: [children, toggleButton]\n    })]\n  });\n};\nexport default ComplementaryAreaHeader;\n//# sourceMappingURL=index.js.map","/**\n * WordPress dependencies\n */\nimport { check } from '@wordpress/icons';\nimport { MenuItem } from '@wordpress/components';\n\n/**\n * Internal dependencies\n */\nimport ComplementaryAreaToggle from '../complementary-area-toggle';\nimport ActionItem from '../action-item';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst PluginsMenuItem = ({\n  // Menu item is marked with unstable prop for backward compatibility.\n  // They are removed so they don't leak to DOM elements.\n  // @see https://github.com/WordPress/gutenberg/issues/14457\n  __unstableExplicitMenuItem,\n  __unstableTarget,\n  ...restProps\n}) => /*#__PURE__*/_jsx(MenuItem, {\n  ...restProps\n});\nexport default function ComplementaryAreaMoreMenuItem({\n  scope,\n  target,\n  __unstableExplicitMenuItem,\n  ...props\n}) {\n  return /*#__PURE__*/_jsx(ComplementaryAreaToggle, {\n    as: toggleProps => {\n      return /*#__PURE__*/_jsx(ActionItem, {\n        __unstableExplicitMenuItem: __unstableExplicitMenuItem,\n        __unstableTarget: `${scope}/${target}`,\n        as: PluginsMenuItem,\n        name: `${scope}/plugin-more-menu`,\n        ...toggleProps\n      });\n    },\n    role: \"menuitemcheckbox\",\n    selectedIcon: check,\n    name: target,\n    scope: scope,\n    ...props\n  });\n}\n//# sourceMappingURL=index.js.map","/**\n * WordPress dependencies\n */\nimport { Button } from '@wordpress/components';\nimport { useDispatch, useSelect } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport { store as interfaceStore } from '../../store';\nimport complementaryAreaContext from '../complementary-area-context';\n\n/**\n * Whether the role supports checked state.\n *\n * @param {import('react').AriaRole} role Role.\n * @return {boolean} Whether the role supports checked state.\n * @see https://www.w3.org/TR/wai-aria-1.1/#aria-checked\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction roleSupportsCheckedState(role) {\n  return ['checkbox', 'option', 'radio', 'switch', 'menuitemcheckbox', 'menuitemradio', 'treeitem'].includes(role);\n}\nfunction ComplementaryAreaToggle({\n  as = Button,\n  scope,\n  identifier,\n  icon,\n  selectedIcon,\n  name,\n  shortcut,\n  ...props\n}) {\n  const ComponentToUse = as;\n  const isSelected = useSelect(select => select(interfaceStore).getActiveComplementaryArea(scope) === identifier, [identifier, scope]);\n  const {\n    enableComplementaryArea,\n    disableComplementaryArea\n  } = useDispatch(interfaceStore);\n  return /*#__PURE__*/_jsx(ComponentToUse, {\n    icon: selectedIcon && isSelected ? selectedIcon : icon,\n    \"aria-controls\": identifier.replace('/', ':')\n    // Make sure aria-checked matches spec https://www.w3.org/TR/wai-aria-1.1/#aria-checked\n    ,\n    \"aria-checked\": roleSupportsCheckedState(props.role) ? isSelected : undefined,\n    onClick: () => {\n      if (isSelected) {\n        disableComplementaryArea(scope);\n      } else {\n        enableComplementaryArea(scope, identifier);\n      }\n    },\n    shortcut: shortcut,\n    ...props\n  });\n}\nexport default complementaryAreaContext(ComplementaryAreaToggle);\n//# sourceMappingURL=index.js.map","/**\n * External dependencies\n */\nimport clsx from 'clsx';\n\n/**\n * WordPress dependencies\n */\nimport { Button, Panel, Slot, Fill, __unstableMotion as motion, __unstableAnimatePresence as AnimatePresence } from '@wordpress/components';\nimport { useDispatch, useSelect } from '@wordpress/data';\nimport { __ } from '@wordpress/i18n';\nimport { check, starEmpty, starFilled } from '@wordpress/icons';\nimport { useEffect, useRef, useState } from '@wordpress/element';\nimport { store as viewportStore } from '@wordpress/viewport';\nimport { store as preferencesStore } from '@wordpress/preferences';\nimport { useReducedMotion, useViewportMatch, usePrevious } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport ComplementaryAreaHeader from '../complementary-area-header';\nimport ComplementaryAreaMoreMenuItem from '../complementary-area-more-menu-item';\nimport ComplementaryAreaToggle from '../complementary-area-toggle';\nimport withComplementaryAreaContext from '../complementary-area-context';\nimport PinnedItems from '../pinned-items';\nimport { store as interfaceStore } from '../../store';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nconst ANIMATION_DURATION = 0.3;\nfunction ComplementaryAreaSlot({\n  scope,\n  ...props\n}) {\n  return /*#__PURE__*/_jsx(Slot, {\n    name: `ComplementaryArea/${scope}`,\n    ...props\n  });\n}\nconst SIDEBAR_WIDTH = 280;\nconst variants = {\n  open: {\n    width: SIDEBAR_WIDTH\n  },\n  closed: {\n    width: 0\n  },\n  mobileOpen: {\n    width: '100vw'\n  }\n};\nfunction ComplementaryAreaFill({\n  activeArea,\n  isActive,\n  scope,\n  children,\n  className,\n  id\n}) {\n  const disableMotion = useReducedMotion();\n  const isMobileViewport = useViewportMatch('medium', '<');\n  // This is used to delay the exit animation to the next tick.\n  // The reason this is done is to allow us to apply the right transition properties\n  // When we switch from an open sidebar to another open sidebar.\n  // we don't want to animate in this case.\n  const previousActiveArea = usePrevious(activeArea);\n  const previousIsActive = usePrevious(isActive);\n  const [, setState] = useState({});\n  useEffect(() => {\n    setState({});\n  }, [isActive]);\n  const transition = {\n    type: 'tween',\n    duration: disableMotion || isMobileViewport || !!previousActiveArea && !!activeArea && activeArea !== previousActiveArea ? 0 : ANIMATION_DURATION,\n    ease: [0.6, 0, 0.4, 1]\n  };\n  return /*#__PURE__*/_jsx(Fill, {\n    name: `ComplementaryArea/${scope}`,\n    children: /*#__PURE__*/_jsx(AnimatePresence, {\n      initial: false,\n      children: (previousIsActive || isActive) && /*#__PURE__*/_jsx(motion.div, {\n        variants: variants,\n        initial: \"closed\",\n        animate: isMobileViewport ? 'mobileOpen' : 'open',\n        exit: \"closed\",\n        transition: transition,\n        className: \"interface-complementary-area__fill\",\n        children: /*#__PURE__*/_jsx(\"div\", {\n          id: id,\n          className: className,\n          style: {\n            width: isMobileViewport ? '100vw' : SIDEBAR_WIDTH\n          },\n          children: children\n        })\n      })\n    })\n  });\n}\nfunction useAdjustComplementaryListener(scope, identifier, activeArea, isActive, isSmall) {\n  const previousIsSmallRef = useRef(false);\n  const shouldOpenWhenNotSmallRef = useRef(false);\n  const {\n    enableComplementaryArea,\n    disableComplementaryArea\n  } = useDispatch(interfaceStore);\n  useEffect(() => {\n    // If the complementary area is active and the editor is switching from\n    // a big to a small window size.\n    if (isActive && isSmall && !previousIsSmallRef.current) {\n      disableComplementaryArea(scope);\n      // Flag the complementary area to be reopened when the window size\n      // goes from small to big.\n      shouldOpenWhenNotSmallRef.current = true;\n    } else if (\n    // If there is a flag indicating the complementary area should be\n    // enabled when we go from small to big window size and we are going\n    // from a small to big window size.\n    shouldOpenWhenNotSmallRef.current && !isSmall && previousIsSmallRef.current) {\n      // Remove the flag indicating the complementary area should be\n      // enabled.\n      shouldOpenWhenNotSmallRef.current = false;\n      enableComplementaryArea(scope, identifier);\n    } else if (\n    // If the flag is indicating the current complementary should be\n    // reopened but another complementary area becomes active, remove\n    // the flag.\n    shouldOpenWhenNotSmallRef.current && activeArea && activeArea !== identifier) {\n      shouldOpenWhenNotSmallRef.current = false;\n    }\n    if (isSmall !== previousIsSmallRef.current) {\n      previousIsSmallRef.current = isSmall;\n    }\n  }, [isActive, isSmall, scope, identifier, activeArea, disableComplementaryArea, enableComplementaryArea]);\n}\nfunction ComplementaryArea({\n  children,\n  className,\n  closeLabel = __('Close plugin'),\n  identifier,\n  header,\n  headerClassName,\n  icon,\n  isPinnable = true,\n  panelClassName,\n  scope,\n  name,\n  smallScreenTitle,\n  title,\n  toggleShortcut,\n  isActiveByDefault\n}) {\n  // This state is used to delay the rendering of the Fill\n  // until the initial effect runs.\n  // This prevents the animation from running on mount if\n  // the complementary area is active by default.\n  const [isReady, setIsReady] = useState(false);\n  const {\n    isLoading,\n    isActive,\n    isPinned,\n    activeArea,\n    isSmall,\n    isLarge,\n    showIconLabels\n  } = useSelect(select => {\n    const {\n      getActiveComplementaryArea,\n      isComplementaryAreaLoading,\n      isItemPinned\n    } = select(interfaceStore);\n    const {\n      get\n    } = select(preferencesStore);\n    const _activeArea = getActiveComplementaryArea(scope);\n    return {\n      isLoading: isComplementaryAreaLoading(scope),\n      isActive: _activeArea === identifier,\n      isPinned: isItemPinned(scope, identifier),\n      activeArea: _activeArea,\n      isSmall: select(viewportStore).isViewportMatch('< medium'),\n      isLarge: select(viewportStore).isViewportMatch('large'),\n      showIconLabels: get('core', 'showIconLabels')\n    };\n  }, [identifier, scope]);\n  useAdjustComplementaryListener(scope, identifier, activeArea, isActive, isSmall);\n  const {\n    enableComplementaryArea,\n    disableComplementaryArea,\n    pinItem,\n    unpinItem\n  } = useDispatch(interfaceStore);\n  useEffect(() => {\n    // Set initial visibility: For large screens, enable if it's active by\n    // default. For small screens, always initially disable.\n    if (isActiveByDefault && activeArea === undefined && !isSmall) {\n      enableComplementaryArea(scope, identifier);\n    } else if (activeArea === undefined && isSmall) {\n      disableComplementaryArea(scope, identifier);\n    }\n    setIsReady(true);\n  }, [activeArea, isActiveByDefault, scope, identifier, isSmall, enableComplementaryArea, disableComplementaryArea]);\n  if (!isReady) {\n    return;\n  }\n  return /*#__PURE__*/_jsxs(_Fragment, {\n    children: [isPinnable && /*#__PURE__*/_jsx(PinnedItems, {\n      scope: scope,\n      children: isPinned && /*#__PURE__*/_jsx(ComplementaryAreaToggle, {\n        scope: scope,\n        identifier: identifier,\n        isPressed: isActive && (!showIconLabels || isLarge),\n        \"aria-expanded\": isActive,\n        \"aria-disabled\": isLoading,\n        label: title,\n        icon: showIconLabels ? check : icon,\n        showTooltip: !showIconLabels,\n        variant: showIconLabels ? 'tertiary' : undefined,\n        size: \"compact\",\n        shortcut: toggleShortcut\n      })\n    }), name && isPinnable && /*#__PURE__*/_jsx(ComplementaryAreaMoreMenuItem, {\n      target: name,\n      scope: scope,\n      icon: icon,\n      children: title\n    }), /*#__PURE__*/_jsxs(ComplementaryAreaFill, {\n      activeArea: activeArea,\n      isActive: isActive,\n      className: clsx('interface-complementary-area', className),\n      scope: scope,\n      id: identifier.replace('/', ':'),\n      children: [/*#__PURE__*/_jsx(ComplementaryAreaHeader, {\n        className: headerClassName,\n        closeLabel: closeLabel,\n        onClose: () => disableComplementaryArea(scope),\n        smallScreenTitle: smallScreenTitle,\n        toggleButtonProps: {\n          label: closeLabel,\n          size: 'small',\n          shortcut: toggleShortcut,\n          scope,\n          identifier\n        },\n        children: header || /*#__PURE__*/_jsxs(_Fragment, {\n          children: [/*#__PURE__*/_jsx(\"h2\", {\n            className: \"interface-complementary-area-header__title\",\n            children: title\n          }), isPinnable && /*#__PURE__*/_jsx(Button, {\n            className: \"interface-complementary-area__pin-unpin-item\",\n            icon: isPinned ? starFilled : starEmpty,\n            label: isPinned ? __('Unpin from toolbar') : __('Pin to toolbar'),\n            onClick: () => (isPinned ? unpinItem : pinItem)(scope, identifier),\n            isPressed: isPinned,\n            \"aria-expanded\": isPinned,\n            size: \"compact\"\n          })]\n        })\n      }), /*#__PURE__*/_jsx(Panel, {\n        className: panelClassName,\n        children: children\n      })]\n    })]\n  });\n}\nconst ComplementaryAreaWrapped = withComplementaryAreaContext(ComplementaryArea);\nComplementaryAreaWrapped.Slot = ComplementaryAreaSlot;\nexport default ComplementaryAreaWrapped;\n//# sourceMappingURL=index.js.map","/**\n * WordPress dependencies\n */\nimport { useEffect } from '@wordpress/element';\nconst FullscreenMode = ({\n  isActive\n}) => {\n  useEffect(() => {\n    let isSticky = false;\n    // `is-fullscreen-mode` is set in PHP as a body class by Gutenberg, and this causes\n    // `sticky-menu` to be applied by WordPress and prevents the admin menu being scrolled\n    // even if `is-fullscreen-mode` is then removed. Let's remove `sticky-menu` here as\n    // a consequence of the FullscreenMode setup.\n    if (document.body.classList.contains('sticky-menu')) {\n      isSticky = true;\n      document.body.classList.remove('sticky-menu');\n    }\n    return () => {\n      if (isSticky) {\n        document.body.classList.add('sticky-menu');\n      }\n    };\n  }, []);\n  useEffect(() => {\n    if (isActive) {\n      document.body.classList.add('is-fullscreen-mode');\n    } else {\n      document.body.classList.remove('is-fullscreen-mode');\n    }\n    return () => {\n      if (isActive) {\n        document.body.classList.remove('is-fullscreen-mode');\n      }\n    };\n  }, [isActive]);\n  return null;\n};\nexport default FullscreenMode;\n//# sourceMappingURL=index.js.map","export { default as ComplementaryArea } from './complementary-area';\nexport { default as ComplementaryAreaMoreMenuItem } from './complementary-area-more-menu-item';\nexport { default as FullscreenMode } from './fullscreen-mode';\nexport { default as InterfaceSkeleton } from './interface-skeleton';\nexport { default as PinnedItems } from './pinned-items';\nexport { default as ActionItem } from './action-item';\nexport { default as NavigableRegion } from './navigable-region';\n//# sourceMappingURL=index.js.map","/**\n * External dependencies\n */\nimport clsx from 'clsx';\n\n/**\n * WordPress dependencies\n */\nimport { forwardRef, useEffect } from '@wordpress/element';\nimport { __unstableUseNavigateRegions as useNavigateRegions, __unstableMotion as motion, __unstableAnimatePresence as AnimatePresence } from '@wordpress/components';\nimport { __, _x } from '@wordpress/i18n';\nimport { useMergeRefs, useReducedMotion, useViewportMatch, useResizeObserver } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport NavigableRegion from '../navigable-region';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nconst ANIMATION_DURATION = 0.25;\nconst commonTransition = {\n  type: 'tween',\n  duration: ANIMATION_DURATION,\n  ease: [0.6, 0, 0.4, 1]\n};\nfunction useHTMLClass(className) {\n  useEffect(() => {\n    const element = document && document.querySelector(`html:not(.${className})`);\n    if (!element) {\n      return;\n    }\n    element.classList.toggle(className);\n    return () => {\n      element.classList.toggle(className);\n    };\n  }, [className]);\n}\nconst headerVariants = {\n  hidden: {\n    opacity: 1,\n    marginTop: -60\n  },\n  visible: {\n    opacity: 1,\n    marginTop: 0\n  },\n  distractionFreeHover: {\n    opacity: 1,\n    marginTop: 0,\n    transition: {\n      ...commonTransition,\n      delay: 0.2,\n      delayChildren: 0.2\n    }\n  },\n  distractionFreeHidden: {\n    opacity: 0,\n    marginTop: -60\n  },\n  distractionFreeDisabled: {\n    opacity: 0,\n    marginTop: 0,\n    transition: {\n      ...commonTransition,\n      delay: 0.8,\n      delayChildren: 0.8\n    }\n  }\n};\nfunction InterfaceSkeleton({\n  isDistractionFree,\n  footer,\n  header,\n  editorNotices,\n  sidebar,\n  secondarySidebar,\n  content,\n  actions,\n  labels,\n  className,\n  enableRegionNavigation = true,\n  // Todo: does this need to be a prop.\n  // Can we use a dependency to keyboard-shortcuts directly?\n  shortcuts\n}, ref) {\n  const [secondarySidebarResizeListener, secondarySidebarSize] = useResizeObserver();\n  const isMobileViewport = useViewportMatch('medium', '<');\n  const disableMotion = useReducedMotion();\n  const defaultTransition = {\n    type: 'tween',\n    duration: disableMotion ? 0 : ANIMATION_DURATION,\n    ease: [0.6, 0, 0.4, 1]\n  };\n  const navigateRegionsProps = useNavigateRegions(shortcuts);\n  useHTMLClass('interface-interface-skeleton__html-container');\n  const defaultLabels = {\n    /* translators: accessibility text for the top bar landmark region. */\n    header: _x('Header', 'header landmark area'),\n    /* translators: accessibility text for the content landmark region. */\n    body: __('Content'),\n    /* translators: accessibility text for the secondary sidebar landmark region. */\n    secondarySidebar: __('Block Library'),\n    /* translators: accessibility text for the settings landmark region. */\n    sidebar: __('Settings'),\n    /* translators: accessibility text for the publish landmark region. */\n    actions: __('Publish'),\n    /* translators: accessibility text for the footer landmark region. */\n    footer: __('Footer')\n  };\n  const mergedLabels = {\n    ...defaultLabels,\n    ...labels\n  };\n  return /*#__PURE__*/_jsxs(\"div\", {\n    ...(enableRegionNavigation ? navigateRegionsProps : {}),\n    ref: useMergeRefs([ref, enableRegionNavigation ? navigateRegionsProps.ref : undefined]),\n    className: clsx(className, 'interface-interface-skeleton', navigateRegionsProps.className, !!footer && 'has-footer'),\n    children: [/*#__PURE__*/_jsxs(\"div\", {\n      className: \"interface-interface-skeleton__editor\",\n      children: [/*#__PURE__*/_jsx(AnimatePresence, {\n        initial: false,\n        children: !!header && /*#__PURE__*/_jsx(NavigableRegion, {\n          as: motion.div,\n          className: \"interface-interface-skeleton__header\",\n          \"aria-label\": mergedLabels.header,\n          initial: isDistractionFree && !isMobileViewport ? 'distractionFreeHidden' : 'hidden',\n          whileHover: isDistractionFree && !isMobileViewport ? 'distractionFreeHover' : 'visible',\n          animate: isDistractionFree && !isMobileViewport ? 'distractionFreeDisabled' : 'visible',\n          exit: isDistractionFree && !isMobileViewport ? 'distractionFreeHidden' : 'hidden',\n          variants: headerVariants,\n          transition: defaultTransition,\n          children: header\n        })\n      }), isDistractionFree && /*#__PURE__*/_jsx(\"div\", {\n        className: \"interface-interface-skeleton__header\",\n        children: editorNotices\n      }), /*#__PURE__*/_jsxs(\"div\", {\n        className: \"interface-interface-skeleton__body\",\n        children: [/*#__PURE__*/_jsx(AnimatePresence, {\n          initial: false,\n          children: !!secondarySidebar && /*#__PURE__*/_jsx(NavigableRegion, {\n            className: \"interface-interface-skeleton__secondary-sidebar\",\n            ariaLabel: mergedLabels.secondarySidebar,\n            as: motion.div,\n            initial: \"closed\",\n            animate: \"open\",\n            exit: \"closed\",\n            variants: {\n              open: {\n                width: secondarySidebarSize.width\n              },\n              closed: {\n                width: 0\n              }\n            },\n            transition: defaultTransition,\n            children: /*#__PURE__*/_jsxs(motion.div, {\n              style: {\n                position: 'absolute',\n                width: isMobileViewport ? '100vw' : 'fit-content',\n                height: '100%',\n                left: 0\n              },\n              variants: {\n                open: {\n                  x: 0\n                },\n                closed: {\n                  x: '-100%'\n                }\n              },\n              transition: defaultTransition,\n              children: [secondarySidebarResizeListener, secondarySidebar]\n            })\n          })\n        }), /*#__PURE__*/_jsx(NavigableRegion, {\n          className: \"interface-interface-skeleton__content\",\n          ariaLabel: mergedLabels.body,\n          children: content\n        }), !!sidebar && /*#__PURE__*/_jsx(NavigableRegion, {\n          className: \"interface-interface-skeleton__sidebar\",\n          ariaLabel: mergedLabels.sidebar,\n          children: sidebar\n        }), !!actions && /*#__PURE__*/_jsx(NavigableRegion, {\n          className: \"interface-interface-skeleton__actions\",\n          ariaLabel: mergedLabels.actions,\n          children: actions\n        })]\n      })]\n    }), !!footer && /*#__PURE__*/_jsx(NavigableRegion, {\n      className: \"interface-interface-skeleton__footer\",\n      ariaLabel: mergedLabels.footer,\n      children: footer\n    })]\n  });\n}\nexport default forwardRef(InterfaceSkeleton);\n//# sourceMappingURL=index.js.map","/**\n * External dependencies\n */\nimport clsx from 'clsx';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default function NavigableRegion({\n  children,\n  className,\n  ariaLabel,\n  as: Tag = 'div',\n  ...props\n}) {\n  return /*#__PURE__*/_jsx(Tag, {\n    className: clsx('interface-navigable-region', className),\n    \"aria-label\": ariaLabel,\n    role: \"region\",\n    tabIndex: \"-1\",\n    ...props,\n    children: children\n  });\n}\n//# sourceMappingURL=index.js.map","/**\n * External dependencies\n */\nimport clsx from 'clsx';\n\n/**\n * WordPress dependencies\n */\nimport { Slot, Fill } from '@wordpress/components';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction PinnedItems({\n  scope,\n  ...props\n}) {\n  return /*#__PURE__*/_jsx(Fill, {\n    name: `PinnedItems/${scope}`,\n    ...props\n  });\n}\nfunction PinnedItemsSlot({\n  scope,\n  className,\n  ...props\n}) {\n  return /*#__PURE__*/_jsx(Slot, {\n    name: `PinnedItems/${scope}`,\n    ...props,\n    children: fills => fills?.length > 0 && /*#__PURE__*/_jsx(\"div\", {\n      className: clsx(className, 'interface-pinned-items'),\n      children: fills\n    })\n  });\n}\nPinnedItems.Slot = PinnedItemsSlot;\nexport default PinnedItems;\n//# sourceMappingURL=index.js.map","export * from './components';\nexport { store } from './store';\n//# sourceMappingURL=index.js.map","/**\n * WordPress dependencies\n */\nimport deprecated from '@wordpress/deprecated';\nimport { store as preferencesStore } from '@wordpress/preferences';\n\n/**\n * Internal dependencies\n */\nimport { normalizeComplementaryAreaScope, normalizeComplementaryAreaName } from './deprecated';\n\n/**\n * Set a default complementary area.\n *\n * @param {string} scope Complementary area scope.\n * @param {string} area  Area identifier.\n *\n * @return {Object} Action object.\n */\nexport const setDefaultComplementaryArea = (scope, area) => {\n  scope = normalizeComplementaryAreaScope(scope);\n  area = normalizeComplementaryAreaName(scope, area);\n  return {\n    type: 'SET_DEFAULT_COMPLEMENTARY_AREA',\n    scope,\n    area\n  };\n};\n\n/**\n * Enable the complementary area.\n *\n * @param {string} scope Complementary area scope.\n * @param {string} area  Area identifier.\n */\nexport const enableComplementaryArea = (scope, area) => ({\n  registry,\n  dispatch\n}) => {\n  // Return early if there's no area.\n  if (!area) {\n    return;\n  }\n  scope = normalizeComplementaryAreaScope(scope);\n  area = normalizeComplementaryAreaName(scope, area);\n  const isComplementaryAreaVisible = registry.select(preferencesStore).get(scope, 'isComplementaryAreaVisible');\n  if (!isComplementaryAreaVisible) {\n    registry.dispatch(preferencesStore).set(scope, 'isComplementaryAreaVisible', true);\n  }\n  dispatch({\n    type: 'ENABLE_COMPLEMENTARY_AREA',\n    scope,\n    area\n  });\n};\n\n/**\n * Disable the complementary area.\n *\n * @param {string} scope Complementary area scope.\n */\nexport const disableComplementaryArea = scope => ({\n  registry\n}) => {\n  scope = normalizeComplementaryAreaScope(scope);\n  const isComplementaryAreaVisible = registry.select(preferencesStore).get(scope, 'isComplementaryAreaVisible');\n  if (isComplementaryAreaVisible) {\n    registry.dispatch(preferencesStore).set(scope, 'isComplementaryAreaVisible', false);\n  }\n};\n\n/**\n * Pins an item.\n *\n * @param {string} scope Item scope.\n * @param {string} item  Item identifier.\n *\n * @return {Object} Action object.\n */\nexport const pinItem = (scope, item) => ({\n  registry\n}) => {\n  // Return early if there's no item.\n  if (!item) {\n    return;\n  }\n  scope = normalizeComplementaryAreaScope(scope);\n  item = normalizeComplementaryAreaName(scope, item);\n  const pinnedItems = registry.select(preferencesStore).get(scope, 'pinnedItems');\n\n  // The item is already pinned, there's nothing to do.\n  if (pinnedItems?.[item] === true) {\n    return;\n  }\n  registry.dispatch(preferencesStore).set(scope, 'pinnedItems', {\n    ...pinnedItems,\n    [item]: true\n  });\n};\n\n/**\n * Unpins an item.\n *\n * @param {string} scope Item scope.\n * @param {string} item  Item identifier.\n */\nexport const unpinItem = (scope, item) => ({\n  registry\n}) => {\n  // Return early if there's no item.\n  if (!item) {\n    return;\n  }\n  scope = normalizeComplementaryAreaScope(scope);\n  item = normalizeComplementaryAreaName(scope, item);\n  const pinnedItems = registry.select(preferencesStore).get(scope, 'pinnedItems');\n  registry.dispatch(preferencesStore).set(scope, 'pinnedItems', {\n    ...pinnedItems,\n    [item]: false\n  });\n};\n\n/**\n * Returns an action object used in signalling that a feature should be toggled.\n *\n * @param {string} scope       The feature scope (e.g. core/edit-post).\n * @param {string} featureName The feature name.\n */\nexport function toggleFeature(scope, featureName) {\n  return function ({\n    registry\n  }) {\n    deprecated(`dispatch( 'core/interface' ).toggleFeature`, {\n      since: '6.0',\n      alternative: `dispatch( 'core/preferences' ).toggle`\n    });\n    registry.dispatch(preferencesStore).toggle(scope, featureName);\n  };\n}\n\n/**\n * Returns an action object used in signalling that a feature should be set to\n * a true or false value\n *\n * @param {string}  scope       The feature scope (e.g. core/edit-post).\n * @param {string}  featureName The feature name.\n * @param {boolean} value       The value to set.\n *\n * @return {Object} Action object.\n */\nexport function setFeatureValue(scope, featureName, value) {\n  return function ({\n    registry\n  }) {\n    deprecated(`dispatch( 'core/interface' ).setFeatureValue`, {\n      since: '6.0',\n      alternative: `dispatch( 'core/preferences' ).set`\n    });\n    registry.dispatch(preferencesStore).set(scope, featureName, !!value);\n  };\n}\n\n/**\n * Returns an action object used in signalling that defaults should be set for features.\n *\n * @param {string}                  scope    The feature scope (e.g. core/edit-post).\n * @param {Object<string, boolean>} defaults A key/value map of feature names to values.\n *\n * @return {Object} Action object.\n */\nexport function setFeatureDefaults(scope, defaults) {\n  return function ({\n    registry\n  }) {\n    deprecated(`dispatch( 'core/interface' ).setFeatureDefaults`, {\n      since: '6.0',\n      alternative: `dispatch( 'core/preferences' ).setDefaults`\n    });\n    registry.dispatch(preferencesStore).setDefaults(scope, defaults);\n  };\n}\n\n/**\n * Returns an action object used in signalling that the user opened a modal.\n *\n * @param {string} name A string that uniquely identifies the modal.\n *\n * @return {Object} Action object.\n */\nexport function openModal(name) {\n  return {\n    type: 'OPEN_MODAL',\n    name\n  };\n}\n\n/**\n * Returns an action object signalling that the user closed a modal.\n *\n * @return {Object} Action object.\n */\nexport function closeModal() {\n  return {\n    type: 'CLOSE_MODAL'\n  };\n}\n//# sourceMappingURL=actions.js.map","/**\n * The identifier for the data store.\n *\n * @type {string}\n */\nexport const STORE_NAME = 'core/interface';\n//# sourceMappingURL=constants.js.map","/**\n * WordPress dependencies\n */\nimport deprecated from '@wordpress/deprecated';\nexport function normalizeComplementaryAreaScope(scope) {\n  if (['core/edit-post', 'core/edit-site'].includes(scope)) {\n    deprecated(`${scope} interface scope`, {\n      alternative: 'core interface scope',\n      hint: 'core/edit-post and core/edit-site are merging.',\n      version: '6.6'\n    });\n    return 'core';\n  }\n  return scope;\n}\nexport function normalizeComplementaryAreaName(scope, name) {\n  if (scope === 'core' && name === 'edit-site/template') {\n    deprecated(`edit-site/template sidebar`, {\n      alternative: 'edit-post/document',\n      version: '6.6'\n    });\n    return 'edit-post/document';\n  }\n  if (scope === 'core' && name === 'edit-site/block-inspector') {\n    deprecated(`edit-site/block-inspector sidebar`, {\n      alternative: 'edit-post/block',\n      version: '6.6'\n    });\n    return 'edit-post/block';\n  }\n  return name;\n}\n//# sourceMappingURL=deprecated.js.map","/**\n * WordPress dependencies\n */\nimport { createReduxStore, register } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport * as actions from './actions';\nimport * as selectors from './selectors';\nimport reducer from './reducer';\nimport { STORE_NAME } from './constants';\n\n/**\n * Store definition for the interface namespace.\n *\n * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore\n *\n * @type {Object}\n */\nexport const store = createReduxStore(STORE_NAME, {\n  reducer,\n  actions,\n  selectors\n});\n\n// Once we build a more generic persistence plugin that works across types of stores\n// we'd be able to replace this with a register call.\nregister(store);\n//# sourceMappingURL=index.js.map","/**\n * WordPress dependencies\n */\nimport { combineReducers } from '@wordpress/data';\nexport function complementaryAreas(state = {}, action) {\n  switch (action.type) {\n    case 'SET_DEFAULT_COMPLEMENTARY_AREA':\n      {\n        const {\n          scope,\n          area\n        } = action;\n\n        // If there's already an area, don't overwrite it.\n        if (state[scope]) {\n          return state;\n        }\n        return {\n          ...state,\n          [scope]: area\n        };\n      }\n    case 'ENABLE_COMPLEMENTARY_AREA':\n      {\n        const {\n          scope,\n          area\n        } = action;\n        return {\n          ...state,\n          [scope]: area\n        };\n      }\n  }\n  return state;\n}\n\n/**\n * Reducer for storing the name of the open modal, or null if no modal is open.\n *\n * @param {Object} state  Previous state.\n * @param {Object} action Action object containing the `name` of the modal\n *\n * @return {Object} Updated state\n */\nexport function activeModal(state = null, action) {\n  switch (action.type) {\n    case 'OPEN_MODAL':\n      return action.name;\n    case 'CLOSE_MODAL':\n      return null;\n  }\n  return state;\n}\nexport default combineReducers({\n  complementaryAreas,\n  activeModal\n});\n//# sourceMappingURL=reducer.js.map","/**\n * WordPress dependencies\n */\nimport { createRegistrySelector } from '@wordpress/data';\nimport deprecated from '@wordpress/deprecated';\nimport { store as preferencesStore } from '@wordpress/preferences';\n\n/**\n * Internal dependencies\n */\nimport { normalizeComplementaryAreaScope, normalizeComplementaryAreaName } from './deprecated';\n\n/**\n * Returns the complementary area that is active in a given scope.\n *\n * @param {Object} state Global application state.\n * @param {string} scope Item scope.\n *\n * @return {string | null | undefined} The complementary area that is active in the given scope.\n */\nexport const getActiveComplementaryArea = createRegistrySelector(select => (state, scope) => {\n  scope = normalizeComplementaryAreaScope(scope);\n  const isComplementaryAreaVisible = select(preferencesStore).get(scope, 'isComplementaryAreaVisible');\n\n  // Return `undefined` to indicate that the user has never toggled\n  // visibility, this is the vanilla default. Other code relies on this\n  // nuance in the return value.\n  if (isComplementaryAreaVisible === undefined) {\n    return undefined;\n  }\n\n  // Return `null` to indicate the user hid the complementary area.\n  if (isComplementaryAreaVisible === false) {\n    return null;\n  }\n  return state?.complementaryAreas?.[scope];\n});\nexport const isComplementaryAreaLoading = createRegistrySelector(select => (state, scope) => {\n  scope = normalizeComplementaryAreaScope(scope);\n  const isVisible = select(preferencesStore).get(scope, 'isComplementaryAreaVisible');\n  const identifier = state?.complementaryAreas?.[scope];\n  return isVisible && identifier === undefined;\n});\n\n/**\n * Returns a boolean indicating if an item is pinned or not.\n *\n * @param {Object} state Global application state.\n * @param {string} scope Scope.\n * @param {string} item  Item to check.\n *\n * @return {boolean} True if the item is pinned and false otherwise.\n */\nexport const isItemPinned = createRegistrySelector(select => (state, scope, item) => {\n  var _pinnedItems$item;\n  scope = normalizeComplementaryAreaScope(scope);\n  item = normalizeComplementaryAreaName(scope, item);\n  const pinnedItems = select(preferencesStore).get(scope, 'pinnedItems');\n  return (_pinnedItems$item = pinnedItems?.[item]) !== null && _pinnedItems$item !== void 0 ? _pinnedItems$item : true;\n});\n\n/**\n * Returns a boolean indicating whether a feature is active for a particular\n * scope.\n *\n * @param {Object} state       The store state.\n * @param {string} scope       The scope of the feature (e.g. core/edit-post).\n * @param {string} featureName The name of the feature.\n *\n * @return {boolean} Is the feature enabled?\n */\nexport const isFeatureActive = createRegistrySelector(select => (state, scope, featureName) => {\n  deprecated(`select( 'core/interface' ).isFeatureActive( scope, featureName )`, {\n    since: '6.0',\n    alternative: `select( 'core/preferences' ).get( scope, featureName )`\n  });\n  return !!select(preferencesStore).get(scope, featureName);\n});\n\n/**\n * Returns true if a modal is active, or false otherwise.\n *\n * @param {Object} state     Global application state.\n * @param {string} modalName A string that uniquely identifies the modal.\n *\n * @return {boolean} Whether the modal is active.\n */\nexport function isModalActive(state, modalName) {\n  return state.activeModal === modalName;\n}\n//# sourceMappingURL=selectors.js.map","function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}export function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;","/*! @license DOMPurify 3.3.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.3.0/LICENSE */\n\nconst {\n  entries,\n  setPrototypeOf,\n  isFrozen,\n  getPrototypeOf,\n  getOwnPropertyDescriptor\n} = Object;\nlet {\n  freeze,\n  seal,\n  create\n} = Object; // eslint-disable-line import/no-mutable-exports\nlet {\n  apply,\n  construct\n} = typeof Reflect !== 'undefined' && Reflect;\nif (!freeze) {\n  freeze = function freeze(x) {\n    return x;\n  };\n}\nif (!seal) {\n  seal = function seal(x) {\n    return x;\n  };\n}\nif (!apply) {\n  apply = function apply(func, thisArg) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    return func.apply(thisArg, args);\n  };\n}\nif (!construct) {\n  construct = function construct(Func) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    return new Func(...args);\n  };\n}\nconst arrayForEach = unapply(Array.prototype.forEach);\nconst arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);\nconst arrayPop = unapply(Array.prototype.pop);\nconst arrayPush = unapply(Array.prototype.push);\nconst arraySplice = unapply(Array.prototype.splice);\nconst stringToLowerCase = unapply(String.prototype.toLowerCase);\nconst stringToString = unapply(String.prototype.toString);\nconst stringMatch = unapply(String.prototype.match);\nconst stringReplace = unapply(String.prototype.replace);\nconst stringIndexOf = unapply(String.prototype.indexOf);\nconst stringTrim = unapply(String.prototype.trim);\nconst objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);\nconst regExpTest = unapply(RegExp.prototype.test);\nconst typeErrorCreate = unconstruct(TypeError);\n/**\n * Creates a new function that calls the given function with a specified thisArg and arguments.\n *\n * @param func - The function to be wrapped and called.\n * @returns A new function that calls the given function with a specified thisArg and arguments.\n */\nfunction unapply(func) {\n  return function (thisArg) {\n    if (thisArg instanceof RegExp) {\n      thisArg.lastIndex = 0;\n    }\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    return apply(func, thisArg, args);\n  };\n}\n/**\n * Creates a new function that constructs an instance of the given constructor function with the provided arguments.\n *\n * @param func - The constructor function to be wrapped and called.\n * @returns A new function that constructs an instance of the given constructor function with the provided arguments.\n */\nfunction unconstruct(Func) {\n  return function () {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    return construct(Func, args);\n  };\n}\n/**\n * Add properties to a lookup table\n *\n * @param set - The set to which elements will be added.\n * @param array - The array containing elements to be added to the set.\n * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.\n * @returns The modified set with added elements.\n */\nfunction addToSet(set, array) {\n  let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;\n  if (setPrototypeOf) {\n    // Make 'in' and truthy checks like Boolean(set.constructor)\n    // independent of any properties defined on Object.prototype.\n    // Prevent prototype setters from intercepting set as a this value.\n    setPrototypeOf(set, null);\n  }\n  let l = array.length;\n  while (l--) {\n    let element = array[l];\n    if (typeof element === 'string') {\n      const lcElement = transformCaseFunc(element);\n      if (lcElement !== element) {\n        // Config presets (e.g. tags.js, attrs.js) are immutable.\n        if (!isFrozen(array)) {\n          array[l] = lcElement;\n        }\n        element = lcElement;\n      }\n    }\n    set[element] = true;\n  }\n  return set;\n}\n/**\n * Clean up an array to harden against CSPP\n *\n * @param array - The array to be cleaned.\n * @returns The cleaned version of the array\n */\nfunction cleanArray(array) {\n  for (let index = 0; index < array.length; index++) {\n    const isPropertyExist = objectHasOwnProperty(array, index);\n    if (!isPropertyExist) {\n      array[index] = null;\n    }\n  }\n  return array;\n}\n/**\n * Shallow clone an object\n *\n * @param object - The object to be cloned.\n * @returns A new object that copies the original.\n */\nfunction clone(object) {\n  const newObject = create(null);\n  for (const [property, value] of entries(object)) {\n    const isPropertyExist = objectHasOwnProperty(object, property);\n    if (isPropertyExist) {\n      if (Array.isArray(value)) {\n        newObject[property] = cleanArray(value);\n      } else if (value && typeof value === 'object' && value.constructor === Object) {\n        newObject[property] = clone(value);\n      } else {\n        newObject[property] = value;\n      }\n    }\n  }\n  return newObject;\n}\n/**\n * This method automatically checks if the prop is function or getter and behaves accordingly.\n *\n * @param object - The object to look up the getter function in its prototype chain.\n * @param prop - The property name for which to find the getter function.\n * @returns The getter function found in the prototype chain or a fallback function.\n */\nfunction lookupGetter(object, prop) {\n  while (object !== null) {\n    const desc = getOwnPropertyDescriptor(object, prop);\n    if (desc) {\n      if (desc.get) {\n        return unapply(desc.get);\n      }\n      if (typeof desc.value === 'function') {\n        return unapply(desc.value);\n      }\n    }\n    object = getPrototypeOf(object);\n  }\n  function fallbackValue() {\n    return null;\n  }\n  return fallbackValue;\n}\n\nconst html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'search', 'section', 'select', 'shadow', 'slot', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\nconst svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'enterkeyhint', 'exportparts', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'inputmode', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'part', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\nconst svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n// List of SVG elements that are disallowed by default.\n// We still need to know them so that we can do namespace\n// checks properly in case one wants to add them to\n// allow-list.\nconst svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\nconst mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);\n// Similarly to SVG, we want to know all MathML elements,\n// even those that we disallow by default.\nconst mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\nconst text = freeze(['#text']);\n\nconst html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'exportparts', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inert', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'part', 'pattern', 'placeholder', 'playsinline', 'popover', 'popovertarget', 'popovertargetaction', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'slot', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'wrap', 'xmlns', 'slot']);\nconst svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'amplitude', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'exponent', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'intercept', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'mask-type', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'slope', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'tablevalues', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\nconst mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\nconst xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n// eslint-disable-next-line unicorn/better-regex\nconst MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nconst ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\nconst TMPLIT_EXPR = seal(/\\$\\{[\\w\\W]*/gm); // eslint-disable-line unicorn/better-regex\nconst DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]+$/); // eslint-disable-line no-useless-escape\nconst ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nconst IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nconst IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nconst ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n);\nconst DOCTYPE_NAME = seal(/^html$/i);\nconst CUSTOM_ELEMENT = seal(/^[a-z][.\\w]*(-[.\\w]+)+$/i);\n\nvar EXPRESSIONS = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ARIA_ATTR: ARIA_ATTR,\n  ATTR_WHITESPACE: ATTR_WHITESPACE,\n  CUSTOM_ELEMENT: CUSTOM_ELEMENT,\n  DATA_ATTR: DATA_ATTR,\n  DOCTYPE_NAME: DOCTYPE_NAME,\n  ERB_EXPR: ERB_EXPR,\n  IS_ALLOWED_URI: IS_ALLOWED_URI,\n  IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n  MUSTACHE_EXPR: MUSTACHE_EXPR,\n  TMPLIT_EXPR: TMPLIT_EXPR\n});\n\n/* eslint-disable @typescript-eslint/indent */\n// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\nconst NODE_TYPE = {\n  element: 1,\n  attribute: 2,\n  text: 3,\n  cdataSection: 4,\n  entityReference: 5,\n  // Deprecated\n  entityNode: 6,\n  // Deprecated\n  progressingInstruction: 7,\n  comment: 8,\n  document: 9,\n  documentType: 10,\n  documentFragment: 11,\n  notation: 12 // Deprecated\n};\nconst getGlobal = function getGlobal() {\n  return typeof window === 'undefined' ? null : window;\n};\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param trustedTypes The policy factory.\n * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n * @return The policy created (or null, if Trusted Types\n * are not supported or creating the policy failed).\n */\nconst _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n  if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n    return null;\n  }\n  // Allow the callers to control the unique policy name\n  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n  // Policy creation with duplicate names throws in Trusted Types.\n  let suffix = null;\n  const ATTR_NAME = 'data-tt-policy-suffix';\n  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n    suffix = purifyHostElement.getAttribute(ATTR_NAME);\n  }\n  const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n  try {\n    return trustedTypes.createPolicy(policyName, {\n      createHTML(html) {\n        return html;\n      },\n      createScriptURL(scriptUrl) {\n        return scriptUrl;\n      }\n    });\n  } catch (_) {\n    // Policy creation failed (most likely another DOMPurify script has\n    // already run). Skip creating the policy, as this will only cause errors\n    // if TT are enforced.\n    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n    return null;\n  }\n};\nconst _createHooksMap = function _createHooksMap() {\n  return {\n    afterSanitizeAttributes: [],\n    afterSanitizeElements: [],\n    afterSanitizeShadowDOM: [],\n    beforeSanitizeAttributes: [],\n    beforeSanitizeElements: [],\n    beforeSanitizeShadowDOM: [],\n    uponSanitizeAttribute: [],\n    uponSanitizeElement: [],\n    uponSanitizeShadowNode: []\n  };\n};\nfunction createDOMPurify() {\n  let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n  const DOMPurify = root => createDOMPurify(root);\n  DOMPurify.version = '3.3.0';\n  DOMPurify.removed = [];\n  if (!window || !window.document || window.document.nodeType !== NODE_TYPE.document || !window.Element) {\n    // Not running in a browser, provide a factory function\n    // so that you can pass your own Window\n    DOMPurify.isSupported = false;\n    return DOMPurify;\n  }\n  let {\n    document\n  } = window;\n  const originalDocument = document;\n  const currentScript = originalDocument.currentScript;\n  const {\n    DocumentFragment,\n    HTMLTemplateElement,\n    Node,\n    Element,\n    NodeFilter,\n    NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,\n    HTMLFormElement,\n    DOMParser,\n    trustedTypes\n  } = window;\n  const ElementPrototype = Element.prototype;\n  const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n  const remove = lookupGetter(ElementPrototype, 'remove');\n  const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n  const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n  const getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n  // As per issue #47, the web-components registry is inherited by a\n  // new document created via createHTMLDocument. As per the spec\n  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n  // a new empty registry is used when creating a template contents owner\n  // document, so we use that as our parent document to ensure nothing\n  // is inherited.\n  if (typeof HTMLTemplateElement === 'function') {\n    const template = document.createElement('template');\n    if (template.content && template.content.ownerDocument) {\n      document = template.content.ownerDocument;\n    }\n  }\n  let trustedTypesPolicy;\n  let emptyHTML = '';\n  const {\n    implementation,\n    createNodeIterator,\n    createDocumentFragment,\n    getElementsByTagName\n  } = document;\n  const {\n    importNode\n  } = originalDocument;\n  let hooks = _createHooksMap();\n  /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */\n  DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;\n  const {\n    MUSTACHE_EXPR,\n    ERB_EXPR,\n    TMPLIT_EXPR,\n    DATA_ATTR,\n    ARIA_ATTR,\n    IS_SCRIPT_OR_DATA,\n    ATTR_WHITESPACE,\n    CUSTOM_ELEMENT\n  } = EXPRESSIONS;\n  let {\n    IS_ALLOWED_URI: IS_ALLOWED_URI$1\n  } = EXPRESSIONS;\n  /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */\n  /* allowed element names */\n  let ALLOWED_TAGS = null;\n  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);\n  /* Allowed attribute names */\n  let ALLOWED_ATTR = null;\n  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);\n  /*\n   * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.\n   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n   */\n  let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {\n    tagNameCheck: {\n      writable: true,\n      configurable: false,\n      enumerable: true,\n      value: null\n    },\n    attributeNameCheck: {\n      writable: true,\n      configurable: false,\n      enumerable: true,\n      value: null\n    },\n    allowCustomizedBuiltInElements: {\n      writable: true,\n      configurable: false,\n      enumerable: true,\n      value: false\n    }\n  }));\n  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n  let FORBID_TAGS = null;\n  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n  let FORBID_ATTR = null;\n  /* Config object to store ADD_TAGS/ADD_ATTR functions (when used as functions) */\n  const EXTRA_ELEMENT_HANDLING = Object.seal(create(null, {\n    tagCheck: {\n      writable: true,\n      configurable: false,\n      enumerable: true,\n      value: null\n    },\n    attributeCheck: {\n      writable: true,\n      configurable: false,\n      enumerable: true,\n      value: null\n    }\n  }));\n  /* Decide if ARIA attributes are okay */\n  let ALLOW_ARIA_ATTR = true;\n  /* Decide if custom data attributes are okay */\n  let ALLOW_DATA_ATTR = true;\n  /* Decide if unknown protocols are okay */\n  let ALLOW_UNKNOWN_PROTOCOLS = false;\n  /* Decide if self-closing tags in attributes are allowed.\n   * Usually removed due to a mXSS issue in jQuery 3.0 */\n  let ALLOW_SELF_CLOSE_IN_ATTR = true;\n  /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */\n  let SAFE_FOR_TEMPLATES = false;\n  /* Output should be safe even for XML used within HTML and alike.\n   * This means, DOMPurify removes comments when containing risky content.\n   */\n  let SAFE_FOR_XML = true;\n  /* Decide if document with <html>... should be returned */\n  let WHOLE_DOCUMENT = false;\n  /* Track whether config is already set on this instance of DOMPurify. */\n  let SET_CONFIG = false;\n  /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */\n  let FORCE_BODY = false;\n  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */\n  let RETURN_DOM = false;\n  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */\n  let RETURN_DOM_FRAGMENT = false;\n  /* Try to return a Trusted Type object instead of a string, return a string in\n   * case Trusted Types are not supported  */\n  let RETURN_TRUSTED_TYPE = false;\n  /* Output should be free from DOM clobbering attacks?\n   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n   */\n  let SANITIZE_DOM = true;\n  /* Achieve full DOM Clobbering protection by isolating the namespace of named\n   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n   *\n   * HTML/DOM spec rules that enable DOM Clobbering:\n   *   - Named Access on Window (7.3.3)\n   *   - DOM Tree Accessors (3.1.5)\n   *   - Form Element Parent-Child Relations (4.10.3)\n   *   - Iframe srcdoc / Nested WindowProxies (4.8.5)\n   *   - HTMLCollection (4.2.10.2)\n   *\n   * Namespace isolation is implemented by prefixing `id` and `name` attributes\n   * with a constant string, i.e., `user-content-`\n   */\n  let SANITIZE_NAMED_PROPS = false;\n  const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n  /* Keep element content when removing element? */\n  let KEEP_CONTENT = true;\n  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */\n  let IN_PLACE = false;\n  /* Allow usage of profiles like html, svg and mathMl */\n  let USE_PROFILES = {};\n  /* Tags to ignore content of when KEEP_CONTENT is true */\n  let FORBID_CONTENTS = null;\n  const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n  /* Tags that are safe for data: URIs */\n  let DATA_URI_TAGS = null;\n  const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n  /* Attributes safe for values like \"javascript:\" */\n  let URI_SAFE_ATTRIBUTES = null;\n  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n  const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n  const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n  const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n  /* Document namespace */\n  let NAMESPACE = HTML_NAMESPACE;\n  let IS_EMPTY_INPUT = false;\n  /* Allowed XHTML+XML namespaces */\n  let ALLOWED_NAMESPACES = null;\n  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);\n  let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n  let HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);\n  // Certain elements are allowed in both SVG and HTML\n  // namespace. We need to specify them explicitly\n  // so that they don't get erroneously deleted from\n  // HTML namespace.\n  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n  /* Parsing of strict XHTML documents */\n  let PARSER_MEDIA_TYPE = null;\n  const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n  const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n  let transformCaseFunc = null;\n  /* Keep a reference to config to pass to hooks */\n  let CONFIG = null;\n  /* Ideally, do not touch anything below this line */\n  /* ______________________________________________ */\n  const formElement = document.createElement('form');\n  const isRegexOrFunction = function isRegexOrFunction(testValue) {\n    return testValue instanceof RegExp || testValue instanceof Function;\n  };\n  /**\n   * _parseConfig\n   *\n   * @param cfg optional config literal\n   */\n  // eslint-disable-next-line complexity\n  const _parseConfig = function _parseConfig() {\n    let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (CONFIG && CONFIG === cfg) {\n      return;\n    }\n    /* Shield configuration object from tampering */\n    if (!cfg || typeof cfg !== 'object') {\n      cfg = {};\n    }\n    /* Shield configuration object from prototype pollution */\n    cfg = clone(cfg);\n    PARSER_MEDIA_TYPE =\n    // eslint-disable-next-line unicorn/prefer-includes\n    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;\n    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n    transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;\n    /* Set configuration parameters */\n    ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n    ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n    ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n    URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;\n    DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;\n    FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n    FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});\n    FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});\n    USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;\n    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true\n    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n    RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n    FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n    IN_PLACE = cfg.IN_PLACE || false; // Default false\n    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n    MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;\n    HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;\n    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n    }\n    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n    }\n    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\n      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n    }\n    if (SAFE_FOR_TEMPLATES) {\n      ALLOW_DATA_ATTR = false;\n    }\n    if (RETURN_DOM_FRAGMENT) {\n      RETURN_DOM = true;\n    }\n    /* Parse profile info */\n    if (USE_PROFILES) {\n      ALLOWED_TAGS = addToSet({}, text);\n      ALLOWED_ATTR = [];\n      if (USE_PROFILES.html === true) {\n        addToSet(ALLOWED_TAGS, html$1);\n        addToSet(ALLOWED_ATTR, html);\n      }\n      if (USE_PROFILES.svg === true) {\n        addToSet(ALLOWED_TAGS, svg$1);\n        addToSet(ALLOWED_ATTR, svg);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n      if (USE_PROFILES.svgFilters === true) {\n        addToSet(ALLOWED_TAGS, svgFilters);\n        addToSet(ALLOWED_ATTR, svg);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n      if (USE_PROFILES.mathMl === true) {\n        addToSet(ALLOWED_TAGS, mathMl$1);\n        addToSet(ALLOWED_ATTR, mathMl);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n    }\n    /* Merge configuration parameters */\n    if (cfg.ADD_TAGS) {\n      if (typeof cfg.ADD_TAGS === 'function') {\n        EXTRA_ELEMENT_HANDLING.tagCheck = cfg.ADD_TAGS;\n      } else {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n      }\n    }\n    if (cfg.ADD_ATTR) {\n      if (typeof cfg.ADD_ATTR === 'function') {\n        EXTRA_ELEMENT_HANDLING.attributeCheck = cfg.ADD_ATTR;\n      } else {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n      }\n    }\n    if (cfg.ADD_URI_SAFE_ATTR) {\n      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n    }\n    if (cfg.FORBID_CONTENTS) {\n      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n        FORBID_CONTENTS = clone(FORBID_CONTENTS);\n      }\n      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n    }\n    /* Add #text in case KEEP_CONTENT is set to true */\n    if (KEEP_CONTENT) {\n      ALLOWED_TAGS['#text'] = true;\n    }\n    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n    if (WHOLE_DOCUMENT) {\n      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n    }\n    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n    if (ALLOWED_TAGS.table) {\n      addToSet(ALLOWED_TAGS, ['tbody']);\n      delete FORBID_TAGS.tbody;\n    }\n    if (cfg.TRUSTED_TYPES_POLICY) {\n      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\n        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n      }\n      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\n        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n      }\n      // Overwrite existing TrustedTypes policy.\n      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n      // Sign local variables required by `sanitize`.\n      emptyHTML = trustedTypesPolicy.createHTML('');\n    } else {\n      // Uninitialized policy, attempt to initialize the internal dompurify policy.\n      if (trustedTypesPolicy === undefined) {\n        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n      }\n      // If creating the internal policy succeeded sign internal variables.\n      if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\n        emptyHTML = trustedTypesPolicy.createHTML('');\n      }\n    }\n    // Prevent further manipulation of configuration.\n    // Not available in IE8, Safari 5, etc.\n    if (freeze) {\n      freeze(cfg);\n    }\n    CONFIG = cfg;\n  };\n  /* Keep track of all possible SVG and MathML tags\n   * so that we can perform the namespace checks\n   * correctly. */\n  const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);\n  const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);\n  /**\n   * @param element a DOM element whose namespace is being checked\n   * @returns Return false if the element has a\n   *  namespace that a spec-compliant parser would never\n   *  return. Return true otherwise.\n   */\n  const _checkValidNamespace = function _checkValidNamespace(element) {\n    let parent = getParentNode(element);\n    // In JSDOM, if we're inside shadow DOM, then parentNode\n    // can be null. We just simulate parent in this case.\n    if (!parent || !parent.tagName) {\n      parent = {\n        namespaceURI: NAMESPACE,\n        tagName: 'template'\n      };\n    }\n    const tagName = stringToLowerCase(element.tagName);\n    const parentTagName = stringToLowerCase(parent.tagName);\n    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n      return false;\n    }\n    if (element.namespaceURI === SVG_NAMESPACE) {\n      // The only way to switch from HTML namespace to SVG\n      // is via <svg>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'svg';\n      }\n      // The only way to switch from MathML to SVG is via`\n      // svg if parent is either <annotation-xml> or MathML\n      // text integration points.\n      if (parent.namespaceURI === MATHML_NAMESPACE) {\n        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n      }\n      // We only allow elements that are defined in SVG\n      // spec. All others are disallowed in SVG namespace.\n      return Boolean(ALL_SVG_TAGS[tagName]);\n    }\n    if (element.namespaceURI === MATHML_NAMESPACE) {\n      // The only way to switch from HTML namespace to MathML\n      // is via <math>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'math';\n      }\n      // The only way to switch from SVG to MathML is via\n      // <math> and HTML integration points\n      if (parent.namespaceURI === SVG_NAMESPACE) {\n        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n      }\n      // We only allow elements that are defined in MathML\n      // spec. All others are disallowed in MathML namespace.\n      return Boolean(ALL_MATHML_TAGS[tagName]);\n    }\n    if (element.namespaceURI === HTML_NAMESPACE) {\n      // The only way to switch from SVG to HTML is via\n      // HTML integration points, and from MathML to HTML\n      // is via MathML text integration points\n      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n        return false;\n      }\n      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n        return false;\n      }\n      // We disallow tags that are specific for MathML\n      // or SVG and should never appear in HTML namespace\n      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n    }\n    // For XHTML and XML documents that support custom namespaces\n    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {\n      return true;\n    }\n    // The code should never reach this place (this means\n    // that the element somehow got namespace that is not\n    // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n    // Return false just in case.\n    return false;\n  };\n  /**\n   * _forceRemove\n   *\n   * @param node a DOM node\n   */\n  const _forceRemove = function _forceRemove(node) {\n    arrayPush(DOMPurify.removed, {\n      element: node\n    });\n    try {\n      // eslint-disable-next-line unicorn/prefer-dom-node-remove\n      getParentNode(node).removeChild(node);\n    } catch (_) {\n      remove(node);\n    }\n  };\n  /**\n   * _removeAttribute\n   *\n   * @param name an Attribute name\n   * @param element a DOM node\n   */\n  const _removeAttribute = function _removeAttribute(name, element) {\n    try {\n      arrayPush(DOMPurify.removed, {\n        attribute: element.getAttributeNode(name),\n        from: element\n      });\n    } catch (_) {\n      arrayPush(DOMPurify.removed, {\n        attribute: null,\n        from: element\n      });\n    }\n    element.removeAttribute(name);\n    // We void attribute values for unremovable \"is\" attributes\n    if (name === 'is') {\n      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n        try {\n          _forceRemove(element);\n        } catch (_) {}\n      } else {\n        try {\n          element.setAttribute(name, '');\n        } catch (_) {}\n      }\n    }\n  };\n  /**\n   * _initDocument\n   *\n   * @param dirty - a string of dirty markup\n   * @return a DOM, filled with the dirty markup\n   */\n  const _initDocument = function _initDocument(dirty) {\n    /* Create a HTML document */\n    let doc = null;\n    let leadingWhitespace = null;\n    if (FORCE_BODY) {\n      dirty = '<remove></remove>' + dirty;\n    } else {\n      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n      const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n      leadingWhitespace = matches && matches[0];\n    }\n    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {\n      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n      dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n    }\n    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n    /*\n     * Use the DOMParser API by default, fallback later if needs be\n     * DOMParser not work for svg when has multiple root element.\n     */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      try {\n        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n      } catch (_) {}\n    }\n    /* Use createHTMLDocument in case DOMParser is not available */\n    if (!doc || !doc.documentElement) {\n      doc = implementation.createDocument(NAMESPACE, 'template', null);\n      try {\n        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n      } catch (_) {\n        // Syntax error if dirtyPayload is invalid xml\n      }\n    }\n    const body = doc.body || doc.documentElement;\n    if (dirty && leadingWhitespace) {\n      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n    }\n    /* Work on whole document or just its body */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n    }\n    return WHOLE_DOCUMENT ? doc.documentElement : body;\n  };\n  /**\n   * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n   *\n   * @param root The root element or node to start traversing on.\n   * @return The created NodeIterator\n   */\n  const _createNodeIterator = function _createNodeIterator(root) {\n    return createNodeIterator.call(root.ownerDocument || root, root,\n    // eslint-disable-next-line no-bitwise\n    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);\n  };\n  /**\n   * _isClobbered\n   *\n   * @param element element to check for clobbering attacks\n   * @return true if clobbered, false if safe\n   */\n  const _isClobbered = function _isClobbered(element) {\n    return element instanceof HTMLFormElement && (typeof element.nodeName !== 'string' || typeof element.textContent !== 'string' || typeof element.removeChild !== 'function' || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== 'function' || typeof element.setAttribute !== 'function' || typeof element.namespaceURI !== 'string' || typeof element.insertBefore !== 'function' || typeof element.hasChildNodes !== 'function');\n  };\n  /**\n   * Checks whether the given object is a DOM node.\n   *\n   * @param value object to check whether it's a DOM node\n   * @return true is object is a DOM node\n   */\n  const _isNode = function _isNode(value) {\n    return typeof Node === 'function' && value instanceof Node;\n  };\n  function _executeHooks(hooks, currentNode, data) {\n    arrayForEach(hooks, hook => {\n      hook.call(DOMPurify, currentNode, data, CONFIG);\n    });\n  }\n  /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   * @param currentNode to check for permission to exist\n   * @return true if node was killed, false if left alive\n   */\n  const _sanitizeElements = function _sanitizeElements(currentNode) {\n    let content = null;\n    /* Execute a hook if present */\n    _executeHooks(hooks.beforeSanitizeElements, currentNode, null);\n    /* Check if element is clobbered or can clobber */\n    if (_isClobbered(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n    /* Now let's check the element's type and name */\n    const tagName = transformCaseFunc(currentNode.nodeName);\n    /* Execute a hook if present */\n    _executeHooks(hooks.uponSanitizeElement, currentNode, {\n      tagName,\n      allowedTags: ALLOWED_TAGS\n    });\n    /* Detect mXSS attempts abusing namespace confusion */\n    if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\\w!]/g, currentNode.textContent)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n    /* Remove any occurrence of processing instructions */\n    if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {\n      _forceRemove(currentNode);\n      return true;\n    }\n    /* Remove any kind of possibly harmful comments */\n    if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\\w]/g, currentNode.data)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n    /* Remove element if anything forbids its presence */\n    if (!(EXTRA_ELEMENT_HANDLING.tagCheck instanceof Function && EXTRA_ELEMENT_HANDLING.tagCheck(tagName)) && (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName])) {\n      /* Check if we have a custom element to handle */\n      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {\n        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {\n          return false;\n        }\n        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {\n          return false;\n        }\n      }\n      /* Keep content except for bad-listed elements */\n      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n        const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n        if (childNodes && parentNode) {\n          const childCount = childNodes.length;\n          for (let i = childCount - 1; i >= 0; --i) {\n            const childClone = cloneNode(childNodes[i], true);\n            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;\n            parentNode.insertBefore(childClone, getNextSibling(currentNode));\n          }\n        }\n      }\n      _forceRemove(currentNode);\n      return true;\n    }\n    /* Check whether element has a valid namespace */\n    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n    /* Make sure that older browsers don't get fallback-tag mXSS */\n    if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n    /* Sanitize element content to be template-safe */\n    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {\n      /* Get the element's text content */\n      content = currentNode.textContent;\n      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n        content = stringReplace(content, expr, ' ');\n      });\n      if (currentNode.textContent !== content) {\n        arrayPush(DOMPurify.removed, {\n          element: currentNode.cloneNode()\n        });\n        currentNode.textContent = content;\n      }\n    }\n    /* Execute a hook if present */\n    _executeHooks(hooks.afterSanitizeElements, currentNode, null);\n    return false;\n  };\n  /**\n   * _isValidAttribute\n   *\n   * @param lcTag Lowercase tag name of containing element.\n   * @param lcName Lowercase attribute name.\n   * @param value Attribute value.\n   * @return Returns true if `value` is valid, otherwise false.\n   */\n  // eslint-disable-next-line complexity\n  const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n    /* Make sure attribute cannot clobber */\n    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n      return false;\n    }\n    /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */\n    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ; else if (EXTRA_ELEMENT_HANDLING.attributeCheck instanceof Function && EXTRA_ELEMENT_HANDLING.attributeCheck(lcName, lcTag)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n      if (\n      // First condition does a very basic check if a) it's basically a valid custom element tagname AND\n      // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n      // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n      _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName, lcTag)) ||\n      // Alternative, second condition checks if it's an `is`-attribute, AND\n      // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n      lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {\n        return false;\n      }\n      /* Check value is safe. First, is attr inert? If so, is safe */\n    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if (value) {\n      return false;\n    } else ;\n    return true;\n  };\n  /**\n   * _isBasicCustomElement\n   * checks if at least one dash is included in tagName, and it's not the first char\n   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n   *\n   * @param tagName name of the tag of the node to sanitize\n   * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.\n   */\n  const _isBasicCustomElement = function _isBasicCustomElement(tagName) {\n    return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);\n  };\n  /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param currentNode to sanitize\n   */\n  const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n    /* Execute a hook if present */\n    _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);\n    const {\n      attributes\n    } = currentNode;\n    /* Check if we have attributes; if not we might have a text node */\n    if (!attributes || _isClobbered(currentNode)) {\n      return;\n    }\n    const hookEvent = {\n      attrName: '',\n      attrValue: '',\n      keepAttr: true,\n      allowedAttributes: ALLOWED_ATTR,\n      forceKeepAttr: undefined\n    };\n    let l = attributes.length;\n    /* Go backwards over all attributes; safely remove bad ones */\n    while (l--) {\n      const attr = attributes[l];\n      const {\n        name,\n        namespaceURI,\n        value: attrValue\n      } = attr;\n      const lcName = transformCaseFunc(name);\n      const initValue = attrValue;\n      let value = name === 'value' ? initValue : stringTrim(initValue);\n      /* Execute a hook if present */\n      hookEvent.attrName = lcName;\n      hookEvent.attrValue = value;\n      hookEvent.keepAttr = true;\n      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n      _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);\n      value = hookEvent.attrValue;\n      /* Full DOM Clobbering protection via namespace isolation,\n       * Prefix id and name attributes with `user-content-`\n       */\n      if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n        // Remove the attribute with this value\n        _removeAttribute(name, currentNode);\n        // Prefix the value and later re-create the attribute with the sanitized value\n        value = SANITIZE_NAMED_PROPS_PREFIX + value;\n      }\n      /* Work around a security issue with comments inside attributes */\n      if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\\/(style|title|textarea)/i, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n      /* Make sure we cannot easily use animated hrefs, even if animations are allowed */\n      if (lcName === 'attributename' && stringMatch(value, 'href')) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n      /* Did the hooks approve of the attribute? */\n      if (hookEvent.forceKeepAttr) {\n        continue;\n      }\n      /* Did the hooks approve of the attribute? */\n      if (!hookEvent.keepAttr) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n      /* Work around a security issue in jQuery 3.0 */\n      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n      /* Sanitize attribute content to be template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n          value = stringReplace(value, expr, ' ');\n        });\n      }\n      /* Is `value` valid for this attribute? */\n      const lcTag = transformCaseFunc(currentNode.nodeName);\n      if (!_isValidAttribute(lcTag, lcName, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n      /* Handle attributes that require Trusted Types */\n      if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {\n        if (namespaceURI) ; else {\n          switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n            case 'TrustedHTML':\n              {\n                value = trustedTypesPolicy.createHTML(value);\n                break;\n              }\n            case 'TrustedScriptURL':\n              {\n                value = trustedTypesPolicy.createScriptURL(value);\n                break;\n              }\n          }\n        }\n      }\n      /* Handle invalid data-* attribute set by try-catching it */\n      if (value !== initValue) {\n        try {\n          if (namespaceURI) {\n            currentNode.setAttributeNS(namespaceURI, name, value);\n          } else {\n            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n            currentNode.setAttribute(name, value);\n          }\n          if (_isClobbered(currentNode)) {\n            _forceRemove(currentNode);\n          } else {\n            arrayPop(DOMPurify.removed);\n          }\n        } catch (_) {\n          _removeAttribute(name, currentNode);\n        }\n      }\n    }\n    /* Execute a hook if present */\n    _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);\n  };\n  /**\n   * _sanitizeShadowDOM\n   *\n   * @param fragment to iterate over recursively\n   */\n  const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n    let shadowNode = null;\n    const shadowIterator = _createNodeIterator(fragment);\n    /* Execute a hook if present */\n    _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);\n    while (shadowNode = shadowIterator.nextNode()) {\n      /* Execute a hook if present */\n      _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);\n      /* Sanitize tags and elements */\n      _sanitizeElements(shadowNode);\n      /* Check attributes next */\n      _sanitizeAttributes(shadowNode);\n      /* Deep shadow DOM detected */\n      if (shadowNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(shadowNode.content);\n      }\n    }\n    /* Execute a hook if present */\n    _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);\n  };\n  // eslint-disable-next-line complexity\n  DOMPurify.sanitize = function (dirty) {\n    let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let body = null;\n    let importedNode = null;\n    let currentNode = null;\n    let returnNode = null;\n    /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */\n    IS_EMPTY_INPUT = !dirty;\n    if (IS_EMPTY_INPUT) {\n      dirty = '<!-->';\n    }\n    /* Stringify, in case dirty is an object */\n    if (typeof dirty !== 'string' && !_isNode(dirty)) {\n      if (typeof dirty.toString === 'function') {\n        dirty = dirty.toString();\n        if (typeof dirty !== 'string') {\n          throw typeErrorCreate('dirty is not a string, aborting');\n        }\n      } else {\n        throw typeErrorCreate('toString is not a function');\n      }\n    }\n    /* Return dirty HTML if DOMPurify cannot run */\n    if (!DOMPurify.isSupported) {\n      return dirty;\n    }\n    /* Assign config vars */\n    if (!SET_CONFIG) {\n      _parseConfig(cfg);\n    }\n    /* Clean up removed elements */\n    DOMPurify.removed = [];\n    /* Check if dirty is correctly typed for IN_PLACE */\n    if (typeof dirty === 'string') {\n      IN_PLACE = false;\n    }\n    if (IN_PLACE) {\n      /* Do some early pre-sanitization to avoid unsafe root nodes */\n      if (dirty.nodeName) {\n        const tagName = transformCaseFunc(dirty.nodeName);\n        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n          throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\n        }\n      }\n    } else if (dirty instanceof Node) {\n      /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */\n      body = _initDocument('<!---->');\n      importedNode = body.ownerDocument.importNode(dirty, true);\n      if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {\n        /* Node is already a body, use as is */\n        body = importedNode;\n      } else if (importedNode.nodeName === 'HTML') {\n        body = importedNode;\n      } else {\n        // eslint-disable-next-line unicorn/prefer-dom-node-append\n        body.appendChild(importedNode);\n      }\n    } else {\n      /* Exit directly if we have nothing to do */\n      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&\n      // eslint-disable-next-line unicorn/prefer-includes\n      dirty.indexOf('<') === -1) {\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      }\n      /* Initialize the document to work on */\n      body = _initDocument(dirty);\n      /* Check we have a DOM node from the data */\n      if (!body) {\n        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n      }\n    }\n    /* Remove first element node (ours) if FORCE_BODY is set */\n    if (body && FORCE_BODY) {\n      _forceRemove(body.firstChild);\n    }\n    /* Get node iterator */\n    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);\n    /* Now start iterating over the created document */\n    while (currentNode = nodeIterator.nextNode()) {\n      /* Sanitize tags and elements */\n      _sanitizeElements(currentNode);\n      /* Check attributes next */\n      _sanitizeAttributes(currentNode);\n      /* Shadow DOM detected, sanitize it */\n      if (currentNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(currentNode.content);\n      }\n    }\n    /* If we sanitized `dirty` in-place, return it. */\n    if (IN_PLACE) {\n      return dirty;\n    }\n    /* Return sanitized string or DOM */\n    if (RETURN_DOM) {\n      if (RETURN_DOM_FRAGMENT) {\n        returnNode = createDocumentFragment.call(body.ownerDocument);\n        while (body.firstChild) {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          returnNode.appendChild(body.firstChild);\n        }\n      } else {\n        returnNode = body;\n      }\n      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n        /*\n          AdoptNode() is not used because internal state is not reset\n          (e.g. the past names map of a HTMLFormElement), this is safe\n          in theory but we would rather not risk another attack vector.\n          The state that is cloned by importNode() is explicitly defined\n          by the specs.\n        */\n        returnNode = importNode.call(originalDocument, returnNode, true);\n      }\n      return returnNode;\n    }\n    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n    /* Serialize doctype if allowed */\n    if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n      serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n    }\n    /* Sanitize final string template-safe */\n    if (SAFE_FOR_TEMPLATES) {\n      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n        serializedHTML = stringReplace(serializedHTML, expr, ' ');\n      });\n    }\n    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n  };\n  DOMPurify.setConfig = function () {\n    let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _parseConfig(cfg);\n    SET_CONFIG = true;\n  };\n  DOMPurify.clearConfig = function () {\n    CONFIG = null;\n    SET_CONFIG = false;\n  };\n  DOMPurify.isValidAttribute = function (tag, attr, value) {\n    /* Initialize shared config vars if necessary. */\n    if (!CONFIG) {\n      _parseConfig({});\n    }\n    const lcTag = transformCaseFunc(tag);\n    const lcName = transformCaseFunc(attr);\n    return _isValidAttribute(lcTag, lcName, value);\n  };\n  DOMPurify.addHook = function (entryPoint, hookFunction) {\n    if (typeof hookFunction !== 'function') {\n      return;\n    }\n    arrayPush(hooks[entryPoint], hookFunction);\n  };\n  DOMPurify.removeHook = function (entryPoint, hookFunction) {\n    if (hookFunction !== undefined) {\n      const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);\n      return index === -1 ? undefined : arraySplice(hooks[entryPoint], index, 1)[0];\n    }\n    return arrayPop(hooks[entryPoint]);\n  };\n  DOMPurify.removeHooks = function (entryPoint) {\n    hooks[entryPoint] = [];\n  };\n  DOMPurify.removeAllHooks = function () {\n    hooks = _createHooksMap();\n  };\n  return DOMPurify;\n}\nvar purify = createDOMPurify();\n\nexport { purify as default };\n//# sourceMappingURL=purify.es.mjs.map\n","class ParseError extends Error {\n  constructor(message, options) {\n    super(message), this.name = \"ParseError\", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;\n  }\n}\nfunction noop(_arg) {\n}\nfunction createParser(callbacks) {\n  if (typeof callbacks == \"function\")\n    throw new TypeError(\n      \"`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?\"\n    );\n  const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;\n  let incompleteLine = \"\", isFirstChunk = !0, id, data = \"\", eventType = \"\";\n  function feed(newChunk) {\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, \"\") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);\n    for (const line of complete)\n      parseLine(line);\n    incompleteLine = incomplete, isFirstChunk = !1;\n  }\n  function parseLine(line) {\n    if (line === \"\") {\n      dispatchEvent();\n      return;\n    }\n    if (line.startsWith(\":\")) {\n      onComment && onComment(line.slice(line.startsWith(\": \") ? 2 : 1));\n      return;\n    }\n    const fieldSeparatorIndex = line.indexOf(\":\");\n    if (fieldSeparatorIndex !== -1) {\n      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === \" \" ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);\n      processField(field, value, line);\n      return;\n    }\n    processField(line, \"\", line);\n  }\n  function processField(field, value, line) {\n    switch (field) {\n      case \"event\":\n        eventType = value;\n        break;\n      case \"data\":\n        data = `${data}${value}\n`;\n        break;\n      case \"id\":\n        id = value.includes(\"\\0\") ? void 0 : value;\n        break;\n      case \"retry\":\n        /^\\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(\n          new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n            type: \"invalid-retry\",\n            value,\n            line\n          })\n        );\n        break;\n      default:\n        onError(\n          new ParseError(\n            `Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}\\u2026` : field}\"`,\n            { type: \"unknown-field\", field, value, line }\n          )\n        );\n        break;\n    }\n  }\n  function dispatchEvent() {\n    data.length > 0 && onEvent({\n      id,\n      event: eventType || void 0,\n      // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n      // then remove the last character from the data buffer.\n      data: data.endsWith(`\n`) ? data.slice(0, -1) : data\n    }), id = void 0, data = \"\", eventType = \"\";\n  }\n  function reset(options = {}) {\n    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = !0, id = void 0, data = \"\", eventType = \"\", incompleteLine = \"\";\n  }\n  return { feed, reset };\n}\nfunction splitLines(chunk) {\n  const lines = [];\n  let incompleteLine = \"\", searchIndex = 0;\n  for (; searchIndex < chunk.length; ) {\n    const crIndex = chunk.indexOf(\"\\r\", searchIndex), lfIndex = chunk.indexOf(`\n`, searchIndex);\n    let lineEnd = -1;\n    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {\n      incompleteLine = chunk.slice(searchIndex);\n      break;\n    } else {\n      const line = chunk.slice(searchIndex, lineEnd);\n      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === \"\\r\" && chunk[searchIndex] === `\n` && searchIndex++;\n    }\n  }\n  return [lines, incompleteLine];\n}\nexport {\n  ParseError,\n  createParser\n};\n//# sourceMappingURL=index.js.map\n","import { createParser } from \"./index.js\";\nimport { ParseError } from \"./index.js\";\nclass EventSourceParserStream extends TransformStream {\n  constructor({ onError, onRetry, onComment } = {}) {\n    let parser;\n    super({\n      start(controller) {\n        parser = createParser({\n          onEvent: (event) => {\n            controller.enqueue(event);\n          },\n          onError(error) {\n            onError === \"terminate\" ? controller.error(error) : typeof onError == \"function\" && onError(error);\n          },\n          onRetry,\n          onComment\n        });\n      },\n      transform(chunk) {\n        parser.feed(chunk);\n      }\n    });\n  }\n}\nexport {\n  EventSourceParserStream,\n  ParseError\n};\n//# sourceMappingURL=stream.js.map\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","'use strict'\n\nconst { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require('./lib/utils')\nconst { SCHEMES, getSchemeHandler } = require('./lib/schemes')\n\n/**\n * @template {import('./types/index').URIComponent|string} T\n * @param {T} uri\n * @param {import('./types/index').Options} [options]\n * @returns {T}\n */\nfunction normalize (uri, options) {\n  if (typeof uri === 'string') {\n    uri = /** @type {T} */ (serialize(parse(uri, options), options))\n  } else if (typeof uri === 'object') {\n    uri = /** @type {T} */ (parse(serialize(uri, options), options))\n  }\n  return uri\n}\n\n/**\n * @param {string} baseURI\n * @param {string} relativeURI\n * @param {import('./types/index').Options} [options]\n * @returns {string}\n */\nfunction resolve (baseURI, relativeURI, options) {\n  const schemelessOptions = options ? Object.assign({ scheme: 'null' }, options) : { scheme: 'null' }\n  const resolved = resolveComponent(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true)\n  schemelessOptions.skipEscape = true\n  return serialize(resolved, schemelessOptions)\n}\n\n/**\n * @param {import ('./types/index').URIComponent} base\n * @param {import ('./types/index').URIComponent} relative\n * @param {import('./types/index').Options} [options]\n * @param {boolean} [skipNormalization=false]\n * @returns {import ('./types/index').URIComponent}\n */\nfunction resolveComponent (base, relative, options, skipNormalization) {\n  /** @type {import('./types/index').URIComponent} */\n  const target = {}\n  if (!skipNormalization) {\n    base = parse(serialize(base, options), options) // normalize base component\n    relative = parse(serialize(relative, options), options) // normalize relative component\n  }\n  options = options || {}\n\n  if (!options.tolerant && relative.scheme) {\n    target.scheme = relative.scheme\n    // target.authority = relative.authority;\n    target.userinfo = relative.userinfo\n    target.host = relative.host\n    target.port = relative.port\n    target.path = removeDotSegments(relative.path || '')\n    target.query = relative.query\n  } else {\n    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n      // target.authority = relative.authority;\n      target.userinfo = relative.userinfo\n      target.host = relative.host\n      target.port = relative.port\n      target.path = removeDotSegments(relative.path || '')\n      target.query = relative.query\n    } else {\n      if (!relative.path) {\n        target.path = base.path\n        if (relative.query !== undefined) {\n          target.query = relative.query\n        } else {\n          target.query = base.query\n        }\n      } else {\n        if (relative.path[0] === '/') {\n          target.path = removeDotSegments(relative.path)\n        } else {\n          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n            target.path = '/' + relative.path\n          } else if (!base.path) {\n            target.path = relative.path\n          } else {\n            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path\n          }\n          target.path = removeDotSegments(target.path)\n        }\n        target.query = relative.query\n      }\n      // target.authority = base.authority;\n      target.userinfo = base.userinfo\n      target.host = base.host\n      target.port = base.port\n    }\n    target.scheme = base.scheme\n  }\n\n  target.fragment = relative.fragment\n\n  return target\n}\n\n/**\n * @param {import ('./types/index').URIComponent|string} uriA\n * @param {import ('./types/index').URIComponent|string} uriB\n * @param {import ('./types/index').Options} options\n * @returns {boolean}\n */\nfunction equal (uriA, uriB, options) {\n  if (typeof uriA === 'string') {\n    uriA = unescape(uriA)\n    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriA === 'object') {\n    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true })\n  }\n\n  if (typeof uriB === 'string') {\n    uriB = unescape(uriB)\n    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriB === 'object') {\n    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true })\n  }\n\n  return uriA.toLowerCase() === uriB.toLowerCase()\n}\n\n/**\n * @param {Readonly<import('./types/index').URIComponent>} cmpts\n * @param {import('./types/index').Options} [opts]\n * @returns {string}\n */\nfunction serialize (cmpts, opts) {\n  const component = {\n    host: cmpts.host,\n    scheme: cmpts.scheme,\n    userinfo: cmpts.userinfo,\n    port: cmpts.port,\n    path: cmpts.path,\n    query: cmpts.query,\n    nid: cmpts.nid,\n    nss: cmpts.nss,\n    uuid: cmpts.uuid,\n    fragment: cmpts.fragment,\n    reference: cmpts.reference,\n    resourceName: cmpts.resourceName,\n    secure: cmpts.secure,\n    error: ''\n  }\n  const options = Object.assign({}, opts)\n  const uriTokens = []\n\n  // find scheme handler\n  const schemeHandler = getSchemeHandler(options.scheme || component.scheme)\n\n  // perform scheme specific serialization\n  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options)\n\n  if (component.path !== undefined) {\n    if (!options.skipEscape) {\n      component.path = escape(component.path)\n\n      if (component.scheme !== undefined) {\n        component.path = component.path.split('%3A').join(':')\n      }\n    } else {\n      component.path = unescape(component.path)\n    }\n  }\n\n  if (options.reference !== 'suffix' && component.scheme) {\n    uriTokens.push(component.scheme, ':')\n  }\n\n  const authority = recomposeAuthority(component)\n  if (authority !== undefined) {\n    if (options.reference !== 'suffix') {\n      uriTokens.push('//')\n    }\n\n    uriTokens.push(authority)\n\n    if (component.path && component.path[0] !== '/') {\n      uriTokens.push('/')\n    }\n  }\n  if (component.path !== undefined) {\n    let s = component.path\n\n    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n      s = removeDotSegments(s)\n    }\n\n    if (\n      authority === undefined &&\n      s[0] === '/' &&\n      s[1] === '/'\n    ) {\n      // don't allow the path to start with \"//\"\n      s = '/%2F' + s.slice(2)\n    }\n\n    uriTokens.push(s)\n  }\n\n  if (component.query !== undefined) {\n    uriTokens.push('?', component.query)\n  }\n\n  if (component.fragment !== undefined) {\n    uriTokens.push('#', component.fragment)\n  }\n  return uriTokens.join('')\n}\n\nconst URI_PARSE = /^(?:([^#/:?]+):)?(?:\\/\\/((?:([^#/?@]*)@)?(\\[[^#/?\\]]+\\]|[^#/:?]*)(?::(\\d*))?))?([^#?]*)(?:\\?([^#]*))?(?:#((?:.|[\\n\\r])*))?/u\n\n/**\n * @param {string} uri\n * @param {import('./types/index').Options} [opts]\n * @returns\n */\nfunction parse (uri, opts) {\n  const options = Object.assign({}, opts)\n  /** @type {import('./types/index').URIComponent} */\n  const parsed = {\n    scheme: undefined,\n    userinfo: undefined,\n    host: '',\n    port: undefined,\n    path: '',\n    query: undefined,\n    fragment: undefined\n  }\n\n  let isIP = false\n  if (options.reference === 'suffix') {\n    if (options.scheme) {\n      uri = options.scheme + ':' + uri\n    } else {\n      uri = '//' + uri\n    }\n  }\n\n  const matches = uri.match(URI_PARSE)\n\n  if (matches) {\n    // store each component\n    parsed.scheme = matches[1]\n    parsed.userinfo = matches[3]\n    parsed.host = matches[4]\n    parsed.port = parseInt(matches[5], 10)\n    parsed.path = matches[6] || ''\n    parsed.query = matches[7]\n    parsed.fragment = matches[8]\n\n    // fix port number\n    if (isNaN(parsed.port)) {\n      parsed.port = matches[5]\n    }\n    if (parsed.host) {\n      const ipv4result = isIPv4(parsed.host)\n      if (ipv4result === false) {\n        const ipv6result = normalizeIPv6(parsed.host)\n        parsed.host = ipv6result.host.toLowerCase()\n        isIP = ipv6result.isIPV6\n      } else {\n        isIP = true\n      }\n    }\n    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && parsed.query === undefined && !parsed.path) {\n      parsed.reference = 'same-document'\n    } else if (parsed.scheme === undefined) {\n      parsed.reference = 'relative'\n    } else if (parsed.fragment === undefined) {\n      parsed.reference = 'absolute'\n    } else {\n      parsed.reference = 'uri'\n    }\n\n    // check for reference errors\n    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {\n      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.'\n    }\n\n    // find scheme handler\n    const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme)\n\n    // check if scheme can't handle IRIs\n    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n      // if host component is a domain name\n      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {\n        // convert Unicode IDN -> ASCII IDN\n        try {\n          parsed.host = URL.domainToASCII(parsed.host.toLowerCase())\n        } catch (e) {\n          parsed.error = parsed.error || \"Host's domain name can not be converted to ASCII: \" + e\n        }\n      }\n      // convert IRI -> URI\n    }\n\n    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {\n      if (uri.indexOf('%') !== -1) {\n        if (parsed.scheme !== undefined) {\n          parsed.scheme = unescape(parsed.scheme)\n        }\n        if (parsed.host !== undefined) {\n          parsed.host = unescape(parsed.host)\n        }\n      }\n      if (parsed.path) {\n        parsed.path = escape(unescape(parsed.path))\n      }\n      if (parsed.fragment) {\n        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment))\n      }\n    }\n\n    // perform scheme specific parsing\n    if (schemeHandler && schemeHandler.parse) {\n      schemeHandler.parse(parsed, options)\n    }\n  } else {\n    parsed.error = parsed.error || 'URI can not be parsed.'\n  }\n  return parsed\n}\n\nconst fastUri = {\n  SCHEMES,\n  normalize,\n  resolve,\n  resolveComponent,\n  equal,\n  serialize,\n  parse\n}\n\nmodule.exports = fastUri\nmodule.exports.default = fastUri\nmodule.exports.fastUri = fastUri\n","'use strict'\n\nconst { isUUID } = require('./utils')\nconst URN_REG = /([\\da-z][\\d\\-a-z]{0,31}):((?:[\\w!$'()*+,\\-.:;=@]|%[\\da-f]{2})+)/iu\n\nconst supportedSchemeNames = /** @type {const} */ (['http', 'https', 'ws',\n  'wss', 'urn', 'urn:uuid'])\n\n/** @typedef {supportedSchemeNames[number]} SchemeName */\n\n/**\n * @param {string} name\n * @returns {name is SchemeName}\n */\nfunction isValidSchemeName (name) {\n  return supportedSchemeNames.indexOf(/** @type {*} */ (name)) !== -1\n}\n\n/**\n * @callback SchemeFn\n * @param {import('../types/index').URIComponent} component\n * @param {import('../types/index').Options} options\n * @returns {import('../types/index').URIComponent}\n */\n\n/**\n * @typedef {Object} SchemeHandler\n * @property {SchemeName} scheme - The scheme name.\n * @property {boolean} [domainHost] - Indicates if the scheme supports domain hosts.\n * @property {SchemeFn} parse - Function to parse the URI component for this scheme.\n * @property {SchemeFn} serialize - Function to serialize the URI component for this scheme.\n * @property {boolean} [skipNormalize] - Indicates if normalization should be skipped for this scheme.\n * @property {boolean} [absolutePath] - Indicates if the scheme uses absolute paths.\n * @property {boolean} [unicodeSupport] - Indicates if the scheme supports Unicode.\n */\n\n/**\n * @param {import('../types/index').URIComponent} wsComponent\n * @returns {boolean}\n */\nfunction wsIsSecure (wsComponent) {\n  if (wsComponent.secure === true) {\n    return true\n  } else if (wsComponent.secure === false) {\n    return false\n  } else if (wsComponent.scheme) {\n    return (\n      wsComponent.scheme.length === 3 &&\n      (wsComponent.scheme[0] === 'w' || wsComponent.scheme[0] === 'W') &&\n      (wsComponent.scheme[1] === 's' || wsComponent.scheme[1] === 'S') &&\n      (wsComponent.scheme[2] === 's' || wsComponent.scheme[2] === 'S')\n    )\n  } else {\n    return false\n  }\n}\n\n/** @type {SchemeFn} */\nfunction httpParse (component) {\n  if (!component.host) {\n    component.error = component.error || 'HTTP URIs must have a host.'\n  }\n\n  return component\n}\n\n/** @type {SchemeFn} */\nfunction httpSerialize (component) {\n  const secure = String(component.scheme).toLowerCase() === 'https'\n\n  // normalize the default port\n  if (component.port === (secure ? 443 : 80) || component.port === '') {\n    component.port = undefined\n  }\n\n  // normalize the empty path\n  if (!component.path) {\n    component.path = '/'\n  }\n\n  // NOTE: We do not parse query strings for HTTP URIs\n  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n  // and not the HTTP spec.\n\n  return component\n}\n\n/** @type {SchemeFn} */\nfunction wsParse (wsComponent) {\n// indicate if the secure flag is set\n  wsComponent.secure = wsIsSecure(wsComponent)\n\n  // construct resouce name\n  wsComponent.resourceName = (wsComponent.path || '/') + (wsComponent.query ? '?' + wsComponent.query : '')\n  wsComponent.path = undefined\n  wsComponent.query = undefined\n\n  return wsComponent\n}\n\n/** @type {SchemeFn} */\nfunction wsSerialize (wsComponent) {\n// normalize the default port\n  if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === '') {\n    wsComponent.port = undefined\n  }\n\n  // ensure scheme matches secure flag\n  if (typeof wsComponent.secure === 'boolean') {\n    wsComponent.scheme = (wsComponent.secure ? 'wss' : 'ws')\n    wsComponent.secure = undefined\n  }\n\n  // reconstruct path from resource name\n  if (wsComponent.resourceName) {\n    const [path, query] = wsComponent.resourceName.split('?')\n    wsComponent.path = (path && path !== '/' ? path : undefined)\n    wsComponent.query = query\n    wsComponent.resourceName = undefined\n  }\n\n  // forbid fragment component\n  wsComponent.fragment = undefined\n\n  return wsComponent\n}\n\n/** @type {SchemeFn} */\nfunction urnParse (urnComponent, options) {\n  if (!urnComponent.path) {\n    urnComponent.error = 'URN can not be parsed'\n    return urnComponent\n  }\n  const matches = urnComponent.path.match(URN_REG)\n  if (matches) {\n    const scheme = options.scheme || urnComponent.scheme || 'urn'\n    urnComponent.nid = matches[1].toLowerCase()\n    urnComponent.nss = matches[2]\n    const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`\n    const schemeHandler = getSchemeHandler(urnScheme)\n    urnComponent.path = undefined\n\n    if (schemeHandler) {\n      urnComponent = schemeHandler.parse(urnComponent, options)\n    }\n  } else {\n    urnComponent.error = urnComponent.error || 'URN can not be parsed.'\n  }\n\n  return urnComponent\n}\n\n/** @type {SchemeFn} */\nfunction urnSerialize (urnComponent, options) {\n  if (urnComponent.nid === undefined) {\n    throw new Error('URN without nid cannot be serialized')\n  }\n  const scheme = options.scheme || urnComponent.scheme || 'urn'\n  const nid = urnComponent.nid.toLowerCase()\n  const urnScheme = `${scheme}:${options.nid || nid}`\n  const schemeHandler = getSchemeHandler(urnScheme)\n\n  if (schemeHandler) {\n    urnComponent = schemeHandler.serialize(urnComponent, options)\n  }\n\n  const uriComponent = urnComponent\n  const nss = urnComponent.nss\n  uriComponent.path = `${nid || options.nid}:${nss}`\n\n  options.skipEscape = true\n  return uriComponent\n}\n\n/** @type {SchemeFn} */\nfunction urnuuidParse (urnComponent, options) {\n  const uuidComponent = urnComponent\n  uuidComponent.uuid = uuidComponent.nss\n  uuidComponent.nss = undefined\n\n  if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {\n    uuidComponent.error = uuidComponent.error || 'UUID is not valid.'\n  }\n\n  return uuidComponent\n}\n\n/** @type {SchemeFn} */\nfunction urnuuidSerialize (uuidComponent) {\n  const urnComponent = uuidComponent\n  // normalize UUID\n  urnComponent.nss = (uuidComponent.uuid || '').toLowerCase()\n  return urnComponent\n}\n\nconst http = /** @type {SchemeHandler} */ ({\n  scheme: 'http',\n  domainHost: true,\n  parse: httpParse,\n  serialize: httpSerialize\n})\n\nconst https = /** @type {SchemeHandler} */ ({\n  scheme: 'https',\n  domainHost: http.domainHost,\n  parse: httpParse,\n  serialize: httpSerialize\n})\n\nconst ws = /** @type {SchemeHandler} */ ({\n  scheme: 'ws',\n  domainHost: true,\n  parse: wsParse,\n  serialize: wsSerialize\n})\n\nconst wss = /** @type {SchemeHandler} */ ({\n  scheme: 'wss',\n  domainHost: ws.domainHost,\n  parse: ws.parse,\n  serialize: ws.serialize\n})\n\nconst urn = /** @type {SchemeHandler} */ ({\n  scheme: 'urn',\n  parse: urnParse,\n  serialize: urnSerialize,\n  skipNormalize: true\n})\n\nconst urnuuid = /** @type {SchemeHandler} */ ({\n  scheme: 'urn:uuid',\n  parse: urnuuidParse,\n  serialize: urnuuidSerialize,\n  skipNormalize: true\n})\n\nconst SCHEMES = /** @type {Record<SchemeName, SchemeHandler>} */ ({\n  http,\n  https,\n  ws,\n  wss,\n  urn,\n  'urn:uuid': urnuuid\n})\n\nObject.setPrototypeOf(SCHEMES, null)\n\n/**\n * @param {string|undefined} scheme\n * @returns {SchemeHandler|undefined}\n */\nfunction getSchemeHandler (scheme) {\n  return (\n    scheme && (\n      SCHEMES[/** @type {SchemeName} */ (scheme)] ||\n      SCHEMES[/** @type {SchemeName} */(scheme.toLowerCase())])\n  ) ||\n    undefined\n}\n\nmodule.exports = {\n  wsIsSecure,\n  SCHEMES,\n  isValidSchemeName,\n  getSchemeHandler,\n}\n","'use strict'\n\n/** @type {(value: string) => boolean} */\nconst isUUID = RegExp.prototype.test.bind(/^[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12}$/iu)\n\n/** @type {(value: string) => boolean} */\nconst isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)$/u)\n\n/**\n * @param {Array<string>} input\n * @returns {string}\n */\nfunction stringArrayToHexStripped (input) {\n  let acc = ''\n  let code = 0\n  let i = 0\n\n  for (i = 0; i < input.length; i++) {\n    code = input[i].charCodeAt(0)\n    if (code === 48) {\n      continue\n    }\n    if (!((code >= 48 && code <= 57) || (code >= 65 && code <= 70) || (code >= 97 && code <= 102))) {\n      return ''\n    }\n    acc += input[i]\n    break\n  }\n\n  for (i += 1; i < input.length; i++) {\n    code = input[i].charCodeAt(0)\n    if (!((code >= 48 && code <= 57) || (code >= 65 && code <= 70) || (code >= 97 && code <= 102))) {\n      return ''\n    }\n    acc += input[i]\n  }\n  return acc\n}\n\n/**\n * @typedef {Object} GetIPV6Result\n * @property {boolean} error - Indicates if there was an error parsing the IPv6 address.\n * @property {string} address - The parsed IPv6 address.\n * @property {string} [zone] - The zone identifier, if present.\n */\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nconst nonSimpleDomain = RegExp.prototype.test.bind(/[^!\"$&'()*+,\\-.;=_`a-z{}~]/u)\n\n/**\n * @param {Array<string>} buffer\n * @returns {boolean}\n */\nfunction consumeIsZone (buffer) {\n  buffer.length = 0\n  return true\n}\n\n/**\n * @param {Array<string>} buffer\n * @param {Array<string>} address\n * @param {GetIPV6Result} output\n * @returns {boolean}\n */\nfunction consumeHextets (buffer, address, output) {\n  if (buffer.length) {\n    const hex = stringArrayToHexStripped(buffer)\n    if (hex !== '') {\n      address.push(hex)\n    } else {\n      output.error = true\n      return false\n    }\n    buffer.length = 0\n  }\n  return true\n}\n\n/**\n * @param {string} input\n * @returns {GetIPV6Result}\n */\nfunction getIPV6 (input) {\n  let tokenCount = 0\n  const output = { error: false, address: '', zone: '' }\n  /** @type {Array<string>} */\n  const address = []\n  /** @type {Array<string>} */\n  const buffer = []\n  let endipv6Encountered = false\n  let endIpv6 = false\n\n  let consume = consumeHextets\n\n  for (let i = 0; i < input.length; i++) {\n    const cursor = input[i]\n    if (cursor === '[' || cursor === ']') { continue }\n    if (cursor === ':') {\n      if (endipv6Encountered === true) {\n        endIpv6 = true\n      }\n      if (!consume(buffer, address, output)) { break }\n      if (++tokenCount > 7) {\n        // not valid\n        output.error = true\n        break\n      }\n      if (i > 0 && input[i - 1] === ':') {\n        endipv6Encountered = true\n      }\n      address.push(':')\n      continue\n    } else if (cursor === '%') {\n      if (!consume(buffer, address, output)) { break }\n      // switch to zone detection\n      consume = consumeIsZone\n    } else {\n      buffer.push(cursor)\n      continue\n    }\n  }\n  if (buffer.length) {\n    if (consume === consumeIsZone) {\n      output.zone = buffer.join('')\n    } else if (endIpv6) {\n      address.push(buffer.join(''))\n    } else {\n      address.push(stringArrayToHexStripped(buffer))\n    }\n  }\n  output.address = address.join('')\n  return output\n}\n\n/**\n * @typedef {Object} NormalizeIPv6Result\n * @property {string} host - The normalized host.\n * @property {string} [escapedHost] - The escaped host.\n * @property {boolean} isIPV6 - Indicates if the host is an IPv6 address.\n */\n\n/**\n * @param {string} host\n * @returns {NormalizeIPv6Result}\n */\nfunction normalizeIPv6 (host) {\n  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }\n  const ipv6 = getIPV6(host)\n\n  if (!ipv6.error) {\n    let newHost = ipv6.address\n    let escapedHost = ipv6.address\n    if (ipv6.zone) {\n      newHost += '%' + ipv6.zone\n      escapedHost += '%25' + ipv6.zone\n    }\n    return { host: newHost, isIPV6: true, escapedHost }\n  } else {\n    return { host, isIPV6: false }\n  }\n}\n\n/**\n * @param {string} str\n * @param {string} token\n * @returns {number}\n */\nfunction findToken (str, token) {\n  let ind = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === token) ind++\n  }\n  return ind\n}\n\n/**\n * @param {string} path\n * @returns {string}\n *\n * @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4\n */\nfunction removeDotSegments (path) {\n  let input = path\n  const output = []\n  let nextSlash = -1\n  let len = 0\n\n  // eslint-disable-next-line no-cond-assign\n  while (len = input.length) {\n    if (len === 1) {\n      if (input === '.') {\n        break\n      } else if (input === '/') {\n        output.push('/')\n        break\n      } else {\n        output.push(input)\n        break\n      }\n    } else if (len === 2) {\n      if (input[0] === '.') {\n        if (input[1] === '.') {\n          break\n        } else if (input[1] === '/') {\n          input = input.slice(2)\n          continue\n        }\n      } else if (input[0] === '/') {\n        if (input[1] === '.' || input[1] === '/') {\n          output.push('/')\n          break\n        }\n      }\n    } else if (len === 3) {\n      if (input === '/..') {\n        if (output.length !== 0) {\n          output.pop()\n        }\n        output.push('/')\n        break\n      }\n    }\n    if (input[0] === '.') {\n      if (input[1] === '.') {\n        if (input[2] === '/') {\n          input = input.slice(3)\n          continue\n        }\n      } else if (input[1] === '/') {\n        input = input.slice(2)\n        continue\n      }\n    } else if (input[0] === '/') {\n      if (input[1] === '.') {\n        if (input[2] === '/') {\n          input = input.slice(2)\n          continue\n        } else if (input[2] === '.') {\n          if (input[3] === '/') {\n            input = input.slice(3)\n            if (output.length !== 0) {\n              output.pop()\n            }\n            continue\n          }\n        }\n      }\n    }\n\n    // Rule 2E: Move normal path segment to output\n    if ((nextSlash = input.indexOf('/', 1)) === -1) {\n      output.push(input)\n      break\n    } else {\n      output.push(input.slice(0, nextSlash))\n      input = input.slice(nextSlash)\n    }\n  }\n\n  return output.join('')\n}\n\n/**\n * @param {import('../types/index').URIComponent} component\n * @param {boolean} esc\n * @returns {import('../types/index').URIComponent}\n */\nfunction normalizeComponentEncoding (component, esc) {\n  const func = esc !== true ? escape : unescape\n  if (component.scheme !== undefined) {\n    component.scheme = func(component.scheme)\n  }\n  if (component.userinfo !== undefined) {\n    component.userinfo = func(component.userinfo)\n  }\n  if (component.host !== undefined) {\n    component.host = func(component.host)\n  }\n  if (component.path !== undefined) {\n    component.path = func(component.path)\n  }\n  if (component.query !== undefined) {\n    component.query = func(component.query)\n  }\n  if (component.fragment !== undefined) {\n    component.fragment = func(component.fragment)\n  }\n  return component\n}\n\n/**\n * @param {import('../types/index').URIComponent} component\n * @returns {string|undefined}\n */\nfunction recomposeAuthority (component) {\n  const uriTokens = []\n\n  if (component.userinfo !== undefined) {\n    uriTokens.push(component.userinfo)\n    uriTokens.push('@')\n  }\n\n  if (component.host !== undefined) {\n    let host = unescape(component.host)\n    if (!isIPv4(host)) {\n      const ipV6res = normalizeIPv6(host)\n      if (ipV6res.isIPV6 === true) {\n        host = `[${ipV6res.escapedHost}]`\n      } else {\n        host = component.host\n      }\n    }\n    uriTokens.push(host)\n  }\n\n  if (typeof component.port === 'number' || typeof component.port === 'string') {\n    uriTokens.push(':')\n    uriTokens.push(String(component.port))\n  }\n\n  return uriTokens.length ? uriTokens.join('') : undefined\n};\n\nmodule.exports = {\n  nonSimpleDomain,\n  recomposeAuthority,\n  normalizeComponentEncoding,\n  removeDotSegments,\n  isIPv4,\n  isUUID,\n  normalizeIPv6,\n  stringArrayToHexStripped\n}\n","/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport { forwardRef, createElement } from 'react';\nimport defaultAttributes from './defaultAttributes.js';\nimport { mergeClasses } from './shared/src/utils.js';\n\nconst Icon = forwardRef(\n  ({\n    color = \"currentColor\",\n    size = 24,\n    strokeWidth = 2,\n    absoluteStrokeWidth,\n    className = \"\",\n    children,\n    iconNode,\n    ...rest\n  }, ref) => {\n    return createElement(\n      \"svg\",\n      {\n        ref,\n        ...defaultAttributes,\n        width: size,\n        height: size,\n        stroke: color,\n        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,\n        className: mergeClasses(\"lucide\", className),\n        ...rest\n      },\n      [\n        ...iconNode.map(([tag, attrs]) => createElement(tag, attrs)),\n        ...Array.isArray(children) ? children : [children]\n      ]\n    );\n  }\n);\n\nexport { Icon as default };\n//# sourceMappingURL=Icon.js.map\n","/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport { forwardRef, createElement } from 'react';\nimport { mergeClasses, toKebabCase } from './shared/src/utils.js';\nimport Icon from './Icon.js';\n\nconst createLucideIcon = (iconName, iconNode) => {\n  const Component = forwardRef(\n    ({ className, ...props }, ref) => createElement(Icon, {\n      ref,\n      iconNode,\n      className: mergeClasses(`lucide-${toKebabCase(iconName)}`, className),\n      ...props\n    })\n  );\n  Component.displayName = `${iconName}`;\n  return Component;\n};\n\nexport { createLucideIcon as default };\n//# sourceMappingURL=createLucideIcon.js.map\n","/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nvar defaultAttributes = {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  width: 24,\n  height: 24,\n  viewBox: \"0 0 24 24\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 2,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\"\n};\n\nexport { defaultAttributes as default };\n//# sourceMappingURL=defaultAttributes.js.map\n","/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst ArrowUp = createLucideIcon(\"ArrowUp\", [\n  [\"path\", { d: \"m5 12 7-7 7 7\", key: \"hav0vg\" }],\n  [\"path\", { d: \"M12 19V5\", key: \"x0mq9r\" }]\n]);\n\nexport { ArrowUp as default };\n//# sourceMappingURL=arrow-up.js.map\n","/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst AtSign = createLucideIcon(\"AtSign\", [\n  [\"circle\", { cx: \"12\", cy: \"12\", r: \"4\", key: \"4exip2\" }],\n  [\"path\", { d: \"M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-4 8\", key: \"7n84p3\" }]\n]);\n\nexport { AtSign as default };\n//# sourceMappingURL=at-sign.js.map\n","/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst Check = createLucideIcon(\"Check\", [[\"path\", { d: \"M20 6 9 17l-5-5\", key: \"1gmf2c\" }]]);\n\nexport { Check as default };\n//# sourceMappingURL=check.js.map\n","/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst CircleStop = createLucideIcon(\"CircleStop\", [\n  [\"circle\", { cx: \"12\", cy: \"12\", r: \"10\", key: \"1mglay\" }],\n  [\"rect\", { x: \"9\", y: \"9\", width: \"6\", height: \"6\", rx: \"1\", key: \"1ssd4o\" }]\n]);\n\nexport { CircleStop as default };\n//# sourceMappingURL=circle-stop.js.map\n","/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst CircleX = createLucideIcon(\"CircleX\", [\n  [\"circle\", { cx: \"12\", cy: \"12\", r: \"10\", key: \"1mglay\" }],\n  [\"path\", { d: \"m15 9-6 6\", key: \"1uzhvr\" }],\n  [\"path\", { d: \"m9 9 6 6\", key: \"z0biqf\" }]\n]);\n\nexport { CircleX as default };\n//# sourceMappingURL=circle-x.js.map\n","/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst FilePlus = createLucideIcon(\"FilePlus\", [\n  [\"path\", { d: \"M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z\", key: \"1rqfz7\" }],\n  [\"path\", { d: \"M14 2v4a2 2 0 0 0 2 2h4\", key: \"tnqrlb\" }],\n  [\"path\", { d: \"M9 15h6\", key: \"cctwl0\" }],\n  [\"path\", { d: \"M12 18v-6\", key: \"17g6i2\" }]\n]);\n\nexport { FilePlus as default };\n//# sourceMappingURL=file-plus.js.map\n","/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst Layers = createLucideIcon(\"Layers\", [\n  [\n    \"path\",\n    {\n      d: \"M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z\",\n      key: \"zw3jo\"\n    }\n  ],\n  [\n    \"path\",\n    {\n      d: \"M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12\",\n      key: \"1wduqc\"\n    }\n  ],\n  [\n    \"path\",\n    {\n      d: \"M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17\",\n      key: \"kqbvx6\"\n    }\n  ]\n]);\n\nexport { Layers as default };\n//# sourceMappingURL=layers.js.map\n","/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst Palette = createLucideIcon(\"Palette\", [\n  [\"circle\", { cx: \"13.5\", cy: \"6.5\", r: \".5\", fill: \"currentColor\", key: \"1okk4w\" }],\n  [\"circle\", { cx: \"17.5\", cy: \"10.5\", r: \".5\", fill: \"currentColor\", key: \"f64h9f\" }],\n  [\"circle\", { cx: \"8.5\", cy: \"7.5\", r: \".5\", fill: \"currentColor\", key: \"fotxhn\" }],\n  [\"circle\", { cx: \"6.5\", cy: \"12.5\", r: \".5\", fill: \"currentColor\", key: \"qy21gx\" }],\n  [\n    \"path\",\n    {\n      d: \"M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z\",\n      key: \"12rzf8\"\n    }\n  ]\n]);\n\nexport { Palette as default };\n//# sourceMappingURL=palette.js.map\n","/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst PenLine = createLucideIcon(\"PenLine\", [\n  [\"path\", { d: \"M12 20h9\", key: \"t2du7b\" }],\n  [\n    \"path\",\n    {\n      d: \"M16.376 3.622a1 1 0 0 1 3.002 3.002L7.368 18.635a2 2 0 0 1-.855.506l-2.872.838a.5.5 0 0 1-.62-.62l.838-2.872a2 2 0 0 1 .506-.854z\",\n      key: \"1ykcvy\"\n    }\n  ]\n]);\n\nexport { PenLine as default };\n//# sourceMappingURL=pen-line.js.map\n","/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst Plus = createLucideIcon(\"Plus\", [\n  [\"path\", { d: \"M5 12h14\", key: \"1ays0h\" }],\n  [\"path\", { d: \"M12 5v14\", key: \"s699le\" }]\n]);\n\nexport { Plus as default };\n//# sourceMappingURL=plus.js.map\n","/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst Sparkles = createLucideIcon(\"Sparkles\", [\n  [\n    \"path\",\n    {\n      d: \"M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z\",\n      key: \"4pj2yx\"\n    }\n  ],\n  [\"path\", { d: \"M20 3v4\", key: \"1olli1\" }],\n  [\"path\", { d: \"M22 5h-4\", key: \"1gvqau\" }],\n  [\"path\", { d: \"M4 17v2\", key: \"vumght\" }],\n  [\"path\", { d: \"M5 18H3\", key: \"zchphs\" }]\n]);\n\nexport { Sparkles as default };\n//# sourceMappingURL=sparkles.js.map\n","/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst X = createLucideIcon(\"X\", [\n  [\"path\", { d: \"M18 6 6 18\", key: \"1bl5f8\" }],\n  [\"path\", { d: \"m6 6 12 12\", key: \"d8bk6v\" }]\n]);\n\nexport { X as default };\n//# sourceMappingURL=x.js.map\n","/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nconst toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\nconst mergeClasses = (...classes) => classes.filter((className, index, array) => {\n  return Boolean(className) && className.trim() !== \"\" && array.indexOf(className) === index;\n}).join(\" \").trim();\n\nexport { mergeClasses, toKebabCase };\n//# sourceMappingURL=utils.js.map\n","/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\nexport class MultipartBody {\n    constructor(body) {\n        this.body = body;\n    }\n    get [Symbol.toStringTag]() {\n        return 'MultipartBody';\n    }\n}\n//# sourceMappingURL=MultipartBody.mjs.map","/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\nimport * as shims from './registry.mjs';\nimport * as auto from 'openai/_shims/auto/runtime';\nexport const init = () => {\n  if (!shims.kind) shims.setShims(auto.getRuntime(), { auto: true });\n};\nexport * from './registry.mjs';\n\ninit();\n","export let auto = false;\nexport let kind = undefined;\nexport let fetch = undefined;\nexport let Request = undefined;\nexport let Response = undefined;\nexport let Headers = undefined;\nexport let FormData = undefined;\nexport let Blob = undefined;\nexport let File = undefined;\nexport let ReadableStream = undefined;\nexport let getMultipartRequestOptions = undefined;\nexport let getDefaultAgent = undefined;\nexport let fileFromPath = undefined;\nexport let isFsReadStream = undefined;\nexport function setShims(shims, options = { auto: false }) {\n    if (auto) {\n        throw new Error(`you must \\`import 'openai/shims/${shims.kind}'\\` before importing anything else from openai`);\n    }\n    if (kind) {\n        throw new Error(`can't \\`import 'openai/shims/${shims.kind}'\\` after \\`import 'openai/shims/${kind}'\\``);\n    }\n    auto = options.auto;\n    kind = shims.kind;\n    fetch = shims.fetch;\n    Request = shims.Request;\n    Response = shims.Response;\n    Headers = shims.Headers;\n    FormData = shims.FormData;\n    Blob = shims.Blob;\n    File = shims.File;\n    ReadableStream = shims.ReadableStream;\n    getMultipartRequestOptions = shims.getMultipartRequestOptions;\n    getDefaultAgent = shims.getDefaultAgent;\n    fileFromPath = shims.fileFromPath;\n    isFsReadStream = shims.isFsReadStream;\n}\n//# sourceMappingURL=registry.mjs.map","import { MultipartBody } from \"./MultipartBody.mjs\";\nexport function getRuntime({ manuallyImported } = {}) {\n    const recommendation = manuallyImported ?\n        `You may need to use polyfills`\n        : `Add one of these imports before your first \\`import  from 'openai'\\`:\n- \\`import 'openai/shims/node'\\` (if you're running on Node)\n- \\`import 'openai/shims/web'\\` (otherwise)\n`;\n    let _fetch, _Request, _Response, _Headers;\n    try {\n        // @ts-ignore\n        _fetch = fetch;\n        // @ts-ignore\n        _Request = Request;\n        // @ts-ignore\n        _Response = Response;\n        // @ts-ignore\n        _Headers = Headers;\n    }\n    catch (error) {\n        throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);\n    }\n    return {\n        kind: 'web',\n        fetch: _fetch,\n        Request: _Request,\n        Response: _Response,\n        Headers: _Headers,\n        FormData: \n        // @ts-ignore\n        typeof FormData !== 'undefined' ? FormData : (class FormData {\n            // @ts-ignore\n            constructor() {\n                throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);\n            }\n        }),\n        Blob: typeof Blob !== 'undefined' ? Blob : (class Blob {\n            constructor() {\n                throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);\n            }\n        }),\n        File: \n        // @ts-ignore\n        typeof File !== 'undefined' ? File : (class File {\n            // @ts-ignore\n            constructor() {\n                throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);\n            }\n        }),\n        ReadableStream: \n        // @ts-ignore\n        typeof ReadableStream !== 'undefined' ? ReadableStream : (class ReadableStream {\n            // @ts-ignore\n            constructor() {\n                throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);\n            }\n        }),\n        getMultipartRequestOptions: async (\n        // @ts-ignore\n        form, opts) => ({\n            ...opts,\n            body: new MultipartBody(form),\n        }),\n        getDefaultAgent: (url) => undefined,\n        fileFromPath: () => {\n            throw new Error('The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads');\n        },\n        isFsReadStream: (value) => false,\n    };\n}\n//# sourceMappingURL=web-runtime.mjs.map","const STR = 0b000000001;\nconst NUM = 0b000000010;\nconst ARR = 0b000000100;\nconst OBJ = 0b000001000;\nconst NULL = 0b000010000;\nconst BOOL = 0b000100000;\nconst NAN = 0b001000000;\nconst INFINITY = 0b010000000;\nconst MINUS_INFINITY = 0b100000000;\nconst INF = INFINITY | MINUS_INFINITY;\nconst SPECIAL = NULL | BOOL | INF | NAN;\nconst ATOM = STR | NUM | SPECIAL;\nconst COLLECTION = ARR | OBJ;\nconst ALL = ATOM | COLLECTION;\nconst Allow = {\n    STR,\n    NUM,\n    ARR,\n    OBJ,\n    NULL,\n    BOOL,\n    NAN,\n    INFINITY,\n    MINUS_INFINITY,\n    INF,\n    SPECIAL,\n    ATOM,\n    COLLECTION,\n    ALL,\n};\n// The JSON string segment was unable to be parsed completely\nclass PartialJSON extends Error {\n}\nclass MalformedJSON extends Error {\n}\n/**\n * Parse incomplete JSON\n * @param {string} jsonString Partial JSON to be parsed\n * @param {number} allowPartial Specify what types are allowed to be partial, see {@link Allow} for details\n * @returns The parsed JSON\n * @throws {PartialJSON} If the JSON is incomplete (related to the `allow` parameter)\n * @throws {MalformedJSON} If the JSON is malformed\n */\nfunction parseJSON(jsonString, allowPartial = Allow.ALL) {\n    if (typeof jsonString !== 'string') {\n        throw new TypeError(`expecting str, got ${typeof jsonString}`);\n    }\n    if (!jsonString.trim()) {\n        throw new Error(`${jsonString} is empty`);\n    }\n    return _parseJSON(jsonString.trim(), allowPartial);\n}\nconst _parseJSON = (jsonString, allow) => {\n    const length = jsonString.length;\n    let index = 0;\n    const markPartialJSON = (msg) => {\n        throw new PartialJSON(`${msg} at position ${index}`);\n    };\n    const throwMalformedError = (msg) => {\n        throw new MalformedJSON(`${msg} at position ${index}`);\n    };\n    const parseAny = () => {\n        skipBlank();\n        if (index >= length)\n            markPartialJSON('Unexpected end of input');\n        if (jsonString[index] === '\"')\n            return parseStr();\n        if (jsonString[index] === '{')\n            return parseObj();\n        if (jsonString[index] === '[')\n            return parseArr();\n        if (jsonString.substring(index, index + 4) === 'null' ||\n            (Allow.NULL & allow && length - index < 4 && 'null'.startsWith(jsonString.substring(index)))) {\n            index += 4;\n            return null;\n        }\n        if (jsonString.substring(index, index + 4) === 'true' ||\n            (Allow.BOOL & allow && length - index < 4 && 'true'.startsWith(jsonString.substring(index)))) {\n            index += 4;\n            return true;\n        }\n        if (jsonString.substring(index, index + 5) === 'false' ||\n            (Allow.BOOL & allow && length - index < 5 && 'false'.startsWith(jsonString.substring(index)))) {\n            index += 5;\n            return false;\n        }\n        if (jsonString.substring(index, index + 8) === 'Infinity' ||\n            (Allow.INFINITY & allow && length - index < 8 && 'Infinity'.startsWith(jsonString.substring(index)))) {\n            index += 8;\n            return Infinity;\n        }\n        if (jsonString.substring(index, index + 9) === '-Infinity' ||\n            (Allow.MINUS_INFINITY & allow &&\n                1 < length - index &&\n                length - index < 9 &&\n                '-Infinity'.startsWith(jsonString.substring(index)))) {\n            index += 9;\n            return -Infinity;\n        }\n        if (jsonString.substring(index, index + 3) === 'NaN' ||\n            (Allow.NAN & allow && length - index < 3 && 'NaN'.startsWith(jsonString.substring(index)))) {\n            index += 3;\n            return NaN;\n        }\n        return parseNum();\n    };\n    const parseStr = () => {\n        const start = index;\n        let escape = false;\n        index++; // skip initial quote\n        while (index < length && (jsonString[index] !== '\"' || (escape && jsonString[index - 1] === '\\\\'))) {\n            escape = jsonString[index] === '\\\\' ? !escape : false;\n            index++;\n        }\n        if (jsonString.charAt(index) == '\"') {\n            try {\n                return JSON.parse(jsonString.substring(start, ++index - Number(escape)));\n            }\n            catch (e) {\n                throwMalformedError(String(e));\n            }\n        }\n        else if (Allow.STR & allow) {\n            try {\n                return JSON.parse(jsonString.substring(start, index - Number(escape)) + '\"');\n            }\n            catch (e) {\n                // SyntaxError: Invalid escape sequence\n                return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('\\\\')) + '\"');\n            }\n        }\n        markPartialJSON('Unterminated string literal');\n    };\n    const parseObj = () => {\n        index++; // skip initial brace\n        skipBlank();\n        const obj = {};\n        try {\n            while (jsonString[index] !== '}') {\n                skipBlank();\n                if (index >= length && Allow.OBJ & allow)\n                    return obj;\n                const key = parseStr();\n                skipBlank();\n                index++; // skip colon\n                try {\n                    const value = parseAny();\n                    Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });\n                }\n                catch (e) {\n                    if (Allow.OBJ & allow)\n                        return obj;\n                    else\n                        throw e;\n                }\n                skipBlank();\n                if (jsonString[index] === ',')\n                    index++; // skip comma\n            }\n        }\n        catch (e) {\n            if (Allow.OBJ & allow)\n                return obj;\n            else\n                markPartialJSON(\"Expected '}' at end of object\");\n        }\n        index++; // skip final brace\n        return obj;\n    };\n    const parseArr = () => {\n        index++; // skip initial bracket\n        const arr = [];\n        try {\n            while (jsonString[index] !== ']') {\n                arr.push(parseAny());\n                skipBlank();\n                if (jsonString[index] === ',') {\n                    index++; // skip comma\n                }\n            }\n        }\n        catch (e) {\n            if (Allow.ARR & allow) {\n                return arr;\n            }\n            markPartialJSON(\"Expected ']' at end of array\");\n        }\n        index++; // skip final bracket\n        return arr;\n    };\n    const parseNum = () => {\n        if (index === 0) {\n            if (jsonString === '-' && Allow.NUM & allow)\n                markPartialJSON(\"Not sure what '-' is\");\n            try {\n                return JSON.parse(jsonString);\n            }\n            catch (e) {\n                if (Allow.NUM & allow) {\n                    try {\n                        if ('.' === jsonString[jsonString.length - 1])\n                            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('.')));\n                        return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('e')));\n                    }\n                    catch (e) { }\n                }\n                throwMalformedError(String(e));\n            }\n        }\n        const start = index;\n        if (jsonString[index] === '-')\n            index++;\n        while (jsonString[index] && !',]}'.includes(jsonString[index]))\n            index++;\n        if (index == length && !(Allow.NUM & allow))\n            markPartialJSON('Unterminated number literal');\n        try {\n            return JSON.parse(jsonString.substring(start, index));\n        }\n        catch (e) {\n            if (jsonString.substring(start, index) === '-' && Allow.NUM & allow)\n                markPartialJSON(\"Not sure what '-' is\");\n            try {\n                return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('e')));\n            }\n            catch (e) {\n                throwMalformedError(String(e));\n            }\n        }\n    };\n    const skipBlank = () => {\n        while (index < length && ' \\n\\r\\t'.includes(jsonString[index])) {\n            index++;\n        }\n    };\n    return parseAny();\n};\n// using this function with malformed JSON is undefined behavior\nconst partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);\nexport { partialParse, PartialJSON, MalformedJSON };\n//# sourceMappingURL=parser.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AbstractPage_client;\nimport { VERSION } from \"./version.mjs\";\nimport { Stream } from \"./streaming.mjs\";\nimport { OpenAIError, APIError, APIConnectionError, APIConnectionTimeoutError, APIUserAbortError, } from \"./error.mjs\";\nimport { kind as shimsKind, getDefaultAgent, fetch, init, } from \"./_shims/index.mjs\";\n// try running side effects outside of _shims/index to workaround https://github.com/vercel/next.js/issues/76881\ninit();\nimport { isBlobLike, isMultipartBody } from \"./uploads.mjs\";\nexport { maybeMultipartFormRequestOptions, multipartFormRequestOptions, createForm, } from \"./uploads.mjs\";\nasync function defaultParseResponse(props) {\n    const { response } = props;\n    if (props.options.stream) {\n        debug('response', response.status, response.url, response.headers, response.body);\n        // Note: there is an invariant here that isn't represented in the type system\n        // that if you set `stream: true` the response type must also be `Stream<T>`\n        if (props.options.__streamClass) {\n            return props.options.__streamClass.fromSSEResponse(response, props.controller);\n        }\n        return Stream.fromSSEResponse(response, props.controller);\n    }\n    // fetch refuses to read the body when the status code is 204.\n    if (response.status === 204) {\n        return null;\n    }\n    if (props.options.__binaryResponse) {\n        return response;\n    }\n    const contentType = response.headers.get('content-type');\n    const mediaType = contentType?.split(';')[0]?.trim();\n    const isJSON = mediaType?.includes('application/json') || mediaType?.endsWith('+json');\n    if (isJSON) {\n        const json = await response.json();\n        debug('response', response.status, response.url, response.headers, json);\n        return _addRequestID(json, response);\n    }\n    const text = await response.text();\n    debug('response', response.status, response.url, response.headers, text);\n    // TODO handle blob, arraybuffer, other content types, etc.\n    return text;\n}\nfunction _addRequestID(value, response) {\n    if (!value || typeof value !== 'object' || Array.isArray(value)) {\n        return value;\n    }\n    return Object.defineProperty(value, '_request_id', {\n        value: response.headers.get('x-request-id'),\n        enumerable: false,\n    });\n}\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nexport class APIPromise extends Promise {\n    constructor(responsePromise, parseResponse = defaultParseResponse) {\n        super((resolve) => {\n            // this is maybe a bit weird but this has to be a no-op to not implicitly\n            // parse the response body; instead .then, .catch, .finally are overridden\n            // to parse the response\n            resolve(null);\n        });\n        this.responsePromise = responsePromise;\n        this.parseResponse = parseResponse;\n    }\n    _thenUnwrap(transform) {\n        return new APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));\n    }\n    /**\n     * Gets the raw `Response` instance instead of parsing the response\n     * data.\n     *\n     * If you want to parse the response body but still get the `Response`\n     * instance, you can use {@link withResponse()}.\n     *\n     *  Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n     * or add one of these imports before your first `import  from 'openai'`:\n     * - `import 'openai/shims/node'` (if you're running on Node)\n     * - `import 'openai/shims/web'` (otherwise)\n     */\n    asResponse() {\n        return this.responsePromise.then((p) => p.response);\n    }\n    /**\n     * Gets the parsed response data, the raw `Response` instance and the ID of the request,\n     * returned via the X-Request-ID header which is useful for debugging requests and reporting\n     * issues to OpenAI.\n     *\n     * If you just want to get the raw `Response` instance without parsing it,\n     * you can use {@link asResponse()}.\n     *\n     *\n     *  Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n     * or add one of these imports before your first `import  from 'openai'`:\n     * - `import 'openai/shims/node'` (if you're running on Node)\n     * - `import 'openai/shims/web'` (otherwise)\n     */\n    async withResponse() {\n        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n        return { data, response, request_id: response.headers.get('x-request-id') };\n    }\n    parse() {\n        if (!this.parsedPromise) {\n            this.parsedPromise = this.responsePromise.then(this.parseResponse);\n        }\n        return this.parsedPromise;\n    }\n    then(onfulfilled, onrejected) {\n        return this.parse().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.parse().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.parse().finally(onfinally);\n    }\n}\nexport class APIClient {\n    constructor({ baseURL, maxRetries = 2, timeout = 600000, // 10 minutes\n    httpAgent, fetch: overriddenFetch, }) {\n        this.baseURL = baseURL;\n        this.maxRetries = validatePositiveInteger('maxRetries', maxRetries);\n        this.timeout = validatePositiveInteger('timeout', timeout);\n        this.httpAgent = httpAgent;\n        this.fetch = overriddenFetch ?? fetch;\n    }\n    authHeaders(opts) {\n        return {};\n    }\n    /**\n     * Override this to add your own default headers, for example:\n     *\n     *  {\n     *    ...super.defaultHeaders(),\n     *    Authorization: 'Bearer 123',\n     *  }\n     */\n    defaultHeaders(opts) {\n        return {\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n            'User-Agent': this.getUserAgent(),\n            ...getPlatformHeaders(),\n            ...this.authHeaders(opts),\n        };\n    }\n    /**\n     * Override this to add your own headers validation:\n     */\n    validateHeaders(headers, customHeaders) { }\n    defaultIdempotencyKey() {\n        return `stainless-node-retry-${uuid4()}`;\n    }\n    get(path, opts) {\n        return this.methodRequest('get', path, opts);\n    }\n    post(path, opts) {\n        return this.methodRequest('post', path, opts);\n    }\n    patch(path, opts) {\n        return this.methodRequest('patch', path, opts);\n    }\n    put(path, opts) {\n        return this.methodRequest('put', path, opts);\n    }\n    delete(path, opts) {\n        return this.methodRequest('delete', path, opts);\n    }\n    methodRequest(method, path, opts) {\n        return this.request(Promise.resolve(opts).then(async (opts) => {\n            const body = opts && isBlobLike(opts?.body) ? new DataView(await opts.body.arrayBuffer())\n                : opts?.body instanceof DataView ? opts.body\n                    : opts?.body instanceof ArrayBuffer ? new DataView(opts.body)\n                        : opts && ArrayBuffer.isView(opts?.body) ? new DataView(opts.body.buffer)\n                            : opts?.body;\n            return { method, path, ...opts, body };\n        }));\n    }\n    getAPIList(path, Page, opts) {\n        return this.requestAPIList(Page, { method: 'get', path, ...opts });\n    }\n    calculateContentLength(body) {\n        if (typeof body === 'string') {\n            if (typeof Buffer !== 'undefined') {\n                return Buffer.byteLength(body, 'utf8').toString();\n            }\n            if (typeof TextEncoder !== 'undefined') {\n                const encoder = new TextEncoder();\n                const encoded = encoder.encode(body);\n                return encoded.length.toString();\n            }\n        }\n        else if (ArrayBuffer.isView(body)) {\n            return body.byteLength.toString();\n        }\n        return null;\n    }\n    buildRequest(inputOptions, { retryCount = 0 } = {}) {\n        const options = { ...inputOptions };\n        const { method, path, query, headers: headers = {} } = options;\n        const body = ArrayBuffer.isView(options.body) || (options.__binaryRequest && typeof options.body === 'string') ?\n            options.body\n            : isMultipartBody(options.body) ? options.body.body\n                : options.body ? JSON.stringify(options.body, null, 2)\n                    : null;\n        const contentLength = this.calculateContentLength(body);\n        const url = this.buildURL(path, query);\n        if ('timeout' in options)\n            validatePositiveInteger('timeout', options.timeout);\n        options.timeout = options.timeout ?? this.timeout;\n        const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);\n        const minAgentTimeout = options.timeout + 1000;\n        if (typeof httpAgent?.options?.timeout === 'number' &&\n            minAgentTimeout > (httpAgent.options.timeout ?? 0)) {\n            // Allow any given request to bump our agent active socket timeout.\n            // This may seem strange, but leaking active sockets should be rare and not particularly problematic,\n            // and without mutating agent we would need to create more of them.\n            // This tradeoff optimizes for performance.\n            httpAgent.options.timeout = minAgentTimeout;\n        }\n        if (this.idempotencyHeader && method !== 'get') {\n            if (!inputOptions.idempotencyKey)\n                inputOptions.idempotencyKey = this.defaultIdempotencyKey();\n            headers[this.idempotencyHeader] = inputOptions.idempotencyKey;\n        }\n        const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });\n        const req = {\n            method,\n            ...(body && { body: body }),\n            headers: reqHeaders,\n            ...(httpAgent && { agent: httpAgent }),\n            // @ts-ignore node-fetch uses a custom AbortSignal type that is\n            // not compatible with standard web types\n            signal: options.signal ?? null,\n        };\n        return { req, url, timeout: options.timeout };\n    }\n    buildHeaders({ options, headers, contentLength, retryCount, }) {\n        const reqHeaders = {};\n        if (contentLength) {\n            reqHeaders['content-length'] = contentLength;\n        }\n        const defaultHeaders = this.defaultHeaders(options);\n        applyHeadersMut(reqHeaders, defaultHeaders);\n        applyHeadersMut(reqHeaders, headers);\n        // let builtin fetch set the Content-Type for multipart bodies\n        if (isMultipartBody(options.body) && shimsKind !== 'node') {\n            delete reqHeaders['content-type'];\n        }\n        // Don't set theses headers if they were already set or removed through default headers or by the caller.\n        // We check `defaultHeaders` and `headers`, which can contain nulls, instead of `reqHeaders` to account\n        // for the removal case.\n        if (getHeader(defaultHeaders, 'x-stainless-retry-count') === undefined &&\n            getHeader(headers, 'x-stainless-retry-count') === undefined) {\n            reqHeaders['x-stainless-retry-count'] = String(retryCount);\n        }\n        if (getHeader(defaultHeaders, 'x-stainless-timeout') === undefined &&\n            getHeader(headers, 'x-stainless-timeout') === undefined &&\n            options.timeout) {\n            reqHeaders['x-stainless-timeout'] = String(Math.trunc(options.timeout / 1000));\n        }\n        this.validateHeaders(reqHeaders, headers);\n        return reqHeaders;\n    }\n    /**\n     * Used as a callback for mutating the given `FinalRequestOptions` object.\n     */\n    async prepareOptions(options) { }\n    /**\n     * Used as a callback for mutating the given `RequestInit` object.\n     *\n     * This is useful for cases where you want to add certain headers based off of\n     * the request properties, e.g. `method` or `url`.\n     */\n    async prepareRequest(request, { url, options }) { }\n    parseHeaders(headers) {\n        return (!headers ? {}\n            : Symbol.iterator in headers ?\n                Object.fromEntries(Array.from(headers).map((header) => [...header]))\n                : { ...headers });\n    }\n    makeStatusError(status, error, message, headers) {\n        return APIError.generate(status, error, message, headers);\n    }\n    request(options, remainingRetries = null) {\n        return new APIPromise(this.makeRequest(options, remainingRetries));\n    }\n    async makeRequest(optionsInput, retriesRemaining) {\n        const options = await optionsInput;\n        const maxRetries = options.maxRetries ?? this.maxRetries;\n        if (retriesRemaining == null) {\n            retriesRemaining = maxRetries;\n        }\n        await this.prepareOptions(options);\n        const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });\n        await this.prepareRequest(req, { url, options });\n        debug('request', url, options, req.headers);\n        if (options.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        const controller = new AbortController();\n        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);\n        if (response instanceof Error) {\n            if (options.signal?.aborted) {\n                throw new APIUserAbortError();\n            }\n            if (retriesRemaining) {\n                return this.retryRequest(options, retriesRemaining);\n            }\n            if (response.name === 'AbortError') {\n                throw new APIConnectionTimeoutError();\n            }\n            throw new APIConnectionError({ cause: response });\n        }\n        const responseHeaders = createResponseHeaders(response.headers);\n        if (!response.ok) {\n            if (retriesRemaining && this.shouldRetry(response)) {\n                const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\n                debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders);\n                return this.retryRequest(options, retriesRemaining, responseHeaders);\n            }\n            const errText = await response.text().catch((e) => castToError(e).message);\n            const errJSON = safeJSON(errText);\n            const errMessage = errJSON ? undefined : errText;\n            const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;\n            debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);\n            const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);\n            throw err;\n        }\n        return { response, options, controller };\n    }\n    requestAPIList(Page, options) {\n        const request = this.makeRequest(options, null);\n        return new PagePromise(this, request, Page);\n    }\n    buildURL(path, query) {\n        const url = isAbsoluteURL(path) ?\n            new URL(path)\n            : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\n        const defaultQuery = this.defaultQuery();\n        if (!isEmptyObj(defaultQuery)) {\n            query = { ...defaultQuery, ...query };\n        }\n        if (typeof query === 'object' && query && !Array.isArray(query)) {\n            url.search = this.stringifyQuery(query);\n        }\n        return url.toString();\n    }\n    stringifyQuery(query) {\n        return Object.entries(query)\n            .filter(([_, value]) => typeof value !== 'undefined')\n            .map(([key, value]) => {\n            if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n                return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n            }\n            if (value === null) {\n                return `${encodeURIComponent(key)}=`;\n            }\n            throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);\n        })\n            .join('&');\n    }\n    async fetchWithTimeout(url, init, ms, controller) {\n        const { signal, ...options } = init || {};\n        if (signal)\n            signal.addEventListener('abort', () => controller.abort());\n        const timeout = setTimeout(() => controller.abort(), ms);\n        const fetchOptions = {\n            signal: controller.signal,\n            ...options,\n        };\n        if (fetchOptions.method) {\n            // Custom methods like 'patch' need to be uppercased\n            // See https://github.com/nodejs/undici/issues/2294\n            fetchOptions.method = fetchOptions.method.toUpperCase();\n        }\n        return (\n        // use undefined this binding; fetch errors if bound to something else in browser/cloudflare\n        this.fetch.call(undefined, url, fetchOptions).finally(() => {\n            clearTimeout(timeout);\n        }));\n    }\n    shouldRetry(response) {\n        // Note this is not a standard header.\n        const shouldRetryHeader = response.headers.get('x-should-retry');\n        // If the server explicitly says whether or not to retry, obey.\n        if (shouldRetryHeader === 'true')\n            return true;\n        if (shouldRetryHeader === 'false')\n            return false;\n        // Retry on request timeouts.\n        if (response.status === 408)\n            return true;\n        // Retry on lock timeouts.\n        if (response.status === 409)\n            return true;\n        // Retry on rate limits.\n        if (response.status === 429)\n            return true;\n        // Retry internal errors.\n        if (response.status >= 500)\n            return true;\n        return false;\n    }\n    async retryRequest(options, retriesRemaining, responseHeaders) {\n        let timeoutMillis;\n        // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.\n        const retryAfterMillisHeader = responseHeaders?.['retry-after-ms'];\n        if (retryAfterMillisHeader) {\n            const timeoutMs = parseFloat(retryAfterMillisHeader);\n            if (!Number.isNaN(timeoutMs)) {\n                timeoutMillis = timeoutMs;\n            }\n        }\n        // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n        const retryAfterHeader = responseHeaders?.['retry-after'];\n        if (retryAfterHeader && !timeoutMillis) {\n            const timeoutSeconds = parseFloat(retryAfterHeader);\n            if (!Number.isNaN(timeoutSeconds)) {\n                timeoutMillis = timeoutSeconds * 1000;\n            }\n            else {\n                timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\n            }\n        }\n        // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\n        // just do what it says, but otherwise calculate a default\n        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {\n            const maxRetries = options.maxRetries ?? this.maxRetries;\n            timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\n        }\n        await sleep(timeoutMillis);\n        return this.makeRequest(options, retriesRemaining - 1);\n    }\n    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {\n        const initialRetryDelay = 0.5;\n        const maxRetryDelay = 8.0;\n        const numRetries = maxRetries - retriesRemaining;\n        // Apply exponential backoff, but not more than the max.\n        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);\n        // Apply some jitter, take up to at most 25 percent of the retry time.\n        const jitter = 1 - Math.random() * 0.25;\n        return sleepSeconds * jitter * 1000;\n    }\n    getUserAgent() {\n        return `${this.constructor.name}/JS ${VERSION}`;\n    }\n}\nexport class AbstractPage {\n    constructor(client, response, body, options) {\n        _AbstractPage_client.set(this, void 0);\n        __classPrivateFieldSet(this, _AbstractPage_client, client, \"f\");\n        this.options = options;\n        this.response = response;\n        this.body = body;\n    }\n    hasNextPage() {\n        const items = this.getPaginatedItems();\n        if (!items.length)\n            return false;\n        return this.nextPageInfo() != null;\n    }\n    async getNextPage() {\n        const nextInfo = this.nextPageInfo();\n        if (!nextInfo) {\n            throw new OpenAIError('No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.');\n        }\n        const nextOptions = { ...this.options };\n        if ('params' in nextInfo && typeof nextOptions.query === 'object') {\n            nextOptions.query = { ...nextOptions.query, ...nextInfo.params };\n        }\n        else if ('url' in nextInfo) {\n            const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];\n            for (const [key, value] of params) {\n                nextInfo.url.searchParams.set(key, value);\n            }\n            nextOptions.query = undefined;\n            nextOptions.path = nextInfo.url.toString();\n        }\n        return await __classPrivateFieldGet(this, _AbstractPage_client, \"f\").requestAPIList(this.constructor, nextOptions);\n    }\n    async *iterPages() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let page = this;\n        yield page;\n        while (page.hasNextPage()) {\n            page = await page.getNextPage();\n            yield page;\n        }\n    }\n    async *[(_AbstractPage_client = new WeakMap(), Symbol.asyncIterator)]() {\n        for await (const page of this.iterPages()) {\n            for (const item of page.getPaginatedItems()) {\n                yield item;\n            }\n        }\n    }\n}\n/**\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\n *\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\n *\n *    for await (const item of client.items.list()) {\n *      console.log(item)\n *    }\n */\nexport class PagePromise extends APIPromise {\n    constructor(client, request, Page) {\n        super(request, async (props) => new Page(client, props.response, await defaultParseResponse(props), props.options));\n    }\n    /**\n     * Allow auto-paginating iteration on an unawaited list call, eg:\n     *\n     *    for await (const item of client.items.list()) {\n     *      console.log(item)\n     *    }\n     */\n    async *[Symbol.asyncIterator]() {\n        const page = await this;\n        for await (const item of page) {\n            yield item;\n        }\n    }\n}\nexport const createResponseHeaders = (headers) => {\n    return new Proxy(Object.fromEntries(\n    // @ts-ignore\n    headers.entries()), {\n        get(target, name) {\n            const key = name.toString();\n            return target[key.toLowerCase()] || target[key];\n        },\n    });\n};\n// This is required so that we can determine if a given object matches the RequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\nconst requestOptionsKeys = {\n    method: true,\n    path: true,\n    query: true,\n    body: true,\n    headers: true,\n    maxRetries: true,\n    stream: true,\n    timeout: true,\n    httpAgent: true,\n    signal: true,\n    idempotencyKey: true,\n    __metadata: true,\n    __binaryRequest: true,\n    __binaryResponse: true,\n    __streamClass: true,\n};\nexport const isRequestOptions = (obj) => {\n    return (typeof obj === 'object' &&\n        obj !== null &&\n        !isEmptyObj(obj) &&\n        Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k)));\n};\nconst getPlatformProperties = () => {\n    if (typeof Deno !== 'undefined' && Deno.build != null) {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': normalizePlatform(Deno.build.os),\n            'X-Stainless-Arch': normalizeArch(Deno.build.arch),\n            'X-Stainless-Runtime': 'deno',\n            'X-Stainless-Runtime-Version': typeof Deno.version === 'string' ? Deno.version : Deno.version?.deno ?? 'unknown',\n        };\n    }\n    if (typeof EdgeRuntime !== 'undefined') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': 'Unknown',\n            'X-Stainless-Arch': `other:${EdgeRuntime}`,\n            'X-Stainless-Runtime': 'edge',\n            'X-Stainless-Runtime-Version': process.version,\n        };\n    }\n    // Check if Node.js\n    if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': normalizePlatform(process.platform),\n            'X-Stainless-Arch': normalizeArch(process.arch),\n            'X-Stainless-Runtime': 'node',\n            'X-Stainless-Runtime-Version': process.version,\n        };\n    }\n    const browserInfo = getBrowserInfo();\n    if (browserInfo) {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': 'Unknown',\n            'X-Stainless-Arch': 'unknown',\n            'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\n            'X-Stainless-Runtime-Version': browserInfo.version,\n        };\n    }\n    // TODO add support for Cloudflare workers, etc.\n    return {\n        'X-Stainless-Lang': 'js',\n        'X-Stainless-Package-Version': VERSION,\n        'X-Stainless-OS': 'Unknown',\n        'X-Stainless-Arch': 'unknown',\n        'X-Stainless-Runtime': 'unknown',\n        'X-Stainless-Runtime-Version': 'unknown',\n    };\n};\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\nfunction getBrowserInfo() {\n    if (typeof navigator === 'undefined' || !navigator) {\n        return null;\n    }\n    // NOTE: The order matters here!\n    const browserPatterns = [\n        { key: 'edge', pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'ie', pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'ie', pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'chrome', pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'firefox', pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'safari', pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/ },\n    ];\n    // Find the FIRST matching browser\n    for (const { key, pattern } of browserPatterns) {\n        const match = pattern.exec(navigator.userAgent);\n        if (match) {\n            const major = match[1] || 0;\n            const minor = match[2] || 0;\n            const patch = match[3] || 0;\n            return { browser: key, version: `${major}.${minor}.${patch}` };\n        }\n    }\n    return null;\n}\nconst normalizeArch = (arch) => {\n    // Node docs:\n    // - https://nodejs.org/api/process.html#processarch\n    // Deno docs:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    if (arch === 'x32')\n        return 'x32';\n    if (arch === 'x86_64' || arch === 'x64')\n        return 'x64';\n    if (arch === 'arm')\n        return 'arm';\n    if (arch === 'aarch64' || arch === 'arm64')\n        return 'arm64';\n    if (arch)\n        return `other:${arch}`;\n    return 'unknown';\n};\nconst normalizePlatform = (platform) => {\n    // Node platforms:\n    // - https://nodejs.org/api/process.html#processplatform\n    // Deno platforms:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    // - https://github.com/denoland/deno/issues/14799\n    platform = platform.toLowerCase();\n    // NOTE: this iOS check is untested and may not work\n    // Node does not work natively on IOS, there is a fork at\n    // https://github.com/nodejs-mobile/nodejs-mobile\n    // however it is unknown at the time of writing how to detect if it is running\n    if (platform.includes('ios'))\n        return 'iOS';\n    if (platform === 'android')\n        return 'Android';\n    if (platform === 'darwin')\n        return 'MacOS';\n    if (platform === 'win32')\n        return 'Windows';\n    if (platform === 'freebsd')\n        return 'FreeBSD';\n    if (platform === 'openbsd')\n        return 'OpenBSD';\n    if (platform === 'linux')\n        return 'Linux';\n    if (platform)\n        return `Other:${platform}`;\n    return 'Unknown';\n};\nlet _platformHeaders;\nconst getPlatformHeaders = () => {\n    return (_platformHeaders ?? (_platformHeaders = getPlatformProperties()));\n};\nexport const safeJSON = (text) => {\n    try {\n        return JSON.parse(text);\n    }\n    catch (err) {\n        return undefined;\n    }\n};\n// https://url.spec.whatwg.org/#url-scheme-string\nconst startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;\nconst isAbsoluteURL = (url) => {\n    return startsWithSchemeRegexp.test(url);\n};\nexport const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nconst validatePositiveInteger = (name, n) => {\n    if (typeof n !== 'number' || !Number.isInteger(n)) {\n        throw new OpenAIError(`${name} must be an integer`);\n    }\n    if (n < 0) {\n        throw new OpenAIError(`${name} must be a positive integer`);\n    }\n    return n;\n};\nexport const castToError = (err) => {\n    if (err instanceof Error)\n        return err;\n    if (typeof err === 'object' && err !== null) {\n        try {\n            return new Error(JSON.stringify(err));\n        }\n        catch { }\n    }\n    return new Error(err);\n};\nexport const ensurePresent = (value) => {\n    if (value == null)\n        throw new OpenAIError(`Expected a value to be given but received ${value} instead.`);\n    return value;\n};\n/**\n * Read an environment variable.\n *\n * Trims beginning and trailing whitespace.\n *\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\n */\nexport const readEnv = (env) => {\n    if (typeof process !== 'undefined') {\n        return process.env?.[env]?.trim() ?? undefined;\n    }\n    if (typeof Deno !== 'undefined') {\n        return Deno.env?.get?.(env)?.trim();\n    }\n    return undefined;\n};\nexport const coerceInteger = (value) => {\n    if (typeof value === 'number')\n        return Math.round(value);\n    if (typeof value === 'string')\n        return parseInt(value, 10);\n    throw new OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexport const coerceFloat = (value) => {\n    if (typeof value === 'number')\n        return value;\n    if (typeof value === 'string')\n        return parseFloat(value);\n    throw new OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexport const coerceBoolean = (value) => {\n    if (typeof value === 'boolean')\n        return value;\n    if (typeof value === 'string')\n        return value === 'true';\n    return Boolean(value);\n};\nexport const maybeCoerceInteger = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return coerceInteger(value);\n};\nexport const maybeCoerceFloat = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return coerceFloat(value);\n};\nexport const maybeCoerceBoolean = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return coerceBoolean(value);\n};\n// https://stackoverflow.com/a/34491287\nexport function isEmptyObj(obj) {\n    if (!obj)\n        return true;\n    for (const _k in obj)\n        return false;\n    return true;\n}\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nexport function hasOwn(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\n/**\n * Copies headers from \"newHeaders\" onto \"targetHeaders\",\n * using lower-case for all properties,\n * ignoring any keys with undefined values,\n * and deleting any keys with null values.\n */\nfunction applyHeadersMut(targetHeaders, newHeaders) {\n    for (const k in newHeaders) {\n        if (!hasOwn(newHeaders, k))\n            continue;\n        const lowerKey = k.toLowerCase();\n        if (!lowerKey)\n            continue;\n        const val = newHeaders[k];\n        if (val === null) {\n            delete targetHeaders[lowerKey];\n        }\n        else if (val !== undefined) {\n            targetHeaders[lowerKey] = val;\n        }\n    }\n}\nconst SENSITIVE_HEADERS = new Set(['authorization', 'api-key']);\nexport function debug(action, ...args) {\n    if (typeof process !== 'undefined' && process?.env?.['DEBUG'] === 'true') {\n        const modifiedArgs = args.map((arg) => {\n            if (!arg) {\n                return arg;\n            }\n            // Check for sensitive headers in request body 'headers' object\n            if (arg['headers']) {\n                // clone so we don't mutate\n                const modifiedArg = { ...arg, headers: { ...arg['headers'] } };\n                for (const header in arg['headers']) {\n                    if (SENSITIVE_HEADERS.has(header.toLowerCase())) {\n                        modifiedArg['headers'][header] = 'REDACTED';\n                    }\n                }\n                return modifiedArg;\n            }\n            let modifiedArg = null;\n            // Check for sensitive headers in headers object\n            for (const header in arg) {\n                if (SENSITIVE_HEADERS.has(header.toLowerCase())) {\n                    // avoid making a copy until we need to\n                    modifiedArg ?? (modifiedArg = { ...arg });\n                    modifiedArg[header] = 'REDACTED';\n                }\n            }\n            return modifiedArg ?? arg;\n        });\n        console.log(`OpenAI:DEBUG:${action}`, ...modifiedArgs);\n    }\n}\n/**\n * https://stackoverflow.com/a/2117523\n */\nconst uuid4 = () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        const r = (Math.random() * 16) | 0;\n        const v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n};\nexport const isRunningInBrowser = () => {\n    return (\n    // @ts-ignore\n    typeof window !== 'undefined' &&\n        // @ts-ignore\n        typeof window.document !== 'undefined' &&\n        // @ts-ignore\n        typeof navigator !== 'undefined');\n};\nexport const isHeadersProtocol = (headers) => {\n    return typeof headers?.get === 'function';\n};\nexport const getRequiredHeader = (headers, header) => {\n    const foundHeader = getHeader(headers, header);\n    if (foundHeader === undefined) {\n        throw new Error(`Could not find ${header} header`);\n    }\n    return foundHeader;\n};\nexport const getHeader = (headers, header) => {\n    const lowerCasedHeader = header.toLowerCase();\n    if (isHeadersProtocol(headers)) {\n        // to deal with the case where the header looks like Stainless-Event-Id\n        const intercapsHeader = header[0]?.toUpperCase() +\n            header.substring(1).replace(/([^\\w])(\\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());\n        for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {\n            const value = headers.get(key);\n            if (value) {\n                return value;\n            }\n        }\n    }\n    for (const [key, value] of Object.entries(headers)) {\n        if (key.toLowerCase() === lowerCasedHeader) {\n            if (Array.isArray(value)) {\n                if (value.length <= 1)\n                    return value[0];\n                console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);\n                return value[0];\n            }\n            return value;\n        }\n    }\n    return undefined;\n};\n/**\n * Encodes a string to Base64 format.\n */\nexport const toBase64 = (str) => {\n    if (!str)\n        return '';\n    if (typeof Buffer !== 'undefined') {\n        return Buffer.from(str).toString('base64');\n    }\n    if (typeof btoa !== 'undefined') {\n        return btoa(str);\n    }\n    throw new OpenAIError('Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined');\n};\n/**\n * Converts a Base64 encoded string to a Float32Array.\n * @param base64Str - The Base64 encoded string.\n * @returns An Array of numbers interpreted as Float32 values.\n */\nexport const toFloat32Array = (base64Str) => {\n    if (typeof Buffer !== 'undefined') {\n        // for Node.js environment\n        const buf = Buffer.from(base64Str, 'base64');\n        return Array.from(new Float32Array(buf.buffer, buf.byteOffset, buf.length / Float32Array.BYTES_PER_ELEMENT));\n    }\n    else {\n        // for legacy web platform APIs\n        const binaryStr = atob(base64Str);\n        const len = binaryStr.length;\n        const bytes = new Uint8Array(len);\n        for (let i = 0; i < len; i++) {\n            bytes[i] = binaryStr.charCodeAt(i);\n        }\n        return Array.from(new Float32Array(bytes.buffer));\n    }\n};\nexport function isObj(obj) {\n    return obj != null && typeof obj === 'object' && !Array.isArray(obj);\n}\n//# sourceMappingURL=core.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { castToError } from \"./core.mjs\";\nexport class OpenAIError extends Error {\n}\nexport class APIError extends OpenAIError {\n    constructor(status, error, message, headers) {\n        super(`${APIError.makeMessage(status, error, message)}`);\n        this.status = status;\n        this.headers = headers;\n        this.request_id = headers?.['x-request-id'];\n        this.error = error;\n        const data = error;\n        this.code = data?.['code'];\n        this.param = data?.['param'];\n        this.type = data?.['type'];\n    }\n    static makeMessage(status, error, message) {\n        const msg = error?.message ?\n            typeof error.message === 'string' ?\n                error.message\n                : JSON.stringify(error.message)\n            : error ? JSON.stringify(error)\n                : message;\n        if (status && msg) {\n            return `${status} ${msg}`;\n        }\n        if (status) {\n            return `${status} status code (no body)`;\n        }\n        if (msg) {\n            return msg;\n        }\n        return '(no status code or body)';\n    }\n    static generate(status, errorResponse, message, headers) {\n        if (!status || !headers) {\n            return new APIConnectionError({ message, cause: castToError(errorResponse) });\n        }\n        const error = errorResponse?.['error'];\n        if (status === 400) {\n            return new BadRequestError(status, error, message, headers);\n        }\n        if (status === 401) {\n            return new AuthenticationError(status, error, message, headers);\n        }\n        if (status === 403) {\n            return new PermissionDeniedError(status, error, message, headers);\n        }\n        if (status === 404) {\n            return new NotFoundError(status, error, message, headers);\n        }\n        if (status === 409) {\n            return new ConflictError(status, error, message, headers);\n        }\n        if (status === 422) {\n            return new UnprocessableEntityError(status, error, message, headers);\n        }\n        if (status === 429) {\n            return new RateLimitError(status, error, message, headers);\n        }\n        if (status >= 500) {\n            return new InternalServerError(status, error, message, headers);\n        }\n        return new APIError(status, error, message, headers);\n    }\n}\nexport class APIUserAbortError extends APIError {\n    constructor({ message } = {}) {\n        super(undefined, undefined, message || 'Request was aborted.', undefined);\n    }\n}\nexport class APIConnectionError extends APIError {\n    constructor({ message, cause }) {\n        super(undefined, undefined, message || 'Connection error.', undefined);\n        // in some environments the 'cause' property is already declared\n        // @ts-ignore\n        if (cause)\n            this.cause = cause;\n    }\n}\nexport class APIConnectionTimeoutError extends APIConnectionError {\n    constructor({ message } = {}) {\n        super({ message: message ?? 'Request timed out.' });\n    }\n}\nexport class BadRequestError extends APIError {\n}\nexport class AuthenticationError extends APIError {\n}\nexport class PermissionDeniedError extends APIError {\n}\nexport class NotFoundError extends APIError {\n}\nexport class ConflictError extends APIError {\n}\nexport class UnprocessableEntityError extends APIError {\n}\nexport class RateLimitError extends APIError {\n}\nexport class InternalServerError extends APIError {\n}\nexport class LengthFinishReasonError extends OpenAIError {\n    constructor() {\n        super(`Could not parse response content as the length limit was reached`);\n    }\n}\nexport class ContentFilterFinishReasonError extends OpenAIError {\n    constructor() {\n        super(`Could not parse response content as the request was rejected by the content filter`);\n    }\n}\n//# sourceMappingURL=error.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar _a;\nimport * as qs from \"./internal/qs/index.mjs\";\nimport * as Core from \"./core.mjs\";\nimport * as Errors from \"./error.mjs\";\nimport * as Pagination from \"./pagination.mjs\";\nimport * as Uploads from \"./uploads.mjs\";\nimport * as API from \"./resources/index.mjs\";\nimport { Batches, BatchesPage, } from \"./resources/batches.mjs\";\nimport { Completions, } from \"./resources/completions.mjs\";\nimport { Embeddings, } from \"./resources/embeddings.mjs\";\nimport { FileObjectsPage, Files, } from \"./resources/files.mjs\";\nimport { Images, } from \"./resources/images.mjs\";\nimport { Models, ModelsPage } from \"./resources/models.mjs\";\nimport { Moderations, } from \"./resources/moderations.mjs\";\nimport { Audio } from \"./resources/audio/audio.mjs\";\nimport { Beta } from \"./resources/beta/beta.mjs\";\nimport { Chat } from \"./resources/chat/chat.mjs\";\nimport { ContainerListResponsesPage, Containers, } from \"./resources/containers/containers.mjs\";\nimport { EvalListResponsesPage, Evals, } from \"./resources/evals/evals.mjs\";\nimport { FineTuning } from \"./resources/fine-tuning/fine-tuning.mjs\";\nimport { Graders } from \"./resources/graders/graders.mjs\";\nimport { Responses } from \"./resources/responses/responses.mjs\";\nimport { Uploads as UploadsAPIUploads, } from \"./resources/uploads/uploads.mjs\";\nimport { VectorStoreSearchResponsesPage, VectorStores, VectorStoresPage, } from \"./resources/vector-stores/vector-stores.mjs\";\nimport { ChatCompletionsPage, } from \"./resources/chat/completions/completions.mjs\";\n/**\n * API Client for interfacing with the OpenAI API.\n */\nexport class OpenAI extends Core.APIClient {\n    /**\n     * API Client for interfacing with the OpenAI API.\n     *\n     * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]\n     * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]\n     * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]\n     * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.\n     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\n     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.\n     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\n     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\n     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.\n     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.\n     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\n     */\n    constructor({ baseURL = Core.readEnv('OPENAI_BASE_URL'), apiKey = Core.readEnv('OPENAI_API_KEY'), organization = Core.readEnv('OPENAI_ORG_ID') ?? null, project = Core.readEnv('OPENAI_PROJECT_ID') ?? null, ...opts } = {}) {\n        if (apiKey === undefined) {\n            throw new Errors.OpenAIError(\"The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).\");\n        }\n        const options = {\n            apiKey,\n            organization,\n            project,\n            ...opts,\n            baseURL: baseURL || `https://api.openai.com/v1`,\n        };\n        if (!options.dangerouslyAllowBrowser && Core.isRunningInBrowser()) {\n            throw new Errors.OpenAIError(\"It looks like you're running in a browser-like environment.\\n\\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\\nIf you understand the risks and have appropriate mitigations in place,\\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\\n\\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\\n\\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\\n\");\n        }\n        super({\n            baseURL: options.baseURL,\n            timeout: options.timeout ?? 600000 /* 10 minutes */,\n            httpAgent: options.httpAgent,\n            maxRetries: options.maxRetries,\n            fetch: options.fetch,\n        });\n        this.completions = new API.Completions(this);\n        this.chat = new API.Chat(this);\n        this.embeddings = new API.Embeddings(this);\n        this.files = new API.Files(this);\n        this.images = new API.Images(this);\n        this.audio = new API.Audio(this);\n        this.moderations = new API.Moderations(this);\n        this.models = new API.Models(this);\n        this.fineTuning = new API.FineTuning(this);\n        this.graders = new API.Graders(this);\n        this.vectorStores = new API.VectorStores(this);\n        this.beta = new API.Beta(this);\n        this.batches = new API.Batches(this);\n        this.uploads = new API.Uploads(this);\n        this.responses = new API.Responses(this);\n        this.evals = new API.Evals(this);\n        this.containers = new API.Containers(this);\n        this._options = options;\n        this.apiKey = apiKey;\n        this.organization = organization;\n        this.project = project;\n    }\n    defaultQuery() {\n        return this._options.defaultQuery;\n    }\n    defaultHeaders(opts) {\n        return {\n            ...super.defaultHeaders(opts),\n            'OpenAI-Organization': this.organization,\n            'OpenAI-Project': this.project,\n            ...this._options.defaultHeaders,\n        };\n    }\n    authHeaders(opts) {\n        return { Authorization: `Bearer ${this.apiKey}` };\n    }\n    stringifyQuery(query) {\n        return qs.stringify(query, { arrayFormat: 'brackets' });\n    }\n}\n_a = OpenAI;\nOpenAI.OpenAI = _a;\nOpenAI.DEFAULT_TIMEOUT = 600000; // 10 minutes\nOpenAI.OpenAIError = Errors.OpenAIError;\nOpenAI.APIError = Errors.APIError;\nOpenAI.APIConnectionError = Errors.APIConnectionError;\nOpenAI.APIConnectionTimeoutError = Errors.APIConnectionTimeoutError;\nOpenAI.APIUserAbortError = Errors.APIUserAbortError;\nOpenAI.NotFoundError = Errors.NotFoundError;\nOpenAI.ConflictError = Errors.ConflictError;\nOpenAI.RateLimitError = Errors.RateLimitError;\nOpenAI.BadRequestError = Errors.BadRequestError;\nOpenAI.AuthenticationError = Errors.AuthenticationError;\nOpenAI.InternalServerError = Errors.InternalServerError;\nOpenAI.PermissionDeniedError = Errors.PermissionDeniedError;\nOpenAI.UnprocessableEntityError = Errors.UnprocessableEntityError;\nOpenAI.toFile = Uploads.toFile;\nOpenAI.fileFromPath = Uploads.fileFromPath;\nOpenAI.Completions = Completions;\nOpenAI.Chat = Chat;\nOpenAI.ChatCompletionsPage = ChatCompletionsPage;\nOpenAI.Embeddings = Embeddings;\nOpenAI.Files = Files;\nOpenAI.FileObjectsPage = FileObjectsPage;\nOpenAI.Images = Images;\nOpenAI.Audio = Audio;\nOpenAI.Moderations = Moderations;\nOpenAI.Models = Models;\nOpenAI.ModelsPage = ModelsPage;\nOpenAI.FineTuning = FineTuning;\nOpenAI.Graders = Graders;\nOpenAI.VectorStores = VectorStores;\nOpenAI.VectorStoresPage = VectorStoresPage;\nOpenAI.VectorStoreSearchResponsesPage = VectorStoreSearchResponsesPage;\nOpenAI.Beta = Beta;\nOpenAI.Batches = Batches;\nOpenAI.BatchesPage = BatchesPage;\nOpenAI.Uploads = UploadsAPIUploads;\nOpenAI.Responses = Responses;\nOpenAI.Evals = Evals;\nOpenAI.EvalListResponsesPage = EvalListResponsesPage;\nOpenAI.Containers = Containers;\nOpenAI.ContainerListResponsesPage = ContainerListResponsesPage;\n/** API Client for interfacing with the Azure OpenAI API. */\nexport class AzureOpenAI extends OpenAI {\n    /**\n     * API Client for interfacing with the Azure OpenAI API.\n     *\n     * @param {string | undefined} [opts.apiVersion=process.env['OPENAI_API_VERSION'] ?? undefined]\n     * @param {string | undefined} [opts.endpoint=process.env['AZURE_OPENAI_ENDPOINT'] ?? undefined] - Your Azure endpoint, including the resource, e.g. `https://example-resource.azure.openai.com/`\n     * @param {string | undefined} [opts.apiKey=process.env['AZURE_OPENAI_API_KEY'] ?? undefined]\n     * @param {string | undefined} opts.deployment - A model deployment, if given, sets the base client URL to include `/deployments/{deployment}`.\n     * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]\n     * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL']] - Sets the base URL for the API, e.g. `https://example-resource.azure.openai.com/openai/`.\n     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\n     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.\n     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\n     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\n     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.\n     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.\n     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\n     */\n    constructor({ baseURL = Core.readEnv('OPENAI_BASE_URL'), apiKey = Core.readEnv('AZURE_OPENAI_API_KEY'), apiVersion = Core.readEnv('OPENAI_API_VERSION'), endpoint, deployment, azureADTokenProvider, dangerouslyAllowBrowser, ...opts } = {}) {\n        if (!apiVersion) {\n            throw new Errors.OpenAIError(\"The OPENAI_API_VERSION environment variable is missing or empty; either provide it, or instantiate the AzureOpenAI client with an apiVersion option, like new AzureOpenAI({ apiVersion: 'My API Version' }).\");\n        }\n        if (typeof azureADTokenProvider === 'function') {\n            dangerouslyAllowBrowser = true;\n        }\n        if (!azureADTokenProvider && !apiKey) {\n            throw new Errors.OpenAIError('Missing credentials. Please pass one of `apiKey` and `azureADTokenProvider`, or set the `AZURE_OPENAI_API_KEY` environment variable.');\n        }\n        if (azureADTokenProvider && apiKey) {\n            throw new Errors.OpenAIError('The `apiKey` and `azureADTokenProvider` arguments are mutually exclusive; only one can be passed at a time.');\n        }\n        // define a sentinel value to avoid any typing issues\n        apiKey ?? (apiKey = API_KEY_SENTINEL);\n        opts.defaultQuery = { ...opts.defaultQuery, 'api-version': apiVersion };\n        if (!baseURL) {\n            if (!endpoint) {\n                endpoint = process.env['AZURE_OPENAI_ENDPOINT'];\n            }\n            if (!endpoint) {\n                throw new Errors.OpenAIError('Must provide one of the `baseURL` or `endpoint` arguments, or the `AZURE_OPENAI_ENDPOINT` environment variable');\n            }\n            baseURL = `${endpoint}/openai`;\n        }\n        else {\n            if (endpoint) {\n                throw new Errors.OpenAIError('baseURL and endpoint are mutually exclusive');\n            }\n        }\n        super({\n            apiKey,\n            baseURL,\n            ...opts,\n            ...(dangerouslyAllowBrowser !== undefined ? { dangerouslyAllowBrowser } : {}),\n        });\n        this.apiVersion = '';\n        this._azureADTokenProvider = azureADTokenProvider;\n        this.apiVersion = apiVersion;\n        this.deploymentName = deployment;\n    }\n    buildRequest(options, props = {}) {\n        if (_deployments_endpoints.has(options.path) && options.method === 'post' && options.body !== undefined) {\n            if (!Core.isObj(options.body)) {\n                throw new Error('Expected request body to be an object');\n            }\n            const model = this.deploymentName || options.body['model'] || options.__metadata?.['model'];\n            if (model !== undefined && !this.baseURL.includes('/deployments')) {\n                options.path = `/deployments/${model}${options.path}`;\n            }\n        }\n        return super.buildRequest(options, props);\n    }\n    async _getAzureADToken() {\n        if (typeof this._azureADTokenProvider === 'function') {\n            const token = await this._azureADTokenProvider();\n            if (!token || typeof token !== 'string') {\n                throw new Errors.OpenAIError(`Expected 'azureADTokenProvider' argument to return a string but it returned ${token}`);\n            }\n            return token;\n        }\n        return undefined;\n    }\n    authHeaders(opts) {\n        return {};\n    }\n    async prepareOptions(opts) {\n        /**\n         * The user should provide a bearer token provider if they want\n         * to use Azure AD authentication. The user shouldn't set the\n         * Authorization header manually because the header is overwritten\n         * with the Azure AD token if a bearer token provider is provided.\n         */\n        if (opts.headers?.['api-key']) {\n            return super.prepareOptions(opts);\n        }\n        const token = await this._getAzureADToken();\n        opts.headers ?? (opts.headers = {});\n        if (token) {\n            opts.headers['Authorization'] = `Bearer ${token}`;\n        }\n        else if (this.apiKey !== API_KEY_SENTINEL) {\n            opts.headers['api-key'] = this.apiKey;\n        }\n        else {\n            throw new Errors.OpenAIError('Unable to handle auth');\n        }\n        return super.prepareOptions(opts);\n    }\n}\nconst _deployments_endpoints = new Set([\n    '/completions',\n    '/chat/completions',\n    '/embeddings',\n    '/audio/transcriptions',\n    '/audio/translations',\n    '/audio/speech',\n    '/images/generations',\n    '/images/edits',\n]);\nconst API_KEY_SENTINEL = '<Missing Key>';\nexport { toFile, fileFromPath } from \"./uploads.mjs\";\nexport { OpenAIError, APIError, APIConnectionError, APIConnectionTimeoutError, APIUserAbortError, NotFoundError, ConflictError, RateLimitError, BadRequestError, AuthenticationError, InternalServerError, PermissionDeniedError, UnprocessableEntityError, } from \"./error.mjs\";\nexport default OpenAI;\n//# sourceMappingURL=index.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _LineDecoder_carriageReturnIndex;\nimport { OpenAIError } from \"../../error.mjs\";\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nexport class LineDecoder {\n    constructor() {\n        _LineDecoder_carriageReturnIndex.set(this, void 0);\n        this.buffer = new Uint8Array();\n        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n    }\n    decode(chunk) {\n        if (chunk == null) {\n            return [];\n        }\n        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n            : typeof chunk === 'string' ? new TextEncoder().encode(chunk)\n                : chunk;\n        let newData = new Uint8Array(this.buffer.length + binaryChunk.length);\n        newData.set(this.buffer);\n        newData.set(binaryChunk, this.buffer.length);\n        this.buffer = newData;\n        const lines = [];\n        let patternIndex;\n        while ((patternIndex = findNewlineIndex(this.buffer, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\"))) != null) {\n            if (patternIndex.carriage && __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") == null) {\n                // skip until we either get a corresponding `\\n`, a new `\\r` or nothing\n                __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index, \"f\");\n                continue;\n            }\n            // we got double \\r or \\rtext\\n\n            if (__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") != null &&\n                (patternIndex.index !== __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") + 1 || patternIndex.carriage)) {\n                lines.push(this.decodeText(this.buffer.slice(0, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") - 1)));\n                this.buffer = this.buffer.slice(__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\"));\n                __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n                continue;\n            }\n            const endIndex = __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;\n            const line = this.decodeText(this.buffer.slice(0, endIndex));\n            lines.push(line);\n            this.buffer = this.buffer.slice(patternIndex.index);\n            __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n        }\n        return lines;\n    }\n    decodeText(bytes) {\n        if (bytes == null)\n            return '';\n        if (typeof bytes === 'string')\n            return bytes;\n        // Node:\n        if (typeof Buffer !== 'undefined') {\n            if (bytes instanceof Buffer) {\n                return bytes.toString();\n            }\n            if (bytes instanceof Uint8Array) {\n                return Buffer.from(bytes).toString();\n            }\n            throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`);\n        }\n        // Browser\n        if (typeof TextDecoder !== 'undefined') {\n            if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n                this.textDecoder ?? (this.textDecoder = new TextDecoder('utf8'));\n                return this.textDecoder.decode(bytes);\n            }\n            throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);\n        }\n        throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);\n    }\n    flush() {\n        if (!this.buffer.length) {\n            return [];\n        }\n        return this.decode('\\n');\n    }\n}\n_LineDecoder_carriageReturnIndex = new WeakMap();\n// prettier-ignore\nLineDecoder.NEWLINE_CHARS = new Set(['\\n', '\\r']);\nLineDecoder.NEWLINE_REGEXP = /\\r\\n|[\\n\\r]/g;\n/**\n * This function searches the buffer for the end patterns, (\\r or \\n)\n * and returns an object with the index preceding the matched newline and the\n * index after the newline char. `null` is returned if no new line is found.\n *\n * ```ts\n * findNewLineIndex('abc\\ndef') -> { preceding: 2, index: 3 }\n * ```\n */\nfunction findNewlineIndex(buffer, startIndex) {\n    const newline = 0x0a; // \\n\n    const carriage = 0x0d; // \\r\n    for (let i = startIndex ?? 0; i < buffer.length; i++) {\n        if (buffer[i] === newline) {\n            return { preceding: i, index: i + 1, carriage: false };\n        }\n        if (buffer[i] === carriage) {\n            return { preceding: i, index: i + 1, carriage: true };\n        }\n    }\n    return null;\n}\nexport function findDoubleNewlineIndex(buffer) {\n    // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n    // and returns the index right after the first occurrence of any pattern,\n    // or -1 if none of the patterns are found.\n    const newline = 0x0a; // \\n\n    const carriage = 0x0d; // \\r\n    for (let i = 0; i < buffer.length - 1; i++) {\n        if (buffer[i] === newline && buffer[i + 1] === newline) {\n            // \\n\\n\n            return i + 2;\n        }\n        if (buffer[i] === carriage && buffer[i + 1] === carriage) {\n            // \\r\\r\n            return i + 2;\n        }\n        if (buffer[i] === carriage &&\n            buffer[i + 1] === newline &&\n            i + 3 < buffer.length &&\n            buffer[i + 2] === carriage &&\n            buffer[i + 3] === newline) {\n            // \\r\\n\\r\\n\n            return i + 4;\n        }\n    }\n    return -1;\n}\n//# sourceMappingURL=line.mjs.map","export const default_format = 'RFC3986';\nexport const formatters = {\n    RFC1738: (v) => String(v).replace(/%20/g, '+'),\n    RFC3986: (v) => String(v),\n};\nexport const RFC1738 = 'RFC1738';\nexport const RFC3986 = 'RFC3986';\n//# sourceMappingURL=formats.mjs.map","import { encode, is_buffer, maybe_map } from \"./utils.mjs\";\nimport { default_format, formatters } from \"./formats.mjs\";\nconst has = Object.prototype.hasOwnProperty;\nconst array_prefix_generators = {\n    brackets(prefix) {\n        return String(prefix) + '[]';\n    },\n    comma: 'comma',\n    indices(prefix, key) {\n        return String(prefix) + '[' + key + ']';\n    },\n    repeat(prefix) {\n        return String(prefix);\n    },\n};\nconst is_array = Array.isArray;\nconst push = Array.prototype.push;\nconst push_to_array = function (arr, value_or_array) {\n    push.apply(arr, is_array(value_or_array) ? value_or_array : [value_or_array]);\n};\nconst to_ISO = Date.prototype.toISOString;\nconst defaults = {\n    addQueryPrefix: false,\n    allowDots: false,\n    allowEmptyArrays: false,\n    arrayFormat: 'indices',\n    charset: 'utf-8',\n    charsetSentinel: false,\n    delimiter: '&',\n    encode: true,\n    encodeDotInKeys: false,\n    encoder: encode,\n    encodeValuesOnly: false,\n    format: default_format,\n    formatter: formatters[default_format],\n    /** @deprecated */\n    indices: false,\n    serializeDate(date) {\n        return to_ISO.call(date);\n    },\n    skipNulls: false,\n    strictNullHandling: false,\n};\nfunction is_non_nullish_primitive(v) {\n    return (typeof v === 'string' ||\n        typeof v === 'number' ||\n        typeof v === 'boolean' ||\n        typeof v === 'symbol' ||\n        typeof v === 'bigint');\n}\nconst sentinel = {};\nfunction inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {\n    let obj = object;\n    let tmp_sc = sideChannel;\n    let step = 0;\n    let find_flag = false;\n    while ((tmp_sc = tmp_sc.get(sentinel)) !== void undefined && !find_flag) {\n        // Where object last appeared in the ref tree\n        const pos = tmp_sc.get(object);\n        step += 1;\n        if (typeof pos !== 'undefined') {\n            if (pos === step) {\n                throw new RangeError('Cyclic object value');\n            }\n            else {\n                find_flag = true; // Break while\n            }\n        }\n        if (typeof tmp_sc.get(sentinel) === 'undefined') {\n            step = 0;\n        }\n    }\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    }\n    else if (obj instanceof Date) {\n        obj = serializeDate?.(obj);\n    }\n    else if (generateArrayPrefix === 'comma' && is_array(obj)) {\n        obj = maybe_map(obj, function (value) {\n            if (value instanceof Date) {\n                return serializeDate?.(value);\n            }\n            return value;\n        });\n    }\n    if (obj === null) {\n        if (strictNullHandling) {\n            return encoder && !encodeValuesOnly ?\n                // @ts-expect-error\n                encoder(prefix, defaults.encoder, charset, 'key', format)\n                : prefix;\n        }\n        obj = '';\n    }\n    if (is_non_nullish_primitive(obj) || is_buffer(obj)) {\n        if (encoder) {\n            const key_value = encodeValuesOnly ? prefix\n                // @ts-expect-error\n                : encoder(prefix, defaults.encoder, charset, 'key', format);\n            return [\n                formatter?.(key_value) +\n                    '=' +\n                    // @ts-expect-error\n                    formatter?.(encoder(obj, defaults.encoder, charset, 'value', format)),\n            ];\n        }\n        return [formatter?.(prefix) + '=' + formatter?.(String(obj))];\n    }\n    const values = [];\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n    let obj_keys;\n    if (generateArrayPrefix === 'comma' && is_array(obj)) {\n        // we need to join elements in\n        if (encodeValuesOnly && encoder) {\n            // @ts-expect-error values only\n            obj = maybe_map(obj, encoder);\n        }\n        obj_keys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];\n    }\n    else if (is_array(filter)) {\n        obj_keys = filter;\n    }\n    else {\n        const keys = Object.keys(obj);\n        obj_keys = sort ? keys.sort(sort) : keys;\n    }\n    const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\\./g, '%2E') : String(prefix);\n    const adjusted_prefix = commaRoundTrip && is_array(obj) && obj.length === 1 ? encoded_prefix + '[]' : encoded_prefix;\n    if (allowEmptyArrays && is_array(obj) && obj.length === 0) {\n        return adjusted_prefix + '[]';\n    }\n    for (let j = 0; j < obj_keys.length; ++j) {\n        const key = obj_keys[j];\n        const value = \n        // @ts-ignore\n        typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];\n        if (skipNulls && value === null) {\n            continue;\n        }\n        // @ts-ignore\n        const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\\./g, '%2E') : key;\n        const key_prefix = is_array(obj) ?\n            typeof generateArrayPrefix === 'function' ?\n                generateArrayPrefix(adjusted_prefix, encoded_key)\n                : adjusted_prefix\n            : adjusted_prefix + (allowDots ? '.' + encoded_key : '[' + encoded_key + ']');\n        sideChannel.set(object, step);\n        const valueSideChannel = new WeakMap();\n        valueSideChannel.set(sentinel, sideChannel);\n        push_to_array(values, inner_stringify(value, key_prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, \n        // @ts-ignore\n        generateArrayPrefix === 'comma' && encodeValuesOnly && is_array(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));\n    }\n    return values;\n}\nfunction normalize_stringify_options(opts = defaults) {\n    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {\n        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');\n    }\n    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {\n        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');\n    }\n    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n    const charset = opts.charset || defaults.charset;\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n    let format = default_format;\n    if (typeof opts.format !== 'undefined') {\n        if (!has.call(formatters, opts.format)) {\n            throw new TypeError('Unknown format option provided.');\n        }\n        format = opts.format;\n    }\n    const formatter = formatters[format];\n    let filter = defaults.filter;\n    if (typeof opts.filter === 'function' || is_array(opts.filter)) {\n        filter = opts.filter;\n    }\n    let arrayFormat;\n    if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {\n        arrayFormat = opts.arrayFormat;\n    }\n    else if ('indices' in opts) {\n        arrayFormat = opts.indices ? 'indices' : 'repeat';\n    }\n    else {\n        arrayFormat = defaults.arrayFormat;\n    }\n    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {\n        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');\n    }\n    const allowDots = typeof opts.allowDots === 'undefined' ?\n        !!opts.encodeDotInKeys === true ?\n            true\n            : defaults.allowDots\n        : !!opts.allowDots;\n    return {\n        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,\n        // @ts-ignore\n        allowDots: allowDots,\n        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,\n        arrayFormat: arrayFormat,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        commaRoundTrip: !!opts.commaRoundTrip,\n        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,\n        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,\n        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,\n        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,\n        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,\n        filter: filter,\n        format: format,\n        formatter: formatter,\n        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,\n        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,\n        // @ts-ignore\n        sort: typeof opts.sort === 'function' ? opts.sort : null,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling,\n    };\n}\nexport function stringify(object, opts = {}) {\n    let obj = object;\n    const options = normalize_stringify_options(opts);\n    let obj_keys;\n    let filter;\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    }\n    else if (is_array(options.filter)) {\n        filter = options.filter;\n        obj_keys = filter;\n    }\n    const keys = [];\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n    const generateArrayPrefix = array_prefix_generators[options.arrayFormat];\n    const commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;\n    if (!obj_keys) {\n        obj_keys = Object.keys(obj);\n    }\n    if (options.sort) {\n        obj_keys.sort(options.sort);\n    }\n    const sideChannel = new WeakMap();\n    for (let i = 0; i < obj_keys.length; ++i) {\n        const key = obj_keys[i];\n        if (options.skipNulls && obj[key] === null) {\n            continue;\n        }\n        push_to_array(keys, inner_stringify(obj[key], key, \n        // @ts-expect-error\n        generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));\n    }\n    const joined = keys.join(options.delimiter);\n    let prefix = options.addQueryPrefix === true ? '?' : '';\n    if (options.charsetSentinel) {\n        if (options.charset === 'iso-8859-1') {\n            // encodeURIComponent('&#10003;'), the \"numeric entity\" representation of a checkmark\n            prefix += 'utf8=%26%2310003%3B&';\n        }\n        else {\n            // encodeURIComponent('')\n            prefix += 'utf8=%E2%9C%93&';\n        }\n    }\n    return joined.length > 0 ? prefix + joined : '';\n}\n//# sourceMappingURL=stringify.mjs.map","import { RFC1738 } from \"./formats.mjs\";\nconst has = Object.prototype.hasOwnProperty;\nconst is_array = Array.isArray;\nconst hex_table = (() => {\n    const array = [];\n    for (let i = 0; i < 256; ++i) {\n        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\n    }\n    return array;\n})();\nfunction compact_queue(queue) {\n    while (queue.length > 1) {\n        const item = queue.pop();\n        if (!item)\n            continue;\n        const obj = item.obj[item.prop];\n        if (is_array(obj)) {\n            const compacted = [];\n            for (let j = 0; j < obj.length; ++j) {\n                if (typeof obj[j] !== 'undefined') {\n                    compacted.push(obj[j]);\n                }\n            }\n            // @ts-ignore\n            item.obj[item.prop] = compacted;\n        }\n    }\n}\nfunction array_to_object(source, options) {\n    const obj = options && options.plainObjects ? Object.create(null) : {};\n    for (let i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n    return obj;\n}\nexport function merge(target, source, options = {}) {\n    if (!source) {\n        return target;\n    }\n    if (typeof source !== 'object') {\n        if (is_array(target)) {\n            target.push(source);\n        }\n        else if (target && typeof target === 'object') {\n            if ((options && (options.plainObjects || options.allowPrototypes)) ||\n                !has.call(Object.prototype, source)) {\n                target[source] = true;\n            }\n        }\n        else {\n            return [target, source];\n        }\n        return target;\n    }\n    if (!target || typeof target !== 'object') {\n        return [target].concat(source);\n    }\n    let mergeTarget = target;\n    if (is_array(target) && !is_array(source)) {\n        // @ts-ignore\n        mergeTarget = array_to_object(target, options);\n    }\n    if (is_array(target) && is_array(source)) {\n        source.forEach(function (item, i) {\n            if (has.call(target, i)) {\n                const targetItem = target[i];\n                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {\n                    target[i] = merge(targetItem, item, options);\n                }\n                else {\n                    target.push(item);\n                }\n            }\n            else {\n                target[i] = item;\n            }\n        });\n        return target;\n    }\n    return Object.keys(source).reduce(function (acc, key) {\n        const value = source[key];\n        if (has.call(acc, key)) {\n            acc[key] = merge(acc[key], value, options);\n        }\n        else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n}\nexport function assign_single_source(target, source) {\n    return Object.keys(source).reduce(function (acc, key) {\n        acc[key] = source[key];\n        return acc;\n    }, target);\n}\nexport function decode(str, _, charset) {\n    const strWithoutPlus = str.replace(/\\+/g, ' ');\n    if (charset === 'iso-8859-1') {\n        // unescape never throws, no try...catch needed:\n        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\n    }\n    // utf-8\n    try {\n        return decodeURIComponent(strWithoutPlus);\n    }\n    catch (e) {\n        return strWithoutPlus;\n    }\n}\nconst limit = 1024;\nexport const encode = (str, _defaultEncoder, charset, _kind, format) => {\n    // This code was originally written by Brian White for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n    let string = str;\n    if (typeof str === 'symbol') {\n        string = Symbol.prototype.toString.call(str);\n    }\n    else if (typeof str !== 'string') {\n        string = String(str);\n    }\n    if (charset === 'iso-8859-1') {\n        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\n            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';\n        });\n    }\n    let out = '';\n    for (let j = 0; j < string.length; j += limit) {\n        const segment = string.length >= limit ? string.slice(j, j + limit) : string;\n        const arr = [];\n        for (let i = 0; i < segment.length; ++i) {\n            let c = segment.charCodeAt(i);\n            if (c === 0x2d || // -\n                c === 0x2e || // .\n                c === 0x5f || // _\n                c === 0x7e || // ~\n                (c >= 0x30 && c <= 0x39) || // 0-9\n                (c >= 0x41 && c <= 0x5a) || // a-z\n                (c >= 0x61 && c <= 0x7a) || // A-Z\n                (format === RFC1738 && (c === 0x28 || c === 0x29)) // ( )\n            ) {\n                arr[arr.length] = segment.charAt(i);\n                continue;\n            }\n            if (c < 0x80) {\n                arr[arr.length] = hex_table[c];\n                continue;\n            }\n            if (c < 0x800) {\n                arr[arr.length] = hex_table[0xc0 | (c >> 6)] + hex_table[0x80 | (c & 0x3f)];\n                continue;\n            }\n            if (c < 0xd800 || c >= 0xe000) {\n                arr[arr.length] =\n                    hex_table[0xe0 | (c >> 12)] + hex_table[0x80 | ((c >> 6) & 0x3f)] + hex_table[0x80 | (c & 0x3f)];\n                continue;\n            }\n            i += 1;\n            c = 0x10000 + (((c & 0x3ff) << 10) | (segment.charCodeAt(i) & 0x3ff));\n            arr[arr.length] =\n                hex_table[0xf0 | (c >> 18)] +\n                    hex_table[0x80 | ((c >> 12) & 0x3f)] +\n                    hex_table[0x80 | ((c >> 6) & 0x3f)] +\n                    hex_table[0x80 | (c & 0x3f)];\n        }\n        out += arr.join('');\n    }\n    return out;\n};\nexport function compact(value) {\n    const queue = [{ obj: { o: value }, prop: 'o' }];\n    const refs = [];\n    for (let i = 0; i < queue.length; ++i) {\n        const item = queue[i];\n        // @ts-ignore\n        const obj = item.obj[item.prop];\n        const keys = Object.keys(obj);\n        for (let j = 0; j < keys.length; ++j) {\n            const key = keys[j];\n            const val = obj[key];\n            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n                queue.push({ obj: obj, prop: key });\n                refs.push(val);\n            }\n        }\n    }\n    compact_queue(queue);\n    return value;\n}\nexport function is_regexp(obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n}\nexport function is_buffer(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return false;\n    }\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n}\nexport function combine(a, b) {\n    return [].concat(a, b);\n}\nexport function maybe_map(val, fn) {\n    if (is_array(val)) {\n        const mapped = [];\n        for (let i = 0; i < val.length; i += 1) {\n            mapped.push(fn(val[i]));\n        }\n        return mapped;\n    }\n    return fn(val);\n}\n//# sourceMappingURL=utils.mjs.map","/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport function ReadableStreamToAsyncIterable(stream) {\n    if (stream[Symbol.asyncIterator])\n        return stream;\n    const reader = stream.getReader();\n    return {\n        async next() {\n            try {\n                const result = await reader.read();\n                if (result?.done)\n                    reader.releaseLock(); // release lock when stream becomes closed\n                return result;\n            }\n            catch (e) {\n                reader.releaseLock(); // release lock when stream becomes errored\n                throw e;\n            }\n        },\n        async return() {\n            const cancelPromise = reader.cancel();\n            reader.releaseLock();\n            await cancelPromise;\n            return { done: true, value: undefined };\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\n//# sourceMappingURL=stream-utils.mjs.map","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionCall, _AbstractChatCompletionRunner_getFinalFunctionCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult;\nimport { OpenAIError } from \"../error.mjs\";\nimport { isRunnableFunctionWithParse, } from \"./RunnableFunction.mjs\";\nimport { isAssistantMessage, isFunctionMessage, isToolMessage } from \"./chatCompletionUtils.mjs\";\nimport { EventStream } from \"./EventStream.mjs\";\nimport { isAutoParsableTool, parseChatCompletion } from \"../lib/parser.mjs\";\nconst DEFAULT_MAX_CHAT_COMPLETIONS = 10;\nexport class AbstractChatCompletionRunner extends EventStream {\n    constructor() {\n        super(...arguments);\n        _AbstractChatCompletionRunner_instances.add(this);\n        this._chatCompletions = [];\n        this.messages = [];\n    }\n    _addChatCompletion(chatCompletion) {\n        this._chatCompletions.push(chatCompletion);\n        this._emit('chatCompletion', chatCompletion);\n        const message = chatCompletion.choices[0]?.message;\n        if (message)\n            this._addMessage(message);\n        return chatCompletion;\n    }\n    _addMessage(message, emit = true) {\n        if (!('content' in message))\n            message.content = null;\n        this.messages.push(message);\n        if (emit) {\n            this._emit('message', message);\n            if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {\n                // Note, this assumes that {role: 'tool', content: } is always the result of a call of tool of type=function.\n                this._emit('functionCallResult', message.content);\n            }\n            else if (isAssistantMessage(message) && message.function_call) {\n                this._emit('functionCall', message.function_call);\n            }\n            else if (isAssistantMessage(message) && message.tool_calls) {\n                for (const tool_call of message.tool_calls) {\n                    if (tool_call.type === 'function') {\n                        this._emit('functionCall', tool_call.function);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * @returns a promise that resolves with the final ChatCompletion, or rejects\n     * if an error occurred or the stream ended prematurely without producing a ChatCompletion.\n     */\n    async finalChatCompletion() {\n        await this.done();\n        const completion = this._chatCompletions[this._chatCompletions.length - 1];\n        if (!completion)\n            throw new OpenAIError('stream ended without producing a ChatCompletion');\n        return completion;\n    }\n    /**\n     * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects\n     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n     */\n    async finalContent() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalContent).call(this);\n    }\n    /**\n     * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,\n     * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n     */\n    async finalMessage() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this);\n    }\n    /**\n     * @returns a promise that resolves with the content of the final FunctionCall, or rejects\n     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n     */\n    async finalFunctionCall() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);\n    }\n    async finalFunctionCallResult() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);\n    }\n    async totalUsage() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);\n    }\n    allChatCompletions() {\n        return [...this._chatCompletions];\n    }\n    _emitFinal() {\n        const completion = this._chatCompletions[this._chatCompletions.length - 1];\n        if (completion)\n            this._emit('finalChatCompletion', completion);\n        const finalMessage = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this);\n        if (finalMessage)\n            this._emit('finalMessage', finalMessage);\n        const finalContent = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalContent).call(this);\n        if (finalContent)\n            this._emit('finalContent', finalContent);\n        const finalFunctionCall = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);\n        if (finalFunctionCall)\n            this._emit('finalFunctionCall', finalFunctionCall);\n        const finalFunctionCallResult = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);\n        if (finalFunctionCallResult != null)\n            this._emit('finalFunctionCallResult', finalFunctionCallResult);\n        if (this._chatCompletions.some((c) => c.usage)) {\n            this._emit('totalUsage', __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));\n        }\n    }\n    async _createChatCompletion(client, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_validateParams).call(this, params);\n        const chatCompletion = await client.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });\n        this._connected();\n        return this._addChatCompletion(parseChatCompletion(chatCompletion, params));\n    }\n    async _runChatCompletion(client, params, options) {\n        for (const message of params.messages) {\n            this._addMessage(message, false);\n        }\n        return await this._createChatCompletion(client, params, options);\n    }\n    async _runFunctions(client, params, options) {\n        const role = 'function';\n        const { function_call = 'auto', stream, ...restParams } = params;\n        const singleFunctionToCall = typeof function_call !== 'string' && function_call?.name;\n        const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n        const functionsByName = {};\n        for (const f of params.functions) {\n            functionsByName[f.name || f.function.name] = f;\n        }\n        const functions = params.functions.map((f) => ({\n            name: f.name || f.function.name,\n            parameters: f.parameters,\n            description: f.description,\n        }));\n        for (const message of params.messages) {\n            this._addMessage(message, false);\n        }\n        for (let i = 0; i < maxChatCompletions; ++i) {\n            const chatCompletion = await this._createChatCompletion(client, {\n                ...restParams,\n                function_call,\n                functions,\n                messages: [...this.messages],\n            }, options);\n            const message = chatCompletion.choices[0]?.message;\n            if (!message) {\n                throw new OpenAIError(`missing message in ChatCompletion response`);\n            }\n            if (!message.function_call)\n                return;\n            const { name, arguments: args } = message.function_call;\n            const fn = functionsByName[name];\n            if (!fn) {\n                const content = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions\n                    .map((f) => JSON.stringify(f.name))\n                    .join(', ')}. Please try again`;\n                this._addMessage({ role, name, content });\n                continue;\n            }\n            else if (singleFunctionToCall && singleFunctionToCall !== name) {\n                const content = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;\n                this._addMessage({ role, name, content });\n                continue;\n            }\n            let parsed;\n            try {\n                parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\n            }\n            catch (error) {\n                this._addMessage({\n                    role,\n                    name,\n                    content: error instanceof Error ? error.message : String(error),\n                });\n                continue;\n            }\n            // @ts-expect-error it can't rule out `never` type.\n            const rawContent = await fn.function(parsed, this);\n            const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);\n            this._addMessage({ role, name, content });\n            if (singleFunctionToCall)\n                return;\n        }\n    }\n    async _runTools(client, params, options) {\n        const role = 'tool';\n        const { tool_choice = 'auto', stream, ...restParams } = params;\n        const singleFunctionToCall = typeof tool_choice !== 'string' && tool_choice?.function?.name;\n        const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n        // TODO(someday): clean this logic up\n        const inputTools = params.tools.map((tool) => {\n            if (isAutoParsableTool(tool)) {\n                if (!tool.$callback) {\n                    throw new OpenAIError('Tool given to `.runTools()` that does not have an associated function');\n                }\n                return {\n                    type: 'function',\n                    function: {\n                        function: tool.$callback,\n                        name: tool.function.name,\n                        description: tool.function.description || '',\n                        parameters: tool.function.parameters,\n                        parse: tool.$parseRaw,\n                        strict: true,\n                    },\n                };\n            }\n            return tool;\n        });\n        const functionsByName = {};\n        for (const f of inputTools) {\n            if (f.type === 'function') {\n                functionsByName[f.function.name || f.function.function.name] = f.function;\n            }\n        }\n        const tools = 'tools' in params ?\n            inputTools.map((t) => t.type === 'function' ?\n                {\n                    type: 'function',\n                    function: {\n                        name: t.function.name || t.function.function.name,\n                        parameters: t.function.parameters,\n                        description: t.function.description,\n                        strict: t.function.strict,\n                    },\n                }\n                : t)\n            : undefined;\n        for (const message of params.messages) {\n            this._addMessage(message, false);\n        }\n        for (let i = 0; i < maxChatCompletions; ++i) {\n            const chatCompletion = await this._createChatCompletion(client, {\n                ...restParams,\n                tool_choice,\n                tools,\n                messages: [...this.messages],\n            }, options);\n            const message = chatCompletion.choices[0]?.message;\n            if (!message) {\n                throw new OpenAIError(`missing message in ChatCompletion response`);\n            }\n            if (!message.tool_calls?.length) {\n                return;\n            }\n            for (const tool_call of message.tool_calls) {\n                if (tool_call.type !== 'function')\n                    continue;\n                const tool_call_id = tool_call.id;\n                const { name, arguments: args } = tool_call.function;\n                const fn = functionsByName[name];\n                if (!fn) {\n                    const content = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName)\n                        .map((name) => JSON.stringify(name))\n                        .join(', ')}. Please try again`;\n                    this._addMessage({ role, tool_call_id, content });\n                    continue;\n                }\n                else if (singleFunctionToCall && singleFunctionToCall !== name) {\n                    const content = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;\n                    this._addMessage({ role, tool_call_id, content });\n                    continue;\n                }\n                let parsed;\n                try {\n                    parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\n                }\n                catch (error) {\n                    const content = error instanceof Error ? error.message : String(error);\n                    this._addMessage({ role, tool_call_id, content });\n                    continue;\n                }\n                // @ts-expect-error it can't rule out `never` type.\n                const rawContent = await fn.function(parsed, this);\n                const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);\n                this._addMessage({ role, tool_call_id, content });\n                if (singleFunctionToCall) {\n                    return;\n                }\n            }\n        }\n        return;\n    }\n}\n_AbstractChatCompletionRunner_instances = new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent() {\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;\n}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage() {\n    let i = this.messages.length;\n    while (i-- > 0) {\n        const message = this.messages[i];\n        if (isAssistantMessage(message)) {\n            const { function_call, ...rest } = message;\n            // TODO: support audio here\n            const ret = {\n                ...rest,\n                content: message.content ?? null,\n                refusal: message.refusal ?? null,\n            };\n            if (function_call) {\n                ret.function_call = function_call;\n            }\n            return ret;\n        }\n    }\n    throw new OpenAIError('stream ended without producing a ChatCompletionMessage with role=assistant');\n}, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall() {\n    for (let i = this.messages.length - 1; i >= 0; i--) {\n        const message = this.messages[i];\n        if (isAssistantMessage(message) && message?.function_call) {\n            return message.function_call;\n        }\n        if (isAssistantMessage(message) && message?.tool_calls?.length) {\n            return message.tool_calls.at(-1)?.function;\n        }\n    }\n    return;\n}, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult() {\n    for (let i = this.messages.length - 1; i >= 0; i--) {\n        const message = this.messages[i];\n        if (isFunctionMessage(message) && message.content != null) {\n            return message.content;\n        }\n        if (isToolMessage(message) &&\n            message.content != null &&\n            typeof message.content === 'string' &&\n            this.messages.some((x) => x.role === 'assistant' &&\n                x.tool_calls?.some((y) => y.type === 'function' && y.id === message.tool_call_id))) {\n            return message.content;\n        }\n    }\n    return;\n}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage() {\n    const total = {\n        completion_tokens: 0,\n        prompt_tokens: 0,\n        total_tokens: 0,\n    };\n    for (const { usage } of this._chatCompletions) {\n        if (usage) {\n            total.completion_tokens += usage.completion_tokens;\n            total.prompt_tokens += usage.prompt_tokens;\n            total.total_tokens += usage.total_tokens;\n        }\n    }\n    return total;\n}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams(params) {\n    if (params.n != null && params.n > 1) {\n        throw new OpenAIError('ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.');\n    }\n}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult(rawContent) {\n    return (typeof rawContent === 'string' ? rawContent\n        : rawContent === undefined ? 'undefined'\n            : JSON.stringify(rawContent));\n};\n//# sourceMappingURL=AbstractChatCompletionRunner.mjs.map","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _AssistantStream_instances, _AssistantStream_events, _AssistantStream_runStepSnapshots, _AssistantStream_messageSnapshots, _AssistantStream_messageSnapshot, _AssistantStream_finalRun, _AssistantStream_currentContentIndex, _AssistantStream_currentContent, _AssistantStream_currentToolCallIndex, _AssistantStream_currentToolCall, _AssistantStream_currentEvent, _AssistantStream_currentRunSnapshot, _AssistantStream_currentRunStepSnapshot, _AssistantStream_addEvent, _AssistantStream_endRequest, _AssistantStream_handleMessage, _AssistantStream_handleRunStep, _AssistantStream_handleEvent, _AssistantStream_accumulateRunStep, _AssistantStream_accumulateMessage, _AssistantStream_accumulateContent, _AssistantStream_handleRun;\nimport * as Core from \"../core.mjs\";\nimport { Stream } from \"../streaming.mjs\";\nimport { APIUserAbortError, OpenAIError } from \"../error.mjs\";\nimport { EventStream } from \"./EventStream.mjs\";\nexport class AssistantStream extends EventStream {\n    constructor() {\n        super(...arguments);\n        _AssistantStream_instances.add(this);\n        //Track all events in a single list for reference\n        _AssistantStream_events.set(this, []);\n        //Used to accumulate deltas\n        //We are accumulating many types so the value here is not strict\n        _AssistantStream_runStepSnapshots.set(this, {});\n        _AssistantStream_messageSnapshots.set(this, {});\n        _AssistantStream_messageSnapshot.set(this, void 0);\n        _AssistantStream_finalRun.set(this, void 0);\n        _AssistantStream_currentContentIndex.set(this, void 0);\n        _AssistantStream_currentContent.set(this, void 0);\n        _AssistantStream_currentToolCallIndex.set(this, void 0);\n        _AssistantStream_currentToolCall.set(this, void 0);\n        //For current snapshot methods\n        _AssistantStream_currentEvent.set(this, void 0);\n        _AssistantStream_currentRunSnapshot.set(this, void 0);\n        _AssistantStream_currentRunStepSnapshot.set(this, void 0);\n    }\n    [(_AssistantStream_events = new WeakMap(), _AssistantStream_runStepSnapshots = new WeakMap(), _AssistantStream_messageSnapshots = new WeakMap(), _AssistantStream_messageSnapshot = new WeakMap(), _AssistantStream_finalRun = new WeakMap(), _AssistantStream_currentContentIndex = new WeakMap(), _AssistantStream_currentContent = new WeakMap(), _AssistantStream_currentToolCallIndex = new WeakMap(), _AssistantStream_currentToolCall = new WeakMap(), _AssistantStream_currentEvent = new WeakMap(), _AssistantStream_currentRunSnapshot = new WeakMap(), _AssistantStream_currentRunStepSnapshot = new WeakMap(), _AssistantStream_instances = new WeakSet(), Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        //Catch all for passing along all events\n        this.on('event', (event) => {\n            const reader = readQueue.shift();\n            if (reader) {\n                reader.resolve(event);\n            }\n            else {\n                pushQueue.push(event);\n            }\n        });\n        this.on('end', () => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.resolve(undefined);\n            }\n            readQueue.length = 0;\n        });\n        this.on('abort', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        this.on('error', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        return {\n            next: async () => {\n                if (!pushQueue.length) {\n                    if (done) {\n                        return { value: undefined, done: true };\n                    }\n                    return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n                }\n                const chunk = pushQueue.shift();\n                return { value: chunk, done: false };\n            },\n            return: async () => {\n                this.abort();\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    static fromReadableStream(stream) {\n        const runner = new AssistantStream();\n        runner._run(() => runner._fromReadableStream(stream));\n        return runner;\n    }\n    async _fromReadableStream(readableStream, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        this._connected();\n        const stream = Stream.fromReadableStream(readableStream, this.controller);\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n    }\n    toReadableStream() {\n        const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n        return stream.toReadableStream();\n    }\n    static createToolAssistantStream(threadId, runId, runs, params, options) {\n        const runner = new AssistantStream();\n        runner._run(() => runner._runToolAssistantStream(threadId, runId, runs, params, {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n        }));\n        return runner;\n    }\n    async _createToolAssistantStream(run, threadId, runId, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        const body = { ...params, stream: true };\n        const stream = await run.submitToolOutputs(threadId, runId, body, {\n            ...options,\n            signal: this.controller.signal,\n        });\n        this._connected();\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n    }\n    static createThreadAssistantStream(params, thread, options) {\n        const runner = new AssistantStream();\n        runner._run(() => runner._threadAssistantStream(params, thread, {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n        }));\n        return runner;\n    }\n    static createAssistantStream(threadId, runs, params, options) {\n        const runner = new AssistantStream();\n        runner._run(() => runner._runAssistantStream(threadId, runs, params, {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n        }));\n        return runner;\n    }\n    currentEvent() {\n        return __classPrivateFieldGet(this, _AssistantStream_currentEvent, \"f\");\n    }\n    currentRun() {\n        return __classPrivateFieldGet(this, _AssistantStream_currentRunSnapshot, \"f\");\n    }\n    currentMessageSnapshot() {\n        return __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\");\n    }\n    currentRunStepSnapshot() {\n        return __classPrivateFieldGet(this, _AssistantStream_currentRunStepSnapshot, \"f\");\n    }\n    async finalRunSteps() {\n        await this.done();\n        return Object.values(__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\"));\n    }\n    async finalMessages() {\n        await this.done();\n        return Object.values(__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, \"f\"));\n    }\n    async finalRun() {\n        await this.done();\n        if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\"))\n            throw Error('Final run was not received.');\n        return __classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\");\n    }\n    async _createThreadAssistantStream(thread, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        const body = { ...params, stream: true };\n        const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });\n        this._connected();\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n    }\n    async _createAssistantStream(run, threadId, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        const body = { ...params, stream: true };\n        const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });\n        this._connected();\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n    }\n    static accumulateDelta(acc, delta) {\n        for (const [key, deltaValue] of Object.entries(delta)) {\n            if (!acc.hasOwnProperty(key)) {\n                acc[key] = deltaValue;\n                continue;\n            }\n            let accValue = acc[key];\n            if (accValue === null || accValue === undefined) {\n                acc[key] = deltaValue;\n                continue;\n            }\n            // We don't accumulate these special properties\n            if (key === 'index' || key === 'type') {\n                acc[key] = deltaValue;\n                continue;\n            }\n            // Type-specific accumulation logic\n            if (typeof accValue === 'string' && typeof deltaValue === 'string') {\n                accValue += deltaValue;\n            }\n            else if (typeof accValue === 'number' && typeof deltaValue === 'number') {\n                accValue += deltaValue;\n            }\n            else if (Core.isObj(accValue) && Core.isObj(deltaValue)) {\n                accValue = this.accumulateDelta(accValue, deltaValue);\n            }\n            else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {\n                if (accValue.every((x) => typeof x === 'string' || typeof x === 'number')) {\n                    accValue.push(...deltaValue); // Use spread syntax for efficient addition\n                    continue;\n                }\n                for (const deltaEntry of deltaValue) {\n                    if (!Core.isObj(deltaEntry)) {\n                        throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);\n                    }\n                    const index = deltaEntry['index'];\n                    if (index == null) {\n                        console.error(deltaEntry);\n                        throw new Error('Expected array delta entry to have an `index` property');\n                    }\n                    if (typeof index !== 'number') {\n                        throw new Error(`Expected array delta entry \\`index\\` property to be a number but got ${index}`);\n                    }\n                    const accEntry = accValue[index];\n                    if (accEntry == null) {\n                        accValue.push(deltaEntry);\n                    }\n                    else {\n                        accValue[index] = this.accumulateDelta(accEntry, deltaEntry);\n                    }\n                }\n                continue;\n            }\n            else {\n                throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);\n            }\n            acc[key] = accValue;\n        }\n        return acc;\n    }\n    _addRun(run) {\n        return run;\n    }\n    async _threadAssistantStream(params, thread, options) {\n        return await this._createThreadAssistantStream(thread, params, options);\n    }\n    async _runAssistantStream(threadId, runs, params, options) {\n        return await this._createAssistantStream(runs, threadId, params, options);\n    }\n    async _runToolAssistantStream(threadId, runId, runs, params, options) {\n        return await this._createToolAssistantStream(runs, threadId, runId, params, options);\n    }\n}\n_AssistantStream_addEvent = function _AssistantStream_addEvent(event) {\n    if (this.ended)\n        return;\n    __classPrivateFieldSet(this, _AssistantStream_currentEvent, event, \"f\");\n    __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleEvent).call(this, event);\n    switch (event.event) {\n        case 'thread.created':\n            //No action on this event.\n            break;\n        case 'thread.run.created':\n        case 'thread.run.queued':\n        case 'thread.run.in_progress':\n        case 'thread.run.requires_action':\n        case 'thread.run.completed':\n        case 'thread.run.incomplete':\n        case 'thread.run.failed':\n        case 'thread.run.cancelling':\n        case 'thread.run.cancelled':\n        case 'thread.run.expired':\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleRun).call(this, event);\n            break;\n        case 'thread.run.step.created':\n        case 'thread.run.step.in_progress':\n        case 'thread.run.step.delta':\n        case 'thread.run.step.completed':\n        case 'thread.run.step.failed':\n        case 'thread.run.step.cancelled':\n        case 'thread.run.step.expired':\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleRunStep).call(this, event);\n            break;\n        case 'thread.message.created':\n        case 'thread.message.in_progress':\n        case 'thread.message.delta':\n        case 'thread.message.completed':\n        case 'thread.message.incomplete':\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleMessage).call(this, event);\n            break;\n        case 'error':\n            //This is included for completeness, but errors are processed in the SSE event processing so this should not occur\n            throw new Error('Encountered an error event in event processing - errors should be processed earlier');\n        default:\n            assertNever(event);\n    }\n}, _AssistantStream_endRequest = function _AssistantStream_endRequest() {\n    if (this.ended) {\n        throw new OpenAIError(`stream has ended, this shouldn't happen`);\n    }\n    if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\"))\n        throw Error('Final run has not been received');\n    return __classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\");\n}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage(event) {\n    const [accumulatedMessage, newContent] = __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n    __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, accumulatedMessage, \"f\");\n    __classPrivateFieldGet(this, _AssistantStream_messageSnapshots, \"f\")[accumulatedMessage.id] = accumulatedMessage;\n    for (const content of newContent) {\n        const snapshotContent = accumulatedMessage.content[content.index];\n        if (snapshotContent?.type == 'text') {\n            this._emit('textCreated', snapshotContent.text);\n        }\n    }\n    switch (event.event) {\n        case 'thread.message.created':\n            this._emit('messageCreated', event.data);\n            break;\n        case 'thread.message.in_progress':\n            break;\n        case 'thread.message.delta':\n            this._emit('messageDelta', event.data.delta, accumulatedMessage);\n            if (event.data.delta.content) {\n                for (const content of event.data.delta.content) {\n                    //If it is text delta, emit a text delta event\n                    if (content.type == 'text' && content.text) {\n                        let textDelta = content.text;\n                        let snapshot = accumulatedMessage.content[content.index];\n                        if (snapshot && snapshot.type == 'text') {\n                            this._emit('textDelta', textDelta, snapshot.text);\n                        }\n                        else {\n                            throw Error('The snapshot associated with this text delta is not text or missing');\n                        }\n                    }\n                    if (content.index != __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, \"f\")) {\n                        //See if we have in progress content\n                        if (__classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\")) {\n                            switch (__classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\").type) {\n                                case 'text':\n                                    this._emit('textDone', __classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\").text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                                    break;\n                                case 'image_file':\n                                    this._emit('imageFileDone', __classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\").image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                                    break;\n                            }\n                        }\n                        __classPrivateFieldSet(this, _AssistantStream_currentContentIndex, content.index, \"f\");\n                    }\n                    __classPrivateFieldSet(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], \"f\");\n                }\n            }\n            break;\n        case 'thread.message.completed':\n        case 'thread.message.incomplete':\n            //We emit the latest content we were working on on completion (including incomplete)\n            if (__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, \"f\") !== undefined) {\n                const currentContent = event.data.content[__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, \"f\")];\n                if (currentContent) {\n                    switch (currentContent.type) {\n                        case 'image_file':\n                            this._emit('imageFileDone', currentContent.image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                            break;\n                        case 'text':\n                            this._emit('textDone', currentContent.text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                            break;\n                    }\n                }\n            }\n            if (__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\")) {\n                this._emit('messageDone', event.data);\n            }\n            __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, undefined, \"f\");\n    }\n}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep(event) {\n    const accumulatedRunStep = __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_accumulateRunStep).call(this, event);\n    __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, \"f\");\n    switch (event.event) {\n        case 'thread.run.step.created':\n            this._emit('runStepCreated', event.data);\n            break;\n        case 'thread.run.step.delta':\n            const delta = event.data.delta;\n            if (delta.step_details &&\n                delta.step_details.type == 'tool_calls' &&\n                delta.step_details.tool_calls &&\n                accumulatedRunStep.step_details.type == 'tool_calls') {\n                for (const toolCall of delta.step_details.tool_calls) {\n                    if (toolCall.index == __classPrivateFieldGet(this, _AssistantStream_currentToolCallIndex, \"f\")) {\n                        this._emit('toolCallDelta', toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);\n                    }\n                    else {\n                        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\")) {\n                            this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                        }\n                        __classPrivateFieldSet(this, _AssistantStream_currentToolCallIndex, toolCall.index, \"f\");\n                        __classPrivateFieldSet(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], \"f\");\n                        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"))\n                            this._emit('toolCallCreated', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                    }\n                }\n            }\n            this._emit('runStepDelta', event.data.delta, accumulatedRunStep);\n            break;\n        case 'thread.run.step.completed':\n        case 'thread.run.step.failed':\n        case 'thread.run.step.cancelled':\n        case 'thread.run.step.expired':\n            __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, undefined, \"f\");\n            const details = event.data.step_details;\n            if (details.type == 'tool_calls') {\n                if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\")) {\n                    this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                    __classPrivateFieldSet(this, _AssistantStream_currentToolCall, undefined, \"f\");\n                }\n            }\n            this._emit('runStepDone', event.data, accumulatedRunStep);\n            break;\n        case 'thread.run.step.in_progress':\n            break;\n    }\n}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent(event) {\n    __classPrivateFieldGet(this, _AssistantStream_events, \"f\").push(event);\n    this._emit('event', event);\n}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep(event) {\n    switch (event.event) {\n        case 'thread.run.step.created':\n            __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id] = event.data;\n            return event.data;\n        case 'thread.run.step.delta':\n            let snapshot = __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n            if (!snapshot) {\n                throw Error('Received a RunStepDelta before creation of a snapshot');\n            }\n            let data = event.data;\n            if (data.delta) {\n                const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta);\n                __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id] = accumulated;\n            }\n            return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n        case 'thread.run.step.completed':\n        case 'thread.run.step.failed':\n        case 'thread.run.step.cancelled':\n        case 'thread.run.step.expired':\n        case 'thread.run.step.in_progress':\n            __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id] = event.data;\n            break;\n    }\n    if (__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id])\n        return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n    throw new Error('No snapshot available');\n}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage(event, snapshot) {\n    let newContent = [];\n    switch (event.event) {\n        case 'thread.message.created':\n            //On creation the snapshot is just the initial message\n            return [event.data, newContent];\n        case 'thread.message.delta':\n            if (!snapshot) {\n                throw Error('Received a delta with no existing snapshot (there should be one from message creation)');\n            }\n            let data = event.data;\n            //If this delta does not have content, nothing to process\n            if (data.delta.content) {\n                for (const contentElement of data.delta.content) {\n                    if (contentElement.index in snapshot.content) {\n                        let currentContent = snapshot.content[contentElement.index];\n                        snapshot.content[contentElement.index] = __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);\n                    }\n                    else {\n                        snapshot.content[contentElement.index] = contentElement;\n                        // This is a new element\n                        newContent.push(contentElement);\n                    }\n                }\n            }\n            return [snapshot, newContent];\n        case 'thread.message.in_progress':\n        case 'thread.message.completed':\n        case 'thread.message.incomplete':\n            //No changes on other thread events\n            if (snapshot) {\n                return [snapshot, newContent];\n            }\n            else {\n                throw Error('Received thread message event with no existing snapshot');\n            }\n    }\n    throw Error('Tried to accumulate a non-message event');\n}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent(contentElement, currentContent) {\n    return AssistantStream.accumulateDelta(currentContent, contentElement);\n}, _AssistantStream_handleRun = function _AssistantStream_handleRun(event) {\n    __classPrivateFieldSet(this, _AssistantStream_currentRunSnapshot, event.data, \"f\");\n    switch (event.event) {\n        case 'thread.run.created':\n            break;\n        case 'thread.run.queued':\n            break;\n        case 'thread.run.in_progress':\n            break;\n        case 'thread.run.requires_action':\n        case 'thread.run.cancelled':\n        case 'thread.run.failed':\n        case 'thread.run.completed':\n        case 'thread.run.expired':\n            __classPrivateFieldSet(this, _AssistantStream_finalRun, event.data, \"f\");\n            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\")) {\n                this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                __classPrivateFieldSet(this, _AssistantStream_currentToolCall, undefined, \"f\");\n            }\n            break;\n        case 'thread.run.cancelling':\n            break;\n    }\n};\nfunction assertNever(_x) { }\n//# sourceMappingURL=AssistantStream.mjs.map","import { AbstractChatCompletionRunner, } from \"./AbstractChatCompletionRunner.mjs\";\nimport { isAssistantMessage } from \"./chatCompletionUtils.mjs\";\nexport class ChatCompletionRunner extends AbstractChatCompletionRunner {\n    /** @deprecated - please use `runTools` instead. */\n    static runFunctions(client, params, options) {\n        const runner = new ChatCompletionRunner();\n        const opts = {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runFunctions' },\n        };\n        runner._run(() => runner._runFunctions(client, params, opts));\n        return runner;\n    }\n    static runTools(client, params, options) {\n        const runner = new ChatCompletionRunner();\n        const opts = {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runTools' },\n        };\n        runner._run(() => runner._runTools(client, params, opts));\n        return runner;\n    }\n    _addMessage(message, emit = true) {\n        super._addMessage(message, emit);\n        if (isAssistantMessage(message) && message.content) {\n            this._emit('content', message.content);\n        }\n    }\n}\n//# sourceMappingURL=ChatCompletionRunner.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ChatCompletionStream_instances, _ChatCompletionStream_params, _ChatCompletionStream_choiceEventStates, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_getChoiceEventState, _ChatCompletionStream_addChunk, _ChatCompletionStream_emitToolCallDoneEvent, _ChatCompletionStream_emitContentDoneEvents, _ChatCompletionStream_endRequest, _ChatCompletionStream_getAutoParseableResponseFormat, _ChatCompletionStream_accumulateChatCompletion;\nimport { OpenAIError, APIUserAbortError, LengthFinishReasonError, ContentFilterFinishReasonError, } from \"../error.mjs\";\nimport { AbstractChatCompletionRunner, } from \"./AbstractChatCompletionRunner.mjs\";\nimport { Stream } from \"../streaming.mjs\";\nimport { hasAutoParseableInput, isAutoParsableResponseFormat, isAutoParsableTool, maybeParseChatCompletion, shouldParseToolCall, } from \"../lib/parser.mjs\";\nimport { partialParse } from \"../_vendor/partial-json-parser/parser.mjs\";\nexport class ChatCompletionStream extends AbstractChatCompletionRunner {\n    constructor(params) {\n        super();\n        _ChatCompletionStream_instances.add(this);\n        _ChatCompletionStream_params.set(this, void 0);\n        _ChatCompletionStream_choiceEventStates.set(this, void 0);\n        _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);\n        __classPrivateFieldSet(this, _ChatCompletionStream_params, params, \"f\");\n        __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], \"f\");\n    }\n    get currentChatCompletionSnapshot() {\n        return __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n    }\n    /**\n     * Intended for use on the frontend, consuming a stream produced with\n     * `.toReadableStream()` on the backend.\n     *\n     * Note that messages sent to the model do not appear in `.on('message')`\n     * in this context.\n     */\n    static fromReadableStream(stream) {\n        const runner = new ChatCompletionStream(null);\n        runner._run(() => runner._fromReadableStream(stream));\n        return runner;\n    }\n    static createChatCompletion(client, params, options) {\n        const runner = new ChatCompletionStream(params);\n        runner._run(() => runner._runChatCompletion(client, { ...params, stream: true }, { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } }));\n        return runner;\n    }\n    async _createChatCompletion(client, params, options) {\n        super._createChatCompletion;\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n        const stream = await client.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });\n        this._connected();\n        for await (const chunk of stream) {\n            __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n    }\n    async _fromReadableStream(readableStream, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n        this._connected();\n        const stream = Stream.fromReadableStream(readableStream, this.controller);\n        let chatId;\n        for await (const chunk of stream) {\n            if (chatId && chatId !== chunk.id) {\n                // A new request has been made.\n                this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n            }\n            __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n            chatId = chunk.id;\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n    }\n    [(_ChatCompletionStream_params = new WeakMap(), _ChatCompletionStream_choiceEventStates = new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = new WeakMap(), _ChatCompletionStream_instances = new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest() {\n        if (this.ended)\n            return;\n        __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n    }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState(choice) {\n        let state = __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, \"f\")[choice.index];\n        if (state) {\n            return state;\n        }\n        state = {\n            content_done: false,\n            refusal_done: false,\n            logprobs_content_done: false,\n            logprobs_refusal_done: false,\n            done_tool_calls: new Set(),\n            current_tool_call_index: null,\n        };\n        __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, \"f\")[choice.index] = state;\n        return state;\n    }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk(chunk) {\n        if (this.ended)\n            return;\n        const completion = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);\n        this._emit('chunk', chunk, completion);\n        for (const choice of chunk.choices) {\n            const choiceSnapshot = completion.choices[choice.index];\n            if (choice.delta.content != null &&\n                choiceSnapshot.message?.role === 'assistant' &&\n                choiceSnapshot.message?.content) {\n                this._emit('content', choice.delta.content, choiceSnapshot.message.content);\n                this._emit('content.delta', {\n                    delta: choice.delta.content,\n                    snapshot: choiceSnapshot.message.content,\n                    parsed: choiceSnapshot.message.parsed,\n                });\n            }\n            if (choice.delta.refusal != null &&\n                choiceSnapshot.message?.role === 'assistant' &&\n                choiceSnapshot.message?.refusal) {\n                this._emit('refusal.delta', {\n                    delta: choice.delta.refusal,\n                    snapshot: choiceSnapshot.message.refusal,\n                });\n            }\n            if (choice.logprobs?.content != null && choiceSnapshot.message?.role === 'assistant') {\n                this._emit('logprobs.content.delta', {\n                    content: choice.logprobs?.content,\n                    snapshot: choiceSnapshot.logprobs?.content ?? [],\n                });\n            }\n            if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === 'assistant') {\n                this._emit('logprobs.refusal.delta', {\n                    refusal: choice.logprobs?.refusal,\n                    snapshot: choiceSnapshot.logprobs?.refusal ?? [],\n                });\n            }\n            const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n            if (choiceSnapshot.finish_reason) {\n                __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);\n                if (state.current_tool_call_index != null) {\n                    __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);\n                }\n            }\n            for (const toolCall of choice.delta.tool_calls ?? []) {\n                if (state.current_tool_call_index !== toolCall.index) {\n                    __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);\n                    // new tool call started, the previous one is done\n                    if (state.current_tool_call_index != null) {\n                        __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);\n                    }\n                }\n                state.current_tool_call_index = toolCall.index;\n            }\n            for (const toolCallDelta of choice.delta.tool_calls ?? []) {\n                const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];\n                if (!toolCallSnapshot?.type) {\n                    continue;\n                }\n                if (toolCallSnapshot?.type === 'function') {\n                    this._emit('tool_calls.function.arguments.delta', {\n                        name: toolCallSnapshot.function?.name,\n                        index: toolCallDelta.index,\n                        arguments: toolCallSnapshot.function.arguments,\n                        parsed_arguments: toolCallSnapshot.function.parsed_arguments,\n                        arguments_delta: toolCallDelta.function?.arguments ?? '',\n                    });\n                }\n                else {\n                    assertNever(toolCallSnapshot?.type);\n                }\n            }\n        }\n    }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent(choiceSnapshot, toolCallIndex) {\n        const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n        if (state.done_tool_calls.has(toolCallIndex)) {\n            // we've already fired the done event\n            return;\n        }\n        const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];\n        if (!toolCallSnapshot) {\n            throw new Error('no tool call snapshot');\n        }\n        if (!toolCallSnapshot.type) {\n            throw new Error('tool call snapshot missing `type`');\n        }\n        if (toolCallSnapshot.type === 'function') {\n            const inputTool = __classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\")?.tools?.find((tool) => tool.type === 'function' && tool.function.name === toolCallSnapshot.function.name);\n            this._emit('tool_calls.function.arguments.done', {\n                name: toolCallSnapshot.function.name,\n                index: toolCallIndex,\n                arguments: toolCallSnapshot.function.arguments,\n                parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments)\n                    : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments)\n                        : null,\n            });\n        }\n        else {\n            assertNever(toolCallSnapshot.type);\n        }\n    }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents(choiceSnapshot) {\n        const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n        if (choiceSnapshot.message.content && !state.content_done) {\n            state.content_done = true;\n            const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);\n            this._emit('content.done', {\n                content: choiceSnapshot.message.content,\n                parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null,\n            });\n        }\n        if (choiceSnapshot.message.refusal && !state.refusal_done) {\n            state.refusal_done = true;\n            this._emit('refusal.done', { refusal: choiceSnapshot.message.refusal });\n        }\n        if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {\n            state.logprobs_content_done = true;\n            this._emit('logprobs.content.done', { content: choiceSnapshot.logprobs.content });\n        }\n        if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {\n            state.logprobs_refusal_done = true;\n            this._emit('logprobs.refusal.done', { refusal: choiceSnapshot.logprobs.refusal });\n        }\n    }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest() {\n        if (this.ended) {\n            throw new OpenAIError(`stream has ended, this shouldn't happen`);\n        }\n        const snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n        if (!snapshot) {\n            throw new OpenAIError(`request ended without sending any chunks`);\n        }\n        __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n        __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], \"f\");\n        return finalizeChatCompletion(snapshot, __classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\"));\n    }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat() {\n        const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\")?.response_format;\n        if (isAutoParsableResponseFormat(responseFormat)) {\n            return responseFormat;\n        }\n        return null;\n    }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion(chunk) {\n        var _a, _b, _c, _d;\n        let snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n        const { choices, ...rest } = chunk;\n        if (!snapshot) {\n            snapshot = __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, {\n                ...rest,\n                choices: [],\n            }, \"f\");\n        }\n        else {\n            Object.assign(snapshot, rest);\n        }\n        for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {\n            let choice = snapshot.choices[index];\n            if (!choice) {\n                choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };\n            }\n            if (logprobs) {\n                if (!choice.logprobs) {\n                    choice.logprobs = Object.assign({}, logprobs);\n                }\n                else {\n                    const { content, refusal, ...rest } = logprobs;\n                    assertIsEmpty(rest);\n                    Object.assign(choice.logprobs, rest);\n                    if (content) {\n                        (_a = choice.logprobs).content ?? (_a.content = []);\n                        choice.logprobs.content.push(...content);\n                    }\n                    if (refusal) {\n                        (_b = choice.logprobs).refusal ?? (_b.refusal = []);\n                        choice.logprobs.refusal.push(...refusal);\n                    }\n                }\n            }\n            if (finish_reason) {\n                choice.finish_reason = finish_reason;\n                if (__classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\") && hasAutoParseableInput(__classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\"))) {\n                    if (finish_reason === 'length') {\n                        throw new LengthFinishReasonError();\n                    }\n                    if (finish_reason === 'content_filter') {\n                        throw new ContentFilterFinishReasonError();\n                    }\n                }\n            }\n            Object.assign(choice, other);\n            if (!delta)\n                continue; // Shouldn't happen; just in case.\n            const { content, refusal, function_call, role, tool_calls, ...rest } = delta;\n            assertIsEmpty(rest);\n            Object.assign(choice.message, rest);\n            if (refusal) {\n                choice.message.refusal = (choice.message.refusal || '') + refusal;\n            }\n            if (role)\n                choice.message.role = role;\n            if (function_call) {\n                if (!choice.message.function_call) {\n                    choice.message.function_call = function_call;\n                }\n                else {\n                    if (function_call.name)\n                        choice.message.function_call.name = function_call.name;\n                    if (function_call.arguments) {\n                        (_c = choice.message.function_call).arguments ?? (_c.arguments = '');\n                        choice.message.function_call.arguments += function_call.arguments;\n                    }\n                }\n            }\n            if (content) {\n                choice.message.content = (choice.message.content || '') + content;\n                if (!choice.message.refusal && __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {\n                    choice.message.parsed = partialParse(choice.message.content);\n                }\n            }\n            if (tool_calls) {\n                if (!choice.message.tool_calls)\n                    choice.message.tool_calls = [];\n                for (const { index, id, type, function: fn, ...rest } of tool_calls) {\n                    const tool_call = ((_d = choice.message.tool_calls)[index] ?? (_d[index] = {}));\n                    Object.assign(tool_call, rest);\n                    if (id)\n                        tool_call.id = id;\n                    if (type)\n                        tool_call.type = type;\n                    if (fn)\n                        tool_call.function ?? (tool_call.function = { name: fn.name ?? '', arguments: '' });\n                    if (fn?.name)\n                        tool_call.function.name = fn.name;\n                    if (fn?.arguments) {\n                        tool_call.function.arguments += fn.arguments;\n                        if (shouldParseToolCall(__classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\"), tool_call)) {\n                            tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);\n                        }\n                    }\n                }\n            }\n        }\n        return snapshot;\n    }, Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        this.on('chunk', (chunk) => {\n            const reader = readQueue.shift();\n            if (reader) {\n                reader.resolve(chunk);\n            }\n            else {\n                pushQueue.push(chunk);\n            }\n        });\n        this.on('end', () => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.resolve(undefined);\n            }\n            readQueue.length = 0;\n        });\n        this.on('abort', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        this.on('error', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        return {\n            next: async () => {\n                if (!pushQueue.length) {\n                    if (done) {\n                        return { value: undefined, done: true };\n                    }\n                    return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n                }\n                const chunk = pushQueue.shift();\n                return { value: chunk, done: false };\n            },\n            return: async () => {\n                this.abort();\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    toReadableStream() {\n        const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n        return stream.toReadableStream();\n    }\n}\nfunction finalizeChatCompletion(snapshot, params) {\n    const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;\n    const completion = {\n        ...rest,\n        id,\n        choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {\n            if (!finish_reason) {\n                throw new OpenAIError(`missing finish_reason for choice ${index}`);\n            }\n            const { content = null, function_call, tool_calls, ...messageRest } = message;\n            const role = message.role; // this is what we expect; in theory it could be different which would make our types a slight lie but would be fine.\n            if (!role) {\n                throw new OpenAIError(`missing role for choice ${index}`);\n            }\n            if (function_call) {\n                const { arguments: args, name } = function_call;\n                if (args == null) {\n                    throw new OpenAIError(`missing function_call.arguments for choice ${index}`);\n                }\n                if (!name) {\n                    throw new OpenAIError(`missing function_call.name for choice ${index}`);\n                }\n                return {\n                    ...choiceRest,\n                    message: {\n                        content,\n                        function_call: { arguments: args, name },\n                        role,\n                        refusal: message.refusal ?? null,\n                    },\n                    finish_reason,\n                    index,\n                    logprobs,\n                };\n            }\n            if (tool_calls) {\n                return {\n                    ...choiceRest,\n                    index,\n                    finish_reason,\n                    logprobs,\n                    message: {\n                        ...messageRest,\n                        role,\n                        content,\n                        refusal: message.refusal ?? null,\n                        tool_calls: tool_calls.map((tool_call, i) => {\n                            const { function: fn, type, id, ...toolRest } = tool_call;\n                            const { arguments: args, name, ...fnRest } = fn || {};\n                            if (id == null) {\n                                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id\\n${str(snapshot)}`);\n                            }\n                            if (type == null) {\n                                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type\\n${str(snapshot)}`);\n                            }\n                            if (name == null) {\n                                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name\\n${str(snapshot)}`);\n                            }\n                            if (args == null) {\n                                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments\\n${str(snapshot)}`);\n                            }\n                            return { ...toolRest, id, type, function: { ...fnRest, name, arguments: args } };\n                        }),\n                    },\n                };\n            }\n            return {\n                ...choiceRest,\n                message: { ...messageRest, content, role, refusal: message.refusal ?? null },\n                finish_reason,\n                index,\n                logprobs,\n            };\n        }),\n        created,\n        model,\n        object: 'chat.completion',\n        ...(system_fingerprint ? { system_fingerprint } : {}),\n    };\n    return maybeParseChatCompletion(completion, params);\n}\nfunction str(x) {\n    return JSON.stringify(x);\n}\n/**\n * Ensures the given argument is an empty object, useful for\n * asserting that all known properties on an object have been\n * destructured.\n */\nfunction assertIsEmpty(obj) {\n    return;\n}\nfunction assertNever(_x) { }\n//# sourceMappingURL=ChatCompletionStream.mjs.map","import { ChatCompletionStream } from \"./ChatCompletionStream.mjs\";\nexport class ChatCompletionStreamingRunner extends ChatCompletionStream {\n    static fromReadableStream(stream) {\n        const runner = new ChatCompletionStreamingRunner(null);\n        runner._run(() => runner._fromReadableStream(stream));\n        return runner;\n    }\n    /** @deprecated - please use `runTools` instead. */\n    static runFunctions(client, params, options) {\n        const runner = new ChatCompletionStreamingRunner(null);\n        const opts = {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runFunctions' },\n        };\n        runner._run(() => runner._runFunctions(client, params, opts));\n        return runner;\n    }\n    static runTools(client, params, options) {\n        const runner = new ChatCompletionStreamingRunner(\n        // @ts-expect-error TODO these types are incompatible\n        params);\n        const opts = {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runTools' },\n        };\n        runner._run(() => runner._runTools(client, params, opts));\n        return runner;\n    }\n}\n//# sourceMappingURL=ChatCompletionStreamingRunner.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _EventStream_instances, _EventStream_connectedPromise, _EventStream_resolveConnectedPromise, _EventStream_rejectConnectedPromise, _EventStream_endPromise, _EventStream_resolveEndPromise, _EventStream_rejectEndPromise, _EventStream_listeners, _EventStream_ended, _EventStream_errored, _EventStream_aborted, _EventStream_catchingPromiseCreated, _EventStream_handleError;\nimport { APIUserAbortError, OpenAIError } from \"../error.mjs\";\nexport class EventStream {\n    constructor() {\n        _EventStream_instances.add(this);\n        this.controller = new AbortController();\n        _EventStream_connectedPromise.set(this, void 0);\n        _EventStream_resolveConnectedPromise.set(this, () => { });\n        _EventStream_rejectConnectedPromise.set(this, () => { });\n        _EventStream_endPromise.set(this, void 0);\n        _EventStream_resolveEndPromise.set(this, () => { });\n        _EventStream_rejectEndPromise.set(this, () => { });\n        _EventStream_listeners.set(this, {});\n        _EventStream_ended.set(this, false);\n        _EventStream_errored.set(this, false);\n        _EventStream_aborted.set(this, false);\n        _EventStream_catchingPromiseCreated.set(this, false);\n        __classPrivateFieldSet(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _EventStream_resolveConnectedPromise, resolve, \"f\");\n            __classPrivateFieldSet(this, _EventStream_rejectConnectedPromise, reject, \"f\");\n        }), \"f\");\n        __classPrivateFieldSet(this, _EventStream_endPromise, new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _EventStream_resolveEndPromise, resolve, \"f\");\n            __classPrivateFieldSet(this, _EventStream_rejectEndPromise, reject, \"f\");\n        }), \"f\");\n        // Don't let these promises cause unhandled rejection errors.\n        // we will manually cause an unhandled rejection error later\n        // if the user hasn't registered any error listener or called\n        // any promise-returning method.\n        __classPrivateFieldGet(this, _EventStream_connectedPromise, \"f\").catch(() => { });\n        __classPrivateFieldGet(this, _EventStream_endPromise, \"f\").catch(() => { });\n    }\n    _run(executor) {\n        // Unfortunately if we call `executor()` immediately we get runtime errors about\n        // references to `this` before the `super()` constructor call returns.\n        setTimeout(() => {\n            executor().then(() => {\n                this._emitFinal();\n                this._emit('end');\n            }, __classPrivateFieldGet(this, _EventStream_instances, \"m\", _EventStream_handleError).bind(this));\n        }, 0);\n    }\n    _connected() {\n        if (this.ended)\n            return;\n        __classPrivateFieldGet(this, _EventStream_resolveConnectedPromise, \"f\").call(this);\n        this._emit('connect');\n    }\n    get ended() {\n        return __classPrivateFieldGet(this, _EventStream_ended, \"f\");\n    }\n    get errored() {\n        return __classPrivateFieldGet(this, _EventStream_errored, \"f\");\n    }\n    get aborted() {\n        return __classPrivateFieldGet(this, _EventStream_aborted, \"f\");\n    }\n    abort() {\n        this.controller.abort();\n    }\n    /**\n     * Adds the listener function to the end of the listeners array for the event.\n     * No checks are made to see if the listener has already been added. Multiple calls passing\n     * the same combination of event and listener will result in the listener being added, and\n     * called, multiple times.\n     * @returns this ChatCompletionStream, so that calls can be chained\n     */\n    on(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener });\n        return this;\n    }\n    /**\n     * Removes the specified listener from the listener array for the event.\n     * off() will remove, at most, one instance of a listener from the listener array. If any single\n     * listener has been added multiple times to the listener array for the specified event, then\n     * off() must be called multiple times to remove each instance.\n     * @returns this ChatCompletionStream, so that calls can be chained\n     */\n    off(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event];\n        if (!listeners)\n            return this;\n        const index = listeners.findIndex((l) => l.listener === listener);\n        if (index >= 0)\n            listeners.splice(index, 1);\n        return this;\n    }\n    /**\n     * Adds a one-time listener function for the event. The next time the event is triggered,\n     * this listener is removed and then invoked.\n     * @returns this ChatCompletionStream, so that calls can be chained\n     */\n    once(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener, once: true });\n        return this;\n    }\n    /**\n     * This is similar to `.once()`, but returns a Promise that resolves the next time\n     * the event is triggered, instead of calling a listener callback.\n     * @returns a Promise that resolves the next time given event is triggered,\n     * or rejects if an error is emitted.  (If you request the 'error' event,\n     * returns a promise that resolves with the error).\n     *\n     * Example:\n     *\n     *   const message = await stream.emitted('message') // rejects if the stream errors\n     */\n    emitted(event) {\n        return new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, \"f\");\n            if (event !== 'error')\n                this.once('error', reject);\n            this.once(event, resolve);\n        });\n    }\n    async done() {\n        __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, \"f\");\n        await __classPrivateFieldGet(this, _EventStream_endPromise, \"f\");\n    }\n    _emit(event, ...args) {\n        // make sure we don't emit any events after end\n        if (__classPrivateFieldGet(this, _EventStream_ended, \"f\")) {\n            return;\n        }\n        if (event === 'end') {\n            __classPrivateFieldSet(this, _EventStream_ended, true, \"f\");\n            __classPrivateFieldGet(this, _EventStream_resolveEndPromise, \"f\").call(this);\n        }\n        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event];\n        if (listeners) {\n            __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = listeners.filter((l) => !l.once);\n            listeners.forEach(({ listener }) => listener(...args));\n        }\n        if (event === 'abort') {\n            const error = args[0];\n            if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                Promise.reject(error);\n            }\n            __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, \"f\").call(this, error);\n            __classPrivateFieldGet(this, _EventStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n            return;\n        }\n        if (event === 'error') {\n            // NOTE: _emit('error', error) should only be called from #handleError().\n            const error = args[0];\n            if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n                // If you are seeing stack traces here, make sure to handle errors via either:\n                // - runner.on('error', () => ...)\n                // - await runner.done()\n                // - await runner.finalChatCompletion()\n                // - etc.\n                Promise.reject(error);\n            }\n            __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, \"f\").call(this, error);\n            __classPrivateFieldGet(this, _EventStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n        }\n    }\n    _emitFinal() { }\n}\n_EventStream_connectedPromise = new WeakMap(), _EventStream_resolveConnectedPromise = new WeakMap(), _EventStream_rejectConnectedPromise = new WeakMap(), _EventStream_endPromise = new WeakMap(), _EventStream_resolveEndPromise = new WeakMap(), _EventStream_rejectEndPromise = new WeakMap(), _EventStream_listeners = new WeakMap(), _EventStream_ended = new WeakMap(), _EventStream_errored = new WeakMap(), _EventStream_aborted = new WeakMap(), _EventStream_catchingPromiseCreated = new WeakMap(), _EventStream_instances = new WeakSet(), _EventStream_handleError = function _EventStream_handleError(error) {\n    __classPrivateFieldSet(this, _EventStream_errored, true, \"f\");\n    if (error instanceof Error && error.name === 'AbortError') {\n        error = new APIUserAbortError();\n    }\n    if (error instanceof APIUserAbortError) {\n        __classPrivateFieldSet(this, _EventStream_aborted, true, \"f\");\n        return this._emit('abort', error);\n    }\n    if (error instanceof OpenAIError) {\n        return this._emit('error', error);\n    }\n    if (error instanceof Error) {\n        const openAIError = new OpenAIError(error.message);\n        // @ts-ignore\n        openAIError.cause = error;\n        return this._emit('error', openAIError);\n    }\n    return this._emit('error', new OpenAIError(String(error)));\n};\n//# sourceMappingURL=EventStream.mjs.map","import { OpenAIError } from \"../error.mjs\";\nimport { isAutoParsableResponseFormat } from \"../lib/parser.mjs\";\nexport function maybeParseResponse(response, params) {\n    if (!params || !hasAutoParseableInput(params)) {\n        return {\n            ...response,\n            output_parsed: null,\n            output: response.output.map((item) => {\n                if (item.type === 'function_call') {\n                    return {\n                        ...item,\n                        parsed_arguments: null,\n                    };\n                }\n                if (item.type === 'message') {\n                    return {\n                        ...item,\n                        content: item.content.map((content) => ({\n                            ...content,\n                            parsed: null,\n                        })),\n                    };\n                }\n                else {\n                    return item;\n                }\n            }),\n        };\n    }\n    return parseResponse(response, params);\n}\nexport function parseResponse(response, params) {\n    const output = response.output.map((item) => {\n        if (item.type === 'function_call') {\n            return {\n                ...item,\n                parsed_arguments: parseToolCall(params, item),\n            };\n        }\n        if (item.type === 'message') {\n            const content = item.content.map((content) => {\n                if (content.type === 'output_text') {\n                    return {\n                        ...content,\n                        parsed: parseTextFormat(params, content.text),\n                    };\n                }\n                return content;\n            });\n            return {\n                ...item,\n                content,\n            };\n        }\n        return item;\n    });\n    const parsed = Object.assign({}, response, { output });\n    if (!Object.getOwnPropertyDescriptor(response, 'output_text')) {\n        addOutputText(parsed);\n    }\n    Object.defineProperty(parsed, 'output_parsed', {\n        enumerable: true,\n        get() {\n            for (const output of parsed.output) {\n                if (output.type !== 'message') {\n                    continue;\n                }\n                for (const content of output.content) {\n                    if (content.type === 'output_text' && content.parsed !== null) {\n                        return content.parsed;\n                    }\n                }\n            }\n            return null;\n        },\n    });\n    return parsed;\n}\nfunction parseTextFormat(params, content) {\n    if (params.text?.format?.type !== 'json_schema') {\n        return null;\n    }\n    if ('$parseRaw' in params.text?.format) {\n        const text_format = params.text?.format;\n        return text_format.$parseRaw(content);\n    }\n    return JSON.parse(content);\n}\nexport function hasAutoParseableInput(params) {\n    if (isAutoParsableResponseFormat(params.text?.format)) {\n        return true;\n    }\n    return false;\n}\nexport function makeParseableResponseTool(tool, { parser, callback, }) {\n    const obj = { ...tool };\n    Object.defineProperties(obj, {\n        $brand: {\n            value: 'auto-parseable-tool',\n            enumerable: false,\n        },\n        $parseRaw: {\n            value: parser,\n            enumerable: false,\n        },\n        $callback: {\n            value: callback,\n            enumerable: false,\n        },\n    });\n    return obj;\n}\nexport function isAutoParsableTool(tool) {\n    return tool?.['$brand'] === 'auto-parseable-tool';\n}\nfunction getInputToolByName(input_tools, name) {\n    return input_tools.find((tool) => tool.type === 'function' && tool.name === name);\n}\nfunction parseToolCall(params, toolCall) {\n    const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\n    return {\n        ...toolCall,\n        ...toolCall,\n        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.arguments)\n            : inputTool?.strict ? JSON.parse(toolCall.arguments)\n                : null,\n    };\n}\nexport function shouldParseToolCall(params, toolCall) {\n    if (!params) {\n        return false;\n    }\n    const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\n    return isAutoParsableTool(inputTool) || inputTool?.strict || false;\n}\nexport function validateInputTools(tools) {\n    for (const tool of tools ?? []) {\n        if (tool.type !== 'function') {\n            throw new OpenAIError(`Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``);\n        }\n        if (tool.function.strict !== true) {\n            throw new OpenAIError(`The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`);\n        }\n    }\n}\nexport function addOutputText(rsp) {\n    const texts = [];\n    for (const output of rsp.output) {\n        if (output.type !== 'message') {\n            continue;\n        }\n        for (const content of output.content) {\n            if (content.type === 'output_text') {\n                texts.push(content.text);\n            }\n        }\n    }\n    rsp.output_text = texts.join('');\n}\n//# sourceMappingURL=ResponsesParser.mjs.map","export function isRunnableFunctionWithParse(fn) {\n    return typeof fn.parse === 'function';\n}\n/**\n * This is helper class for passing a `function` and `parse` where the `function`\n * argument type matches the `parse` return type.\n *\n * @deprecated - please use ParsingToolFunction instead.\n */\nexport class ParsingFunction {\n    constructor(input) {\n        this.function = input.function;\n        this.parse = input.parse;\n        this.parameters = input.parameters;\n        this.description = input.description;\n        this.name = input.name;\n    }\n}\n/**\n * This is helper class for passing a `function` and `parse` where the `function`\n * argument type matches the `parse` return type.\n */\nexport class ParsingToolFunction {\n    constructor(input) {\n        this.type = 'function';\n        this.function = input;\n    }\n}\n//# sourceMappingURL=RunnableFunction.mjs.map","/**\n * Like `Promise.allSettled()` but throws an error if any promises are rejected.\n */\nexport const allSettledWithThrow = async (promises) => {\n    const results = await Promise.allSettled(promises);\n    const rejected = results.filter((result) => result.status === 'rejected');\n    if (rejected.length) {\n        for (const result of rejected) {\n            console.error(result.reason);\n        }\n        throw new Error(`${rejected.length} promise(s) failed - see the above errors`);\n    }\n    // Note: TS was complaining about using `.filter().map()` here for some reason\n    const values = [];\n    for (const result of results) {\n        if (result.status === 'fulfilled') {\n            values.push(result.value);\n        }\n    }\n    return values;\n};\n//# sourceMappingURL=Util.mjs.map","export const isAssistantMessage = (message) => {\n    return message?.role === 'assistant';\n};\nexport const isFunctionMessage = (message) => {\n    return message?.role === 'function';\n};\nexport const isToolMessage = (message) => {\n    return message?.role === 'tool';\n};\nexport function isPresent(obj) {\n    return obj != null;\n}\n//# sourceMappingURL=chatCompletionUtils.mjs.map","import { ContentFilterFinishReasonError, LengthFinishReasonError, OpenAIError } from \"../error.mjs\";\nexport function makeParseableResponseFormat(response_format, parser) {\n    const obj = { ...response_format };\n    Object.defineProperties(obj, {\n        $brand: {\n            value: 'auto-parseable-response-format',\n            enumerable: false,\n        },\n        $parseRaw: {\n            value: parser,\n            enumerable: false,\n        },\n    });\n    return obj;\n}\nexport function makeParseableTextFormat(response_format, parser) {\n    const obj = { ...response_format };\n    Object.defineProperties(obj, {\n        $brand: {\n            value: 'auto-parseable-response-format',\n            enumerable: false,\n        },\n        $parseRaw: {\n            value: parser,\n            enumerable: false,\n        },\n    });\n    return obj;\n}\nexport function isAutoParsableResponseFormat(response_format) {\n    return response_format?.['$brand'] === 'auto-parseable-response-format';\n}\nexport function makeParseableTool(tool, { parser, callback, }) {\n    const obj = { ...tool };\n    Object.defineProperties(obj, {\n        $brand: {\n            value: 'auto-parseable-tool',\n            enumerable: false,\n        },\n        $parseRaw: {\n            value: parser,\n            enumerable: false,\n        },\n        $callback: {\n            value: callback,\n            enumerable: false,\n        },\n    });\n    return obj;\n}\nexport function isAutoParsableTool(tool) {\n    return tool?.['$brand'] === 'auto-parseable-tool';\n}\nexport function maybeParseChatCompletion(completion, params) {\n    if (!params || !hasAutoParseableInput(params)) {\n        return {\n            ...completion,\n            choices: completion.choices.map((choice) => ({\n                ...choice,\n                message: {\n                    ...choice.message,\n                    parsed: null,\n                    ...(choice.message.tool_calls ?\n                        {\n                            tool_calls: choice.message.tool_calls,\n                        }\n                        : undefined),\n                },\n            })),\n        };\n    }\n    return parseChatCompletion(completion, params);\n}\nexport function parseChatCompletion(completion, params) {\n    const choices = completion.choices.map((choice) => {\n        if (choice.finish_reason === 'length') {\n            throw new LengthFinishReasonError();\n        }\n        if (choice.finish_reason === 'content_filter') {\n            throw new ContentFilterFinishReasonError();\n        }\n        return {\n            ...choice,\n            message: {\n                ...choice.message,\n                ...(choice.message.tool_calls ?\n                    {\n                        tool_calls: choice.message.tool_calls?.map((toolCall) => parseToolCall(params, toolCall)) ?? undefined,\n                    }\n                    : undefined),\n                parsed: choice.message.content && !choice.message.refusal ?\n                    parseResponseFormat(params, choice.message.content)\n                    : null,\n            },\n        };\n    });\n    return { ...completion, choices };\n}\nfunction parseResponseFormat(params, content) {\n    if (params.response_format?.type !== 'json_schema') {\n        return null;\n    }\n    if (params.response_format?.type === 'json_schema') {\n        if ('$parseRaw' in params.response_format) {\n            const response_format = params.response_format;\n            return response_format.$parseRaw(content);\n        }\n        return JSON.parse(content);\n    }\n    return null;\n}\nfunction parseToolCall(params, toolCall) {\n    const inputTool = params.tools?.find((inputTool) => inputTool.function?.name === toolCall.function.name);\n    return {\n        ...toolCall,\n        function: {\n            ...toolCall.function,\n            parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments)\n                : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments)\n                    : null,\n        },\n    };\n}\nexport function shouldParseToolCall(params, toolCall) {\n    if (!params) {\n        return false;\n    }\n    const inputTool = params.tools?.find((inputTool) => inputTool.function?.name === toolCall.function.name);\n    return isAutoParsableTool(inputTool) || inputTool?.function.strict || false;\n}\nexport function hasAutoParseableInput(params) {\n    if (isAutoParsableResponseFormat(params.response_format)) {\n        return true;\n    }\n    return (params.tools?.some((t) => isAutoParsableTool(t) || (t.type === 'function' && t.function.strict === true)) ?? false);\n}\nexport function validateInputTools(tools) {\n    for (const tool of tools ?? []) {\n        if (tool.type !== 'function') {\n            throw new OpenAIError(`Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``);\n        }\n        if (tool.function.strict !== true) {\n            throw new OpenAIError(`The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`);\n        }\n    }\n}\n//# sourceMappingURL=parser.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ResponseStream_instances, _ResponseStream_params, _ResponseStream_currentResponseSnapshot, _ResponseStream_finalResponse, _ResponseStream_beginRequest, _ResponseStream_addEvent, _ResponseStream_endRequest, _ResponseStream_accumulateResponse;\nimport { APIUserAbortError, OpenAIError } from \"../../error.mjs\";\nimport { EventStream } from \"../EventStream.mjs\";\nimport { maybeParseResponse } from \"../ResponsesParser.mjs\";\nexport class ResponseStream extends EventStream {\n    constructor(params) {\n        super();\n        _ResponseStream_instances.add(this);\n        _ResponseStream_params.set(this, void 0);\n        _ResponseStream_currentResponseSnapshot.set(this, void 0);\n        _ResponseStream_finalResponse.set(this, void 0);\n        __classPrivateFieldSet(this, _ResponseStream_params, params, \"f\");\n    }\n    static createResponse(client, params, options) {\n        const runner = new ResponseStream(params);\n        runner._run(() => runner._createOrRetrieveResponse(client, params, {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n        }));\n        return runner;\n    }\n    async _createOrRetrieveResponse(client, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_beginRequest).call(this);\n        let stream;\n        let starting_after = null;\n        if ('response_id' in params) {\n            stream = await client.responses.retrieve(params.response_id, { stream: true }, { ...options, signal: this.controller.signal, stream: true });\n            starting_after = params.starting_after ?? null;\n        }\n        else {\n            stream = await client.responses.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });\n        }\n        this._connected();\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_addEvent).call(this, event, starting_after);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_endRequest).call(this);\n    }\n    [(_ResponseStream_params = new WeakMap(), _ResponseStream_currentResponseSnapshot = new WeakMap(), _ResponseStream_finalResponse = new WeakMap(), _ResponseStream_instances = new WeakSet(), _ResponseStream_beginRequest = function _ResponseStream_beginRequest() {\n        if (this.ended)\n            return;\n        __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, undefined, \"f\");\n    }, _ResponseStream_addEvent = function _ResponseStream_addEvent(event, starting_after) {\n        if (this.ended)\n            return;\n        const maybeEmit = (name, event) => {\n            if (starting_after == null || event.sequence_number > starting_after) {\n                this._emit(name, event);\n            }\n        };\n        const response = __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_accumulateResponse).call(this, event);\n        maybeEmit('event', event);\n        switch (event.type) {\n            case 'response.output_text.delta': {\n                const output = response.output[event.output_index];\n                if (!output) {\n                    throw new OpenAIError(`missing output at index ${event.output_index}`);\n                }\n                if (output.type === 'message') {\n                    const content = output.content[event.content_index];\n                    if (!content) {\n                        throw new OpenAIError(`missing content at index ${event.content_index}`);\n                    }\n                    if (content.type !== 'output_text') {\n                        throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);\n                    }\n                    maybeEmit('response.output_text.delta', {\n                        ...event,\n                        snapshot: content.text,\n                    });\n                }\n                break;\n            }\n            case 'response.function_call_arguments.delta': {\n                const output = response.output[event.output_index];\n                if (!output) {\n                    throw new OpenAIError(`missing output at index ${event.output_index}`);\n                }\n                if (output.type === 'function_call') {\n                    maybeEmit('response.function_call_arguments.delta', {\n                        ...event,\n                        snapshot: output.arguments,\n                    });\n                }\n                break;\n            }\n            default:\n                maybeEmit(event.type, event);\n                break;\n        }\n    }, _ResponseStream_endRequest = function _ResponseStream_endRequest() {\n        if (this.ended) {\n            throw new OpenAIError(`stream has ended, this shouldn't happen`);\n        }\n        const snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, \"f\");\n        if (!snapshot) {\n            throw new OpenAIError(`request ended without sending any events`);\n        }\n        __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, undefined, \"f\");\n        const parsedResponse = finalizeResponse(snapshot, __classPrivateFieldGet(this, _ResponseStream_params, \"f\"));\n        __classPrivateFieldSet(this, _ResponseStream_finalResponse, parsedResponse, \"f\");\n        return parsedResponse;\n    }, _ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse(event) {\n        let snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, \"f\");\n        if (!snapshot) {\n            if (event.type !== 'response.created') {\n                throw new OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);\n            }\n            snapshot = __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, \"f\");\n            return snapshot;\n        }\n        switch (event.type) {\n            case 'response.output_item.added': {\n                snapshot.output.push(event.item);\n                break;\n            }\n            case 'response.content_part.added': {\n                const output = snapshot.output[event.output_index];\n                if (!output) {\n                    throw new OpenAIError(`missing output at index ${event.output_index}`);\n                }\n                if (output.type === 'message') {\n                    output.content.push(event.part);\n                }\n                break;\n            }\n            case 'response.output_text.delta': {\n                const output = snapshot.output[event.output_index];\n                if (!output) {\n                    throw new OpenAIError(`missing output at index ${event.output_index}`);\n                }\n                if (output.type === 'message') {\n                    const content = output.content[event.content_index];\n                    if (!content) {\n                        throw new OpenAIError(`missing content at index ${event.content_index}`);\n                    }\n                    if (content.type !== 'output_text') {\n                        throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);\n                    }\n                    content.text += event.delta;\n                }\n                break;\n            }\n            case 'response.function_call_arguments.delta': {\n                const output = snapshot.output[event.output_index];\n                if (!output) {\n                    throw new OpenAIError(`missing output at index ${event.output_index}`);\n                }\n                if (output.type === 'function_call') {\n                    output.arguments += event.delta;\n                }\n                break;\n            }\n            case 'response.completed': {\n                __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, \"f\");\n                break;\n            }\n        }\n        return snapshot;\n    }, Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        this.on('event', (event) => {\n            const reader = readQueue.shift();\n            if (reader) {\n                reader.resolve(event);\n            }\n            else {\n                pushQueue.push(event);\n            }\n        });\n        this.on('end', () => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.resolve(undefined);\n            }\n            readQueue.length = 0;\n        });\n        this.on('abort', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        this.on('error', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        return {\n            next: async () => {\n                if (!pushQueue.length) {\n                    if (done) {\n                        return { value: undefined, done: true };\n                    }\n                    return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((event) => (event ? { value: event, done: false } : { value: undefined, done: true }));\n                }\n                const event = pushQueue.shift();\n                return { value: event, done: false };\n            },\n            return: async () => {\n                this.abort();\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    /**\n     * @returns a promise that resolves with the final Response, or rejects\n     * if an error occurred or the stream ended prematurely without producing a REsponse.\n     */\n    async finalResponse() {\n        await this.done();\n        const response = __classPrivateFieldGet(this, _ResponseStream_finalResponse, \"f\");\n        if (!response)\n            throw new OpenAIError('stream ended without producing a ChatCompletion');\n        return response;\n    }\n}\nfunction finalizeResponse(snapshot, params) {\n    return maybeParseResponse(snapshot, params);\n}\n//# sourceMappingURL=ResponseStream.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { AbstractPage } from \"./core.mjs\";\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class Page extends AbstractPage {\n    constructor(client, response, body, options) {\n        super(client, response, body, options);\n        this.data = body.data || [];\n        this.object = body.object;\n    }\n    getPaginatedItems() {\n        return this.data ?? [];\n    }\n    // @deprecated Please use `nextPageInfo()` instead\n    /**\n     * This page represents a response that isn't actually paginated at the API level\n     * so there will never be any next page params.\n     */\n    nextPageParams() {\n        return null;\n    }\n    nextPageInfo() {\n        return null;\n    }\n}\nexport class CursorPage extends AbstractPage {\n    constructor(client, response, body, options) {\n        super(client, response, body, options);\n        this.data = body.data || [];\n        this.has_more = body.has_more || false;\n    }\n    getPaginatedItems() {\n        return this.data ?? [];\n    }\n    hasNextPage() {\n        if (this.has_more === false) {\n            return false;\n        }\n        return super.hasNextPage();\n    }\n    // @deprecated Please use `nextPageInfo()` instead\n    nextPageParams() {\n        const info = this.nextPageInfo();\n        if (!info)\n            return null;\n        if ('params' in info)\n            return info.params;\n        const params = Object.fromEntries(info.url.searchParams);\n        if (!Object.keys(params).length)\n            return null;\n        return params;\n    }\n    nextPageInfo() {\n        const data = this.getPaginatedItems();\n        if (!data.length) {\n            return null;\n        }\n        const id = data[data.length - 1]?.id;\n        if (!id) {\n            return null;\n        }\n        return { params: { after: id } };\n    }\n}\n//# sourceMappingURL=pagination.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nexport class APIResource {\n    constructor(client) {\n        this._client = client;\n    }\n}\n//# sourceMappingURL=resource.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as SpeechAPI from \"./speech.mjs\";\nimport { Speech } from \"./speech.mjs\";\nimport * as TranscriptionsAPI from \"./transcriptions.mjs\";\nimport { Transcriptions, } from \"./transcriptions.mjs\";\nimport * as TranslationsAPI from \"./translations.mjs\";\nimport { Translations, } from \"./translations.mjs\";\nexport class Audio extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.transcriptions = new TranscriptionsAPI.Transcriptions(this._client);\n        this.translations = new TranslationsAPI.Translations(this._client);\n        this.speech = new SpeechAPI.Speech(this._client);\n    }\n}\nAudio.Transcriptions = Transcriptions;\nAudio.Translations = Translations;\nAudio.Speech = Speech;\n//# sourceMappingURL=audio.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nexport class Speech extends APIResource {\n    /**\n     * Generates audio from the input text.\n     *\n     * @example\n     * ```ts\n     * const speech = await client.audio.speech.create({\n     *   input: 'input',\n     *   model: 'string',\n     *   voice: 'ash',\n     * });\n     *\n     * const content = await speech.blob();\n     * console.log(content);\n     * ```\n     */\n    create(body, options) {\n        return this._client.post('/audio/speech', {\n            body,\n            ...options,\n            headers: { Accept: 'application/octet-stream', ...options?.headers },\n            __binaryResponse: true,\n        });\n    }\n}\n//# sourceMappingURL=speech.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as Core from \"../../core.mjs\";\nexport class Transcriptions extends APIResource {\n    create(body, options) {\n        return this._client.post('/audio/transcriptions', Core.multipartFormRequestOptions({\n            body,\n            ...options,\n            stream: body.stream ?? false,\n            __metadata: { model: body.model },\n        }));\n    }\n}\n//# sourceMappingURL=transcriptions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as Core from \"../../core.mjs\";\nexport class Translations extends APIResource {\n    create(body, options) {\n        return this._client.post('/audio/translations', Core.multipartFormRequestOptions({ body, ...options, __metadata: { model: body.model } }));\n    }\n}\n//# sourceMappingURL=translations.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nimport { isRequestOptions } from \"../core.mjs\";\nimport { CursorPage } from \"../pagination.mjs\";\nexport class Batches extends APIResource {\n    /**\n     * Creates and executes a batch from an uploaded file of requests\n     */\n    create(body, options) {\n        return this._client.post('/batches', { body, ...options });\n    }\n    /**\n     * Retrieves a batch.\n     */\n    retrieve(batchId, options) {\n        return this._client.get(`/batches/${batchId}`, options);\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/batches', BatchesPage, { query, ...options });\n    }\n    /**\n     * Cancels an in-progress batch. The batch will be in status `cancelling` for up to\n     * 10 minutes, before changing to `cancelled`, where it will have partial results\n     * (if any) available in the output file.\n     */\n    cancel(batchId, options) {\n        return this._client.post(`/batches/${batchId}/cancel`, options);\n    }\n}\nexport class BatchesPage extends CursorPage {\n}\nBatches.BatchesPage = BatchesPage;\n//# sourceMappingURL=batches.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { isRequestOptions } from \"../../core.mjs\";\nimport { CursorPage } from \"../../pagination.mjs\";\nimport { AssistantStream } from \"../../lib/AssistantStream.mjs\";\nexport class Assistants extends APIResource {\n    /**\n     * Create an assistant with a model and instructions.\n     *\n     * @example\n     * ```ts\n     * const assistant = await client.beta.assistants.create({\n     *   model: 'gpt-4o',\n     * });\n     * ```\n     */\n    create(body, options) {\n        return this._client.post('/assistants', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves an assistant.\n     *\n     * @example\n     * ```ts\n     * const assistant = await client.beta.assistants.retrieve(\n     *   'assistant_id',\n     * );\n     * ```\n     */\n    retrieve(assistantId, options) {\n        return this._client.get(`/assistants/${assistantId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies an assistant.\n     *\n     * @example\n     * ```ts\n     * const assistant = await client.beta.assistants.update(\n     *   'assistant_id',\n     * );\n     * ```\n     */\n    update(assistantId, body, options) {\n        return this._client.post(`/assistants/${assistantId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/assistants', AssistantsPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Delete an assistant.\n     *\n     * @example\n     * ```ts\n     * const assistantDeleted = await client.beta.assistants.del(\n     *   'assistant_id',\n     * );\n     * ```\n     */\n    del(assistantId, options) {\n        return this._client.delete(`/assistants/${assistantId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\nexport class AssistantsPage extends CursorPage {\n}\nAssistants.AssistantsPage = AssistantsPage;\n//# sourceMappingURL=assistants.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as AssistantsAPI from \"./assistants.mjs\";\nimport * as ChatAPI from \"./chat/chat.mjs\";\nimport { Assistants, AssistantsPage, } from \"./assistants.mjs\";\nimport * as RealtimeAPI from \"./realtime/realtime.mjs\";\nimport { Realtime, } from \"./realtime/realtime.mjs\";\nimport * as ThreadsAPI from \"./threads/threads.mjs\";\nimport { Threads, } from \"./threads/threads.mjs\";\nimport { Chat } from \"./chat/chat.mjs\";\nexport class Beta extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.realtime = new RealtimeAPI.Realtime(this._client);\n        this.chat = new ChatAPI.Chat(this._client);\n        this.assistants = new AssistantsAPI.Assistants(this._client);\n        this.threads = new ThreadsAPI.Threads(this._client);\n    }\n}\nBeta.Realtime = Realtime;\nBeta.Assistants = Assistants;\nBeta.AssistantsPage = AssistantsPage;\nBeta.Threads = Threads;\n//# sourceMappingURL=beta.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport * as CompletionsAPI from \"./completions.mjs\";\nexport class Chat extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.completions = new CompletionsAPI.Completions(this._client);\n    }\n}\n(function (Chat) {\n    Chat.Completions = CompletionsAPI.Completions;\n})(Chat || (Chat = {}));\n//# sourceMappingURL=chat.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { ChatCompletionRunner } from \"../../../lib/ChatCompletionRunner.mjs\";\nimport { ChatCompletionStreamingRunner, } from \"../../../lib/ChatCompletionStreamingRunner.mjs\";\nimport { ChatCompletionStream } from \"../../../lib/ChatCompletionStream.mjs\";\nimport { parseChatCompletion, validateInputTools } from \"../../../lib/parser.mjs\";\nexport { ChatCompletionStreamingRunner, } from \"../../../lib/ChatCompletionStreamingRunner.mjs\";\nexport { ParsingFunction, ParsingToolFunction, } from \"../../../lib/RunnableFunction.mjs\";\nexport { ChatCompletionStream } from \"../../../lib/ChatCompletionStream.mjs\";\nexport { ChatCompletionRunner, } from \"../../../lib/ChatCompletionRunner.mjs\";\nexport class Completions extends APIResource {\n    parse(body, options) {\n        validateInputTools(body.tools);\n        return this._client.chat.completions\n            .create(body, {\n            ...options,\n            headers: {\n                ...options?.headers,\n                'X-Stainless-Helper-Method': 'beta.chat.completions.parse',\n            },\n        })\n            ._thenUnwrap((completion) => parseChatCompletion(completion, body));\n    }\n    runFunctions(body, options) {\n        if (body.stream) {\n            return ChatCompletionStreamingRunner.runFunctions(this._client, body, options);\n        }\n        return ChatCompletionRunner.runFunctions(this._client, body, options);\n    }\n    runTools(body, options) {\n        if (body.stream) {\n            return ChatCompletionStreamingRunner.runTools(this._client, body, options);\n        }\n        return ChatCompletionRunner.runTools(this._client, body, options);\n    }\n    /**\n     * Creates a chat completion stream\n     */\n    stream(body, options) {\n        return ChatCompletionStream.createChatCompletion(this._client, body, options);\n    }\n}\n//# sourceMappingURL=completions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport * as SessionsAPI from \"./sessions.mjs\";\nimport { Sessions, } from \"./sessions.mjs\";\nimport * as TranscriptionSessionsAPI from \"./transcription-sessions.mjs\";\nimport { TranscriptionSessions, } from \"./transcription-sessions.mjs\";\nexport class Realtime extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.sessions = new SessionsAPI.Sessions(this._client);\n        this.transcriptionSessions = new TranscriptionSessionsAPI.TranscriptionSessions(this._client);\n    }\n}\nRealtime.Sessions = Sessions;\nRealtime.TranscriptionSessions = TranscriptionSessions;\n//# sourceMappingURL=realtime.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nexport class Sessions extends APIResource {\n    /**\n     * Create an ephemeral API token for use in client-side applications with the\n     * Realtime API. Can be configured with the same session parameters as the\n     * `session.update` client event.\n     *\n     * It responds with a session object, plus a `client_secret` key which contains a\n     * usable ephemeral API token that can be used to authenticate browser clients for\n     * the Realtime API.\n     *\n     * @example\n     * ```ts\n     * const session =\n     *   await client.beta.realtime.sessions.create();\n     * ```\n     */\n    create(body, options) {\n        return this._client.post('/realtime/sessions', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\n//# sourceMappingURL=sessions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nexport class TranscriptionSessions extends APIResource {\n    /**\n     * Create an ephemeral API token for use in client-side applications with the\n     * Realtime API specifically for realtime transcriptions. Can be configured with\n     * the same session parameters as the `transcription_session.update` client event.\n     *\n     * It responds with a session object, plus a `client_secret` key which contains a\n     * usable ephemeral API token that can be used to authenticate browser clients for\n     * the Realtime API.\n     *\n     * @example\n     * ```ts\n     * const transcriptionSession =\n     *   await client.beta.realtime.transcriptionSessions.create();\n     * ```\n     */\n    create(body, options) {\n        return this._client.post('/realtime/transcription_sessions', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\n//# sourceMappingURL=transcription-sessions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport { CursorPage } from \"../../../pagination.mjs\";\n/**\n * @deprecated The Assistants API is deprecated in favor of the Responses API\n */\nexport class Messages extends APIResource {\n    /**\n     * Create a message.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    create(threadId, body, options) {\n        return this._client.post(`/threads/${threadId}/messages`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieve a message.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    retrieve(threadId, messageId, options) {\n        return this._client.get(`/threads/${threadId}/messages/${messageId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies a message.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    update(threadId, messageId, body, options) {\n        return this._client.post(`/threads/${threadId}/messages/${messageId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(threadId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(threadId, {}, query);\n        }\n        return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Deletes a message.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    del(threadId, messageId, options) {\n        return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\nexport class MessagesPage extends CursorPage {\n}\nMessages.MessagesPage = MessagesPage;\n//# sourceMappingURL=messages.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../../core.mjs\";\nimport { AssistantStream } from \"../../../../lib/AssistantStream.mjs\";\nimport { sleep } from \"../../../../core.mjs\";\nimport * as StepsAPI from \"./steps.mjs\";\nimport { RunStepsPage, Steps, } from \"./steps.mjs\";\nimport { CursorPage } from \"../../../../pagination.mjs\";\n/**\n * @deprecated The Assistants API is deprecated in favor of the Responses API\n */\nexport class Runs extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.steps = new StepsAPI.Steps(this._client);\n    }\n    create(threadId, params, options) {\n        const { include, ...body } = params;\n        return this._client.post(`/threads/${threadId}/runs`, {\n            query: { include },\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n            stream: params.stream ?? false,\n        });\n    }\n    /**\n     * Retrieves a run.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    retrieve(threadId, runId, options) {\n        return this._client.get(`/threads/${threadId}/runs/${runId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies a run.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    update(threadId, runId, body, options) {\n        return this._client.post(`/threads/${threadId}/runs/${runId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(threadId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(threadId, {}, query);\n        }\n        return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Cancels a run that is `in_progress`.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    cancel(threadId, runId, options) {\n        return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * A helper to create a run an poll for a terminal state. More information on Run\n     * lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    async createAndPoll(threadId, body, options) {\n        const run = await this.create(threadId, body, options);\n        return await this.poll(threadId, run.id, options);\n    }\n    /**\n     * Create a Run stream\n     *\n     * @deprecated use `stream` instead\n     */\n    createAndStream(threadId, body, options) {\n        return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);\n    }\n    /**\n     * A helper to poll a run status until it reaches a terminal state. More\n     * information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    async poll(threadId, runId, options) {\n        const headers = { ...options?.headers, 'X-Stainless-Poll-Helper': 'true' };\n        if (options?.pollIntervalMs) {\n            headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();\n        }\n        while (true) {\n            const { data: run, response } = await this.retrieve(threadId, runId, {\n                ...options,\n                headers: { ...options?.headers, ...headers },\n            }).withResponse();\n            switch (run.status) {\n                //If we are in any sort of intermediate state we poll\n                case 'queued':\n                case 'in_progress':\n                case 'cancelling':\n                    let sleepInterval = 5000;\n                    if (options?.pollIntervalMs) {\n                        sleepInterval = options.pollIntervalMs;\n                    }\n                    else {\n                        const headerInterval = response.headers.get('openai-poll-after-ms');\n                        if (headerInterval) {\n                            const headerIntervalMs = parseInt(headerInterval);\n                            if (!isNaN(headerIntervalMs)) {\n                                sleepInterval = headerIntervalMs;\n                            }\n                        }\n                    }\n                    await sleep(sleepInterval);\n                    break;\n                //We return the run in any terminal state.\n                case 'requires_action':\n                case 'incomplete':\n                case 'cancelled':\n                case 'completed':\n                case 'failed':\n                case 'expired':\n                    return run;\n            }\n        }\n    }\n    /**\n     * Create a Run stream\n     */\n    stream(threadId, body, options) {\n        return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);\n    }\n    submitToolOutputs(threadId, runId, body, options) {\n        return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n            stream: body.stream ?? false,\n        });\n    }\n    /**\n     * A helper to submit a tool output to a run and poll for a terminal run state.\n     * More information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    async submitToolOutputsAndPoll(threadId, runId, body, options) {\n        const run = await this.submitToolOutputs(threadId, runId, body, options);\n        return await this.poll(threadId, run.id, options);\n    }\n    /**\n     * Submit the tool outputs from a previous run and stream the run to a terminal\n     * state. More information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    submitToolOutputsStream(threadId, runId, body, options) {\n        return AssistantStream.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);\n    }\n}\nexport class RunsPage extends CursorPage {\n}\nRuns.RunsPage = RunsPage;\nRuns.Steps = Steps;\nRuns.RunStepsPage = RunStepsPage;\n//# sourceMappingURL=runs.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../../core.mjs\";\nimport { CursorPage } from \"../../../../pagination.mjs\";\n/**\n * @deprecated The Assistants API is deprecated in favor of the Responses API\n */\nexport class Steps extends APIResource {\n    retrieve(threadId, runId, stepId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.retrieve(threadId, runId, stepId, {}, query);\n        }\n        return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(threadId, runId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(threadId, runId, {}, query);\n        }\n        return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\nexport class RunStepsPage extends CursorPage {\n}\nSteps.RunStepsPage = RunStepsPage;\n//# sourceMappingURL=steps.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport { AssistantStream } from \"../../../lib/AssistantStream.mjs\";\nimport * as MessagesAPI from \"./messages.mjs\";\nimport { Messages, MessagesPage, } from \"./messages.mjs\";\nimport * as RunsAPI from \"./runs/runs.mjs\";\nimport { Runs, RunsPage, } from \"./runs/runs.mjs\";\n/**\n * @deprecated The Assistants API is deprecated in favor of the Responses API\n */\nexport class Threads extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.runs = new RunsAPI.Runs(this._client);\n        this.messages = new MessagesAPI.Messages(this._client);\n    }\n    create(body = {}, options) {\n        if (isRequestOptions(body)) {\n            return this.create({}, body);\n        }\n        return this._client.post('/threads', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves a thread.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    retrieve(threadId, options) {\n        return this._client.get(`/threads/${threadId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies a thread.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    update(threadId, body, options) {\n        return this._client.post(`/threads/${threadId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Delete a thread.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    del(threadId, options) {\n        return this._client.delete(`/threads/${threadId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    createAndRun(body, options) {\n        return this._client.post('/threads/runs', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n            stream: body.stream ?? false,\n        });\n    }\n    /**\n     * A helper to create a thread, start a run and then poll for a terminal state.\n     * More information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    async createAndRunPoll(body, options) {\n        const run = await this.createAndRun(body, options);\n        return await this.runs.poll(run.thread_id, run.id, options);\n    }\n    /**\n     * Create a thread and stream the run back\n     */\n    createAndRunStream(body, options) {\n        return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);\n    }\n}\nThreads.Runs = Runs;\nThreads.RunsPage = RunsPage;\nThreads.Messages = Messages;\nThreads.MessagesPage = MessagesPage;\n//# sourceMappingURL=threads.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as CompletionsAPI from \"./completions/completions.mjs\";\nimport { ChatCompletionsPage, Completions, } from \"./completions/completions.mjs\";\nexport class Chat extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.completions = new CompletionsAPI.Completions(this._client);\n    }\n}\nChat.Completions = Completions;\nChat.ChatCompletionsPage = ChatCompletionsPage;\n//# sourceMappingURL=chat.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport * as MessagesAPI from \"./messages.mjs\";\nimport { Messages } from \"./messages.mjs\";\nimport { CursorPage } from \"../../../pagination.mjs\";\nexport class Completions extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.messages = new MessagesAPI.Messages(this._client);\n    }\n    create(body, options) {\n        return this._client.post('/chat/completions', { body, ...options, stream: body.stream ?? false });\n    }\n    /**\n     * Get a stored chat completion. Only Chat Completions that have been created with\n     * the `store` parameter set to `true` will be returned.\n     *\n     * @example\n     * ```ts\n     * const chatCompletion =\n     *   await client.chat.completions.retrieve('completion_id');\n     * ```\n     */\n    retrieve(completionId, options) {\n        return this._client.get(`/chat/completions/${completionId}`, options);\n    }\n    /**\n     * Modify a stored chat completion. Only Chat Completions that have been created\n     * with the `store` parameter set to `true` can be modified. Currently, the only\n     * supported modification is to update the `metadata` field.\n     *\n     * @example\n     * ```ts\n     * const chatCompletion = await client.chat.completions.update(\n     *   'completion_id',\n     *   { metadata: { foo: 'string' } },\n     * );\n     * ```\n     */\n    update(completionId, body, options) {\n        return this._client.post(`/chat/completions/${completionId}`, { body, ...options });\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/chat/completions', ChatCompletionsPage, { query, ...options });\n    }\n    /**\n     * Delete a stored chat completion. Only Chat Completions that have been created\n     * with the `store` parameter set to `true` can be deleted.\n     *\n     * @example\n     * ```ts\n     * const chatCompletionDeleted =\n     *   await client.chat.completions.del('completion_id');\n     * ```\n     */\n    del(completionId, options) {\n        return this._client.delete(`/chat/completions/${completionId}`, options);\n    }\n}\nexport class ChatCompletionsPage extends CursorPage {\n}\nexport class ChatCompletionStoreMessagesPage extends CursorPage {\n}\nCompletions.ChatCompletionsPage = ChatCompletionsPage;\nCompletions.Messages = Messages;\n//# sourceMappingURL=completions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport { ChatCompletionStoreMessagesPage } from \"./completions.mjs\";\nexport class Messages extends APIResource {\n    list(completionId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(completionId, {}, query);\n        }\n        return this._client.getAPIList(`/chat/completions/${completionId}/messages`, ChatCompletionStoreMessagesPage, { query, ...options });\n    }\n}\nexport { ChatCompletionStoreMessagesPage };\n//# sourceMappingURL=messages.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nexport class Completions extends APIResource {\n    create(body, options) {\n        return this._client.post('/completions', { body, ...options, stream: body.stream ?? false });\n    }\n}\n//# sourceMappingURL=completions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { isRequestOptions } from \"../../core.mjs\";\nimport * as FilesAPI from \"./files/files.mjs\";\nimport { FileListResponsesPage, Files, } from \"./files/files.mjs\";\nimport { CursorPage } from \"../../pagination.mjs\";\nexport class Containers extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.files = new FilesAPI.Files(this._client);\n    }\n    /**\n     * Create Container\n     */\n    create(body, options) {\n        return this._client.post('/containers', { body, ...options });\n    }\n    /**\n     * Retrieve Container\n     */\n    retrieve(containerId, options) {\n        return this._client.get(`/containers/${containerId}`, options);\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/containers', ContainerListResponsesPage, { query, ...options });\n    }\n    /**\n     * Delete Container\n     */\n    del(containerId, options) {\n        return this._client.delete(`/containers/${containerId}`, {\n            ...options,\n            headers: { Accept: '*/*', ...options?.headers },\n        });\n    }\n}\nexport class ContainerListResponsesPage extends CursorPage {\n}\nContainers.ContainerListResponsesPage = ContainerListResponsesPage;\nContainers.Files = Files;\nContainers.FileListResponsesPage = FileListResponsesPage;\n//# sourceMappingURL=containers.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nexport class Content extends APIResource {\n    /**\n     * Retrieve Container File Content\n     */\n    retrieve(containerId, fileId, options) {\n        return this._client.get(`/containers/${containerId}/files/${fileId}/content`, {\n            ...options,\n            headers: { Accept: 'application/binary', ...options?.headers },\n            __binaryResponse: true,\n        });\n    }\n}\n//# sourceMappingURL=content.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport * as Core from \"../../../core.mjs\";\nimport * as ContentAPI from \"./content.mjs\";\nimport { Content } from \"./content.mjs\";\nimport { CursorPage } from \"../../../pagination.mjs\";\nexport class Files extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.content = new ContentAPI.Content(this._client);\n    }\n    /**\n     * Create a Container File\n     *\n     * You can send either a multipart/form-data request with the raw file content, or\n     * a JSON request with a file ID.\n     */\n    create(containerId, body, options) {\n        return this._client.post(`/containers/${containerId}/files`, Core.multipartFormRequestOptions({ body, ...options }));\n    }\n    /**\n     * Retrieve Container File\n     */\n    retrieve(containerId, fileId, options) {\n        return this._client.get(`/containers/${containerId}/files/${fileId}`, options);\n    }\n    list(containerId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(containerId, {}, query);\n        }\n        return this._client.getAPIList(`/containers/${containerId}/files`, FileListResponsesPage, {\n            query,\n            ...options,\n        });\n    }\n    /**\n     * Delete Container File\n     */\n    del(containerId, fileId, options) {\n        return this._client.delete(`/containers/${containerId}/files/${fileId}`, {\n            ...options,\n            headers: { Accept: '*/*', ...options?.headers },\n        });\n    }\n}\nexport class FileListResponsesPage extends CursorPage {\n}\nFiles.FileListResponsesPage = FileListResponsesPage;\nFiles.Content = Content;\n//# sourceMappingURL=files.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nimport * as Core from \"../core.mjs\";\nexport class Embeddings extends APIResource {\n    /**\n     * Creates an embedding vector representing the input text.\n     *\n     * @example\n     * ```ts\n     * const createEmbeddingResponse =\n     *   await client.embeddings.create({\n     *     input: 'The quick brown fox jumped over the lazy dog',\n     *     model: 'text-embedding-3-small',\n     *   });\n     * ```\n     */\n    create(body, options) {\n        const hasUserProvidedEncodingFormat = !!body.encoding_format;\n        // No encoding_format specified, defaulting to base64 for performance reasons\n        // See https://github.com/openai/openai-node/pull/1312\n        let encoding_format = hasUserProvidedEncodingFormat ? body.encoding_format : 'base64';\n        if (hasUserProvidedEncodingFormat) {\n            Core.debug('Request', 'User defined encoding_format:', body.encoding_format);\n        }\n        const response = this._client.post('/embeddings', {\n            body: {\n                ...body,\n                encoding_format: encoding_format,\n            },\n            ...options,\n        });\n        // if the user specified an encoding_format, return the response as-is\n        if (hasUserProvidedEncodingFormat) {\n            return response;\n        }\n        // in this stage, we are sure the user did not specify an encoding_format\n        // and we defaulted to base64 for performance reasons\n        // we are sure then that the response is base64 encoded, let's decode it\n        // the returned result will be a float32 array since this is OpenAI API's default encoding\n        Core.debug('response', 'Decoding base64 embeddings to float32 array');\n        return response._thenUnwrap((response) => {\n            if (response && response.data) {\n                response.data.forEach((embeddingBase64Obj) => {\n                    const embeddingBase64Str = embeddingBase64Obj.embedding;\n                    embeddingBase64Obj.embedding = Core.toFloat32Array(embeddingBase64Str);\n                });\n            }\n            return response;\n        });\n    }\n}\n//# sourceMappingURL=embeddings.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { isRequestOptions } from \"../../core.mjs\";\nimport * as RunsAPI from \"./runs/runs.mjs\";\nimport { RunListResponsesPage, Runs, } from \"./runs/runs.mjs\";\nimport { CursorPage } from \"../../pagination.mjs\";\nexport class Evals extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.runs = new RunsAPI.Runs(this._client);\n    }\n    /**\n     * Create the structure of an evaluation that can be used to test a model's\n     * performance. An evaluation is a set of testing criteria and the config for a\n     * data source, which dictates the schema of the data used in the evaluation. After\n     * creating an evaluation, you can run it on different models and model parameters.\n     * We support several types of graders and datasources. For more information, see\n     * the [Evals guide](https://platform.openai.com/docs/guides/evals).\n     */\n    create(body, options) {\n        return this._client.post('/evals', { body, ...options });\n    }\n    /**\n     * Get an evaluation by ID.\n     */\n    retrieve(evalId, options) {\n        return this._client.get(`/evals/${evalId}`, options);\n    }\n    /**\n     * Update certain properties of an evaluation.\n     */\n    update(evalId, body, options) {\n        return this._client.post(`/evals/${evalId}`, { body, ...options });\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/evals', EvalListResponsesPage, { query, ...options });\n    }\n    /**\n     * Delete an evaluation.\n     */\n    del(evalId, options) {\n        return this._client.delete(`/evals/${evalId}`, options);\n    }\n}\nexport class EvalListResponsesPage extends CursorPage {\n}\nEvals.EvalListResponsesPage = EvalListResponsesPage;\nEvals.Runs = Runs;\nEvals.RunListResponsesPage = RunListResponsesPage;\n//# sourceMappingURL=evals.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport { CursorPage } from \"../../../pagination.mjs\";\nexport class OutputItems extends APIResource {\n    /**\n     * Get an evaluation run output item by ID.\n     */\n    retrieve(evalId, runId, outputItemId, options) {\n        return this._client.get(`/evals/${evalId}/runs/${runId}/output_items/${outputItemId}`, options);\n    }\n    list(evalId, runId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(evalId, runId, {}, query);\n        }\n        return this._client.getAPIList(`/evals/${evalId}/runs/${runId}/output_items`, OutputItemListResponsesPage, { query, ...options });\n    }\n}\nexport class OutputItemListResponsesPage extends CursorPage {\n}\nOutputItems.OutputItemListResponsesPage = OutputItemListResponsesPage;\n//# sourceMappingURL=output-items.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport * as OutputItemsAPI from \"./output-items.mjs\";\nimport { OutputItemListResponsesPage, OutputItems, } from \"./output-items.mjs\";\nimport { CursorPage } from \"../../../pagination.mjs\";\nexport class Runs extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.outputItems = new OutputItemsAPI.OutputItems(this._client);\n    }\n    /**\n     * Kicks off a new run for a given evaluation, specifying the data source, and what\n     * model configuration to use to test. The datasource will be validated against the\n     * schema specified in the config of the evaluation.\n     */\n    create(evalId, body, options) {\n        return this._client.post(`/evals/${evalId}/runs`, { body, ...options });\n    }\n    /**\n     * Get an evaluation run by ID.\n     */\n    retrieve(evalId, runId, options) {\n        return this._client.get(`/evals/${evalId}/runs/${runId}`, options);\n    }\n    list(evalId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(evalId, {}, query);\n        }\n        return this._client.getAPIList(`/evals/${evalId}/runs`, RunListResponsesPage, { query, ...options });\n    }\n    /**\n     * Delete an eval run.\n     */\n    del(evalId, runId, options) {\n        return this._client.delete(`/evals/${evalId}/runs/${runId}`, options);\n    }\n    /**\n     * Cancel an ongoing evaluation run.\n     */\n    cancel(evalId, runId, options) {\n        return this._client.post(`/evals/${evalId}/runs/${runId}`, options);\n    }\n}\nexport class RunListResponsesPage extends CursorPage {\n}\nRuns.RunListResponsesPage = RunListResponsesPage;\nRuns.OutputItems = OutputItems;\nRuns.OutputItemListResponsesPage = OutputItemListResponsesPage;\n//# sourceMappingURL=runs.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nimport { isRequestOptions } from \"../core.mjs\";\nimport { sleep } from \"../core.mjs\";\nimport { APIConnectionTimeoutError } from \"../error.mjs\";\nimport * as Core from \"../core.mjs\";\nimport { CursorPage } from \"../pagination.mjs\";\nexport class Files extends APIResource {\n    /**\n     * Upload a file that can be used across various endpoints. Individual files can be\n     * up to 512 MB, and the size of all files uploaded by one organization can be up\n     * to 100 GB.\n     *\n     * The Assistants API supports files up to 2 million tokens and of specific file\n     * types. See the\n     * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for\n     * details.\n     *\n     * The Fine-tuning API only supports `.jsonl` files. The input also has certain\n     * required formats for fine-tuning\n     * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or\n     * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)\n     * models.\n     *\n     * The Batch API only supports `.jsonl` files up to 200 MB in size. The input also\n     * has a specific required\n     * [format](https://platform.openai.com/docs/api-reference/batch/request-input).\n     *\n     * Please [contact us](https://help.openai.com/) if you need to increase these\n     * storage limits.\n     */\n    create(body, options) {\n        return this._client.post('/files', Core.multipartFormRequestOptions({ body, ...options }));\n    }\n    /**\n     * Returns information about a specific file.\n     */\n    retrieve(fileId, options) {\n        return this._client.get(`/files/${fileId}`, options);\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/files', FileObjectsPage, { query, ...options });\n    }\n    /**\n     * Delete a file.\n     */\n    del(fileId, options) {\n        return this._client.delete(`/files/${fileId}`, options);\n    }\n    /**\n     * Returns the contents of the specified file.\n     */\n    content(fileId, options) {\n        return this._client.get(`/files/${fileId}/content`, {\n            ...options,\n            headers: { Accept: 'application/binary', ...options?.headers },\n            __binaryResponse: true,\n        });\n    }\n    /**\n     * Returns the contents of the specified file.\n     *\n     * @deprecated The `.content()` method should be used instead\n     */\n    retrieveContent(fileId, options) {\n        return this._client.get(`/files/${fileId}/content`, options);\n    }\n    /**\n     * Waits for the given file to be processed, default timeout is 30 mins.\n     */\n    async waitForProcessing(id, { pollInterval = 5000, maxWait = 30 * 60 * 1000 } = {}) {\n        const TERMINAL_STATES = new Set(['processed', 'error', 'deleted']);\n        const start = Date.now();\n        let file = await this.retrieve(id);\n        while (!file.status || !TERMINAL_STATES.has(file.status)) {\n            await sleep(pollInterval);\n            file = await this.retrieve(id);\n            if (Date.now() - start > maxWait) {\n                throw new APIConnectionTimeoutError({\n                    message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`,\n                });\n            }\n        }\n        return file;\n    }\n}\nexport class FileObjectsPage extends CursorPage {\n}\nFiles.FileObjectsPage = FileObjectsPage;\n//# sourceMappingURL=files.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport * as GradersAPI from \"./graders.mjs\";\nimport { Graders, } from \"./graders.mjs\";\nexport class Alpha extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.graders = new GradersAPI.Graders(this._client);\n    }\n}\nAlpha.Graders = Graders;\n//# sourceMappingURL=alpha.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nexport class Graders extends APIResource {\n    /**\n     * Run a grader.\n     *\n     * @example\n     * ```ts\n     * const response = await client.fineTuning.alpha.graders.run({\n     *   grader: {\n     *     input: 'input',\n     *     name: 'name',\n     *     operation: 'eq',\n     *     reference: 'reference',\n     *     type: 'string_check',\n     *   },\n     *   model_sample: 'model_sample',\n     *   reference_answer: 'string',\n     * });\n     * ```\n     */\n    run(body, options) {\n        return this._client.post('/fine_tuning/alpha/graders/run', { body, ...options });\n    }\n    /**\n     * Validate a grader.\n     *\n     * @example\n     * ```ts\n     * const response =\n     *   await client.fineTuning.alpha.graders.validate({\n     *     grader: {\n     *       input: 'input',\n     *       name: 'name',\n     *       operation: 'eq',\n     *       reference: 'reference',\n     *       type: 'string_check',\n     *     },\n     *   });\n     * ```\n     */\n    validate(body, options) {\n        return this._client.post('/fine_tuning/alpha/graders/validate', { body, ...options });\n    }\n}\n//# sourceMappingURL=graders.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport * as PermissionsAPI from \"./permissions.mjs\";\nimport { PermissionCreateResponsesPage, Permissions, } from \"./permissions.mjs\";\nexport class Checkpoints extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.permissions = new PermissionsAPI.Permissions(this._client);\n    }\n}\nCheckpoints.Permissions = Permissions;\nCheckpoints.PermissionCreateResponsesPage = PermissionCreateResponsesPage;\n//# sourceMappingURL=checkpoints.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport { Page } from \"../../../pagination.mjs\";\nexport class Permissions extends APIResource {\n    /**\n     * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).\n     *\n     * This enables organization owners to share fine-tuned models with other projects\n     * in their organization.\n     *\n     * @example\n     * ```ts\n     * // Automatically fetches more pages as needed.\n     * for await (const permissionCreateResponse of client.fineTuning.checkpoints.permissions.create(\n     *   'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',\n     *   { project_ids: ['string'] },\n     * )) {\n     *   // ...\n     * }\n     * ```\n     */\n    create(fineTunedModelCheckpoint, body, options) {\n        return this._client.getAPIList(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, PermissionCreateResponsesPage, { body, method: 'post', ...options });\n    }\n    retrieve(fineTunedModelCheckpoint, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.retrieve(fineTunedModelCheckpoint, {}, query);\n        }\n        return this._client.get(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, {\n            query,\n            ...options,\n        });\n    }\n    /**\n     * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).\n     *\n     * Organization owners can use this endpoint to delete a permission for a\n     * fine-tuned model checkpoint.\n     *\n     * @example\n     * ```ts\n     * const permission =\n     *   await client.fineTuning.checkpoints.permissions.del(\n     *     'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',\n     *     'cp_zc4Q7MP6XxulcVzj4MZdwsAB',\n     *   );\n     * ```\n     */\n    del(fineTunedModelCheckpoint, permissionId, options) {\n        return this._client.delete(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions/${permissionId}`, options);\n    }\n}\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class PermissionCreateResponsesPage extends Page {\n}\nPermissions.PermissionCreateResponsesPage = PermissionCreateResponsesPage;\n//# sourceMappingURL=permissions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as MethodsAPI from \"./methods.mjs\";\nimport { Methods, } from \"./methods.mjs\";\nimport * as AlphaAPI from \"./alpha/alpha.mjs\";\nimport { Alpha } from \"./alpha/alpha.mjs\";\nimport * as CheckpointsAPI from \"./checkpoints/checkpoints.mjs\";\nimport { Checkpoints } from \"./checkpoints/checkpoints.mjs\";\nimport * as JobsAPI from \"./jobs/jobs.mjs\";\nimport { FineTuningJobEventsPage, FineTuningJobsPage, Jobs, } from \"./jobs/jobs.mjs\";\nexport class FineTuning extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.methods = new MethodsAPI.Methods(this._client);\n        this.jobs = new JobsAPI.Jobs(this._client);\n        this.checkpoints = new CheckpointsAPI.Checkpoints(this._client);\n        this.alpha = new AlphaAPI.Alpha(this._client);\n    }\n}\nFineTuning.Methods = Methods;\nFineTuning.Jobs = Jobs;\nFineTuning.FineTuningJobsPage = FineTuningJobsPage;\nFineTuning.FineTuningJobEventsPage = FineTuningJobEventsPage;\nFineTuning.Checkpoints = Checkpoints;\nFineTuning.Alpha = Alpha;\n//# sourceMappingURL=fine-tuning.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport { CursorPage } from \"../../../pagination.mjs\";\nexport class Checkpoints extends APIResource {\n    list(fineTuningJobId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(fineTuningJobId, {}, query);\n        }\n        return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`, FineTuningJobCheckpointsPage, { query, ...options });\n    }\n}\nexport class FineTuningJobCheckpointsPage extends CursorPage {\n}\nCheckpoints.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;\n//# sourceMappingURL=checkpoints.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport * as CheckpointsAPI from \"./checkpoints.mjs\";\nimport { Checkpoints, FineTuningJobCheckpointsPage, } from \"./checkpoints.mjs\";\nimport { CursorPage } from \"../../../pagination.mjs\";\nexport class Jobs extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.checkpoints = new CheckpointsAPI.Checkpoints(this._client);\n    }\n    /**\n     * Creates a fine-tuning job which begins the process of creating a new model from\n     * a given dataset.\n     *\n     * Response includes details of the enqueued job including job status and the name\n     * of the fine-tuned models once complete.\n     *\n     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)\n     *\n     * @example\n     * ```ts\n     * const fineTuningJob = await client.fineTuning.jobs.create({\n     *   model: 'gpt-4o-mini',\n     *   training_file: 'file-abc123',\n     * });\n     * ```\n     */\n    create(body, options) {\n        return this._client.post('/fine_tuning/jobs', { body, ...options });\n    }\n    /**\n     * Get info about a fine-tuning job.\n     *\n     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)\n     *\n     * @example\n     * ```ts\n     * const fineTuningJob = await client.fineTuning.jobs.retrieve(\n     *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',\n     * );\n     * ```\n     */\n    retrieve(fineTuningJobId, options) {\n        return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/fine_tuning/jobs', FineTuningJobsPage, { query, ...options });\n    }\n    /**\n     * Immediately cancel a fine-tune job.\n     *\n     * @example\n     * ```ts\n     * const fineTuningJob = await client.fineTuning.jobs.cancel(\n     *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',\n     * );\n     * ```\n     */\n    cancel(fineTuningJobId, options) {\n        return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);\n    }\n    listEvents(fineTuningJobId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.listEvents(fineTuningJobId, {}, query);\n        }\n        return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {\n            query,\n            ...options,\n        });\n    }\n    /**\n     * Pause a fine-tune job.\n     *\n     * @example\n     * ```ts\n     * const fineTuningJob = await client.fineTuning.jobs.pause(\n     *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',\n     * );\n     * ```\n     */\n    pause(fineTuningJobId, options) {\n        return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/pause`, options);\n    }\n    /**\n     * Resume a fine-tune job.\n     *\n     * @example\n     * ```ts\n     * const fineTuningJob = await client.fineTuning.jobs.resume(\n     *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',\n     * );\n     * ```\n     */\n    resume(fineTuningJobId, options) {\n        return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/resume`, options);\n    }\n}\nexport class FineTuningJobsPage extends CursorPage {\n}\nexport class FineTuningJobEventsPage extends CursorPage {\n}\nJobs.FineTuningJobsPage = FineTuningJobsPage;\nJobs.FineTuningJobEventsPage = FineTuningJobEventsPage;\nJobs.Checkpoints = Checkpoints;\nJobs.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;\n//# sourceMappingURL=jobs.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nexport class Methods extends APIResource {\n}\n//# sourceMappingURL=methods.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nexport class GraderModels extends APIResource {\n}\n//# sourceMappingURL=grader-models.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as GraderModelsAPI from \"./grader-models.mjs\";\nimport { GraderModels, } from \"./grader-models.mjs\";\nexport class Graders extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.graderModels = new GraderModelsAPI.GraderModels(this._client);\n    }\n}\nGraders.GraderModels = GraderModels;\n//# sourceMappingURL=graders.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nimport * as Core from \"../core.mjs\";\nexport class Images extends APIResource {\n    /**\n     * Creates a variation of a given image. This endpoint only supports `dall-e-2`.\n     *\n     * @example\n     * ```ts\n     * const imagesResponse = await client.images.createVariation({\n     *   image: fs.createReadStream('otter.png'),\n     * });\n     * ```\n     */\n    createVariation(body, options) {\n        return this._client.post('/images/variations', Core.multipartFormRequestOptions({ body, ...options }));\n    }\n    /**\n     * Creates an edited or extended image given one or more source images and a\n     * prompt. This endpoint only supports `gpt-image-1` and `dall-e-2`.\n     *\n     * @example\n     * ```ts\n     * const imagesResponse = await client.images.edit({\n     *   image: fs.createReadStream('path/to/file'),\n     *   prompt: 'A cute baby sea otter wearing a beret',\n     * });\n     * ```\n     */\n    edit(body, options) {\n        return this._client.post('/images/edits', Core.multipartFormRequestOptions({ body, ...options }));\n    }\n    /**\n     * Creates an image given a prompt.\n     * [Learn more](https://platform.openai.com/docs/guides/images).\n     *\n     * @example\n     * ```ts\n     * const imagesResponse = await client.images.generate({\n     *   prompt: 'A cute baby sea otter',\n     * });\n     * ```\n     */\n    generate(body, options) {\n        return this._client.post('/images/generations', { body, ...options });\n    }\n}\n//# sourceMappingURL=images.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nimport { Page } from \"../pagination.mjs\";\nexport class Models extends APIResource {\n    /**\n     * Retrieves a model instance, providing basic information about the model such as\n     * the owner and permissioning.\n     */\n    retrieve(model, options) {\n        return this._client.get(`/models/${model}`, options);\n    }\n    /**\n     * Lists the currently available models, and provides basic information about each\n     * one such as the owner and availability.\n     */\n    list(options) {\n        return this._client.getAPIList('/models', ModelsPage, options);\n    }\n    /**\n     * Delete a fine-tuned model. You must have the Owner role in your organization to\n     * delete a model.\n     */\n    del(model, options) {\n        return this._client.delete(`/models/${model}`, options);\n    }\n}\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class ModelsPage extends Page {\n}\nModels.ModelsPage = ModelsPage;\n//# sourceMappingURL=models.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nexport class Moderations extends APIResource {\n    /**\n     * Classifies if text and/or image inputs are potentially harmful. Learn more in\n     * the [moderation guide](https://platform.openai.com/docs/guides/moderation).\n     */\n    create(body, options) {\n        return this._client.post('/moderations', { body, ...options });\n    }\n}\n//# sourceMappingURL=moderations.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { isRequestOptions } from \"../../core.mjs\";\nimport { ResponseItemsPage } from \"./responses.mjs\";\nexport class InputItems extends APIResource {\n    list(responseId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(responseId, {}, query);\n        }\n        return this._client.getAPIList(`/responses/${responseId}/input_items`, ResponseItemsPage, {\n            query,\n            ...options,\n        });\n    }\n}\nexport { ResponseItemsPage };\n//# sourceMappingURL=input-items.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { parseResponse, addOutputText, } from \"../../lib/ResponsesParser.mjs\";\nimport { APIResource } from \"../../resource.mjs\";\nimport * as InputItemsAPI from \"./input-items.mjs\";\nimport { InputItems } from \"./input-items.mjs\";\nimport { ResponseStream } from \"../../lib/responses/ResponseStream.mjs\";\nimport { CursorPage } from \"../../pagination.mjs\";\nexport class Responses extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.inputItems = new InputItemsAPI.InputItems(this._client);\n    }\n    create(body, options) {\n        return this._client.post('/responses', { body, ...options, stream: body.stream ?? false })._thenUnwrap((rsp) => {\n            if ('object' in rsp && rsp.object === 'response') {\n                addOutputText(rsp);\n            }\n            return rsp;\n        });\n    }\n    retrieve(responseId, query = {}, options) {\n        return this._client.get(`/responses/${responseId}`, {\n            query,\n            ...options,\n            stream: query?.stream ?? false,\n        });\n    }\n    /**\n     * Deletes a model response with the given ID.\n     *\n     * @example\n     * ```ts\n     * await client.responses.del(\n     *   'resp_677efb5139a88190b512bc3fef8e535d',\n     * );\n     * ```\n     */\n    del(responseId, options) {\n        return this._client.delete(`/responses/${responseId}`, {\n            ...options,\n            headers: { Accept: '*/*', ...options?.headers },\n        });\n    }\n    parse(body, options) {\n        return this._client.responses\n            .create(body, options)\n            ._thenUnwrap((response) => parseResponse(response, body));\n    }\n    /**\n     * Creates a model response stream\n     */\n    stream(body, options) {\n        return ResponseStream.createResponse(this._client, body, options);\n    }\n    /**\n     * Cancels a model response with the given ID. Only responses created with the\n     * `background` parameter set to `true` can be cancelled.\n     * [Learn more](https://platform.openai.com/docs/guides/background).\n     *\n     * @example\n     * ```ts\n     * await client.responses.cancel(\n     *   'resp_677efb5139a88190b512bc3fef8e535d',\n     * );\n     * ```\n     */\n    cancel(responseId, options) {\n        return this._client.post(`/responses/${responseId}/cancel`, {\n            ...options,\n            headers: { Accept: '*/*', ...options?.headers },\n        });\n    }\n}\nexport class ResponseItemsPage extends CursorPage {\n}\nResponses.InputItems = InputItems;\n//# sourceMappingURL=responses.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as Core from \"../../core.mjs\";\nexport class Parts extends APIResource {\n    /**\n     * Adds a\n     * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an\n     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.\n     * A Part represents a chunk of bytes from the file you are trying to upload.\n     *\n     * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload\n     * maximum of 8 GB.\n     *\n     * It is possible to add multiple Parts in parallel. You can decide the intended\n     * order of the Parts when you\n     * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).\n     */\n    create(uploadId, body, options) {\n        return this._client.post(`/uploads/${uploadId}/parts`, Core.multipartFormRequestOptions({ body, ...options }));\n    }\n}\n//# sourceMappingURL=parts.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as PartsAPI from \"./parts.mjs\";\nimport { Parts } from \"./parts.mjs\";\nexport class Uploads extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.parts = new PartsAPI.Parts(this._client);\n    }\n    /**\n     * Creates an intermediate\n     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object\n     * that you can add\n     * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.\n     * Currently, an Upload can accept at most 8 GB in total and expires after an hour\n     * after you create it.\n     *\n     * Once you complete the Upload, we will create a\n     * [File](https://platform.openai.com/docs/api-reference/files/object) object that\n     * contains all the parts you uploaded. This File is usable in the rest of our\n     * platform as a regular File object.\n     *\n     * For certain `purpose` values, the correct `mime_type` must be specified. Please\n     * refer to documentation for the\n     * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).\n     *\n     * For guidance on the proper filename extensions for each purpose, please follow\n     * the documentation on\n     * [creating a File](https://platform.openai.com/docs/api-reference/files/create).\n     */\n    create(body, options) {\n        return this._client.post('/uploads', { body, ...options });\n    }\n    /**\n     * Cancels the Upload. No Parts may be added after an Upload is cancelled.\n     */\n    cancel(uploadId, options) {\n        return this._client.post(`/uploads/${uploadId}/cancel`, options);\n    }\n    /**\n     * Completes the\n     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).\n     *\n     * Within the returned Upload object, there is a nested\n     * [File](https://platform.openai.com/docs/api-reference/files/object) object that\n     * is ready to use in the rest of the platform.\n     *\n     * You can specify the order of the Parts by passing in an ordered list of the Part\n     * IDs.\n     *\n     * The number of bytes uploaded upon completion must match the number of bytes\n     * initially specified when creating the Upload object. No Parts may be added after\n     * an Upload is completed.\n     */\n    complete(uploadId, body, options) {\n        return this._client.post(`/uploads/${uploadId}/complete`, { body, ...options });\n    }\n}\nUploads.Parts = Parts;\n//# sourceMappingURL=uploads.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { isRequestOptions } from \"../../core.mjs\";\nimport { sleep } from \"../../core.mjs\";\nimport { allSettledWithThrow } from \"../../lib/Util.mjs\";\nimport { VectorStoreFilesPage } from \"./files.mjs\";\nexport class FileBatches extends APIResource {\n    /**\n     * Create a vector store file batch.\n     */\n    create(vectorStoreId, body, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves a vector store file batch.\n     */\n    retrieve(vectorStoreId, batchId, options) {\n        return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Cancel a vector store file batch. This attempts to cancel the processing of\n     * files in this batch as soon as possible.\n     */\n    cancel(vectorStoreId, batchId, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Create a vector store batch and poll until all files have been processed.\n     */\n    async createAndPoll(vectorStoreId, body, options) {\n        const batch = await this.create(vectorStoreId, body);\n        return await this.poll(vectorStoreId, batch.id, options);\n    }\n    listFiles(vectorStoreId, batchId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.listFiles(vectorStoreId, batchId, {}, query);\n        }\n        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`, VectorStoreFilesPage, { query, ...options, headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers } });\n    }\n    /**\n     * Wait for the given file batch to be processed.\n     *\n     * Note: this will return even if one of the files failed to process, you need to\n     * check batch.file_counts.failed_count to handle this case.\n     */\n    async poll(vectorStoreId, batchId, options) {\n        const headers = { ...options?.headers, 'X-Stainless-Poll-Helper': 'true' };\n        if (options?.pollIntervalMs) {\n            headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();\n        }\n        while (true) {\n            const { data: batch, response } = await this.retrieve(vectorStoreId, batchId, {\n                ...options,\n                headers,\n            }).withResponse();\n            switch (batch.status) {\n                case 'in_progress':\n                    let sleepInterval = 5000;\n                    if (options?.pollIntervalMs) {\n                        sleepInterval = options.pollIntervalMs;\n                    }\n                    else {\n                        const headerInterval = response.headers.get('openai-poll-after-ms');\n                        if (headerInterval) {\n                            const headerIntervalMs = parseInt(headerInterval);\n                            if (!isNaN(headerIntervalMs)) {\n                                sleepInterval = headerIntervalMs;\n                            }\n                        }\n                    }\n                    await sleep(sleepInterval);\n                    break;\n                case 'failed':\n                case 'cancelled':\n                case 'completed':\n                    return batch;\n            }\n        }\n    }\n    /**\n     * Uploads the given files concurrently and then creates a vector store file batch.\n     *\n     * The concurrency limit is configurable using the `maxConcurrency` parameter.\n     */\n    async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {\n        if (files == null || files.length == 0) {\n            throw new Error(`No \\`files\\` provided to process. If you've already uploaded files you should use \\`.createAndPoll()\\` instead`);\n        }\n        const configuredConcurrency = options?.maxConcurrency ?? 5;\n        // We cap the number of workers at the number of files (so we don't start any unnecessary workers)\n        const concurrencyLimit = Math.min(configuredConcurrency, files.length);\n        const client = this._client;\n        const fileIterator = files.values();\n        const allFileIds = [...fileIds];\n        // This code is based on this design. The libraries don't accommodate our environment limits.\n        // https://stackoverflow.com/questions/40639432/what-is-the-best-way-to-limit-concurrency-when-using-es6s-promise-all\n        async function processFiles(iterator) {\n            for (let item of iterator) {\n                const fileObj = await client.files.create({ file: item, purpose: 'assistants' }, options);\n                allFileIds.push(fileObj.id);\n            }\n        }\n        // Start workers to process results\n        const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);\n        // Wait for all processing to complete.\n        await allSettledWithThrow(workers);\n        return await this.createAndPoll(vectorStoreId, {\n            file_ids: allFileIds,\n        });\n    }\n}\nexport { VectorStoreFilesPage };\n//# sourceMappingURL=file-batches.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { sleep, isRequestOptions } from \"../../core.mjs\";\nimport { CursorPage, Page } from \"../../pagination.mjs\";\nexport class Files extends APIResource {\n    /**\n     * Create a vector store file by attaching a\n     * [File](https://platform.openai.com/docs/api-reference/files) to a\n     * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).\n     */\n    create(vectorStoreId, body, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}/files`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves a vector store file.\n     */\n    retrieve(vectorStoreId, fileId, options) {\n        return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Update attributes on a vector store file.\n     */\n    update(vectorStoreId, fileId, body, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}/files/${fileId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(vectorStoreId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(vectorStoreId, {}, query);\n        }\n        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, VectorStoreFilesPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Delete a vector store file. This will remove the file from the vector store but\n     * the file itself will not be deleted. To delete the file, use the\n     * [delete file](https://platform.openai.com/docs/api-reference/files/delete)\n     * endpoint.\n     */\n    del(vectorStoreId, fileId, options) {\n        return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Attach a file to the given vector store and wait for it to be processed.\n     */\n    async createAndPoll(vectorStoreId, body, options) {\n        const file = await this.create(vectorStoreId, body, options);\n        return await this.poll(vectorStoreId, file.id, options);\n    }\n    /**\n     * Wait for the vector store file to finish processing.\n     *\n     * Note: this will return even if the file failed to process, you need to check\n     * file.last_error and file.status to handle these cases\n     */\n    async poll(vectorStoreId, fileId, options) {\n        const headers = { ...options?.headers, 'X-Stainless-Poll-Helper': 'true' };\n        if (options?.pollIntervalMs) {\n            headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();\n        }\n        while (true) {\n            const fileResponse = await this.retrieve(vectorStoreId, fileId, {\n                ...options,\n                headers,\n            }).withResponse();\n            const file = fileResponse.data;\n            switch (file.status) {\n                case 'in_progress':\n                    let sleepInterval = 5000;\n                    if (options?.pollIntervalMs) {\n                        sleepInterval = options.pollIntervalMs;\n                    }\n                    else {\n                        const headerInterval = fileResponse.response.headers.get('openai-poll-after-ms');\n                        if (headerInterval) {\n                            const headerIntervalMs = parseInt(headerInterval);\n                            if (!isNaN(headerIntervalMs)) {\n                                sleepInterval = headerIntervalMs;\n                            }\n                        }\n                    }\n                    await sleep(sleepInterval);\n                    break;\n                case 'failed':\n                case 'completed':\n                    return file;\n            }\n        }\n    }\n    /**\n     * Upload a file to the `files` API and then attach it to the given vector store.\n     *\n     * Note the file will be asynchronously processed (you can use the alternative\n     * polling helper method to wait for processing to complete).\n     */\n    async upload(vectorStoreId, file, options) {\n        const fileInfo = await this._client.files.create({ file: file, purpose: 'assistants' }, options);\n        return this.create(vectorStoreId, { file_id: fileInfo.id }, options);\n    }\n    /**\n     * Add a file to a vector store and poll until processing is complete.\n     */\n    async uploadAndPoll(vectorStoreId, file, options) {\n        const fileInfo = await this.upload(vectorStoreId, file, options);\n        return await this.poll(vectorStoreId, fileInfo.id, options);\n    }\n    /**\n     * Retrieve the parsed contents of a vector store file.\n     */\n    content(vectorStoreId, fileId, options) {\n        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files/${fileId}/content`, FileContentResponsesPage, { ...options, headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers } });\n    }\n}\nexport class VectorStoreFilesPage extends CursorPage {\n}\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class FileContentResponsesPage extends Page {\n}\nFiles.VectorStoreFilesPage = VectorStoreFilesPage;\nFiles.FileContentResponsesPage = FileContentResponsesPage;\n//# sourceMappingURL=files.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { isRequestOptions } from \"../../core.mjs\";\nimport * as FileBatchesAPI from \"./file-batches.mjs\";\nimport { FileBatches, } from \"./file-batches.mjs\";\nimport * as FilesAPI from \"./files.mjs\";\nimport { FileContentResponsesPage, Files, VectorStoreFilesPage, } from \"./files.mjs\";\nimport { CursorPage, Page } from \"../../pagination.mjs\";\nexport class VectorStores extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.files = new FilesAPI.Files(this._client);\n        this.fileBatches = new FileBatchesAPI.FileBatches(this._client);\n    }\n    /**\n     * Create a vector store.\n     */\n    create(body, options) {\n        return this._client.post('/vector_stores', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves a vector store.\n     */\n    retrieve(vectorStoreId, options) {\n        return this._client.get(`/vector_stores/${vectorStoreId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies a vector store.\n     */\n    update(vectorStoreId, body, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/vector_stores', VectorStoresPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Delete a vector store.\n     */\n    del(vectorStoreId, options) {\n        return this._client.delete(`/vector_stores/${vectorStoreId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Search a vector store for relevant chunks based on a query and file attributes\n     * filter.\n     */\n    search(vectorStoreId, body, options) {\n        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/search`, VectorStoreSearchResponsesPage, {\n            body,\n            method: 'post',\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\nexport class VectorStoresPage extends CursorPage {\n}\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class VectorStoreSearchResponsesPage extends Page {\n}\nVectorStores.VectorStoresPage = VectorStoresPage;\nVectorStores.VectorStoreSearchResponsesPage = VectorStoreSearchResponsesPage;\nVectorStores.Files = Files;\nVectorStores.VectorStoreFilesPage = VectorStoreFilesPage;\nVectorStores.FileContentResponsesPage = FileContentResponsesPage;\nVectorStores.FileBatches = FileBatches;\n//# sourceMappingURL=vector-stores.mjs.map","import { ReadableStream } from \"./_shims/index.mjs\";\nimport { OpenAIError } from \"./error.mjs\";\nimport { findDoubleNewlineIndex, LineDecoder } from \"./internal/decoders/line.mjs\";\nimport { ReadableStreamToAsyncIterable } from \"./internal/stream-utils.mjs\";\nimport { createResponseHeaders } from \"./core.mjs\";\nimport { APIError } from \"./error.mjs\";\nexport class Stream {\n    constructor(iterator, controller) {\n        this.iterator = iterator;\n        this.controller = controller;\n    }\n    static fromSSEResponse(response, controller) {\n        let consumed = false;\n        async function* iterator() {\n            if (consumed) {\n                throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n            }\n            consumed = true;\n            let done = false;\n            try {\n                for await (const sse of _iterSSEMessages(response, controller)) {\n                    if (done)\n                        continue;\n                    if (sse.data.startsWith('[DONE]')) {\n                        done = true;\n                        continue;\n                    }\n                    if (sse.event === null ||\n                        sse.event.startsWith('response.') ||\n                        sse.event.startsWith('transcript.')) {\n                        let data;\n                        try {\n                            data = JSON.parse(sse.data);\n                        }\n                        catch (e) {\n                            console.error(`Could not parse message into JSON:`, sse.data);\n                            console.error(`From chunk:`, sse.raw);\n                            throw e;\n                        }\n                        if (data && data.error) {\n                            throw new APIError(undefined, data.error, undefined, createResponseHeaders(response.headers));\n                        }\n                        yield data;\n                    }\n                    else {\n                        let data;\n                        try {\n                            data = JSON.parse(sse.data);\n                        }\n                        catch (e) {\n                            console.error(`Could not parse message into JSON:`, sse.data);\n                            console.error(`From chunk:`, sse.raw);\n                            throw e;\n                        }\n                        // TODO: Is this where the error should be thrown?\n                        if (sse.event == 'error') {\n                            throw new APIError(undefined, data.error, data.message, undefined);\n                        }\n                        yield { event: sse.event, data: data };\n                    }\n                }\n                done = true;\n            }\n            catch (e) {\n                // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                if (e instanceof Error && e.name === 'AbortError')\n                    return;\n                throw e;\n            }\n            finally {\n                // If the user `break`s, abort the ongoing request.\n                if (!done)\n                    controller.abort();\n            }\n        }\n        return new Stream(iterator, controller);\n    }\n    /**\n     * Generates a Stream from a newline-separated ReadableStream\n     * where each item is a JSON value.\n     */\n    static fromReadableStream(readableStream, controller) {\n        let consumed = false;\n        async function* iterLines() {\n            const lineDecoder = new LineDecoder();\n            const iter = ReadableStreamToAsyncIterable(readableStream);\n            for await (const chunk of iter) {\n                for (const line of lineDecoder.decode(chunk)) {\n                    yield line;\n                }\n            }\n            for (const line of lineDecoder.flush()) {\n                yield line;\n            }\n        }\n        async function* iterator() {\n            if (consumed) {\n                throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n            }\n            consumed = true;\n            let done = false;\n            try {\n                for await (const line of iterLines()) {\n                    if (done)\n                        continue;\n                    if (line)\n                        yield JSON.parse(line);\n                }\n                done = true;\n            }\n            catch (e) {\n                // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                if (e instanceof Error && e.name === 'AbortError')\n                    return;\n                throw e;\n            }\n            finally {\n                // If the user `break`s, abort the ongoing request.\n                if (!done)\n                    controller.abort();\n            }\n        }\n        return new Stream(iterator, controller);\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterator();\n    }\n    /**\n     * Splits the stream into two streams which can be\n     * independently read from at different speeds.\n     */\n    tee() {\n        const left = [];\n        const right = [];\n        const iterator = this.iterator();\n        const teeIterator = (queue) => {\n            return {\n                next: () => {\n                    if (queue.length === 0) {\n                        const result = iterator.next();\n                        left.push(result);\n                        right.push(result);\n                    }\n                    return queue.shift();\n                },\n            };\n        };\n        return [\n            new Stream(() => teeIterator(left), this.controller),\n            new Stream(() => teeIterator(right), this.controller),\n        ];\n    }\n    /**\n     * Converts this stream to a newline-separated ReadableStream of\n     * JSON stringified values in the stream\n     * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n     */\n    toReadableStream() {\n        const self = this;\n        let iter;\n        const encoder = new TextEncoder();\n        return new ReadableStream({\n            async start() {\n                iter = self[Symbol.asyncIterator]();\n            },\n            async pull(ctrl) {\n                try {\n                    const { value, done } = await iter.next();\n                    if (done)\n                        return ctrl.close();\n                    const bytes = encoder.encode(JSON.stringify(value) + '\\n');\n                    ctrl.enqueue(bytes);\n                }\n                catch (err) {\n                    ctrl.error(err);\n                }\n            },\n            async cancel() {\n                await iter.return?.();\n            },\n        });\n    }\n}\nexport async function* _iterSSEMessages(response, controller) {\n    if (!response.body) {\n        controller.abort();\n        throw new OpenAIError(`Attempted to iterate over a response with no body`);\n    }\n    const sseDecoder = new SSEDecoder();\n    const lineDecoder = new LineDecoder();\n    const iter = ReadableStreamToAsyncIterable(response.body);\n    for await (const sseChunk of iterSSEChunks(iter)) {\n        for (const line of lineDecoder.decode(sseChunk)) {\n            const sse = sseDecoder.decode(line);\n            if (sse)\n                yield sse;\n        }\n    }\n    for (const line of lineDecoder.flush()) {\n        const sse = sseDecoder.decode(line);\n        if (sse)\n            yield sse;\n    }\n}\n/**\n * Given an async iterable iterator, iterates over it and yields full\n * SSE chunks, i.e. yields when a double new-line is encountered.\n */\nasync function* iterSSEChunks(iterator) {\n    let data = new Uint8Array();\n    for await (const chunk of iterator) {\n        if (chunk == null) {\n            continue;\n        }\n        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n            : typeof chunk === 'string' ? new TextEncoder().encode(chunk)\n                : chunk;\n        let newData = new Uint8Array(data.length + binaryChunk.length);\n        newData.set(data);\n        newData.set(binaryChunk, data.length);\n        data = newData;\n        let patternIndex;\n        while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {\n            yield data.slice(0, patternIndex);\n            data = data.slice(patternIndex);\n        }\n    }\n    if (data.length > 0) {\n        yield data;\n    }\n}\nclass SSEDecoder {\n    constructor() {\n        this.event = null;\n        this.data = [];\n        this.chunks = [];\n    }\n    decode(line) {\n        if (line.endsWith('\\r')) {\n            line = line.substring(0, line.length - 1);\n        }\n        if (!line) {\n            // empty line and we didn't previously encounter any messages\n            if (!this.event && !this.data.length)\n                return null;\n            const sse = {\n                event: this.event,\n                data: this.data.join('\\n'),\n                raw: this.chunks,\n            };\n            this.event = null;\n            this.data = [];\n            this.chunks = [];\n            return sse;\n        }\n        this.chunks.push(line);\n        if (line.startsWith(':')) {\n            return null;\n        }\n        let [fieldname, _, value] = partition(line, ':');\n        if (value.startsWith(' ')) {\n            value = value.substring(1);\n        }\n        if (fieldname === 'event') {\n            this.event = value;\n        }\n        else if (fieldname === 'data') {\n            this.data.push(value);\n        }\n        return null;\n    }\n}\nfunction partition(str, delimiter) {\n    const index = str.indexOf(delimiter);\n    if (index !== -1) {\n        return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n    }\n    return [str, '', ''];\n}\n//# sourceMappingURL=streaming.mjs.map","import { FormData, File, getMultipartRequestOptions, isFsReadStream, } from \"./_shims/index.mjs\";\nexport { fileFromPath } from \"./_shims/index.mjs\";\nexport const isResponseLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.url === 'string' &&\n    typeof value.blob === 'function';\nexport const isFileLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.name === 'string' &&\n    typeof value.lastModified === 'number' &&\n    isBlobLike(value);\n/**\n * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\n * adds the arrayBuffer() method type because it is available and used at runtime\n */\nexport const isBlobLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.size === 'number' &&\n    typeof value.type === 'string' &&\n    typeof value.text === 'function' &&\n    typeof value.slice === 'function' &&\n    typeof value.arrayBuffer === 'function';\nexport const isUploadable = (value) => {\n    return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);\n};\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */\nexport async function toFile(value, name, options) {\n    // If it's a promise, resolve it.\n    value = await value;\n    // If we've been given a `File` we don't need to do anything\n    if (isFileLike(value)) {\n        return value;\n    }\n    if (isResponseLike(value)) {\n        const blob = await value.blob();\n        name || (name = new URL(value.url).pathname.split(/[\\\\/]/).pop() ?? 'unknown_file');\n        // we need to convert the `Blob` into an array buffer because the `Blob` class\n        // that `node-fetch` defines is incompatible with the web standard which results\n        // in `new File` interpreting it as a string instead of binary data.\n        const data = isBlobLike(blob) ? [(await blob.arrayBuffer())] : [blob];\n        return new File(data, name, options);\n    }\n    const bits = await getBytes(value);\n    name || (name = getName(value) ?? 'unknown_file');\n    if (!options?.type) {\n        const type = bits[0]?.type;\n        if (typeof type === 'string') {\n            options = { ...options, type };\n        }\n    }\n    return new File(bits, name, options);\n}\nasync function getBytes(value) {\n    let parts = [];\n    if (typeof value === 'string' ||\n        ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\n        value instanceof ArrayBuffer) {\n        parts.push(value);\n    }\n    else if (isBlobLike(value)) {\n        parts.push(await value.arrayBuffer());\n    }\n    else if (isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\n    ) {\n        for await (const chunk of value) {\n            parts.push(chunk); // TODO, consider validating?\n        }\n    }\n    else {\n        throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor\n            ?.name}; props: ${propsForError(value)}`);\n    }\n    return parts;\n}\nfunction propsForError(value) {\n    const props = Object.getOwnPropertyNames(value);\n    return `[${props.map((p) => `\"${p}\"`).join(', ')}]`;\n}\nfunction getName(value) {\n    return (getStringFromMaybeBuffer(value.name) ||\n        getStringFromMaybeBuffer(value.filename) ||\n        // For fs.ReadStream\n        getStringFromMaybeBuffer(value.path)?.split(/[\\\\/]/).pop());\n}\nconst getStringFromMaybeBuffer = (x) => {\n    if (typeof x === 'string')\n        return x;\n    if (typeof Buffer !== 'undefined' && x instanceof Buffer)\n        return String(x);\n    return undefined;\n};\nconst isAsyncIterableIterator = (value) => value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\nexport const isMultipartBody = (body) => body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';\n/**\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\n * Otherwise returns the request as is.\n */\nexport const maybeMultipartFormRequestOptions = async (opts) => {\n    if (!hasUploadableValue(opts.body))\n        return opts;\n    const form = await createForm(opts.body);\n    return getMultipartRequestOptions(form, opts);\n};\nexport const multipartFormRequestOptions = async (opts) => {\n    const form = await createForm(opts.body);\n    return getMultipartRequestOptions(form, opts);\n};\nexport const createForm = async (body) => {\n    const form = new FormData();\n    await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\n    return form;\n};\nconst hasUploadableValue = (value) => {\n    if (isUploadable(value))\n        return true;\n    if (Array.isArray(value))\n        return value.some(hasUploadableValue);\n    if (value && typeof value === 'object') {\n        for (const k in value) {\n            if (hasUploadableValue(value[k]))\n                return true;\n        }\n    }\n    return false;\n};\nconst addFormValue = async (form, key, value) => {\n    if (value === undefined)\n        return;\n    if (value == null) {\n        throw new TypeError(`Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`);\n    }\n    // TODO: make nested formats configurable\n    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        form.append(key, String(value));\n    }\n    else if (isUploadable(value)) {\n        const file = await toFile(value);\n        form.append(key, file);\n    }\n    else if (Array.isArray(value)) {\n        await Promise.all(value.map((entry) => addFormValue(form, key + '[]', entry)));\n    }\n    else if (typeof value === 'object') {\n        await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));\n    }\n    else {\n        throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);\n    }\n};\n//# sourceMappingURL=uploads.mjs.map","export const VERSION = '4.104.0'; // x-release-please-version\n//# sourceMappingURL=version.mjs.map","let crypto;\ncrypto = globalThis.crypto; // web browsers\n/**\n * Creates an array of length `size` of random bytes\n * @param size\n * @returns Array of random ints (0 to 255)\n */\nasync function getRandomValues(size) {\n    return (await crypto).getRandomValues(new Uint8Array(size));\n}\n/** Generate cryptographically strong random string\n * @param size The desired length of the string\n * @returns The random string\n */\nasync function random(size) {\n    const mask = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~\";\n    const evenDistCutoff = Math.pow(2, 8) - Math.pow(2, 8) % mask.length;\n    let result = \"\";\n    while (result.length < size) {\n        const randomBytes = await getRandomValues(size - result.length);\n        for (const randomByte of randomBytes) {\n            if (randomByte < evenDistCutoff) {\n                result += mask[randomByte % mask.length];\n            }\n        }\n    }\n    return result;\n}\n/** Generate a PKCE challenge verifier\n * @param length Length of the verifier\n * @returns A random verifier `length` characters long\n */\nasync function generateVerifier(length) {\n    return await random(length);\n}\n/** Generate a PKCE code challenge from a code verifier\n * @param code_verifier\n * @returns The base64 url encoded code challenge\n */\nexport async function generateChallenge(code_verifier) {\n    const buffer = await (await crypto).subtle.digest(\"SHA-256\", new TextEncoder().encode(code_verifier));\n    // Generate base64url string\n    // btoa is deprecated in Node.js but is used here for web browser compatibility\n    // (which has no good replacement yet, see also https://github.com/whatwg/html/issues/6811)\n    return btoa(String.fromCharCode(...new Uint8Array(buffer)))\n        .replace(/\\//g, '_')\n        .replace(/\\+/g, '-')\n        .replace(/=/g, '');\n}\n/** Generate a PKCE challenge pair\n * @param length Length of the verifer (between 43-128). Defaults to 43.\n * @returns PKCE challenge pair\n */\nexport default async function pkceChallenge(length) {\n    if (!length)\n        length = 43;\n    if (length < 43 || length > 128) {\n        throw `Expected a length between 43 and 128. Received ${length}.`;\n    }\n    const verifier = await generateVerifier(length);\n    const challenge = await generateChallenge(verifier);\n    return {\n        code_verifier: verifier,\n        code_challenge: challenge,\n    };\n}\n/** Verify that a code_verifier produces the expected code challenge\n * @param code_verifier\n * @param expectedChallenge The code challenge to verify\n * @returns True if challenges are equal. False otherwise.\n */\nexport async function verifyChallenge(code_verifier, expectedChallenge) {\n    const actualChallenge = await generateChallenge(code_verifier);\n    return actualChallenge === expectedChallenge;\n}\n","/**\n * WordPress dependencies\n */\nimport { useDispatch } from \"@wordpress/data\";\nimport { PluginSidebar, PluginSidebarMoreMenuItem } from \"@wordpress/editor\";\nimport { useEffect } from \"@wordpress/element\";\nimport { __ } from \"@wordpress/i18n\";\nimport { store as interfaceStore } from \"@wordpress/interface\";\n\n/**\n * Internal dependencies\n */\nimport useChat from \"../hooks/useChat\";\nimport ActionButtons from \"./chat/ActionButtons\";\nimport ChatInput from \"./chat/ChatInput\";\nimport ChatMessages from \"./chat/ChatMessages\";\nimport WelcomeScreen from \"./chat/WelcomeScreen\";\nimport SidebarHeader from \"./sidebar/SidebarHeader\";\nimport AILogo from \"./ui/AILogo\";\n\nconst SIDEBAR_NAME = \"nfd-editor-chat\";\nconst SIDEBAR_SCOPE = \"core\";\n\nconst ChatEditor = () => {\n\tconst { enableComplementaryArea } = useDispatch(interfaceStore);\n\tconst {\n\t\tmessages,\n\t\tisLoading,\n\t\terror,\n\t\tstatus,\n\t\tisSaving,\n\t\tactiveToolCall,\n\t\thandleSendMessage,\n\t\thandleNewChat,\n\t\thandleAcceptChanges,\n\t\thandleDeclineChanges,\n\t\thandleStopRequest,\n\t} = useChat();\n\n\tuseEffect(() => {\n\t\tenableComplementaryArea(SIDEBAR_SCOPE, SIDEBAR_NAME);\n\t}, [enableComplementaryArea]);\n\n\t// Check if there are any messages with pending actions and count them\n\tconst pendingActionsCount = messages.filter((msg) => msg.hasActions).length;\n\tconst hasPendingActions = pendingActionsCount > 0;\n\n\t// Disable new chat button when there are no messages (brand new chat)\n\tconst isNewChatDisabled = messages.length === 0;\n\n\treturn (\n\t\t<>\n\t\t\t<PluginSidebarMoreMenuItem\n\t\t\t\tscope={SIDEBAR_SCOPE}\n\t\t\t\ttarget={SIDEBAR_NAME}\n\t\t\t\ticon={<AILogo width={24} height={24} />}\n\t\t\t>\n\t\t\t\t{__(\"AI Chat Editor\", \"wp-module-editor-chat\")}\n\t\t\t</PluginSidebarMoreMenuItem>\n\t\t\t<PluginSidebar\n\t\t\t\tscope={SIDEBAR_SCOPE}\n\t\t\t\tidentifier={SIDEBAR_NAME}\n\t\t\t\tclassName=\"nfd-editor-chat-sidebar\"\n\t\t\t\tcloseLabel={__(\"Close AI Chat Editor\", \"wp-module-editor-chat\")}\n\t\t\t\ticon={<AILogo width={24} height={24} />}\n\t\t\t\theaderClassName=\"nfd-editor-chat-sidebar__header\"\n\t\t\t\tpanelClassName=\"nfd-editor-chat-sidebar__panel\"\n\t\t\t\theader={<SidebarHeader onNewChat={handleNewChat} isNewChatDisabled={isNewChatDisabled} />}\n\t\t\t>\n\t\t\t\t<div className=\"nfd-editor-chat-sidebar__content\">\n\t\t\t\t\t{messages.length === 0 ? (\n\t\t\t\t\t\t<WelcomeScreen onSendMessage={handleSendMessage} />\n\t\t\t\t\t) : (\n\t\t\t\t\t\t<ChatMessages\n\t\t\t\t\t\t\tmessages={messages}\n\t\t\t\t\t\t\tisLoading={isLoading}\n\t\t\t\t\t\t\terror={error}\n\t\t\t\t\t\t\tstatus={status}\n\t\t\t\t\t\t\tactiveToolCall={activeToolCall}\n\t\t\t\t\t\t/>\n\t\t\t\t\t)}\n\t\t\t\t\t{hasPendingActions && (\n\t\t\t\t\t\t<ActionButtons\n\t\t\t\t\t\t\tpendingCount={pendingActionsCount}\n\t\t\t\t\t\t\tonAccept={handleAcceptChanges}\n\t\t\t\t\t\t\tonDecline={handleDeclineChanges}\n\t\t\t\t\t\t\tisSaving={isSaving}\n\t\t\t\t\t\t/>\n\t\t\t\t\t)}\n\t\t\t\t\t<ChatInput\n\t\t\t\t\t\tonSendMessage={handleSendMessage}\n\t\t\t\t\t\tonStopRequest={handleStopRequest}\n\t\t\t\t\t\tdisabled={isLoading}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t</PluginSidebar>\n\t\t</>\n\t);\n};\n\nexport default ChatEditor;\n","/**\n * WordPress dependencies\n */\nimport { Button } from \"@wordpress/components\";\n\n/**\n * External dependencies\n */\nimport { Check, X } from \"lucide-react\";\n\n/**\n * ActionButtons Component\n *\n * Displays accept/decline buttons above the input when actions have been executed.\n *\n * @param {Object}   props              - The component props.\n * @param {number}   props.pendingCount - Number of pending changes.\n * @param {Function} props.onAccept     - Callback when accept is clicked.\n * @param {Function} props.onDecline    - Callback when decline is clicked.\n * @param {boolean}  props.isSaving     - Whether the post is currently saving.\n * @return {JSX.Element} The ActionButtons component.\n */\nconst ActionButtons = ({ pendingCount, onAccept, onDecline, isSaving }) => {\n\tconst changeText = pendingCount === 1 ? \"change\" : \"changes\";\n\n\treturn (\n\t\t<div className=\"nfd-editor-chat-action-buttons\">\n\t\t\t<div className=\"nfd-editor-chat-action-buttons__indicator\">\n\t\t\t\t<span className=\"nfd-editor-chat-action-buttons__indicator-dot\" />\n\t\t\t\t{pendingCount} pending {changeText}\n\t\t\t</div>\n\t\t\t<div className=\"nfd-editor-chat-action-buttons__buttons\">\n\t\t\t\t<Button\n\t\t\t\t\tclassName=\"nfd-editor-chat-action-buttons__button nfd-editor-chat-action-buttons__button--decline\"\n\t\t\t\t\tonClick={onDecline}\n\t\t\t\t\tdisabled={isSaving}\n\t\t\t\t>\n\t\t\t\t\t<X size={12} />\n\t\t\t\t\tRevert All\n\t\t\t\t</Button>\n\t\t\t\t<Button\n\t\t\t\t\tclassName=\"nfd-editor-chat-action-buttons__button nfd-editor-chat-action-buttons__button--accept\"\n\t\t\t\t\tonClick={onAccept}\n\t\t\t\t\tdisabled={isSaving}\n\t\t\t\t>\n\t\t\t\t\t<Check size={14} />\n\t\t\t\t\tKeep Changes\n\t\t\t\t</Button>\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n\nexport default ActionButtons;\n","/**\n * WordPress dependencies\n */\nimport { Button } from \"@wordpress/components\";\nimport { useDispatch } from \"@wordpress/data\";\nimport { useEffect, useRef, useState } from \"@wordpress/element\";\nimport { __ } from \"@wordpress/i18n\";\n\n/**\n * External dependencies\n */\nimport { ArrowUp, CircleStop } from \"lucide-react\";\n\n/**\n * Internal dependencies\n */\nimport useSelectedBlock from \"../../hooks/useSelectedBlock\";\nimport ContextTag from \"../ui/ContextTag\";\n\n/**\n * ChatInput Component\n *\n * @param {Object}   props               - The component props.\n * @param {Function} props.onSendMessage - The function to call when the message is sent.\n * @param {Function} props.onStopRequest - The function to call when the stop button is clicked.\n * @param {boolean}  props.disabled      - Whether the input is disabled.\n * @return {JSX.Element} The ChatInput component.\n */\nconst ChatInput = ({ onSendMessage, onStopRequest, disabled = false }) => {\n\tconst [message, setMessage] = useState(\"\");\n\tconst textareaRef = useRef(null);\n\tconst selectedBlock = useSelectedBlock();\n\tconst { clearSelectedBlock } = useDispatch(\"core/block-editor\");\n\n\t// Auto-resize textarea as user types\n\tuseEffect(() => {\n\t\tif (textareaRef.current) {\n\t\t\ttextareaRef.current.style.height = \"auto\";\n\t\t\tconst newHeight = Math.min(textareaRef.current.scrollHeight, 200);\n\t\t\ttextareaRef.current.style.height = `${newHeight}px`;\n\t\t}\n\t}, [message]);\n\n\t// Focus textarea when it becomes enabled again (after AI response)\n\tuseEffect(() => {\n\t\tif (!disabled && textareaRef.current) {\n\t\t\tsetTimeout(() => {\n\t\t\t\ttextareaRef.current.focus();\n\t\t\t}, 100);\n\t\t}\n\t}, [disabled]);\n\n\tconst handleSubmit = () => {\n\t\tif (message.trim() && !disabled) {\n\t\t\tonSendMessage(message);\n\t\t\tsetMessage(\"\");\n\t\t\t// Reset textarea height and maintain focus\n\t\t\tif (textareaRef.current) {\n\t\t\t\ttextareaRef.current.style.height = \"auto\";\n\t\t\t\ttextareaRef.current.focus();\n\t\t\t}\n\t\t}\n\t};\n\n\tconst handleKeyDown = (e) => {\n\t\tif (e.key === \"Enter\" && !e.shiftKey) {\n\t\t\te.preventDefault();\n\t\t\thandleSubmit();\n\t\t}\n\t};\n\n\treturn (\n\t\t<div className=\"nfd-editor-chat-input\">\n\t\t\t<div className=\"nfd-editor-chat-input__container\">\n\t\t\t\t<textarea\n\t\t\t\t\tname=\"nfd-editor-chat-input\"\n\t\t\t\t\tref={textareaRef}\n\t\t\t\t\tvalue={message}\n\t\t\t\t\tonChange={(e) => setMessage(e.target.value)}\n\t\t\t\t\tonKeyDown={handleKeyDown}\n\t\t\t\t\tplaceholder={__(\"How can I help you today?\", \"wp-module-editor-chat\")}\n\t\t\t\t\tclassName=\"nfd-editor-chat-input__textarea\"\n\t\t\t\t\trows={1}\n\t\t\t\t\tdisabled={disabled}\n\t\t\t\t/>\n\t\t\t\t<div className=\"nfd-editor-chat-input__actions\">\n\t\t\t\t\t{selectedBlock && (\n\t\t\t\t\t\t<ContextTag\n\t\t\t\t\t\t\tblock={selectedBlock}\n\t\t\t\t\t\t\tonRemove={(clientId) => {\n\t\t\t\t\t\t\t\tclearSelectedBlock(clientId);\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t/>\n\t\t\t\t\t)}\n\t\t\t\t\t{disabled ? (\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\ticon={<CircleStop width={16} height={16} />}\n\t\t\t\t\t\t\tlabel={__(\"Stop generating\", \"wp-module-editor-chat\")}\n\t\t\t\t\t\t\tonClick={onStopRequest}\n\t\t\t\t\t\t\tclassName=\"nfd-editor-chat-input__stop\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t) : (\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\ticon={<ArrowUp width={16} height={16} />}\n\t\t\t\t\t\t\tlabel={__(\"Send message\", \"wp-module-editor-chat\")}\n\t\t\t\t\t\t\tonClick={handleSubmit}\n\t\t\t\t\t\t\tclassName=\"nfd-editor-chat-input__submit\"\n\t\t\t\t\t\t\tdisabled={!message.trim()}\n\t\t\t\t\t\t/>\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div className=\"nfd-editor-chat-input__disclaimer\">\n\t\t\t\t{__(\"AI-generated content is not guaranteed for accuracy.\", \"wp-module-editor-chat\")}\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n\nexport default ChatInput;\n","/**\n * WordPress dependencies\n */\nimport { useMemo } from \"@wordpress/element\";\n\n/**\n * Internal dependencies\n */\nimport { containsHtml, sanitizeHtml } from \"../../utils/sanitizeHtml\";\nimport { containsMarkdown, parseMarkdown } from \"../../utils/markdownParser\";\n\n/**\n * ChatMessage Component\n *\n * Displays a single message in the chat with appropriate styling and avatar.\n * Supports HTML and Markdown rendering for assistant messages.\n *\n * @param {Object} props                    - The component props.\n * @param {string} props.message            - The message content to display.\n * @param {string} [props.type=\"assistant\"] - The message type (\"user\" or \"assistant\").\n * @return {JSX.Element} The ChatMessage component.\n */\nconst ChatMessage = ({ message, type = \"assistant\" }) => {\n\tconst isUser = type === \"user\";\n\n\t// Sanitize and prepare content for rendering\n\tconst { content, isRichContent } = useMemo(() => {\n\t\tif (!message) {\n\t\t\treturn { content: \"\", isRichContent: false };\n\t\t}\n\n\t\t// For user messages, always render as plain text\n\t\tif (isUser) {\n\t\t\treturn { content: message, isRichContent: false };\n\t\t}\n\n\t\t// For AI messages, check if it contains HTML first\n\t\tif (containsHtml(message)) {\n\t\t\treturn { content: sanitizeHtml(message), isRichContent: true };\n\t\t}\n\n\t\t// Check if it contains Markdown\n\t\tif (containsMarkdown(message)) {\n\t\t\tconst parsed = parseMarkdown(message);\n\t\t\treturn { content: sanitizeHtml(parsed), isRichContent: true };\n\t\t}\n\n\t\t// Plain text messages\n\t\treturn { content: message, isRichContent: false };\n\t}, [message, isUser]);\n\n\treturn (\n\t\t<div className={`nfd-editor-chat-message nfd-editor-chat-message--${type}`}>\n\t\t\t{isRichContent ? (\n\t\t\t\t<div\n\t\t\t\t\tclassName=\"nfd-editor-chat-message__content nfd-editor-chat-message__content--rich\"\n\t\t\t\t\tdangerouslySetInnerHTML={{ __html: content }}\n\t\t\t\t/>\n\t\t\t) : (\n\t\t\t\t<div className=\"nfd-editor-chat-message__content\">{content}</div>\n\t\t\t)}\n\t\t</div>\n\t);\n};\n\nexport default ChatMessage;\n","/**\n * WordPress dependencies\n */\nimport { useEffect, useRef } from \"@wordpress/element\";\n\n/**\n * Internal dependencies\n */\nimport ErrorAlert from \"../ui/ErrorAlert\";\nimport TypingIndicator from \"../ui/TypingIndicator\";\nimport ChatMessage from \"./ChatMessage\";\n\n/**\n * ChatMessages Component\n *\n * Scrollable container for all chat messages\n * Auto-scrolls to bottom when new messages arrive\n *\n * @param {Object}  props                - The component props.\n * @param {Array}   props.messages       - The messages to display.\n * @param {boolean} props.isLoading      - Whether the AI is currently generating a response.\n * @param {string}  props.error          - Error message to display (optional).\n * @param {string}  props.status         - The current status ('received', 'generating', 'tool_call', etc.).\n * @param {Object}  props.activeToolCall - The currently executing tool call (optional).\n * @return {JSX.Element} The ChatMessages component.\n */\nconst ChatMessages = ({\n\tmessages = [],\n\tisLoading = false,\n\terror = null,\n\tstatus = null,\n\tactiveToolCall = null,\n}) => {\n\tconst messagesEndRef = useRef(null);\n\n\t// Scroll to bottom when new messages arrive or loading state changes\n\tuseEffect(() => {\n\t\tmessagesEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\n\t}, [messages, isLoading]);\n\n\treturn (\n\t\t<div className=\"nfd-editor-chat-messages\">\n\t\t\t{messages.length &&\n\t\t\t\tmessages.map((msg, index) => (\n\t\t\t\t\t<ChatMessage key={index} message={msg.content} type={msg.type} />\n\t\t\t\t))}\n\t\t\t{error && <ErrorAlert message={error} />}\n\t\t\t{isLoading && <TypingIndicator status={status} activeToolCall={activeToolCall} />}\n\t\t\t<div ref={messagesEndRef} />\n\t\t</div>\n\t);\n};\n\nexport default ChatMessages;\n","/**\n * WordPress dependencies\n */\nimport { __ } from \"@wordpress/i18n\";\n\n/**\n * External dependencies\n */\nimport { Edit3, FilePlus, Layers, Palette } from \"lucide-react\";\n\n/**\n * Internal dependencies\n */\nimport AILogo from \"../ui/AILogo\";\nimport SuggestionButton from \"../ui/SuggestionButton\";\n\n/**\n * WelcomeScreen Component\n *\n * Displays the welcome screen with AI avatar, introduction message, and suggestion tags.\n *\n * @param {Object}   props               - The component props.\n * @param {Function} props.onSendMessage - The function to call when a suggestion is clicked.\n * @return {JSX.Element} The WelcomeScreen component.\n */\nconst WelcomeScreen = ({ onSendMessage }) => {\n\tconst suggestions = [\n\t\t{\n\t\t\ticon: <Edit3 width={16} height={16} />,\n\t\t\ttext: __(\"Add a new section\", \"wp-module-editor-chat\"),\n\t\t\taction: () => onSendMessage(\"Add a new section\"),\n\t\t},\n\t\t{\n\t\t\ticon: <Palette width={16} height={16} />,\n\t\t\ttext: __(\"Update color scheme\", \"wp-module-editor-chat\"),\n\t\t\taction: () => onSendMessage(\"Update color scheme\"),\n\t\t},\n\t\t{\n\t\t\ticon: <FilePlus width={16} height={16} />,\n\t\t\ttext: __(\"Create new page\", \"wp-module-editor-chat\"),\n\t\t\taction: () => onSendMessage(\"Create new page\"),\n\t\t},\n\t\t{\n\t\t\ticon: <Layers width={16} height={16} />,\n\t\t\ttext: __(\"Edit content\", \"wp-module-editor-chat\"),\n\t\t\taction: () => onSendMessage(\"Edit content\"),\n\t\t},\n\t];\n\n\treturn (\n\t\t<div className=\"nfd-editor-chat-welcome\">\n\t\t\t<div className=\"nfd-editor-chat-welcome__content\">\n\t\t\t\t<div className=\"nfd-editor-chat-welcome__avatar\">\n\t\t\t\t\t<AILogo width={48} height={48} />\n\t\t\t\t</div>\n\t\t\t\t<div className=\"nfd-editor-chat-welcome__message\">\n\t\t\t\t\t<div className=\"nfd-editor-chat-welcome__title\">\n\t\t\t\t\t\t{__(\"Hi, I'm BLU, your AI assistant.\", \"wp-module-editor-chat\")}\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"nfd-editor-chat-welcome__subtitle\">\n\t\t\t\t\t\t{__(\"I can help you update page sections and styles,\", \"wp-module-editor-chat\")}\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"nfd-editor-chat-welcome__subtitle\">\n\t\t\t\t\t\t{__(\"add, remove, or edit existing content.\", \"wp-module-editor-chat\")}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div className=\"nfd-editor-chat-suggestions\">\n\t\t\t\t{false &&\n\t\t\t\t\tsuggestions.map((suggestion, index) => (\n\t\t\t\t\t\t<SuggestionButton\n\t\t\t\t\t\t\tkey={index}\n\t\t\t\t\t\t\ticon={suggestion.icon}\n\t\t\t\t\t\t\ttext={suggestion.text}\n\t\t\t\t\t\t\tonClick={suggestion.action}\n\t\t\t\t\t\t/>\n\t\t\t\t\t))}\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n\nexport default WelcomeScreen;\n","/**\n * WordPress dependencies\n */\nimport { Button } from \"@wordpress/components\";\nimport { __ } from \"@wordpress/i18n\";\n\n/**\n * External dependencies\n */\nimport { Plus, Sparkles } from \"lucide-react\";\n\n/**\n * SidebarHeader Component\n *\n * Displays the sidebar header with title and action buttons.\n *\n * @param {Object}   props                   Component props\n * @param {Function} props.onNewChat         Function to call when new chat is requested\n * @param {boolean}  props.isNewChatDisabled Whether the new chat button should be disabled\n * @return {JSX.Element} The SidebarHeader component.\n */\nconst SidebarHeader = ({ onNewChat, isNewChatDisabled = false }) => {\n\treturn (\n\t\t<div className=\"nfd-editor-chat-sidebar__header-content\">\n\t\t\t<div className=\"interface-complementary-area-header__title\">\n\t\t\t\t<Sparkles width={15} height={15} />\n\t\t\t\t<h2>\n\t\t\t\t\t{__(\"Blu Chat\", \"wp-module-editor-chat\")}\n\t\t\t\t\t<span className=\"nfd-editor-chat-sidebar__beta-badge\">Beta</span>\n\t\t\t\t</h2>\n\t\t\t</div>\n\t\t\t{onNewChat && (\n\t\t\t\t<div className=\"nfd-editor-chat-sidebar__header-actions\">\n\t\t\t\t\t<Button\n\t\t\t\t\t\ticon={<Plus width={16} height={16} />}\n\t\t\t\t\t\tlabel={__(\"New chat\", \"wp-module-editor-chat\")}\n\t\t\t\t\t\tonClick={onNewChat}\n\t\t\t\t\t\tclassName=\"nfd-editor-chat-sidebar__new-chat\"\n\t\t\t\t\t\tdisabled={isNewChatDisabled}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t)}\n\t\t</div>\n\t);\n};\n\nexport default SidebarHeader;\n","/**\n * Internal dependencies\n */\nimport { ReactComponent as SparksIcon } from \"../../svg/sparks.svg\";\n\n/**\n * AILogo Component\n *\n * A reusable logo component for the AI assistant with purple gradient background\n * and white sparks icon.\n *\n * @param {Object} props        - The component props.\n * @param {number} props.width  - The width of the logo (default: 24).\n * @param {number} props.height - The height of the logo (default: 24).\n * @return {JSX.Element} The AILogo component.\n */\nconst AILogo = ({ width = 24, height = 24 }) => (\n\t<div\n\t\tclassName=\"nfd-editor-chat-ai-avatar\"\n\t\tstyle={{\n\t\t\twidth,\n\t\t\theight,\n\t\t}}\n\t>\n\t\t<SparksIcon width={width * 0.625} height={height * 0.625} />\n\t</div>\n);\n\nexport default AILogo;\n","/**\n * WordPress dependencies\n */\nimport { __ } from \"@wordpress/i18n\";\n\n/**\n * External dependencies\n */\nimport { AtSign, X } from \"lucide-react\";\n\n/**\n * Get a human-readable label for a block name\n *\n * @param {string} blockName - The block name (e.g., \"core/paragraph\")\n * @return {string} The formatted label\n */\nconst getBlockLabel = (blockName) => {\n\tif (!blockName) {\n\t\treturn \"\";\n\t}\n\n\t// Remove the namespace prefix (e.g., \"core/\" or \"custom/\")\n\tconst cleanName = blockName.split(\"/\").pop();\n\n\t// Convert kebab-case to Title Case\n\treturn cleanName\n\t\t.split(\"-\")\n\t\t.map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n\t\t.join(\" \");\n};\n\n/**\n * Extract and truncate text content from block content\n *\n * @param {string} content - The raw content (HTML or plain text)\n * @return {string|null} The truncated text or null if no content\n */\nconst extractBlockText = (content) => {\n\tif (!content) {\n\t\treturn null;\n\t}\n\n\t// Remove HTML tags to get plain text\n\tconst plainText = content.replace(/<[^>]*>/g, \"\").trim();\n\n\tif (!plainText) {\n\t\treturn null;\n\t}\n\n\t// Truncate and add ellipsis if needed\n\treturn plainText;\n};\n\n/**\n * ContextTag Component\n *\n * Displays a tag showing the current context (e.g., selected block)\n *\n * @param {Object}   props          Component props\n * @param {Object}   props.block    Single block object to display\n * @param {Function} props.onRemove Optional callback when tag is removed\n * @return {JSX.Element|null} The ContextTag component\n */\nconst ContextTag = ({ block, onRemove }) => {\n\tif (!block) {\n\t\treturn null;\n\t}\n\n\tconst blockLabel = getBlockLabel(block.name);\n\tconst metadataName = block.attributes?.metadata?.name;\n\n\t// Extract text content for specific block types\n\tconst blockType = block.name.split(\"/\").pop();\n\tconst isTextBlock = [\"paragraph\", \"heading\"].includes(blockType);\n\tconst blockContent = block.attributes?.content;\n\tconst extractedText = isTextBlock ? extractBlockText(blockContent) : null;\n\n\t// Build display label: use extracted text if available, otherwise use metadata name or default label\n\tlet displayLabel = blockLabel;\n\tif (metadataName) {\n\t\tdisplayLabel = `${blockLabel}: ${metadataName}`;\n\t} else if (extractedText) {\n\t\tdisplayLabel = `${blockLabel}: ${extractedText}`;\n\t}\n\n\t// Store full label for tooltip before truncating\n\tconst fullDisplayLabel = displayLabel;\n\n\t// Truncate display label to 30 characters max\n\tif (displayLabel.length > 30) {\n\t\tdisplayLabel = `${displayLabel.substring(0, 30)}...`;\n\t}\n\n\treturn (\n\t\t<div className=\"nfd-editor-chat-context-tag\" title={fullDisplayLabel}>\n\t\t\t<span className=\"nfd-editor-chat-context-tag__label\">\n\t\t\t\t<AtSign size={12} />\n\t\t\t</span>\n\t\t\t{onRemove && (\n\t\t\t\t<button\n\t\t\t\t\tclassName=\"nfd-editor-chat-context-tag__remove\"\n\t\t\t\t\tonClick={() => onRemove(block.clientId)}\n\t\t\t\t\taria-label={__(\"Remove context\", \"wp-module-editor-chat\")}\n\t\t\t\t>\n\t\t\t\t\t<X size={12} />\n\t\t\t\t</button>\n\t\t\t)}\n\t\t\t<span className=\"nfd-editor-chat-context-tag__block\">{displayLabel}</span>\n\t\t</div>\n\t);\n}; // Close ContextTag component\n\nexport default ContextTag;\n","/**\n * External dependencies\n */\nimport { CircleX } from \"lucide-react\";\n\n/**\n * ErrorAlert Component\n *\n * A reusable error alert component that displays error messages\n * in a red box with an exclamation mark icon.\n *\n * @param {Object} props           - The component props.\n * @param {string} props.message   - The error message to display.\n * @param {string} props.className - Additional CSS classes (optional).\n * @return {JSX.Element} The ErrorAlert component.\n */\nconst ErrorAlert = ({ message, className = \"\" }) => {\n\treturn (\n\t\t<div className={`nfd-editor-chat-error-alert ${className}`}>\n\t\t\t<div className=\"nfd-editor-chat-error-alert__icon\">\n\t\t\t\t<CircleX width={16} height={16} />\n\t\t\t</div>\n\t\t\t<div className=\"nfd-editor-chat-error-alert__content\">\n\t\t\t\t<div className=\"nfd-editor-chat-error-alert__message\">{message}</div>\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n\nexport default ErrorAlert;\n","/**\n * WordPress dependencies\n */\nimport { Button } from \"@wordpress/components\";\n\n/**\n * SuggestionButton Component\n *\n * A reusable suggestion button component that can be used in various contexts.\n * Takes an icon, text, and onClick action as parameters.\n *\n * @param {Object}      props           - The component props.\n * @param {JSX.Element} props.icon      - The icon element to display.\n * @param {string}      props.text      - The text to display.\n * @param {Function}    props.onClick   - The function to call when clicked.\n * @param {string}      props.className - Additional CSS classes (optional).\n * @return {JSX.Element} The SuggestionButton component.\n */\nconst SuggestionButton = ({ icon, text, onClick, className = \"\" }) => {\n\treturn (\n\t\t<Button className={`nfd-editor-chat-suggestion ${className}`} onClick={onClick}>\n\t\t\t<div className=\"nfd-editor-chat-suggestion__icon\">{icon}</div>\n\t\t\t<div className=\"nfd-editor-chat-suggestion__text\">{text}</div>\n\t\t</Button>\n\t);\n};\n\nexport default SuggestionButton;\n","/**\n * WordPress dependencies\n */\nimport { __ } from \"@wordpress/i18n\";\n\n/**\n * Get ability details for display\n * @param {string} abilityName The ability name\n * @return {Object} { title, description, icon }\n */\nconst getAbilityDetails = (abilityName) => {\n\tconst abilityMap = {\n\t\t\"nfd-editor-chat/get-global-styles\": {\n\t\t\ttitle: \"Reading Site Colors\",\n\t\t\tdescription: \"Fetching current color palette and typography settings\",\n\t\t},\n\t\t\"nfd-editor-chat/update-global-palette\": {\n\t\t\ttitle: \"Updating Site Colors\",\n\t\t\tdescription: \"Applying new colors to global styles\",\n\t\t},\n\t};\n\n\treturn (\n\t\tabilityMap[abilityName] || {\n\t\t\ttitle: abilityName,\n\t\t\tdescription: \"Executing action\",\n\t\t\ticon: \"\",\n\t\t}\n\t);\n};\n\n/**\n * Get tool details for display\n * @param {string} toolName The tool name\n * @param {Object} args     The tool arguments\n * @return {Object} { title, description, icon, params }\n */\nconst getToolDetails = (toolName, args = {}) => {\n\tif (toolName === \"mcp-adapter-execute-ability\") {\n\t\tconst abilityName = args?.ability_name || \"unknown\";\n\t\tconst details = getAbilityDetails(abilityName);\n\n\t\t// Add specific parameter info\n\t\tlet params = null;\n\t\tif (abilityName === \"nfd-editor-chat/update-global-palette\" && args?.parameters?.colors) {\n\t\t\tconst colorCount = args.parameters.colors.length;\n\t\t\tparams = `${colorCount} color${colorCount !== 1 ? \"s\" : \"\"}`;\n\t\t}\n\n\t\treturn { ...details, params };\n\t}\n\n\tif (toolName === \"mcp-adapter-discover-abilities\") {\n\t\treturn {\n\t\t\ttitle: \"Discovering Actions\",\n\t\t\tdescription: \"Finding available WordPress abilities\",\n\t\t\ticon: \"\",\n\t\t\tparams: null,\n\t\t};\n\t}\n\n\tif (toolName === \"mcp-adapter-get-ability-info\") {\n\t\treturn {\n\t\t\ttitle: \"Getting Ability Info\",\n\t\t\tdescription: `Fetching details for ${args?.ability_name || \"ability\"}`,\n\t\t\ticon: \"\",\n\t\t\tparams: null,\n\t\t};\n\t}\n\n\treturn {\n\t\ttitle: toolName,\n\t\tdescription: \"Executing tool\",\n\t\ticon: \"\",\n\t\tparams: null,\n\t};\n};\n\n/**\n * TypingIndicator Component\n *\n * Displays an animated typing indicator with detailed tool call information.\n *\n * @param {Object} props                - The component props.\n * @param {string} props.status         - The current status ('received', 'generating', 'tool_call', 'summarizing', etc.).\n * @param {Object} props.activeToolCall - The currently executing tool call (optional).\n * @return {JSX.Element} The TypingIndicator component.\n */\nconst TypingIndicator = ({ status = null, activeToolCall = null }) => {\n\t// If we have an active tool call, show detailed view\n\tif (activeToolCall) {\n\t\tconst details = getToolDetails(activeToolCall.name, activeToolCall.arguments);\n\n\t\treturn (\n\t\t\t<div className=\"nfd-editor-chat-message nfd-editor-chat-message--assistant\">\n\t\t\t\t<div className=\"nfd-editor-chat-message__content\">\n\t\t\t\t\t<div className=\"nfd-editor-chat-tool-status\">\n\t\t\t\t\t\t<div className=\"nfd-editor-chat-tool-status__header\">\n\t\t\t\t\t\t\t<span className=\"nfd-editor-chat-tool-status__icon\">{details.icon}</span>\n\t\t\t\t\t\t\t<span className=\"nfd-editor-chat-tool-status__title\">{details.title}</span>\n\t\t\t\t\t\t\t<div className=\"nfd-editor-chat-tool-status__spinner\"></div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className=\"nfd-editor-chat-tool-status__description\">\n\t\t\t\t\t\t\t{details.description}\n\t\t\t\t\t\t\t{details.params && (\n\t\t\t\t\t\t\t\t<span className=\"nfd-editor-chat-tool-status__params\">  {details.params}</span>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t);\n\t}\n\n\t// Default status text\n\tconst getStatusText = () => {\n\t\tswitch (status) {\n\t\t\tcase \"received\":\n\t\t\t\treturn { text: __(\"Message received\", \"wp-module-editor-chat\") };\n\t\t\tcase \"generating\":\n\t\t\t\treturn { text: __(\"Thinking\", \"wp-module-editor-chat\") };\n\t\t\tcase \"tool_call\":\n\t\t\t\treturn { text: __(\"Executing action\", \"wp-module-editor-chat\") };\n\t\t\tcase \"summarizing\":\n\t\t\t\treturn { text: __(\"Summarizing results\", \"wp-module-editor-chat\") };\n\t\t\tcase \"completed\":\n\t\t\t\treturn { text: __(\"Processing\", \"wp-module-editor-chat\") };\n\t\t\tcase \"failed\":\n\t\t\t\treturn { text: __(\"Error occurred\", \"wp-module-editor-chat\") };\n\t\t\tdefault:\n\t\t\t\treturn { text: __(\"Thinking\", \"wp-module-editor-chat\") };\n\t\t}\n\t};\n\n\tconst statusInfo = getStatusText();\n\n\treturn (\n\t\t<div className=\"nfd-editor-chat-message nfd-editor-chat-message--assistant\">\n\t\t\t<div className=\"nfd-editor-chat-message__content\">\n\t\t\t\t<div className=\"nfd-editor-chat-typing-indicator\">\n\t\t\t\t\t<div className=\"nfd-editor-chat-typing-indicator__icon\">{statusInfo.icon}</div>\n\t\t\t\t\t<div className=\"nfd-editor-chat-typing-indicator__status\">{statusInfo.text}</div>\n\t\t\t\t\t<div className=\"nfd-editor-chat-typing-indicator__dots\">\n\t\t\t\t\t\t<span></span>\n\t\t\t\t\t\t<span></span>\n\t\t\t\t\t\t<span></span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n\nexport default TypingIndicator;\n","/* eslint-disable no-undef, no-console */\n/**\n * WordPress dependencies\n */\nimport { useEffect, useState, useRef, useCallback } from \"@wordpress/element\";\nimport { __ } from \"@wordpress/i18n\";\nimport { useDispatch, useSelect } from \"@wordpress/data\";\nimport { store as coreStore } from \"@wordpress/core-data\";\n\n/**\n * Internal dependencies\n */\nimport { mcpClient } from \"../services/mcpClient\";\nimport { openaiClient } from \"../services/openaiClient\";\nimport actionExecutor from \"../services/actionExecutor\";\nimport { simpleHash } from \"../utils/helpers\";\nimport { updateGlobalPalette, getCurrentGlobalStyles } from \"../services/globalStylesService\";\n\n/**\n * Get site-specific localStorage keys for chat persistence\n * Uses the site URL to ensure each site has its own isolated chat history\n *\n * @return {Object} Storage keys object with site-specific keys\n */\nconst getStorageKeys = () => {\n\t// Hash the site home URL to create a unique, compact identifier\n\tconst siteId = simpleHash(window.nfdEditorChat?.homeUrl || \"default\");\n\n\treturn {\n\t\tSESSION_ID: `nfd-editor-chat-session-id-${siteId}`,\n\t\tMESSAGES: `nfd-editor-chat-messages-${siteId}`,\n\t};\n};\n\n/**\n * Load session ID from localStorage\n *\n * @return {string|null} The session ID or null\n */\nconst loadSessionId = () => {\n\ttry {\n\t\tconst STORAGE_KEYS = getStorageKeys();\n\t\treturn localStorage.getItem(STORAGE_KEYS.SESSION_ID);\n\t} catch (error) {\n\t\tconsole.warn(\"Failed to load session ID from localStorage:\", error);\n\t\treturn null;\n\t}\n};\n\n/**\n * Save session ID to localStorage\n *\n * @param {string} sessionId The session ID to save\n */\nconst saveSessionId = (sessionId) => {\n\ttry {\n\t\tconst STORAGE_KEYS = getStorageKeys();\n\t\tif (sessionId) {\n\t\t\tlocalStorage.setItem(STORAGE_KEYS.SESSION_ID, sessionId);\n\t\t} else {\n\t\t\tlocalStorage.removeItem(STORAGE_KEYS.SESSION_ID);\n\t\t}\n\t} catch (error) {\n\t\tconsole.warn(\"Failed to save session ID to localStorage:\", error);\n\t}\n};\n\n/**\n * Load messages from localStorage\n *\n * @return {Array} Array of messages\n */\nconst loadMessages = () => {\n\ttry {\n\t\tconst STORAGE_KEYS = getStorageKeys();\n\t\tconst stored = localStorage.getItem(STORAGE_KEYS.MESSAGES);\n\t\tif (stored) {\n\t\t\tconst messages = JSON.parse(stored);\n\t\t\t// Remove hasActions and undoData from loaded messages (actions should only show once)\n\t\t\treturn messages.map((msg) => {\n\t\t\t\tconst { hasActions, undoData, isStreaming, ...rest } = msg;\n\t\t\t\treturn rest;\n\t\t\t});\n\t\t}\n\t\treturn [];\n\t} catch (error) {\n\t\tconsole.warn(\"Failed to load messages from localStorage:\", error);\n\t\treturn [];\n\t}\n};\n\n/**\n * Save messages to localStorage\n *\n * @param {Array} messages Array of messages to save\n */\nconst saveMessages = (messages) => {\n\ttry {\n\t\tconst STORAGE_KEYS = getStorageKeys();\n\t\t// Filter out streaming state before saving\n\t\tconst cleanMessages = messages.map(({ isStreaming, ...rest }) => rest);\n\t\tlocalStorage.setItem(STORAGE_KEYS.MESSAGES, JSON.stringify(cleanMessages));\n\t} catch (error) {\n\t\tconsole.warn(\"Failed to save messages to localStorage:\", error);\n\t}\n};\n\n/**\n * Clear all chat data from localStorage\n */\nconst clearChatData = () => {\n\ttry {\n\t\tconst STORAGE_KEYS = getStorageKeys();\n\t\tlocalStorage.removeItem(STORAGE_KEYS.SESSION_ID);\n\t\tlocalStorage.removeItem(STORAGE_KEYS.MESSAGES);\n\t} catch (error) {\n\t\tconsole.warn(\"Failed to clear chat data from localStorage:\", error);\n\t}\n};\n\n/**\n * Generate a new session ID\n *\n * @return {string} New session ID\n */\nconst generateSessionId = () => {\n\treturn crypto.randomUUID\n\t\t? crypto.randomUUID()\n\t\t: `${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;\n};\n\n/**\n * Custom hook for managing chat functionality with MCP and streaming support\n *\n * @return {Object} Chat state and handlers\n */\nconst useChat = () => {\n\t// Initialize state from localStorage\n\tconst savedSessionId = loadSessionId();\n\tconst savedMessages = loadMessages();\n\n\tconst [messages, setMessages] = useState(savedMessages || []);\n\tconst [isLoading, setIsLoading] = useState(false);\n\tconst [sessionId, setSessionId] = useState(savedSessionId || generateSessionId());\n\tconst [error, setError] = useState(null);\n\tconst [status, setStatus] = useState(null);\n\tconst [isSaving, setIsSaving] = useState(false);\n\tconst [hasGlobalStylesChanges, setHasGlobalStylesChanges] = useState(false);\n\tconst [mcpConnectionStatus, setMcpConnectionStatus] = useState(\"disconnected\");\n\tconst [tools, setTools] = useState([]);\n\tconst [activeToolCall, setActiveToolCall] = useState(null);\n\n\tconst hasInitializedRef = useRef(false);\n\tconst abortControllerRef = useRef(null);\n\n\t// Get WordPress editor dispatch functions\n\tconst { savePost } = useDispatch(\"core/editor\");\n\tconst { saveEditedEntityRecord } = useDispatch(coreStore);\n\tconst { __experimentalGetCurrentGlobalStylesId } = useSelect(\n\t\t(select) => ({\n\t\t\t__experimentalGetCurrentGlobalStylesId:\n\t\t\t\tselect(coreStore).__experimentalGetCurrentGlobalStylesId,\n\t\t}),\n\t\t[]\n\t);\n\n\t// Get WordPress save status\n\tconst isSavingPost = useSelect((select) => select(\"core/editor\").isSavingPost(), []);\n\n\t// Watch for save completion\n\tuseEffect(() => {\n\t\tif (isSaving && !isSavingPost) {\n\t\t\t// Save just completed - remove hasActions and undoData from ALL messages\n\t\t\tsetMessages((prev) =>\n\t\t\t\tprev.map((msg) => {\n\t\t\t\t\tif (msg.hasActions) {\n\t\t\t\t\t\tconst { hasActions, undoData, ...rest } = msg;\n\t\t\t\t\t\treturn rest;\n\t\t\t\t\t}\n\t\t\t\t\treturn msg;\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Reset global styles changes flag\n\t\t\tsetHasGlobalStylesChanges(false);\n\t\t\tsetIsSaving(false);\n\t\t}\n\t}, [isSaving, isSavingPost]);\n\n\t/**\n\t * Initialize MCP client connection\n\t */\n\tconst initializeMCP = useCallback(async () => {\n\t\tif (mcpConnectionStatus === \"connecting\" || mcpConnectionStatus === \"connected\") {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tsetMcpConnectionStatus(\"connecting\");\n\n\t\t\tawait mcpClient.connect();\n\t\t\tawait mcpClient.initialize();\n\n\t\t\tconst availableTools = await mcpClient.listTools();\n\t\t\tsetTools(availableTools);\n\n\t\t\tsetMcpConnectionStatus(\"connected\");\n\t\t} catch (err) {\n\t\t\tconsole.error(\"Failed to initialize MCP:\", err);\n\t\t\tsetMcpConnectionStatus(\"disconnected\");\n\t\t\t// Don't set error here - MCP is optional, chat can work without it\n\t\t}\n\t}, [mcpConnectionStatus]);\n\n\t// Initialize on mount\n\tuseEffect(() => {\n\t\tif (hasInitializedRef.current) {\n\t\t\treturn;\n\t\t}\n\n\t\thasInitializedRef.current = true;\n\n\t\t// Save session ID if it's new\n\t\tif (!savedSessionId) {\n\t\t\tsaveSessionId(sessionId);\n\t\t}\n\n\t\t// Initialize MCP connection\n\t\tinitializeMCP();\n\t}, [sessionId, savedSessionId, initializeMCP]);\n\n\t// Save session ID when it changes\n\tuseEffect(() => {\n\t\tsaveSessionId(sessionId);\n\t}, [sessionId]);\n\n\t// Save messages when they change\n\tuseEffect(() => {\n\t\tif (messages.length > 0) {\n\t\t\tsaveMessages(messages);\n\t\t}\n\t}, [messages]);\n\n\t// Cleanup on unmount\n\tuseEffect(() => {\n\t\treturn () => {\n\t\t\tif (abortControllerRef.current) {\n\t\t\t\tabortControllerRef.current.abort();\n\t\t\t}\n\t\t};\n\t}, []);\n\n\t/**\n\t * Handle sending a message with streaming support\n\t *\n\t * @param {string} messageContent The message to send\n\t */\n\tconst handleSendMessage = async (messageContent) => {\n\t\t// Clear any previous errors\n\t\tsetError(null);\n\t\tsetStatus(null);\n\n\t\t// Add user message\n\t\tconst userMessage = {\n\t\t\tid: `user-${Date.now()}`,\n\t\t\ttype: \"user\",\n\t\t\trole: \"user\",\n\t\t\tcontent: messageContent,\n\t\t};\n\t\tsetMessages((prev) => [...prev, userMessage]);\n\t\tsetIsLoading(true);\n\t\tsetStatus(\"generating\");\n\n\t\t// Create abort controller for this request\n\t\tabortControllerRef.current = new AbortController();\n\n\t\ttry {\n\t\t\t// Build message context for OpenAI\n\t\t\tconst systemMessage = openaiClient.createWordPressSystemMessage();\n\t\t\tconst recentMessages = [...messages, userMessage].slice(-10);\n\n\t\t\tconst openaiMessages = [\n\t\t\t\tsystemMessage,\n\t\t\t\t...openaiClient.convertMessagesToOpenAI(\n\t\t\t\t\trecentMessages.map((msg) => ({\n\t\t\t\t\t\trole: msg.type === \"user\" ? \"user\" : \"assistant\",\n\t\t\t\t\t\tcontent: msg.content,\n\t\t\t\t\t\ttoolCalls: msg.toolCalls,\n\t\t\t\t\t\ttoolResults: msg.toolResults,\n\t\t\t\t\t}))\n\t\t\t\t),\n\t\t\t];\n\n\t\t\t// Get MCP tools in OpenAI format\n\t\t\tconst openaiTools = mcpClient.isConnected() ? mcpClient.getToolsForOpenAI() : [];\n\n\t\t\t// Create streaming assistant message\n\t\t\tconst assistantMessageId = `assistant-${Date.now()}`;\n\t\t\tlet currentContent = \"\";\n\n\t\t\tsetMessages((prev) => [\n\t\t\t\t...prev,\n\t\t\t\t{\n\t\t\t\t\tid: assistantMessageId,\n\t\t\t\t\ttype: \"assistant\",\n\t\t\t\t\trole: \"assistant\",\n\t\t\t\t\tcontent: \"\",\n\t\t\t\t\tisStreaming: true,\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\t// Make streaming request\n\t\t\tawait openaiClient.createStreamingCompletion(\n\t\t\t\t{\n\t\t\t\t\tmodel: \"gpt-4o-mini\",\n\t\t\t\t\tmessages: openaiMessages,\n\t\t\t\t\ttools: openaiTools.length > 0 ? openaiTools : undefined,\n\t\t\t\t\ttool_choice: openaiTools.length > 0 ? \"auto\" : undefined,\n\t\t\t\t\ttemperature: 0.7,\n\t\t\t\t\tmax_tokens: 2000,\n\t\t\t\t},\n\t\t\t\t// onChunk callback\n\t\t\t\t(chunk) => {\n\t\t\t\t\tif (chunk.type === \"content\") {\n\t\t\t\t\t\tcurrentContent += chunk.content;\n\t\t\t\t\t\tsetMessages((prev) =>\n\t\t\t\t\t\t\tprev.map((msg) =>\n\t\t\t\t\t\t\t\tmsg.id === assistantMessageId ? { ...msg, content: currentContent } : msg\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t// onComplete callback\n\t\t\t\tasync (fullMessage, toolCallsResult) => {\n\t\t\t\t\t// Mark streaming as complete\n\t\t\t\t\tsetMessages((prev) =>\n\t\t\t\t\t\tprev.map((msg) =>\n\t\t\t\t\t\t\tmsg.id === assistantMessageId\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t...msg,\n\t\t\t\t\t\t\t\t\t\tcontent: fullMessage,\n\t\t\t\t\t\t\t\t\t\tisStreaming: false,\n\t\t\t\t\t\t\t\t\t\ttoolCalls: toolCallsResult,\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: msg\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\t// Handle tool calls if present\n\t\t\t\t\tif (toolCallsResult && toolCallsResult.length > 0 && mcpClient.isConnected()) {\n\t\t\t\t\t\t// handleToolCalls will manage isLoading and status\n\t\t\t\t\t\tawait handleToolCalls(toolCallsResult, assistantMessageId, openaiMessages);\n\t\t\t\t\t\t// Don't reset here - handleToolCalls manages the state\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only reset if no tool calls\n\t\t\t\t\tsetIsLoading(false);\n\t\t\t\t\tsetStatus(null);\n\t\t\t\t},\n\t\t\t\t// onError callback\n\t\t\t\t(err) => {\n\t\t\t\t\tconsole.error(\"Streaming error:\", err);\n\t\t\t\t\tsetMessages((prev) =>\n\t\t\t\t\t\tprev.map((msg) =>\n\t\t\t\t\t\t\tmsg.id === assistantMessageId\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t...msg,\n\t\t\t\t\t\t\t\t\t\tcontent:\n\t\t\t\t\t\t\t\t\t\t\tcurrentContent || __(\"Sorry, an error occurred.\", \"wp-module-editor-chat\"),\n\t\t\t\t\t\t\t\t\t\tisStreaming: false,\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: msg\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tsetError(\n\t\t\t\t\t\terr.message ||\n\t\t\t\t\t\t\t__(\"An error occurred while processing your request.\", \"wp-module-editor-chat\")\n\t\t\t\t\t);\n\t\t\t\t\tsetIsLoading(false);\n\t\t\t\t\tsetStatus(null);\n\t\t\t\t}\n\t\t\t);\n\t\t} catch (err) {\n\t\t\tif (err.name === \"AbortError\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconsole.error(\"Error sending message:\", err);\n\t\t\tsetError(\n\t\t\t\t__(\n\t\t\t\t\t\"Sorry, I encountered an error processing your request. Please try again.\",\n\t\t\t\t\t\"wp-module-editor-chat\"\n\t\t\t\t)\n\t\t\t);\n\t\t\tsetIsLoading(false);\n\t\t\tsetStatus(null);\n\t\t}\n\t};\n\n\t/**\n\t * Handle tool calls from OpenAI response\n\t *\n\t * @param {Array}  toolCalls          Tool calls from OpenAI\n\t * @param {string} assistantMessageId ID of the assistant message\n\t * @param {Array}  previousMessages   Previous messages for context\n\t */\n\tconst handleToolCalls = async (toolCalls, assistantMessageId, previousMessages) => {\n\t\tconst toolResults = [];\n\n\t\t// Set status to tool_call mode\n\t\tsetStatus(\"tool_call\");\n\n\t\tfor (const toolCall of toolCalls) {\n\t\t\t// Set the active tool call for UI display\n\t\t\tsetActiveToolCall({\n\t\t\t\tname: toolCall.name,\n\t\t\t\targuments: toolCall.arguments,\n\t\t\t});\n\n\t\t\ttry {\n\t\t\t\t// Check if this is a global styles update - handle it via JS for real-time updates\n\t\t\t\tif (toolCall.name === \"mcp-adapter-execute-ability\") {\n\t\t\t\t\tconst args = toolCall.arguments || {};\n\t\t\t\t\tconst abilityName = args.ability_name;\n\t\t\t\t\tconst params = args.parameters || {};\n\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\"Tool call intercepted:\",\n\t\t\t\t\t\ttoolCall.name,\n\t\t\t\t\t\t\"ability:\",\n\t\t\t\t\t\tabilityName,\n\t\t\t\t\t\t\"params:\",\n\t\t\t\t\t\tparams\n\t\t\t\t\t);\n\n\t\t\t\t\t// Handle global palette update via JS service for real-time updates\n\t\t\t\t\tif (abilityName === \"nfd-editor-chat/update-global-palette\") {\n\t\t\t\t\t\tconsole.log(\"=== Intercepting global palette update for real-time changes ===\");\n\t\t\t\t\t\tconsole.log(\"Colors:\", params.colors);\n\t\t\t\t\t\tconsole.log(\"Replace all:\", params.replace_all);\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst jsResult = await updateGlobalPalette(params.colors, params.replace_all);\n\t\t\t\t\t\t\tconsole.log(\"JS update result:\", jsResult);\n\n\t\t\t\t\t\t\tif (jsResult.success) {\n\t\t\t\t\t\t\t\tsetHasGlobalStylesChanges(true);\n\t\t\t\t\t\t\t\ttoolResults.push({\n\t\t\t\t\t\t\t\t\tid: toolCall.id,\n\t\t\t\t\t\t\t\t\tresult: [{ type: \"text\", text: JSON.stringify(jsResult) }],\n\t\t\t\t\t\t\t\t\tisError: false,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Fall back to MCP if JS fails\n\t\t\t\t\t\t\t\tconsole.warn(\"JS update failed, falling back to MCP:\", jsResult.error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (jsError) {\n\t\t\t\t\t\t\tconsole.error(\"JS update threw error:\", jsError);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Fallback to MCP\n\t\t\t\t\t\tconst result = await mcpClient.callTool(toolCall.name, toolCall.arguments);\n\t\t\t\t\t\ttoolResults.push({\n\t\t\t\t\t\t\tid: toolCall.id,\n\t\t\t\t\t\t\tresult: result.content,\n\t\t\t\t\t\t\tisError: result.isError,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle get global styles via JS service for more accurate data\n\t\t\t\t\tif (abilityName === \"nfd-editor-chat/get-global-styles\") {\n\t\t\t\t\t\tconsole.log(\"=== Intercepting get global styles for real-time data ===\");\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst jsResult = getCurrentGlobalStyles();\n\t\t\t\t\t\t\tconsole.log(\"JS get styles result:\", jsResult);\n\n\t\t\t\t\t\t\t// Check if we got valid data (palette has items or we have rawSettings)\n\t\t\t\t\t\t\tif (jsResult.palette?.length > 0 || jsResult.rawSettings) {\n\t\t\t\t\t\t\t\ttoolResults.push({\n\t\t\t\t\t\t\t\t\tid: toolCall.id,\n\t\t\t\t\t\t\t\t\tresult: [\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\ttype: \"text\",\n\t\t\t\t\t\t\t\t\t\t\ttext: JSON.stringify({\n\t\t\t\t\t\t\t\t\t\t\t\tstyles: jsResult,\n\t\t\t\t\t\t\t\t\t\t\t\tmessage: \"Retrieved global styles from editor\",\n\t\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\tisError: false,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconsole.warn(\"JS get styles returned empty, falling back to MCP\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (jsError) {\n\t\t\t\t\t\t\tconsole.error(\"JS get styles threw error:\", jsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Fall through to MCP if JS fails\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Default: use MCP for all other tool calls\n\t\t\t\tconst result = await mcpClient.callTool(toolCall.name, toolCall.arguments);\n\t\t\t\ttoolResults.push({\n\t\t\t\t\tid: toolCall.id,\n\t\t\t\t\tresult: result.content,\n\t\t\t\t\tisError: result.isError,\n\t\t\t\t});\n\t\t\t} catch (err) {\n\t\t\t\tconsole.error(`Tool call ${toolCall.name} failed:`, err);\n\t\t\t\ttoolResults.push({\n\t\t\t\t\tid: toolCall.id,\n\t\t\t\t\tresult: null,\n\t\t\t\t\terror: err.message,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Update message with tool results\n\t\tsetMessages((prev) =>\n\t\t\tprev.map((msg) =>\n\t\t\t\tmsg.id === assistantMessageId\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...msg,\n\t\t\t\t\t\t\ttoolResults,\n\t\t\t\t\t\t}\n\t\t\t\t\t: msg\n\t\t\t)\n\t\t);\n\n\t\t// Clear active tool call\n\t\tsetActiveToolCall(null);\n\n\t\t// If we have successful results, get a streaming follow-up response\n\t\tif (toolResults.some((r) => !r.error)) {\n\t\t\t// Set status to summarizing\n\t\t\tsetStatus(\"summarizing\");\n\n\t\t\ttry {\n\t\t\t\t// Format tool results for AI\n\t\t\t\tconst toolResultsSummary = toolResults\n\t\t\t\t\t.map((r) => {\n\t\t\t\t\t\tif (r.error) {\n\t\t\t\t\t\t\treturn `Tool failed: ${r.error}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst resultText = Array.isArray(r.result)\n\t\t\t\t\t\t\t? r.result.map((item) => item.text || JSON.stringify(item)).join(\"\\n\")\n\t\t\t\t\t\t\t: JSON.stringify(r.result);\n\t\t\t\t\t\treturn resultText;\n\t\t\t\t\t})\n\t\t\t\t\t.join(\"\\n\\n\");\n\n\t\t\t\t// Create a streaming follow-up message\n\t\t\t\tconst followUpMessageId = `assistant-followup-${Date.now()}`;\n\t\t\t\tlet followUpContent = \"\";\n\n\t\t\t\t// Add placeholder message for streaming\n\t\t\t\tsetMessages((prev) => [\n\t\t\t\t\t...prev,\n\t\t\t\t\t{\n\t\t\t\t\t\tid: followUpMessageId,\n\t\t\t\t\t\ttype: \"assistant\",\n\t\t\t\t\t\trole: \"assistant\",\n\t\t\t\t\t\tcontent: \"\",\n\t\t\t\t\t\tisStreaming: true,\n\t\t\t\t\t},\n\t\t\t\t]);\n\n\t\t\t\t// Build messages for follow-up\n\t\t\t\tconst systemMessage = openaiClient.createWordPressSystemMessage();\n\t\t\t\tconst followUpMessages = [\n\t\t\t\t\tsystemMessage,\n\t\t\t\t\t...openaiClient.convertMessagesToOpenAI(previousMessages.slice(0, -1)),\n\t\t\t\t\t{\n\t\t\t\t\t\trole: \"user\",\n\t\t\t\t\t\tcontent: `Here are the results from the tool execution:\\n\\n${toolResultsSummary}\\n\\nPlease provide a brief, helpful summary of what was done for the user. Be concise.`,\n\t\t\t\t\t},\n\t\t\t\t];\n\n\t\t\t\t// Stream the follow-up response (no tools for summary)\n\t\t\t\tawait openaiClient.createStreamingCompletion(\n\t\t\t\t\t{\n\t\t\t\t\t\tmodel: \"gpt-4o-mini\",\n\t\t\t\t\t\tmessages: followUpMessages,\n\t\t\t\t\t\ttools: [], // Explicitly no tools for follow-up\n\t\t\t\t\t\ttemperature: 0.7,\n\t\t\t\t\t\tmax_tokens: 500,\n\t\t\t\t\t},\n\t\t\t\t\t// onChunk\n\t\t\t\t\t(chunk) => {\n\t\t\t\t\t\tif (chunk.type === \"content\") {\n\t\t\t\t\t\t\tfollowUpContent += chunk.content;\n\t\t\t\t\t\t\tsetMessages((prev) =>\n\t\t\t\t\t\t\t\tprev.map((msg) =>\n\t\t\t\t\t\t\t\t\tmsg.id === followUpMessageId ? { ...msg, content: followUpContent } : msg\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t// onComplete\n\t\t\t\t\tasync (fullMessage) => {\n\t\t\t\t\t\tsetMessages((prev) =>\n\t\t\t\t\t\t\tprev.map((msg) =>\n\t\t\t\t\t\t\t\tmsg.id === followUpMessageId\n\t\t\t\t\t\t\t\t\t? { ...msg, content: fullMessage, isStreaming: false }\n\t\t\t\t\t\t\t\t\t: msg\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tsetStatus(null);\n\t\t\t\t\t\tsetIsLoading(false);\n\t\t\t\t\t},\n\t\t\t\t\t// onError\n\t\t\t\t\t(err) => {\n\t\t\t\t\t\tconsole.error(\"Follow-up streaming error:\", err);\n\t\t\t\t\t\tsetMessages((prev) =>\n\t\t\t\t\t\t\tprev.map((msg) =>\n\t\t\t\t\t\t\t\tmsg.id === followUpMessageId\n\t\t\t\t\t\t\t\t\t? { ...msg, content: followUpContent || \"Done.\", isStreaming: false }\n\t\t\t\t\t\t\t\t\t: msg\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tsetStatus(null);\n\t\t\t\t\t\tsetIsLoading(false);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t} catch (followUpError) {\n\t\t\t\tconsole.error(\"Follow-up response failed:\", followUpError);\n\t\t\t\tsetStatus(null);\n\t\t\t\tsetIsLoading(false);\n\t\t\t}\n\t\t} else {\n\t\t\t// No successful results, reset state\n\t\t\tsetStatus(null);\n\t\t\tsetIsLoading(false);\n\t\t}\n\t};\n\n\t/**\n\t * Start a new chat session\n\t */\n\tconst handleNewChat = async () => {\n\t\t// Abort any ongoing requests\n\t\tif (abortControllerRef.current) {\n\t\t\tabortControllerRef.current.abort();\n\t\t}\n\n\t\t// Clear state\n\t\tsetIsLoading(false);\n\t\tsetStatus(null);\n\t\tsetError(null);\n\t\tsetMessages([]);\n\n\t\t// Generate new session ID\n\t\tconst newSessionId = generateSessionId();\n\t\tsetSessionId(newSessionId);\n\n\t\t// Clear localStorage\n\t\tclearChatData();\n\t\tsaveSessionId(newSessionId);\n\n\t\t// Reconnect MCP if needed\n\t\tif (mcpConnectionStatus !== \"connected\") {\n\t\t\tawait initializeMCP();\n\t\t}\n\t};\n\n\t/**\n\t * Accept changes - trigger WordPress save\n\t */\n\tconst handleAcceptChanges = async () => {\n\t\tsetIsSaving(true);\n\n\t\t// Save global styles if they were changed\n\t\tif (hasGlobalStylesChanges) {\n\t\t\ttry {\n\t\t\t\tconst globalStylesId = __experimentalGetCurrentGlobalStylesId\n\t\t\t\t\t? __experimentalGetCurrentGlobalStylesId()\n\t\t\t\t\t: undefined;\n\n\t\t\t\tif (globalStylesId) {\n\t\t\t\t\tawait saveEditedEntityRecord(\"root\", \"globalStyles\", globalStylesId);\n\t\t\t\t}\n\t\t\t} catch (saveError) {\n\t\t\t\tconsole.error(\"Error saving global styles:\", saveError);\n\t\t\t}\n\t\t}\n\n\t\t// Trigger WordPress save/publish\n\t\tif (savePost) {\n\t\t\tsavePost();\n\t\t}\n\t};\n\n\t/**\n\t * Decline changes - restore to initial state\n\t */\n\tconst handleDeclineChanges = async () => {\n\t\t// Find the first message with undo data\n\t\tconst firstActionMessage = messages.find((msg) => msg.hasActions && msg.undoData);\n\n\t\tif (!firstActionMessage || !firstActionMessage.undoData) {\n\t\t\tconsole.error(\"No undo data available\");\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst undoData = firstActionMessage.undoData;\n\n\t\t\t// Handle new structure: { blocks: [], globalStyles: {...} }\n\t\t\tif (undoData && typeof undoData === \"object\" && !Array.isArray(undoData)) {\n\t\t\t\t// Restore blocks if they exist\n\t\t\t\tif (undoData.blocks && Array.isArray(undoData.blocks) && undoData.blocks.length > 0) {\n\t\t\t\t\tawait actionExecutor.restoreBlocks(undoData.blocks);\n\t\t\t\t}\n\n\t\t\t\t// Restore global styles if they exist\n\t\t\t\tif (\n\t\t\t\t\tundoData.globalStyles &&\n\t\t\t\t\tundoData.globalStyles.originalStyles &&\n\t\t\t\t\tundoData.globalStyles.globalStylesId\n\t\t\t\t) {\n\t\t\t\t\tawait actionExecutor.restoreGlobalStyles(undoData.globalStyles);\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(undoData)) {\n\t\t\t\t// Handle old structure: array of blocks (backward compatibility)\n\t\t\t\tawait actionExecutor.restoreBlocks(undoData);\n\t\t\t}\n\n\t\t\t// Remove hasActions and undoData from ALL messages\n\t\t\tsetMessages((prev) =>\n\t\t\t\tprev.map((msg) => {\n\t\t\t\t\tif (msg.hasActions) {\n\t\t\t\t\t\tconst { hasActions, undoData: msgUndoData, ...rest } = msg;\n\t\t\t\t\t\treturn rest;\n\t\t\t\t\t}\n\t\t\t\t\treturn msg;\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Reset global styles changes flag\n\t\t\tsetHasGlobalStylesChanges(false);\n\t\t} catch (restoreError) {\n\t\t\tconsole.error(\"Error restoring changes:\", restoreError);\n\t\t}\n\t};\n\n\t/**\n\t * Stop the current request\n\t */\n\tconst handleStopRequest = () => {\n\t\tif (abortControllerRef.current) {\n\t\t\tabortControllerRef.current.abort();\n\t\t}\n\n\t\t// Update any streaming messages to complete\n\t\tsetMessages((prev) =>\n\t\t\tprev.map((msg) =>\n\t\t\t\tmsg.isStreaming\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...msg,\n\t\t\t\t\t\t\tisStreaming: false,\n\t\t\t\t\t\t}\n\t\t\t\t\t: msg\n\t\t\t)\n\t\t);\n\n\t\tsetIsLoading(false);\n\t\tsetStatus(null);\n\t\tsetError(null);\n\t};\n\n\t/**\n\t * Refresh MCP connection\n\t */\n\tconst refreshMCPConnection = async () => {\n\t\tif (mcpClient.isConnected()) {\n\t\t\tawait mcpClient.disconnect();\n\t\t}\n\t\tsetMcpConnectionStatus(\"disconnected\");\n\t\tawait initializeMCP();\n\t};\n\n\treturn {\n\t\tmessages,\n\t\tisLoading,\n\t\tconversationId: sessionId, // Alias for backward compatibility\n\t\tsessionId,\n\t\terror,\n\t\tstatus,\n\t\tisSaving,\n\t\tmcpConnectionStatus,\n\t\ttools,\n\t\tactiveToolCall,\n\t\thandleSendMessage,\n\t\thandleNewChat,\n\t\thandleAcceptChanges,\n\t\thandleDeclineChanges,\n\t\thandleStopRequest,\n\t\trefreshMCPConnection,\n\t};\n};\n\nexport default useChat;\n","/**\n * WordPress dependencies\n */\nimport { useSelect } from \"@wordpress/data\";\n\n/**\n * Internal dependencies\n */\nimport { getSelectedBlock } from \"../utils/editorHelpers\";\n\n/**\n * Custom hook to get the currently selected block(s)\n *\n * @return {Array} Array of selected block objects or empty array\n */\nconst useSelectedBlock = () => {\n\tconst selectedBlock = useSelect(() => {\n\t\t// Use the shared utility function\n\t\treturn getSelectedBlock();\n\t}, []);\n\n\treturn selectedBlock;\n};\n\nexport default useSelectedBlock;\n","/**\n * WordPress dependencies\n */\nimport { dispatch, select, resolveSelect } from \"@wordpress/data\";\nimport { store as coreStore } from \"@wordpress/core-data\";\nimport { serialize, parse, createBlock } from \"@wordpress/blocks\";\n\n/**\n * Internal dependencies\n */\nimport {\n\tupdateTemplatePartContent,\n\tgetTemplatePartEntity,\n\tisTemplatePart,\n\tfetchTemplatePartContent,\n} from \"../utils/editorHelpers\";\n\n/**\n * Simple Action Executor\n *\n * Executes actions received from the AI chat API.\n * Supports the following action types:\n * - edit_content: Edit block content with two modes:\n *   - patch: Apply find/replace changes to block content\n *   - rewrite: Replace entire block content\n *   Also supports add and delete operations\n * - change_site_colors: Update WordPress global styles color palette\n */\nclass ActionExecutor {\n\t/**\n\t * Execute actions array\n\t *\n\t * @param {Array} actions Array of actions to execute\n\t * @return {Promise<Object>} Result of action execution\n\t */\n\tasync executeActions(actions) {\n\t\tif (!actions || !Array.isArray(actions)) {\n\t\t\treturn { success: true, message: \"No actions to execute\" };\n\t\t}\n\n\t\tconst results = [];\n\t\tconst errors = [];\n\n\t\tfor (const action of actions) {\n\t\t\ttry {\n\t\t\t\tif (!action.action) {\n\t\t\t\t\terrors.push(\"Action missing 'action' property\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst result = await this.executeAction(action);\n\t\t\t\tresults.push(result);\n\t\t\t} catch (error) {\n\t\t\t\terrors.push(error.message);\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tconsole.error(\"Action failed:\", error);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: errors.length === 0,\n\t\t\tmessage: errors.length === 0 ? \"All actions executed successfully\" : \"Some actions failed\",\n\t\t\tresults,\n\t\t\terrors,\n\t\t};\n\t}\n\n\t/**\n\t * Execute a single action\n\t *\n\t * @param {Object} action The action to execute\n\t * @return {Promise<Object>} Result of action execution\n\t */\n\tasync executeAction(action) {\n\t\tif (action.action === \"edit_content\") {\n\t\t\treturn this.handleEditContentAction(action);\n\t\t}\n\n\t\tif (action.action === \"change_site_colors\") {\n\t\t\treturn this.handleChangeSiteColorsAction(action);\n\t\t}\n\n\t\tthrow new Error(`Unsupported action type: ${action.action}`);\n\t}\n\n\t/**\n\t * Handle edit_content action\n\t *\n\t * @param {Object} action The action data\n\t * @return {Promise<Object>} Result of the action\n\t */\n\tasync handleEditContentAction(action) {\n\t\tconst { data } = action;\n\n\t\tif (!data) {\n\t\t\tthrow new Error(\"Edit content action requires data object\");\n\t\t}\n\n\t\tconst operationType = data.operation_type;\n\t\tif (!operationType) {\n\t\t\tthrow new Error(\"Edit content action requires data.operation_type\");\n\t\t}\n\n\t\tconst results = [];\n\t\tconst errors = [];\n\n\t\ttry {\n\t\t\tlet result;\n\t\t\tif (operationType === \"edit\") {\n\t\t\t\t// Parser outputs: data.section and data.block_content\n\t\t\t\t// The parser has already processed patch mode server-side,\n\t\t\t\t// so we treat all edit operations as rewrite (full replacement)\n\t\t\t\tconst clientId = data.section;\n\t\t\t\tif (!clientId) {\n\t\t\t\t\tthrow new Error(\"Edit action requires section\");\n\t\t\t\t}\n\n\t\t\t\tconst blockContent = data.block_content;\n\t\t\t\tif (!blockContent) {\n\t\t\t\t\tthrow new Error(\"Edit action requires block_content\");\n\t\t\t\t}\n\n\t\t\t\tresult = await this.handleRewriteAction(clientId, blockContent);\n\t\t\t\tresults.push(result);\n\t\t\t} else if (operationType === \"delete\") {\n\t\t\t\t// Parser outputs: data.section\n\t\t\t\tconst clientId = data.section;\n\t\t\t\tif (!clientId) {\n\t\t\t\t\tthrow new Error(\"Delete action requires section\");\n\t\t\t\t}\n\t\t\t\tresult = await this.handleDeleteAction(clientId);\n\t\t\t\tresults.push(result);\n\t\t\t} else if (operationType === \"add\") {\n\t\t\t\t// Parser outputs: data.location and data.block_content\n\t\t\t\tconst clientId = data.location; // Can be null for top of page\n\t\t\t\tconst blockContent = data.block_content;\n\t\t\t\tif (!blockContent) {\n\t\t\t\t\tthrow new Error(\"Add action requires block_content\");\n\t\t\t\t}\n\t\t\t\tresult = await this.handleAddAction(clientId || null, [{ block_content: blockContent }]);\n\t\t\t\tresults.push(result);\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Unsupported operation_type: ${operationType}`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\terrors.push(`Failed to execute ${operationType} action: ${error.message}`);\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.error(`Failed to execute ${operationType} action:`, error);\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"edit_content\",\n\t\t\tsuccess: errors.length === 0,\n\t\t\tmessage:\n\t\t\t\terrors.length === 0\n\t\t\t\t\t? \"All content changes applied successfully\"\n\t\t\t\t\t: \"Some content changes failed\",\n\t\t\tresults,\n\t\t\terrors,\n\t\t};\n\t}\n\n\t/**\n\t * Handle \"patch\" action - apply find/replace changes to a block's content\n\t *\n\t * @param {string} clientId The block's client ID\n\t * @param {Array}  changes  Array of {find, replace} objects\n\t * @return {Promise<Object>} Result of the changes\n\t */\n\tasync handlePatchAction(clientId, changes) {\n\t\treturn this.applyContentChanges(clientId, changes);\n\t}\n\n\t/**\n\t * Handle \"rewrite\" action - replace entire block content\n\t *\n\t * @param {string} clientId     The block's client ID\n\t * @param {string} blockContent The new block content HTML\n\t * @return {Promise<Object>} Result of the rewrite\n\t */\n\tasync handleRewriteAction(clientId, blockContent) {\n\t\tconst { getBlock } = select(\"core/block-editor\");\n\t\tconst block = getBlock(clientId);\n\n\t\tif (!block) {\n\t\t\tthrow new Error(`Block with clientId ${clientId} not found`);\n\t\t}\n\n\t\t// Check if this is a template part - handle differently\n\t\tif (isTemplatePart(block)) {\n\t\t\treturn this.applyTemplatePartRewrite(clientId, block, blockContent);\n\t\t}\n\n\t\t// Save the original block state for undo\n\t\tconst originalBlock = {\n\t\t\tclientId,\n\t\t\tname: block.name,\n\t\t\tattributes: { ...block.attributes },\n\t\t\tinnerBlocks: block.innerBlocks ? [...block.innerBlocks] : [],\n\t\t};\n\n\t\t// Parse the new block content into blocks\n\t\tconst updatedBlocks = parse(blockContent);\n\n\t\tif (!updatedBlocks || updatedBlocks.length === 0) {\n\t\t\tthrow new Error(\"Failed to parse block_content into blocks\");\n\t\t}\n\n\t\t// Get the first parsed block (should be the updated version of our block)\n\t\tconst updatedBlock = updatedBlocks[0];\n\n\t\tif (!updatedBlock) {\n\t\t\tthrow new Error(\"Failed to parse updated block\");\n\t\t}\n\n\t\t// Update the original block's attributes to preserve the clientID\n\t\tconst { updateBlockAttributes, replaceInnerBlocks } = dispatch(\"core/block-editor\");\n\n\t\t// Update block attributes\n\t\tif (updatedBlock.attributes) {\n\t\t\tupdateBlockAttributes(clientId, updatedBlock.attributes);\n\t\t}\n\n\t\t// Update inner blocks if they exist\n\t\tif (updatedBlock.innerBlocks && updatedBlock.innerBlocks.length > 0) {\n\t\t\t// Map inner blocks to preserve their structure\n\t\t\tconst innerBlocks = updatedBlock.innerBlocks.map((innerBlock) => {\n\t\t\t\t// Recursively handle nested inner blocks\n\t\t\t\treturn this.createBlockFromParsed(innerBlock);\n\t\t\t});\n\t\t\treplaceInnerBlocks(clientId, innerBlocks);\n\t\t} else if (block.innerBlocks && block.innerBlocks.length > 0) {\n\t\t\t// If the updated block has no inner blocks but original did, clear them\n\t\t\treplaceInnerBlocks(clientId, []);\n\t\t}\n\n\t\treturn {\n\t\t\tclientId,\n\t\t\tblockName: block.name,\n\t\t\tmessage: `Block ${block.name} content rewritten successfully`,\n\t\t\toriginalBlock, // Include original block state for undo\n\t\t};\n\t}\n\n\t/**\n\t * Apply find/replace changes to a block's content\n\t *\n\t * @param {string} clientId The block's client ID\n\t * @param {Array}  changes  Array of {find, replace} objects\n\t * @return {Promise<Object>} Result of the changes\n\t */\n\tasync applyContentChanges(clientId, changes) {\n\t\tconst { getBlock } = select(\"core/block-editor\");\n\t\tconst block = getBlock(clientId);\n\n\t\tif (!block) {\n\t\t\tthrow new Error(`Block with clientId ${clientId} not found`);\n\t\t}\n\n\t\t// Check if this is a template part - handle differently\n\t\tif (isTemplatePart(block)) {\n\t\t\treturn this.applyTemplatePartChanges(clientId, block, changes);\n\t\t}\n\n\t\t// Save the original block state for undo\n\t\tconst originalBlock = {\n\t\t\tclientId,\n\t\t\tname: block.name,\n\t\t\tattributes: { ...block.attributes },\n\t\t\tinnerBlocks: block.innerBlocks ? [...block.innerBlocks] : [],\n\t\t};\n\n\t\t// Serialize the block to HTML\n\t\tlet blockHtml = serialize(block);\n\n\t\t// Apply all find/replace operations\n\t\tfor (const change of changes) {\n\t\t\tconst { find, replace } = change;\n\n\t\t\tif (typeof find !== \"string\" || typeof replace !== \"string\") {\n\t\t\t\tthrow new Error(\"Change must have find and replace as strings\");\n\t\t\t}\n\n\t\t\t// Normalize both strings to handle whitespace/newline differences\n\t\t\tconst normalizedBlockHtml = this.normalizeHtml(blockHtml);\n\t\t\tconst normalizedFind = this.normalizeHtml(find);\n\t\t\tconst normalizedReplace = this.normalizeHtml(replace);\n\n\t\t\t// Perform the replacement on normalized strings\n\t\t\tif (normalizedBlockHtml.includes(normalizedFind)) {\n\t\t\t\t// Replace in the normalized version\n\t\t\t\tblockHtml = normalizedBlockHtml.replace(normalizedFind, normalizedReplace);\n\t\t\t} else {\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tconsole.warn(`Find string not found in block ${clientId}:`, find.substring(0, 50));\n\t\t\t}\n\t\t}\n\n\t\t// Parse the updated HTML back into blocks\n\t\tconst updatedBlocks = parse(blockHtml);\n\n\t\tif (!updatedBlocks || updatedBlocks.length === 0) {\n\t\t\tthrow new Error(\"Failed to parse updated content into blocks\");\n\t\t}\n\n\t\t// Get the first parsed block (should be the updated version of our block)\n\t\tconst updatedBlock = updatedBlocks[0];\n\n\t\tif (!updatedBlock) {\n\t\t\tthrow new Error(\"Failed to parse updated block\");\n\t\t}\n\n\t\t// Update the original block's attributes to preserve the clientID\n\t\tconst { updateBlockAttributes, replaceInnerBlocks } = dispatch(\"core/block-editor\");\n\n\t\t// Update block attributes\n\t\tif (updatedBlock.attributes) {\n\t\t\tupdateBlockAttributes(clientId, updatedBlock.attributes);\n\t\t}\n\n\t\t// Update inner blocks if they exist\n\t\tif (updatedBlock.innerBlocks && updatedBlock.innerBlocks.length > 0) {\n\t\t\t// Map inner blocks to preserve their structure\n\t\t\tconst innerBlocks = updatedBlock.innerBlocks.map((innerBlock) => {\n\t\t\t\t// Recursively handle nested inner blocks\n\t\t\t\treturn this.createBlockFromParsed(innerBlock);\n\t\t\t});\n\t\t\treplaceInnerBlocks(clientId, innerBlocks);\n\t\t} else if (block.innerBlocks && block.innerBlocks.length > 0) {\n\t\t\t// If the updated block has no inner blocks but original did, clear them\n\t\t\treplaceInnerBlocks(clientId, []);\n\t\t}\n\n\t\treturn {\n\t\t\tclientId,\n\t\t\tblockName: block.name,\n\t\t\tchangesApplied: changes.length,\n\t\t\tmessage: `Block ${block.name} content updated successfully`,\n\t\t\toriginalBlock, // Include original block state for undo\n\t\t};\n\t}\n\n\t/**\n\t * Apply rewrite to a template part's content\n\t *\n\t * @param {string} clientId     The template part's client ID\n\t * @param {Object} block        The template part block\n\t * @param {string} blockContent The new block content HTML\n\t * @return {Promise<Object>} Result of the rewrite\n\t */\n\tasync applyTemplatePartRewrite(clientId, block, blockContent) {\n\t\t// Get the template part entity to store original content\n\t\tconst originalEntity = await getTemplatePartEntity(block);\n\n\t\t// Save original state for undo (includes entity data)\n\t\tconst originalBlock = {\n\t\t\tclientId,\n\t\t\tname: block.name,\n\t\t\tattributes: { ...block.attributes },\n\t\t\tinnerBlocks: block.innerBlocks ? [...block.innerBlocks] : [],\n\t\t\tisTemplatePart: true,\n\t\t\tentityContent: originalEntity ? originalEntity.content : null,\n\t\t};\n\n\t\t// Parse the new block content into blocks\n\t\tconst updatedBlocks = parse(blockContent);\n\n\t\tif (!updatedBlocks || updatedBlocks.length === 0) {\n\t\t\tthrow new Error(\"Failed to parse block_content into blocks\");\n\t\t}\n\n\t\t// Update inner blocks in the editor\n\t\tconst { replaceInnerBlocks } = dispatch(\"core/block-editor\");\n\n\t\t// Convert parsed blocks to WordPress block format\n\t\tconst updatedInnerBlocks = updatedBlocks.map((parsedBlock) =>\n\t\t\tthis.createBlockFromParsed(parsedBlock)\n\t\t);\n\n\t\t// Replace all inner blocks of the template part\n\t\treplaceInnerBlocks(clientId, updatedInnerBlocks);\n\n\t\t// Save changes to the template part entity\n\t\t// This ensures the changes persist across page reloads\n\t\tconst entityUpdateResult = await updateTemplatePartContent(block, updatedBlocks);\n\n\t\tif (!entityUpdateResult.success) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.warn(\"Template part entity update failed:\", entityUpdateResult.message);\n\t\t}\n\n\t\treturn {\n\t\t\tclientId,\n\t\t\tblockName: block.name,\n\t\t\tmessage: `Template part content rewritten successfully`,\n\t\t\toriginalBlock,\n\t\t\tisTemplatePart: true,\n\t\t\tentityUpdateResult,\n\t\t};\n\t}\n\n\t/**\n\t * Apply find/replace changes to a template part's content\n\t *\n\t * Uses fetchTemplatePartContent to ensure we work with the same content format\n\t * that was sent as context to the AI, guaranteeing consistency.\n\t *\n\t * @param {string} clientId The template part's client ID\n\t * @param {Object} block    The template part block\n\t * @param {Array}  changes  Array of {find, replace} objects\n\t * @return {Promise<Object>} Result of the changes\n\t */\n\tasync applyTemplatePartChanges(clientId, block, changes) {\n\t\tconst coreResolve = resolveSelect(\"core\");\n\n\t\t// Get the template part entity to store original content\n\t\tconst originalEntity = await getTemplatePartEntity(block);\n\n\t\t// Save original state for undo (includes entity data)\n\t\tconst originalBlock = {\n\t\t\tclientId,\n\t\t\tname: block.name,\n\t\t\tattributes: { ...block.attributes },\n\t\t\tinnerBlocks: block.innerBlocks ? [...block.innerBlocks] : [],\n\t\t\tisTemplatePart: true,\n\t\t\tentityContent: originalEntity ? originalEntity.content : null,\n\t\t};\n\n\t\t// Get the template part content using the same function that builds context\n\t\t// This ensures we're working with the exact same content format\n\t\tconst templatePartContent = await fetchTemplatePartContent(block, coreResolve);\n\t\tif (!templatePartContent) {\n\t\t\tthrow new Error(\"Template part has no content to modify\");\n\t\t}\n\n\t\t// Apply all find/replace operations to the full template part content\n\t\tlet updatedContent = templatePartContent;\n\t\tlet changesApplied = 0;\n\n\t\tfor (const change of changes) {\n\t\t\tconst { find, replace } = change;\n\n\t\t\tif (typeof find !== \"string\" || typeof replace !== \"string\") {\n\t\t\t\tthrow new Error(\"Change must have find and replace as strings\");\n\t\t\t}\n\n\t\t\t// Normalize strings\n\t\t\tconst normalizedContent = this.normalizeHtml(updatedContent);\n\t\t\tconst normalizedFind = this.normalizeHtml(find);\n\t\t\tconst normalizedReplace = this.normalizeHtml(replace);\n\n\t\t\t// Perform the replacement\n\t\t\tif (normalizedContent.includes(normalizedFind)) {\n\t\t\t\tupdatedContent = normalizedContent.replace(normalizedFind, normalizedReplace);\n\t\t\t\tchangesApplied++;\n\t\t\t}\n\t\t}\n\n\t\t// If no changes were applied, return early\n\t\tif (changesApplied === 0) {\n\t\t\treturn {\n\t\t\t\tclientId,\n\t\t\t\tblockName: block.name,\n\t\t\t\tchangesApplied: 0,\n\t\t\t\tmessage: `No matching content found in template part`,\n\t\t\t\toriginalBlock,\n\t\t\t\tisTemplatePart: true,\n\t\t\t};\n\t\t}\n\n\t\t// Parse the updated content back into blocks\n\t\tconst updatedBlocks = parse(updatedContent);\n\n\t\tif (!updatedBlocks || updatedBlocks.length === 0) {\n\t\t\tthrow new Error(\"Failed to parse updated template part content into blocks\");\n\t\t}\n\n\t\t// Update the editor's inner blocks to reflect the changes\n\t\tconst { replaceInnerBlocks } = dispatch(\"core/block-editor\");\n\t\tconst updatedInnerBlocks = updatedBlocks.map((parsedBlock) =>\n\t\t\tthis.createBlockFromParsed(parsedBlock)\n\t\t);\n\t\treplaceInnerBlocks(clientId, updatedInnerBlocks);\n\n\t\t// Save changes to the template part entity\n\t\t// This ensures the changes persist across page reloads\n\t\tconst entityUpdateResult = await updateTemplatePartContent(block, updatedInnerBlocks);\n\n\t\tif (!entityUpdateResult.success) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.warn(\"Template part entity update failed:\", entityUpdateResult.message);\n\t\t}\n\n\t\treturn {\n\t\t\tclientId,\n\t\t\tblockName: block.name,\n\t\t\tchangesApplied,\n\t\t\tmessage: `Template part content updated successfully`,\n\t\t\toriginalBlock,\n\t\t\tisTemplatePart: true,\n\t\t\tentityUpdateResult,\n\t\t};\n\t}\n\n\t/**\n\t * Restore blocks to their previous state\n\t *\n\t * @param {Array} undoData Array of original block states\n\t * @return {Promise<Object>} Result of the restore operation\n\t */\n\tasync restoreBlocks(undoData) {\n\t\tif (!undoData || !Array.isArray(undoData)) {\n\t\t\treturn { success: false, message: \"No undo data available\" };\n\t\t}\n\n\t\tconst { updateBlockAttributes, replaceInnerBlocks } = dispatch(\"core/block-editor\");\n\t\tconst { getBlock } = select(\"core/block-editor\");\n\t\tconst results = [];\n\t\tconst errors = [];\n\n\t\tfor (const blockData of undoData) {\n\t\t\ttry {\n\t\t\t\tconst {\n\t\t\t\t\tclientId,\n\t\t\t\t\tattributes,\n\t\t\t\t\tinnerBlocks,\n\t\t\t\t\tisTemplatePart: isTemplatePartBlock,\n\t\t\t\t\tentityContent,\n\t\t\t\t} = blockData;\n\n\t\t\t\tif (!clientId) {\n\t\t\t\t\terrors.push(\"Missing clientId in undo data\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// If this is a template part, restore the entity content first\n\t\t\t\tif (isTemplatePartBlock && entityContent) {\n\t\t\t\t\tconst block = getBlock(clientId);\n\t\t\t\t\tif (block) {\n\t\t\t\t\t\t// Parse the original content back into blocks\n\t\t\t\t\t\tconst contentString =\n\t\t\t\t\t\t\ttypeof entityContent === \"string\"\n\t\t\t\t\t\t\t\t? entityContent\n\t\t\t\t\t\t\t\t: entityContent.raw || entityContent.rendered;\n\n\t\t\t\t\t\tif (contentString) {\n\t\t\t\t\t\t\tconst originalBlocks = parse(contentString);\n\n\t\t\t\t\t\t\t// Update the entity (database)\n\t\t\t\t\t\t\tconst updateResult = await updateTemplatePartContent(block, originalBlocks);\n\n\t\t\t\t\t\t\tif (!updateResult.success) {\n\t\t\t\t\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\t\t\t\t\tconsole.warn(\"Failed to restore template part entity:\", updateResult.message);\n\t\t\t\t\t\t\t\terrors.push(`Template part entity restore failed: ${updateResult.message}`);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Also update the editor's inner blocks to immediately reflect the changes\n\t\t\t\t\t\t\t// This ensures the visual editor shows the restored content\n\t\t\t\t\t\t\tconst restoredInnerBlocks = originalBlocks.map((inner) =>\n\t\t\t\t\t\t\t\tthis.createBlockFromParsed(inner)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treplaceInnerBlocks(clientId, restoredInnerBlocks);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\t\t\t\tconsole.error(\"No content string to restore for template part\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\t\t\tconsole.error(\"Could not find block with clientId:\", clientId);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// For non-template-part blocks, restore attributes and inner blocks\n\t\t\t\t\t// Restore attributes\n\t\t\t\t\tupdateBlockAttributes(clientId, attributes);\n\n\t\t\t\t\t// Restore inner blocks\n\t\t\t\t\tif (innerBlocks && Array.isArray(innerBlocks)) {\n\t\t\t\t\t\tconst restoredInnerBlocks = innerBlocks.map((inner) =>\n\t\t\t\t\t\t\tthis.createBlockFromParsed(inner)\n\t\t\t\t\t\t);\n\t\t\t\t\t\treplaceInnerBlocks(clientId, restoredInnerBlocks);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst messageType = isTemplatePartBlock ? \"Template part\" : \"Block\";\n\t\t\t\tresults.push({\n\t\t\t\t\tclientId,\n\t\t\t\t\tmessage: `${messageType} restored successfully`,\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\terrors.push(`Failed to restore block: ${error.message}`);\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tconsole.error(\"Failed to restore block:\", error);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: errors.length === 0,\n\t\t\tmessage:\n\t\t\t\terrors.length === 0 ? \"All blocks restored successfully\" : \"Some blocks failed to restore\",\n\t\t\tresults,\n\t\t\terrors,\n\t\t};\n\t}\n\n\t/**\n\t * Normalize HTML string by removing extra whitespace and newlines\n\t *\n\t * Normalizes whitespace to ensure consistent comparison between\n\t * the content sent as context and the find/replace strings.\n\t *\n\t * @param {string} html The HTML string to normalize\n\t * @return {string} Normalized HTML string\n\t */\n\tnormalizeHtml(html) {\n\t\t// First normalize whitespace\n\t\tconst normalized = html\n\t\t\t.replace(/\\s+/g, \" \") // Replace all whitespace sequences with single space\n\t\t\t.replace(/>\\s+</g, \"><\") // Remove spaces between tags\n\t\t\t.replace(/\\\\\\//g, \"/\") // Remove backslashes from slashes\n\t\t\t.trim(); // Remove leading/trailing whitespace\n\n\t\treturn normalized;\n\t}\n\n\t/**\n\t * Handle \"delete\" action - remove a block from the editor\n\t *\n\t * @param {string} clientId The block's client ID to delete\n\t * @return {Promise<Object>} Result of the deletion\n\t */\n\tasync handleDeleteAction(clientId) {\n\t\tconst { getBlock } = select(\"core/block-editor\");\n\t\tconst block = getBlock(clientId);\n\n\t\tif (!block) {\n\t\t\tthrow new Error(`Block with clientId ${clientId} not found`);\n\t\t}\n\n\t\t// Check if this is a template part - handle differently\n\t\tif (isTemplatePart(block)) {\n\t\t\treturn this.handleDeleteTemplatePart(clientId, block);\n\t\t}\n\n\t\t// Save the original block state for undo\n\t\tconst originalBlock = {\n\t\t\tclientId,\n\t\t\tname: block.name,\n\t\t\tattributes: { ...block.attributes },\n\t\t\tinnerBlocks: block.innerBlocks ? [...block.innerBlocks] : [],\n\t\t};\n\n\t\t// Remove the block\n\t\tconst { removeBlock } = dispatch(\"core/block-editor\");\n\t\tremoveBlock(clientId);\n\n\t\treturn {\n\t\t\tclientId,\n\t\t\tblockName: block.name,\n\t\t\tmessage: `Block ${block.name} deleted successfully`,\n\t\t\toriginalBlock, // Include original block state for undo\n\t\t};\n\t}\n\n\t/**\n\t * Handle deletion of a template part\n\t *\n\t * @param {string} clientId The template part's client ID\n\t * @param {Object} block    The template part block\n\t * @return {Promise<Object>} Result of the deletion\n\t */\n\tasync handleDeleteTemplatePart(clientId, block) {\n\t\t// Get the template part entity to store original content\n\t\tconst originalEntity = await getTemplatePartEntity(block);\n\n\t\t// Save original state for undo (includes entity data)\n\t\tconst originalBlock = {\n\t\t\tclientId,\n\t\t\tname: block.name,\n\t\t\tattributes: { ...block.attributes },\n\t\t\tinnerBlocks: block.innerBlocks ? [...block.innerBlocks] : [],\n\t\t\tisTemplatePart: true,\n\t\t\tentityContent: originalEntity ? originalEntity.content : null,\n\t\t};\n\n\t\t// Remove the template part block\n\t\tconst { removeBlock } = dispatch(\"core/block-editor\");\n\t\tremoveBlock(clientId);\n\n\t\treturn {\n\t\t\tclientId,\n\t\t\tblockName: block.name,\n\t\t\tmessage: `Template part deleted successfully`,\n\t\t\toriginalBlock,\n\t\t\tisTemplatePart: true,\n\t\t};\n\t}\n\n\t/**\n\t * Get effective root blocks (root blocks + first level of post-content blocks)\n\t *\n\t * @return {Object} Object with blocks array and parentClientId (null for root, post-content clientId for post-content)\n\t */\n\tgetEffectiveRootBlocks() {\n\t\tconst { getBlocks } = select(\"core/block-editor\");\n\t\tconst rootBlocks = getBlocks();\n\n\t\t// Find the post-content block\n\t\tconst postContentBlock = rootBlocks.find((block) => block.name === \"core/post-content\");\n\n\t\tif (postContentBlock) {\n\t\t\t// Get inner blocks of post-content\n\t\t\tconst postContentInnerBlocks = getBlocks(postContentBlock.clientId);\n\t\t\tif (postContentInnerBlocks.length > 0) {\n\t\t\t\t// Return post-content inner blocks as effective root\n\t\t\t\treturn {\n\t\t\t\t\tblocks: postContentInnerBlocks,\n\t\t\t\t\tparentClientId: postContentBlock.clientId,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// No post-content or it's empty, use actual root blocks\n\t\treturn {\n\t\t\tblocks: rootBlocks,\n\t\t\tparentClientId: null,\n\t\t};\n\t}\n\n\t/**\n\t * Find which context a block belongs to (root or post-content)\n\t *\n\t * @param {string} clientId The block's client ID\n\t * @return {Object|null} Object with blocks array and parentClientId, or null if not found\n\t */\n\tfindBlockContext(clientId) {\n\t\tconst { getBlocks } = select(\"core/block-editor\");\n\t\tconst rootBlocks = getBlocks();\n\n\t\t// Check if it's a root block\n\t\tconst rootIndex = rootBlocks.findIndex((block) => block.clientId === clientId);\n\t\tif (rootIndex !== -1) {\n\t\t\treturn {\n\t\t\t\tblocks: rootBlocks,\n\t\t\t\tparentClientId: null,\n\t\t\t\tindex: rootIndex,\n\t\t\t};\n\t\t}\n\n\t\t// Check if it's inside post-content\n\t\tconst postContentBlock = rootBlocks.find((block) => block.name === \"core/post-content\");\n\t\tif (postContentBlock) {\n\t\t\tconst postContentInnerBlocks = getBlocks(postContentBlock.clientId);\n\t\t\tconst innerIndex = postContentInnerBlocks.findIndex((block) => block.clientId === clientId);\n\t\t\tif (innerIndex !== -1) {\n\t\t\t\treturn {\n\t\t\t\t\tblocks: postContentInnerBlocks,\n\t\t\t\t\tparentClientId: postContentBlock.clientId,\n\t\t\t\t\tindex: innerIndex,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Handle \"add\" action - add new block(s) to the editor\n\t *\n\t * @param {string|null} clientId The client ID to add after (null for top of page)\n\t * @param {Array}       changes  Array of {block_content} objects\n\t * @return {Promise<Object>} Result of the addition\n\t */\n\tasync handleAddAction(clientId, changes) {\n\t\tconst { getBlocks, getBlock } = select(\"core/block-editor\");\n\t\tconst { insertBlocks } = dispatch(\"core/block-editor\");\n\t\tconst errors = [];\n\n\t\t// Parse all block contents\n\t\tconst blocksToInsert = [];\n\t\tfor (const change of changes) {\n\t\t\tif (!change.block_content || typeof change.block_content !== \"string\") {\n\t\t\t\terrors.push(\"Add action change missing block_content string\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Parse the block content into blocks\n\t\t\t\tconst parsedBlocks = parse(change.block_content);\n\t\t\t\tif (!parsedBlocks || parsedBlocks.length === 0) {\n\t\t\t\t\terrors.push(\"Failed to parse block_content into blocks\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Convert parsed blocks to WordPress block format\n\t\t\t\tconst wpBlocks = parsedBlocks.map((parsedBlock) => this.createBlockFromParsed(parsedBlock));\n\t\t\t\tblocksToInsert.push(...wpBlocks);\n\t\t\t} catch (error) {\n\t\t\t\terrors.push(`Failed to parse block_content: ${error.message}`);\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tconsole.error(\"Failed to parse block_content:\", error);\n\t\t\t}\n\t\t}\n\n\t\tif (blocksToInsert.length === 0) {\n\t\t\tthrow new Error(\"No valid blocks to insert\");\n\t\t}\n\n\t\t// Determine insertion position\n\t\tif (clientId === null) {\n\t\t\t// Insert at the top of the page\n\t\t\tconst effectiveRoot = this.getEffectiveRootBlocks();\n\t\t\tif (effectiveRoot.blocks.length > 0) {\n\t\t\t\t// Insert at the beginning of the effective root blocks\n\t\t\t\tif (effectiveRoot.parentClientId) {\n\t\t\t\t\t// Insert into post-content\n\t\t\t\t\tinsertBlocks(blocksToInsert, 0, effectiveRoot.parentClientId);\n\t\t\t\t} else {\n\t\t\t\t\t// Insert at root\n\t\t\t\t\tinsertBlocks(blocksToInsert, 0, effectiveRoot.blocks[0].clientId);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Page is empty, check if we have post-content block\n\t\t\t\tconst rootBlocks = getBlocks();\n\t\t\t\tconst postContentBlock = rootBlocks.find((block) => block.name === \"core/post-content\");\n\t\t\t\tif (postContentBlock) {\n\t\t\t\t\t// Insert into post-content\n\t\t\t\t\tinsertBlocks(blocksToInsert, 0, postContentBlock.clientId);\n\t\t\t\t} else {\n\t\t\t\t\t// Insert at root\n\t\t\t\t\tinsertBlocks(blocksToInsert, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Insert after the specified block\n\t\t\tconst targetBlock = getBlock(clientId);\n\t\t\tif (!targetBlock) {\n\t\t\t\tthrow new Error(`Target block with clientId ${clientId} not found`);\n\t\t\t}\n\n\t\t\t// Find which context the target block belongs to\n\t\t\tconst context = this.findBlockContext(clientId);\n\t\t\tif (!context) {\n\t\t\t\tthrow new Error(`Target block ${clientId} not found in root blocks or post-content`);\n\t\t\t}\n\n\t\t\t// Insert after the target block in its context\n\t\t\tconst insertIndex = context.index + 1;\n\t\t\tif (context.parentClientId) {\n\t\t\t\t// Insert into post-content (always use parentClientId for post-content)\n\t\t\t\tinsertBlocks(blocksToInsert, insertIndex, context.parentClientId);\n\t\t\t} else if (insertIndex < context.blocks.length) {\n\t\t\t\t// Insert at root level before the next block\n\t\t\t\tinsertBlocks(blocksToInsert, insertIndex, context.blocks[insertIndex].clientId);\n\t\t\t} else {\n\t\t\t\t// Insert at the end of root\n\t\t\t\tinsertBlocks(blocksToInsert, insertIndex);\n\t\t\t}\n\t\t}\n\n\t\t// Return result with original state (empty since these are new blocks)\n\t\t// For undo, we'll need to track the clientIds of the inserted blocks\n\t\t// Note: createBlock generates new clientIds, so we need to get them after insertion\n\t\tconst insertedClientIds = blocksToInsert\n\t\t\t.map((block) => {\n\t\t\t\t// After insertion, blocks will have clientIds assigned by WordPress\n\t\t\t\t// We'll need to track these for undo functionality\n\t\t\t\treturn block.clientId || null;\n\t\t\t})\n\t\t\t.filter(Boolean);\n\n\t\treturn {\n\t\t\tclientId: clientId || \"root\",\n\t\t\tblocksAdded: blocksToInsert.length,\n\t\t\tinsertedClientIds,\n\t\t\tmessage: `Added ${blocksToInsert.length} block(s) successfully`,\n\t\t\terrors: errors.length > 0 ? errors : undefined,\n\t\t};\n\t}\n\n\t/**\n\t * Create a block structure from a parsed block (recursive for inner blocks)\n\t *\n\t * @param {Object} parsedBlock The parsed block object\n\t * @return {Object} Block structure compatible with WordPress block editor\n\t */\n\tcreateBlockFromParsed(parsedBlock) {\n\t\tconst innerBlocks = parsedBlock.innerBlocks\n\t\t\t? parsedBlock.innerBlocks.map((inner) => this.createBlockFromParsed(inner))\n\t\t\t: [];\n\n\t\treturn createBlock(parsedBlock.name, parsedBlock.attributes || {}, innerBlocks);\n\t}\n\n\t/**\n\t * Handle change_site_colors action\n\t *\n\t * Uses the same logic as useColorSettings hook's updateCustomColor function\n\t *\n\t * @param {Object} action The action data\n\t * @return {Promise<Object>} Result of the action\n\t */\n\tasync handleChangeSiteColorsAction(action) {\n\t\tconst { data } = action;\n\n\t\tif (!data || !data.colors || !Array.isArray(data.colors)) {\n\t\t\tthrow new Error(\"Change site colors action requires data.colors array\");\n\t\t}\n\n\t\t// Get global styles ID and settings using the same pattern as useColorSettings\n\t\tconst { __experimentalGetCurrentGlobalStylesId, getEditedEntityRecord } = select(coreStore);\n\t\tconst globalStylesId = __experimentalGetCurrentGlobalStylesId\n\t\t\t? __experimentalGetCurrentGlobalStylesId()\n\t\t\t: undefined;\n\n\t\tif (!globalStylesId) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Global styles not found. Please ensure you have permission to edit global styles.\"\n\t\t\t);\n\t\t}\n\n\t\t// Get current global styles record (same as useColorSettings)\n\t\tconst record = getEditedEntityRecord(\"root\", \"globalStyles\", globalStylesId);\n\n\t\tif (!record || !record.settings) {\n\t\t\tthrow new Error(\"Unable to access global styles settings.\");\n\t\t}\n\n\t\tconst settings = record.settings;\n\t\tconst rawPalette = settings?.color?.palette?.theme;\n\t\tconst themePalette = rawPalette || [];\n\n\t\t// Save original state for undo\n\t\tconst originalStyles = JSON.parse(JSON.stringify(settings));\n\n\t\t// Update colors using the same logic as updateCustomColor from useColorSettings\n\t\t// For each color update, map over themePalette and update matching slugs\n\t\tlet updatedPalette = themePalette;\n\t\tfor (const colorUpdate of data.colors) {\n\t\t\tconst { slug, color: newColor } = colorUpdate;\n\n\t\t\tif (!slug || !newColor) {\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tconsole.warn(\"Invalid color update:\", colorUpdate);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Use the same pattern as updateCustomColor: map and update matching slug\n\t\t\tupdatedPalette = updatedPalette.map((color) =>\n\t\t\t\tcolor.slug === slug ? { ...color, color: newColor } : color\n\t\t\t);\n\t\t}\n\n\t\t// Use the same pattern as setConfig from useColorSettings\n\t\tconst { editEntityRecord } = dispatch(coreStore);\n\n\t\teditEntityRecord(\"root\", \"globalStyles\", globalStylesId, {\n\t\t\tsettings: {\n\t\t\t\t...(settings || {}),\n\t\t\t\tcolor: {\n\t\t\t\t\tpalette: {\n\t\t\t\t\t\t...(settings?.color?.palette || {}),\n\t\t\t\t\t\ttheme: updatedPalette,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\n\t\treturn {\n\t\t\ttype: \"change_site_colors\",\n\t\t\tsuccess: true,\n\t\t\tmessage: \"Site colors updated successfully\",\n\t\t\tcolorsUpdated: data.colors.length,\n\t\t\toriginalStyles, // Include original state for undo\n\t\t\tglobalStylesId, // Include global styles ID for restore\n\t\t};\n\t}\n\n\t/**\n\t * Restore global styles to their previous state\n\t *\n\t * @param {Object} undoData Object containing originalStyles and globalStylesId\n\t * @return {Promise<Object>} Result of the restore operation\n\t */\n\tasync restoreGlobalStyles(undoData) {\n\t\tif (!undoData || !undoData.originalStyles || !undoData.globalStylesId) {\n\t\t\treturn { success: false, message: \"No undo data available for global styles\" };\n\t\t}\n\n\t\tconst { originalStyles, globalStylesId } = undoData;\n\t\tconst { editEntityRecord } = dispatch(coreStore);\n\n\t\ttry {\n\t\t\t// Restore the original settings\n\t\t\teditEntityRecord(\"root\", \"globalStyles\", globalStylesId, {\n\t\t\t\tsettings: originalStyles,\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: \"Global styles restored successfully\",\n\t\t\t};\n\t\t} catch (error) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.error(\"Failed to restore global styles:\", error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Failed to restore global styles: ${error.message}`,\n\t\t\t};\n\t\t}\n\t}\n}\n\n// Create and export a singleton instance\nconst actionExecutor = new ActionExecutor();\nexport default actionExecutor;\n","/* eslint-disable no-console */\n/**\n * Global Styles Service\n *\n * Provides real-time updates to WordPress global styles using the Gutenberg data store.\n * Changes made through this service are immediately reflected in the Site Editor.\n */\n\n/**\n * Get the WordPress data module\n * @return {Object|null} WordPress data object or null if not available\n */\nfunction getWPData() {\n\tif (typeof window !== \"undefined\" && window.wp && window.wp.data) {\n\t\treturn window.wp.data;\n\t}\n\treturn null;\n}\n\n/**\n * Get the global styles ID from the current site editor context\n * @return {number|null} Global styles post ID or null\n */\nexport function getGlobalStylesId() {\n\tconst data = getWPData();\n\tif (!data) {\n\t\tconsole.warn(\"WordPress data store not available\");\n\t\treturn null;\n\t}\n\n\ttry {\n\t\tconst coreStore = data.select(\"core\");\n\n\t\t// Method 1: Use __experimentalGetCurrentGlobalStylesId if available\n\t\tif (typeof coreStore.__experimentalGetCurrentGlobalStylesId === \"function\") {\n\t\t\tconst id = coreStore.__experimentalGetCurrentGlobalStylesId();\n\t\t\tif (id) {\n\t\t\t\tconsole.log(\"Found global styles ID via __experimentalGetCurrentGlobalStylesId:\", id);\n\t\t\t\treturn id;\n\t\t\t}\n\t\t}\n\n\t\t// Method 2: Try to get from edit-site store\n\t\tconst editSiteStore = data.select(\"core/edit-site\");\n\t\tif (editSiteStore) {\n\t\t\t// Try getSettings\n\t\t\tif (typeof editSiteStore.getSettings === \"function\") {\n\t\t\t\tconst settings = editSiteStore.getSettings();\n\t\t\t\tif (settings?.__experimentalGlobalStylesUserEntityId) {\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\"Found global styles ID via edit-site settings:\",\n\t\t\t\t\t\tsettings.__experimentalGlobalStylesUserEntityId\n\t\t\t\t\t);\n\t\t\t\t\treturn settings.__experimentalGlobalStylesUserEntityId;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Try getEditedPostId for global styles\n\t\t\tif (typeof editSiteStore.getEditedPostId === \"function\") {\n\t\t\t\tconst postId = editSiteStore.getEditedPostId();\n\t\t\t\tconst postType = editSiteStore.getEditedPostType?.();\n\t\t\t\tif (postType === \"wp_global_styles\" && postId) {\n\t\t\t\t\tconsole.log(\"Found global styles ID via edit-site post:\", postId);\n\t\t\t\t\treturn postId;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Method 3: Get from entity records\n\t\tconst records = coreStore.getEntityRecords(\"root\", \"globalStyles\", { per_page: 1 });\n\t\tif (records && records.length > 0) {\n\t\t\tconsole.log(\"Found global styles ID via entity records:\", records[0].id);\n\t\t\treturn records[0].id;\n\t\t}\n\n\t\tconsole.warn(\"Could not find global styles ID\");\n\t} catch (error) {\n\t\tconsole.error(\"Error getting global styles ID:\", error);\n\t}\n\n\treturn null;\n}\n\n/**\n * Get current global styles from the data store\n * @return {Object} Current global styles object\n */\nexport function getCurrentGlobalStyles() {\n\tconst data = getWPData();\n\tif (!data) {\n\t\treturn { palette: [], error: \"WordPress data store not available\" };\n\t}\n\n\ttry {\n\t\tconst coreStore = data.select(\"core\");\n\t\tlet palette = [];\n\t\tlet themePalette = [];\n\t\tlet customPalette = [];\n\t\tlet rawSettings = null;\n\n\t\t// Method 1: Get from global styles entity record\n\t\tconst globalStylesId = getGlobalStylesId();\n\t\tif (globalStylesId) {\n\t\t\tconst record = coreStore.getEditedEntityRecord(\"root\", \"globalStyles\", globalStylesId);\n\t\t\tconsole.log(\"Global styles record:\", record);\n\n\t\t\tif (record && record.settings) {\n\t\t\t\trawSettings = record.settings;\n\t\t\t\tconst paletteData = record.settings?.color?.palette;\n\n\t\t\t\tif (paletteData) {\n\t\t\t\t\t// Handle nested structure (theme/custom)\n\t\t\t\t\tif (paletteData.theme) {\n\t\t\t\t\t\tthemePalette = paletteData.theme;\n\t\t\t\t\t}\n\t\t\t\t\tif (paletteData.custom) {\n\t\t\t\t\t\tcustomPalette = paletteData.custom;\n\t\t\t\t\t}\n\t\t\t\t\t// Handle flat array structure\n\t\t\t\t\tif (Array.isArray(paletteData)) {\n\t\t\t\t\t\tthemePalette = paletteData;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Method 2: Fallback to base styles / theme.json data\n\t\tif (themePalette.length === 0) {\n\t\t\t// Try to get theme.json settings via the block editor\n\t\t\tconst blockEditorStore = data.select(\"core/block-editor\");\n\t\t\tif (blockEditorStore && typeof blockEditorStore.getSettings === \"function\") {\n\t\t\t\tconst editorSettings = blockEditorStore.getSettings();\n\t\t\t\tconsole.log(\"Block editor settings:\", editorSettings);\n\n\t\t\t\tif (editorSettings?.colors) {\n\t\t\t\t\tthemePalette = editorSettings.colors;\n\t\t\t\t}\n\t\t\t\tif (editorSettings?.__experimentalFeatures?.color?.palette) {\n\t\t\t\t\tconst featurePalette = editorSettings.__experimentalFeatures.color.palette;\n\t\t\t\t\tif (featurePalette.theme) {\n\t\t\t\t\t\tthemePalette = featurePalette.theme;\n\t\t\t\t\t}\n\t\t\t\t\tif (featurePalette.custom) {\n\t\t\t\t\t\tcustomPalette = featurePalette.custom;\n\t\t\t\t\t}\n\t\t\t\t\tif (Array.isArray(featurePalette)) {\n\t\t\t\t\t\tthemePalette = featurePalette;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpalette = [...themePalette, ...customPalette];\n\t\tconsole.log(\"Final palette:\", palette);\n\n\t\treturn {\n\t\t\tpalette,\n\t\t\tthemePalette,\n\t\t\tcustomPalette,\n\t\t\trawSettings,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Error getting current global styles:\", error);\n\t\treturn { palette: [], error: error.message };\n\t}\n}\n\n/**\n * Update the global color palette in real-time\n *\n * @param {Array}   colors     Array of color objects: [{ slug: string, color: string, name: string }]\n * @param {boolean} replaceAll If true, replace entire custom palette. If false, merge with existing.\n * @return {Promise<Object>} Result object with success status and updated palette\n */\nexport async function updateGlobalPalette(colors, replaceAll = false) {\n\tconst data = getWPData();\n\tif (!data) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"WordPress data store not available. Make sure you're in the Site Editor.\",\n\t\t};\n\t}\n\n\ttry {\n\t\tconst coreStore = data.select(\"core\");\n\t\tconst coreDispatch = data.dispatch(\"core\");\n\t\tconst globalStylesId = getGlobalStylesId();\n\n\t\tconsole.log(\"Updating global palette with ID:\", globalStylesId);\n\t\tconsole.log(\"Colors to update:\", colors);\n\n\t\tif (!globalStylesId) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Could not find global styles. Make sure you're in the Site Editor.\",\n\t\t\t};\n\t\t}\n\n\t\t// Get current record\n\t\tconst currentRecord = coreStore.getEditedEntityRecord(\"root\", \"globalStyles\", globalStylesId);\n\t\tconsole.log(\"Current record:\", currentRecord);\n\n\t\tif (!currentRecord) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Could not load current global styles.\",\n\t\t\t};\n\t\t}\n\n\t\t// Build the new settings\n\t\tconst currentSettings = currentRecord.settings || {};\n\t\tconst currentColorSettings = currentSettings.color || {};\n\t\tconst currentPalette = currentColorSettings.palette || {};\n\n\t\t// Get existing custom palette - handle different structures\n\t\tlet existingCustomPalette = [];\n\t\tif (Array.isArray(currentPalette.custom)) {\n\t\t\texistingCustomPalette = currentPalette.custom;\n\t\t} else if (Array.isArray(currentPalette)) {\n\t\t\t// Some themes use flat palette structure\n\t\t\texistingCustomPalette = [];\n\t\t}\n\n\t\t// Also get theme palette for reference\n\t\tconst themePalette = currentPalette.theme || [];\n\t\tconsole.log(\"Existing custom palette:\", existingCustomPalette);\n\t\tconsole.log(\"Theme palette:\", themePalette);\n\n\t\t// Validate and prepare new colors\n\t\tconst validatedColors = colors\n\t\t\t.filter((c) => c.slug && c.color)\n\t\t\t.map((c) => ({\n\t\t\t\tslug: c.slug,\n\t\t\t\tcolor: c.color,\n\t\t\t\tname: c.name || c.slug.charAt(0).toUpperCase() + c.slug.slice(1).replace(/-/g, \" \"),\n\t\t\t}));\n\n\t\tif (validatedColors.length === 0) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"No valid colors provided. Each color needs a slug and color value.\",\n\t\t\t};\n\t\t}\n\n\t\tlet newCustomPalette;\n\t\tif (replaceAll) {\n\t\t\tnewCustomPalette = validatedColors;\n\t\t} else {\n\t\t\t// Merge: update existing by slug, add new ones\n\t\t\t// Start with existing custom palette\n\t\t\tconst paletteBySlug = new Map(existingCustomPalette.map((c) => [c.slug, c]));\n\n\t\t\t// Update/add new colors\n\t\t\tfor (const newColor of validatedColors) {\n\t\t\t\tpaletteBySlug.set(newColor.slug, newColor);\n\t\t\t}\n\n\t\t\tnewCustomPalette = Array.from(paletteBySlug.values());\n\t\t}\n\n\t\tconsole.log(\"New custom palette:\", newCustomPalette);\n\n\t\t// Build new settings object - preserve theme palette structure\n\t\tconst newSettings = {\n\t\t\t...currentSettings,\n\t\t\tcolor: {\n\t\t\t\t...currentColorSettings,\n\t\t\t\tpalette: {\n\t\t\t\t\ttheme: themePalette, // Preserve theme palette\n\t\t\t\t\tcustom: newCustomPalette,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tconsole.log(\"New settings:\", newSettings);\n\n\t\t// Update the entity record (this makes it appear immediately in the editor)\n\t\tawait coreDispatch.editEntityRecord(\"root\", \"globalStyles\", globalStylesId, {\n\t\t\tsettings: newSettings,\n\t\t});\n\n\t\tconsole.log(\"Entity record updated, now saving...\");\n\n\t\t// Save the changes to persist them\n\t\tawait coreDispatch.saveEditedEntityRecord(\"root\", \"globalStyles\", globalStylesId);\n\n\t\tconsole.log(\"Global styles saved successfully!\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tupdatedColors: validatedColors,\n\t\t\tcurrentPalette: newCustomPalette,\n\t\t\tmessage: `Successfully updated ${validatedColors.length} color(s) in the global palette. The changes should be visible immediately.`,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Error updating global palette:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: `Failed to update palette: ${error.message}`,\n\t\t};\n\t}\n}\n\n/**\n * Check if we're in an environment where global styles can be edited\n * @return {boolean} True if global styles editing is available\n */\nexport function isGlobalStylesAvailable() {\n\tconst data = getWPData();\n\tif (!data) {\n\t\treturn false;\n\t}\n\n\ttry {\n\t\t// Check if we have access to the core store and global styles\n\t\tconst coreStore = data.select(\"core\");\n\t\treturn typeof coreStore.getEditedEntityRecord === \"function\";\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Get a formatted list of current palette colors for display\n * @return {Array} Array of formatted color strings\n */\nexport function getFormattedPalette() {\n\tconst { palette } = getCurrentGlobalStyles();\n\treturn palette.map((c) => `${c.name || c.slug}: ${c.color}`);\n}\n\nexport default {\n\tgetGlobalStylesId,\n\tgetCurrentGlobalStyles,\n\tupdateGlobalPalette,\n\tisGlobalStylesAvailable,\n\tgetFormattedPalette,\n};\n","/* eslint-disable no-console */\n/**\n * WordPress MCP Client using the official TypeScript SDK\n *\n * This client uses StreamableHTTPClientTransport to communicate with\n * the WordPress MCP adapter endpoint.\n */\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { StreamableHTTPClientTransport } from \"@modelcontextprotocol/sdk/client/streamableHttp.js\";\n\n/**\n * Custom error class for MCP errors\n */\nexport class MCPError extends Error {\n\tconstructor(message, code = null) {\n\t\tsuper(message);\n\t\tthis.name = \"MCPError\";\n\t\tthis.code = code;\n\t}\n}\n\n/**\n * WordPress MCP Client implementation using the official TypeScript SDK\n */\nclass WordPressMCPClient {\n\tconstructor() {\n\t\tthis.client = null;\n\t\tthis.transport = null;\n\t\tthis.connected = false;\n\t\tthis.tools = [];\n\t\tthis.resources = [];\n\t\tthis.eventListeners = new Map();\n\t\tthis.config = null;\n\t}\n\n\t/**\n\t * Get configuration from WordPress\n\t *\n\t * @return {Object} Configuration object\n\t */\n\tgetConfig() {\n\t\tif (this.config) {\n\t\t\treturn this.config;\n\t\t}\n\n\t\t// Get config from WordPress localized script\n\t\tif (typeof window !== \"undefined\" && window.nfdEditorChat) {\n\t\t\tthis.config = {\n\t\t\t\tnonce: window.nfdEditorChat.nonce,\n\t\t\t\tmcpUrl: window.nfdEditorChat.mcpUrl,\n\t\t\t\trestUrl: window.nfdEditorChat.restUrl,\n\t\t\t\thomeUrl: window.nfdEditorChat.homeUrl,\n\t\t\t};\n\t\t} else {\n\t\t\tthis.config = {\n\t\t\t\tnonce: \"\",\n\t\t\t\tmcpUrl: \"\",\n\t\t\t\trestUrl: \"\",\n\t\t\t\thomeUrl: \"\",\n\t\t\t};\n\t\t}\n\n\t\treturn this.config;\n\t}\n\n\t/**\n\t * Add event listener\n\t *\n\t * @param {string}   event    Event name\n\t * @param {Function} listener Callback function\n\t */\n\ton(event, listener) {\n\t\tif (!this.eventListeners.has(event)) {\n\t\t\tthis.eventListeners.set(event, new Set());\n\t\t}\n\t\tthis.eventListeners.get(event).add(listener);\n\t}\n\n\t/**\n\t * Remove event listener\n\t *\n\t * @param {string}   event    Event name\n\t * @param {Function} listener Callback function\n\t */\n\toff(event, listener) {\n\t\tconst listeners = this.eventListeners.get(event);\n\t\tif (listeners) {\n\t\t\tlisteners.delete(listener);\n\t\t}\n\t}\n\n\t/**\n\t * Emit event to listeners\n\t *\n\t * @param {Object} event Event object with type and optional data\n\t */\n\temit(event) {\n\t\tconst listeners = this.eventListeners.get(event.type);\n\t\tif (listeners) {\n\t\t\tlisteners.forEach((listener) => {\n\t\t\t\ttry {\n\t\t\t\t\tlistener(event);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error(\"Error in MCP event listener:\", error);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Connect to the MCP server using official SDK StreamableHTTPClientTransport\n\t *\n\t * @param {string} serverUrl Optional server URL (uses config if not provided)\n\t * @return {Promise<void>}\n\t */\n\tasync connect(serverUrl = null) {\n\t\ttry {\n\t\t\tconst config = this.getConfig();\n\t\t\tconst mcpEndpoint = serverUrl || config.mcpUrl;\n\n\t\t\tif (!mcpEndpoint) {\n\t\t\t\tthrow new MCPError(\"MCP endpoint URL not configured\");\n\t\t\t}\n\n\t\t\t// Initialize the MCP Client using the official SDK\n\t\t\tthis.client = new Client(\n\t\t\t\t{\n\t\t\t\t\tname: \"nfd-editor-chat-client\",\n\t\t\t\t\tversion: \"1.0.0\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tcapabilities: {},\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// Create HTTP transport with WordPress authentication headers\n\t\t\tthis.transport = new StreamableHTTPClientTransport(new URL(mcpEndpoint), {\n\t\t\t\trequestInit: {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"X-WP-Nonce\": config.nonce,\n\t\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// Connect using the official SDK\n\t\t\tawait this.client.connect(this.transport);\n\n\t\t\tthis.connected = true;\n\t\t\tthis.emit({ type: \"connected\" });\n\t\t} catch (error) {\n\t\t\tconst mcpError =\n\t\t\t\terror instanceof MCPError ? error : new MCPError(`Connection failed: ${error}`);\n\t\t\tthis.emit({ type: \"error\", data: mcpError });\n\t\t\tthrow mcpError;\n\t\t}\n\t}\n\n\t/**\n\t * Initialize the MCP session - SDK handles this automatically after connect\n\t *\n\t * @return {Promise<Object>} Initialization result\n\t */\n\tasync initialize() {\n\t\tif (!this.connected) {\n\t\t\tthrow new MCPError(\"Not connected to MCP server\");\n\t\t}\n\n\t\ttry {\n\t\t\t// The SDK has already handled initialization during connect()\n\t\t\t// Load initial tools and resources using SDK methods\n\t\t\tawait Promise.all([this.loadTools(), this.loadResources()]);\n\n\t\t\t// Create a compatible result object\n\t\t\tconst initResult = {\n\t\t\t\tprotocolVersion: \"2025-06-18\",\n\t\t\t\tcapabilities: {\n\t\t\t\t\ttools: {},\n\t\t\t\t\tresources: {},\n\t\t\t\t\tprompts: {},\n\t\t\t\t},\n\t\t\t\tserverInfo: {\n\t\t\t\t\tname: \"WordPress MCP Server\",\n\t\t\t\t\tversion: \"1.0.0\",\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tthis.emit({ type: \"initialized\", data: initResult });\n\n\t\t\treturn initResult;\n\t\t} catch (error) {\n\t\t\tconst mcpError =\n\t\t\t\terror instanceof MCPError ? error : new MCPError(`Initialization failed: ${error}`);\n\t\t\tthis.emit({ type: \"error\", data: mcpError });\n\t\t\tthrow mcpError;\n\t\t}\n\t}\n\n\t/**\n\t * Normalize input schema to valid JSON Schema object\n\t * Handles cases where the MCP server returns empty arrays or invalid schemas\n\t *\n\t * @param {any} schema Raw input schema from MCP\n\t * @return {Object} Valid JSON Schema object\n\t */\n\tnormalizeInputSchema(schema) {\n\t\t// Handle null, undefined, empty array, or non-object schemas\n\t\tif (\n\t\t\t!schema ||\n\t\t\tArray.isArray(schema) ||\n\t\t\ttypeof schema !== \"object\" ||\n\t\t\tObject.keys(schema).length === 0\n\t\t) {\n\t\t\treturn {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: {},\n\t\t\t\trequired: [],\n\t\t\t};\n\t\t}\n\n\t\t// Ensure type is set to object and properties/required exist\n\t\treturn {\n\t\t\ttype: schema.type || \"object\",\n\t\t\tproperties: schema.properties || {},\n\t\t\trequired: Array.isArray(schema.required) ? schema.required : [],\n\t\t};\n\t}\n\n\t/**\n\t * Load tools using the official MCP SDK\n\t *\n\t * @return {Promise<void>}\n\t */\n\tasync loadTools() {\n\t\ttry {\n\t\t\t// Use the SDK's listTools method - it handles all the protocol details\n\t\t\tconst result = await this.client.listTools();\n\n\t\t\t// Convert SDK tools format to our internal format with normalized schemas\n\t\t\tthis.tools = result.tools.map((tool) => ({\n\t\t\t\tname: tool.name,\n\t\t\t\tdescription: tool.description || \"\",\n\t\t\t\tinputSchema: this.normalizeInputSchema(tool.inputSchema),\n\t\t\t\tannotations: tool.annotations || {},\n\t\t\t}));\n\n\t\t\tthis.emit({ type: \"tools_updated\", data: this.tools });\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Failed to load tools via SDK:\", error);\n\t\t\tthis.tools = [];\n\t\t}\n\t}\n\n\t/**\n\t * Load resources using the official MCP SDK\n\t *\n\t * @return {Promise<void>}\n\t */\n\tasync loadResources() {\n\t\ttry {\n\t\t\t// Use the SDK's listResources method - it handles all the protocol details\n\t\t\tconst result = await this.client.listResources();\n\n\t\t\t// Convert SDK resources format to our internal format\n\t\t\tthis.resources = result.resources.map((resource) => ({\n\t\t\t\turi: resource.uri,\n\t\t\t\tname: resource.name || \"\",\n\t\t\t\tdescription: resource.description,\n\t\t\t\tmimeType: resource.mimeType,\n\t\t\t}));\n\n\t\t\tthis.emit({ type: \"resources_updated\", data: this.resources });\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Failed to load resources via SDK:\", error);\n\t\t\tthis.resources = [];\n\t\t}\n\t}\n\n\t/**\n\t * List available tools\n\t *\n\t * @return {Promise<Array>} List of tools\n\t */\n\tasync listTools() {\n\t\tif (!this.connected) {\n\t\t\tthrow new MCPError(\"Not connected to MCP server\");\n\t\t}\n\t\treturn this.tools;\n\t}\n\n\t/**\n\t * Call a tool using the official MCP SDK\n\t *\n\t * @param {string} name Tool name\n\t * @param {Object} args Tool arguments\n\t * @return {Promise<Object>} Tool result\n\t */\n\tasync callTool(name, args = {}) {\n\t\tif (!this.connected) {\n\t\t\tthrow new MCPError(\"Not connected to MCP server\");\n\t\t}\n\n\t\ttry {\n\t\t\t// Use the SDK's callTool method - it handles all the protocol details\n\t\t\tconst result = await this.client.callTool({ name, arguments: args });\n\n\t\t\t// Convert SDK result format to our internal format\n\t\t\tconst toolResult = {\n\t\t\t\tcontent: Array.isArray(result.content) ? result.content : [],\n\t\t\t\tisError: Boolean(result.isError),\n\t\t\t\tmeta: result.meta || {},\n\t\t\t};\n\n\t\t\treturn toolResult;\n\t\t} catch (error) {\n\t\t\tconsole.error(`Tool \"${name}\" call failed:`, error);\n\t\t\tconst mcpError =\n\t\t\t\terror instanceof MCPError ? error : new MCPError(`Tool call failed: ${error}`);\n\t\t\tthis.emit({ type: \"error\", data: mcpError });\n\t\t\tthrow mcpError;\n\t\t}\n\t}\n\n\t/**\n\t * List available resources\n\t *\n\t * @return {Promise<Array>} List of resources\n\t */\n\tasync listResources() {\n\t\tif (!this.connected) {\n\t\t\tthrow new MCPError(\"Not connected to MCP server\");\n\t\t}\n\t\treturn this.resources;\n\t}\n\n\t/**\n\t * Read a resource using the official MCP SDK\n\t *\n\t * @param {string} uri Resource URI\n\t * @return {Promise<Object>} Resource content\n\t */\n\tasync readResource(uri) {\n\t\tif (!this.connected) {\n\t\t\tthrow new MCPError(\"Not connected to MCP server\");\n\t\t}\n\n\t\ttry {\n\t\t\t// Use the SDK's readResource method - it handles all the protocol details\n\t\t\tconst result = await this.client.readResource({ uri });\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tconsole.error(`Resource \"${uri}\" read failed:`, error);\n\t\t\tconst mcpError =\n\t\t\t\terror instanceof MCPError ? error : new MCPError(`Resource read failed: ${error}`);\n\t\t\tthis.emit({ type: \"error\", data: mcpError });\n\t\t\tthrow mcpError;\n\t\t}\n\t}\n\n\t/**\n\t * Disconnect from the MCP server using the official SDK\n\t *\n\t * @return {Promise<void>}\n\t */\n\tasync disconnect() {\n\t\ttry {\n\t\t\t// Use the SDK's disconnect method\n\t\t\tif (this.transport) {\n\t\t\t\tawait this.client.close();\n\t\t\t\tthis.transport = null;\n\t\t\t}\n\n\t\t\tthis.connected = false;\n\t\t\tthis.tools = [];\n\t\t\tthis.resources = [];\n\t\t\tthis.emit({ type: \"disconnected\" });\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Error during SDK disconnect:\", error);\n\t\t}\n\t}\n\n\t/**\n\t * Get connection status\n\t *\n\t * @return {boolean} True if connected\n\t */\n\tisConnected() {\n\t\treturn this.connected;\n\t}\n\n\t/**\n\t * Get available tools (cached)\n\t *\n\t * @return {Array} List of tools\n\t */\n\tgetTools() {\n\t\treturn [...this.tools];\n\t}\n\n\t/**\n\t * Get available resources (cached)\n\t *\n\t * @return {Array} List of resources\n\t */\n\tgetResources() {\n\t\treturn [...this.resources];\n\t}\n\n\t/**\n\t * Check if a tool is read-only based on annotations\n\t *\n\t * @param {string} toolName Tool name to check\n\t * @return {boolean} True if tool is read-only\n\t */\n\tisToolReadOnly(toolName) {\n\t\tconst tool = this.tools.find((t) => t.name === toolName);\n\t\tif (!tool) {\n\t\t\treturn false;\n\t\t}\n\t\t// Check annotations for readonly flag\n\t\treturn tool.annotations?.readonly === true || tool.annotations?.readOnlyHint === true;\n\t}\n\n\t/**\n\t * Convert a single MCP tool to OpenAI function format\n\t *\n\t * @param {Object} tool MCP tool object\n\t * @return {Object} OpenAI function format\n\t */\n\ttoolToOpenAIFunction(tool) {\n\t\treturn {\n\t\t\ttype: \"function\",\n\t\t\tfunction: {\n\t\t\t\tname: tool.name,\n\t\t\t\tdescription: tool.description,\n\t\t\t\tparameters: tool.inputSchema,\n\t\t\t},\n\t\t};\n\t}\n\n\t/**\n\t * Convert all tools to OpenAI functions format\n\t *\n\t * @return {Array} OpenAI tools array\n\t */\n\tgetToolsForOpenAI() {\n\t\treturn this.tools.map((tool) => {\n\t\t\t// Use normalizeInputSchema for extra safety\n\t\t\tconst parameters = this.normalizeInputSchema(tool.inputSchema);\n\n\t\t\treturn {\n\t\t\t\ttype: \"function\",\n\t\t\t\tfunction: {\n\t\t\t\t\tname: tool.name,\n\t\t\t\t\tdescription: tool.description || \"\",\n\t\t\t\t\tparameters,\n\t\t\t\t},\n\t\t\t};\n\t\t});\n\t}\n}\n\n// Export a singleton instance\nexport const mcpClient = new WordPressMCPClient();\n\nexport default mcpClient;\n","/* eslint-disable no-console */\n/**\n * OpenAI Client that proxies requests through WordPress REST API\n *\n * This client uses the OpenAI SDK configured to route requests through\n * the WordPress proxy endpoint, which then forwards to Cloudflare AI Gateway\n * or direct OpenAI API.\n */\nimport OpenAI from \"openai\";\n\nconst DEFAULT_MODEL = \"gpt-4o-mini\";\n\n/**\n * Custom error class for OpenAI errors\n */\nexport class OpenAIError extends Error {\n\tconstructor(message, status = null, code = null) {\n\t\tsuper(message);\n\t\tthis.name = \"OpenAIError\";\n\t\tthis.status = status;\n\t\tthis.code = code;\n\t}\n}\n\n/**\n * OpenAI client that proxies requests through WordPress REST API\n */\nclass CloudflareOpenAIClient {\n\tconstructor() {\n\t\tthis.openai = null;\n\t\tthis.config = null;\n\t}\n\n\t/**\n\t * Get configuration from WordPress\n\t *\n\t * @return {Object} Configuration object\n\t */\n\tgetConfig() {\n\t\tif (this.config) {\n\t\t\treturn this.config;\n\t\t}\n\n\t\t// Get config from WordPress localized script\n\t\tif (typeof window !== \"undefined\" && window.nfdEditorChat) {\n\t\t\tthis.config = {\n\t\t\t\tnonce: window.nfdEditorChat.nonce,\n\t\t\t\trestUrl: window.nfdEditorChat.restUrl,\n\t\t\t\thomeUrl: window.nfdEditorChat.homeUrl,\n\t\t\t\tcurrentUser: window.nfdEditorChat.currentUser || {},\n\t\t\t};\n\t\t} else {\n\t\t\tthis.config = {\n\t\t\t\tnonce: \"\",\n\t\t\t\trestUrl: \"\",\n\t\t\t\thomeUrl: \"\",\n\t\t\t\tcurrentUser: {},\n\t\t\t};\n\t\t}\n\n\t\treturn this.config;\n\t}\n\n\t/**\n\t * Initialize the OpenAI client\n\t *\n\t * @return {OpenAI} OpenAI client instance\n\t */\n\tgetOpenAIClient() {\n\t\tif (this.openai) {\n\t\t\treturn this.openai;\n\t\t}\n\n\t\tconst config = this.getConfig();\n\n\t\t// Use WordPress proxy endpoint - all authentication handled server-side\n\t\tthis.openai = new OpenAI({\n\t\t\tapiKey: \"proxy\", // Dummy key - real key is on the server\n\t\t\tbaseURL: `${config.restUrl}ai`,\n\t\t\tdangerouslyAllowBrowser: true,\n\t\t\tdefaultHeaders: {\n\t\t\t\t\"X-WP-Nonce\": config.nonce,\n\t\t\t},\n\t\t});\n\n\t\treturn this.openai;\n\t}\n\n\t/**\n\t * Create a chat completion request (non-streaming)\n\t *\n\t * @param {Object} request Chat completion request params\n\t * @return {Promise<Object>} Chat completion response\n\t */\n\tasync createChatCompletion(request) {\n\t\ttry {\n\t\t\tconst openai = this.getOpenAIClient();\n\t\t\tconst response = await openai.chat.completions.create({\n\t\t\t\tmodel: request.model || DEFAULT_MODEL,\n\t\t\t\tmessages: request.messages,\n\t\t\t\ttools: request.tools,\n\t\t\t\ttool_choice: request.tool_choice,\n\t\t\t\tstream: false,\n\t\t\t\tmax_tokens: request.max_tokens,\n\t\t\t\ttemperature: request.temperature,\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\tthrow new OpenAIError(error.message || \"OpenAI API request failed\", error.status, error.code);\n\t\t}\n\t}\n\n\t/**\n\t * Create a streaming chat completion\n\t *\n\t * @param {Object}   request    Chat completion request params\n\t * @param {Function} onChunk    Callback for each chunk\n\t * @param {Function} onComplete Callback when complete\n\t * @param {Function} onError    Callback for errors\n\t * @return {Promise<void>}\n\t */\n\tasync createStreamingCompletion(request, onChunk, onComplete, onError) {\n\t\ttry {\n\t\t\tconst openai = this.getOpenAIClient();\n\t\t\tconst stream = await openai.chat.completions.create({\n\t\t\t\t...request,\n\t\t\t\tmessages: request.messages,\n\t\t\t\tstream: true,\n\t\t\t});\n\n\t\t\tlet fullMessage = \"\";\n\t\t\tconst toolCallsInProgress = {};\n\n\t\t\tfor await (const chunk of stream) {\n\t\t\t\tconst delta = chunk.choices[0]?.delta;\n\n\t\t\t\tif (delta?.content) {\n\t\t\t\t\tfullMessage += delta.content;\n\t\t\t\t\tonChunk({\n\t\t\t\t\t\ttype: \"content\",\n\t\t\t\t\t\tcontent: delta.content,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Handle streaming tool calls\n\t\t\t\tif (delta?.tool_calls) {\n\t\t\t\t\tfor (const toolCall of delta.tool_calls) {\n\t\t\t\t\t\tconst index = toolCall.index;\n\n\t\t\t\t\t\tif (!toolCallsInProgress[index]) {\n\t\t\t\t\t\t\ttoolCallsInProgress[index] = {\n\t\t\t\t\t\t\t\tid: toolCall.id || \"\",\n\t\t\t\t\t\t\t\ttype: \"function\",\n\t\t\t\t\t\t\t\tfunction: {\n\t\t\t\t\t\t\t\t\tname: toolCall.function?.name || \"\",\n\t\t\t\t\t\t\t\t\targuments: \"\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (toolCall.id) {\n\t\t\t\t\t\t\ttoolCallsInProgress[index].id = toolCall.id;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (toolCall.function?.name) {\n\t\t\t\t\t\t\ttoolCallsInProgress[index].function.name = toolCall.function.name;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (toolCall.function?.arguments) {\n\t\t\t\t\t\t\ttoolCallsInProgress[index].function.arguments += toolCall.function.arguments;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tonChunk({\n\t\t\t\t\t\ttype: \"tool_calls\",\n\t\t\t\t\t\ttool_calls: Object.values(toolCallsInProgress),\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (chunk.choices[0]?.finish_reason) {\n\t\t\t\t\t// Convert tool calls to final format\n\t\t\t\t\tconst finalToolCalls = Object.values(toolCallsInProgress).map((tc) => ({\n\t\t\t\t\t\tid: tc.id,\n\t\t\t\t\t\tname: tc.function.name,\n\t\t\t\t\t\targuments: tc.function.arguments ? JSON.parse(tc.function.arguments) : {},\n\t\t\t\t\t}));\n\n\t\t\t\t\t// Await onComplete in case it's async (e.g., handles tool calls)\n\t\t\t\t\tawait onComplete(fullMessage, finalToolCalls.length > 0 ? finalToolCalls : null);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tonError(\n\t\t\t\tnew OpenAIError(error.message || \"Streaming request failed\", error.status, error.code)\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Convert chat messages to OpenAI format\n\t *\n\t * OpenAI requires that tool messages MUST follow an assistant message with tool_calls.\n\t * This function ensures that constraint is satisfied.\n\t *\n\t * @param {Array} messages Array of chat messages\n\t * @return {Array} OpenAI formatted messages\n\t */\n\tconvertMessagesToOpenAI(messages) {\n\t\tconst openaiMessages = [];\n\n\t\tfor (const message of messages) {\n\t\t\tif (message.role === \"system\" || message.role === \"user\") {\n\t\t\t\topenaiMessages.push({\n\t\t\t\t\trole: message.role,\n\t\t\t\t\tcontent: message.content || \"\",\n\t\t\t\t});\n\t\t\t} else if (message.role === \"assistant\") {\n\t\t\t\tconst assistantMessage = {\n\t\t\t\t\trole: \"assistant\",\n\t\t\t\t\tcontent: message.content || \"\",\n\t\t\t\t};\n\n\t\t\t\t// Add tool calls if present\n\t\t\t\tconst hasToolCalls = message.toolCalls && message.toolCalls.length > 0;\n\t\t\t\tif (hasToolCalls) {\n\t\t\t\t\tassistantMessage.tool_calls = message.toolCalls.map((call) => ({\n\t\t\t\t\t\tid: call.id,\n\t\t\t\t\t\ttype: \"function\",\n\t\t\t\t\t\tfunction: {\n\t\t\t\t\t\t\tname: call.name,\n\t\t\t\t\t\t\targuments:\n\t\t\t\t\t\t\t\ttypeof call.arguments === \"string\"\n\t\t\t\t\t\t\t\t\t? call.arguments\n\t\t\t\t\t\t\t\t\t: JSON.stringify(call.arguments),\n\t\t\t\t\t\t},\n\t\t\t\t\t}));\n\t\t\t\t}\n\n\t\t\t\topenaiMessages.push(assistantMessage);\n\n\t\t\t\t// ONLY add tool results if there are corresponding tool_calls\n\t\t\t\t// OpenAI requires tool messages to follow an assistant message with tool_calls\n\t\t\t\tif (hasToolCalls && message.toolResults && message.toolResults.length > 0) {\n\t\t\t\t\tfor (const result of message.toolResults) {\n\t\t\t\t\t\t// Only add if this result has a matching tool call\n\t\t\t\t\t\tconst hasMatchingCall = message.toolCalls.some((call) => call.id === result.id);\n\t\t\t\t\t\tif (hasMatchingCall) {\n\t\t\t\t\t\t\topenaiMessages.push({\n\t\t\t\t\t\t\t\trole: \"tool\",\n\t\t\t\t\t\t\t\tcontent: result.error || JSON.stringify(result.result),\n\t\t\t\t\t\t\t\ttool_call_id: result.id,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Skip standalone tool messages - they're only valid after assistant tool_calls\n\t\t\t// which we handle above\n\t\t}\n\n\t\treturn openaiMessages;\n\t}\n\n\t/**\n\t * Convert MCP tools to OpenAI tools format\n\t *\n\t * @param {Array} mcpTools Array of MCP tools\n\t * @return {Array} OpenAI tools array\n\t */\n\tconvertMCPToolsToOpenAI(mcpTools) {\n\t\treturn mcpTools.map((tool) => ({\n\t\t\ttype: \"function\",\n\t\t\tfunction: {\n\t\t\t\tname: tool.name,\n\t\t\t\tdescription: tool.description,\n\t\t\t\tparameters: tool.inputSchema,\n\t\t\t},\n\t\t}));\n\t}\n\n\t/**\n\t * Process tool calls from OpenAI response\n\t *\n\t * @param {Array} toolCalls Raw tool calls from OpenAI\n\t * @return {Array} Processed tool calls\n\t */\n\tprocessToolCalls(toolCalls) {\n\t\treturn toolCalls.map((call) => ({\n\t\t\tid: call.id,\n\t\t\tname: call.function.name,\n\t\t\targuments: JSON.parse(call.function.arguments || \"{}\"),\n\t\t}));\n\t}\n\n\t/**\n\t * Send a simple chat message\n\t *\n\t * @param {string} message User message\n\t * @param {Array}  context Previous messages for context\n\t * @param {Array}  tools   Available MCP tools\n\t * @return {Promise<Object>} Response with message and optional tool calls\n\t */\n\tasync sendMessage(message, context = [], tools = []) {\n\t\tconst messages = this.convertMessagesToOpenAI([\n\t\t\t...context,\n\t\t\t{\n\t\t\t\tid: `user-${Date.now()}`,\n\t\t\t\trole: \"user\",\n\t\t\t\tcontent: message,\n\t\t\t\ttimestamp: new Date(),\n\t\t\t},\n\t\t]);\n\n\t\tconst request = {\n\t\t\tmodel: DEFAULT_MODEL,\n\t\t\tmessages,\n\t\t\ttools: tools.length > 0 ? this.convertMCPToolsToOpenAI(tools) : undefined,\n\t\t\ttool_choice: tools.length > 0 ? \"auto\" : undefined,\n\t\t\ttemperature: 0.7,\n\t\t\tmax_tokens: 2000,\n\t\t};\n\n\t\ttry {\n\t\t\tconst response = await this.createChatCompletion(request);\n\t\t\tconst choice = response.choices[0];\n\n\t\t\tif (!choice) {\n\t\t\t\tthrow new OpenAIError(\"No response from OpenAI\");\n\t\t\t}\n\n\t\t\tconst result = {\n\t\t\t\tmessage: choice.message.content || \"\",\n\t\t\t};\n\n\t\t\tif (choice.message.tool_calls) {\n\t\t\t\tresult.toolCalls = this.processToolCalls(choice.message.tool_calls);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tif (error instanceof OpenAIError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new OpenAIError(`Failed to send message: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Create a system message for WordPress context\n\t *\n\t * @return {Object} System message object\n\t */\n\tcreateWordPressSystemMessage() {\n\t\tconst config = this.getConfig();\n\n\t\treturn {\n\t\t\trole: \"system\",\n\t\t\tcontent: `You are a helpful AI assistant integrated into a WordPress editor. You specialize in managing global styles and color palettes.\n\n## How to Use MCP Tools\n\nYou have THREE tools available:\n1. **mcp-adapter-discover-abilities** - Lists all available WordPress abilities\n2. **mcp-adapter-get-ability-info** - Gets detailed info about a specific ability  \n3. **mcp-adapter-execute-ability** - EXECUTES an ability to perform actions\n\n## Bluehost Blueprint Theme Color Mappings\n\nThis site uses the Bluehost Blueprint theme with these color slugs:\n- **accent-2** = Primary color (main brand color)\n- **accent-5** = Secondary color\n- **base** = Background color\n- **contrast** = Text color\n- **accent-1** = Darkest accent shade\n- **accent-3, accent-4, accent-6** = Lighter accent shades\n\n### Color Request Mappings:\n- \"primary color\" or \"main color\"  use slug \\`accent-2\\`\n- \"secondary color\"  use slug \\`accent-5\\`\n- \"background color\"  use slug \\`base\\`\n- \"text color\" or \"foreground\"  use slug \\`contrast\\`\n\n### Accent Palette Generation (for primary color changes):\nWhen changing the primary/accent color, generate ALL 6 accent shades from the provided color:\n- **accent-1**: Darkest (lightness -24%, saturation -3%)\n- **accent-2**: Primary color (unchanged - this is the user's color)\n- **accent-3**: Lighter (lightness +18%, saturation +1%)\n- **accent-4**: Lighter (lightness +28%, saturation +2%)\n- **accent-5**: Lighter (lightness +56%, saturation +3%)\n- **accent-6**: Lightest (lightness +63%, saturation +5%)\n\n## Available Abilities\n\n- \\`nfd-editor-chat/get-global-styles\\` - Get current palette\n- \\`nfd-editor-chat/update-global-palette\\` - Update colors\n\n## Examples\n\nUser: \"Change the primary color to blue (#0073aa)\"\nCall update-global-palette with ALL accent colors generated from blue:\n{ \"colors\": [\n  { \"slug\": \"accent-1\", \"color\": \"#003d5c\", \"name\": \"Accent 1\" },\n  { \"slug\": \"accent-2\", \"color\": \"#0073aa\", \"name\": \"Accent 2\" },\n  { \"slug\": \"accent-3\", \"color\": \"#3399cc\", \"name\": \"Accent 3\" },\n  { \"slug\": \"accent-4\", \"color\": \"#66b3d9\", \"name\": \"Accent 4\" },\n  { \"slug\": \"accent-5\", \"color\": \"#b3d9ec\", \"name\": \"Accent 5\" },\n  { \"slug\": \"accent-6\", \"color\": \"#cce6f2\", \"name\": \"Accent 6\" }\n] }\n\nUser: \"Change the background to #d3d3d3\"\nCall: mcp-adapter-execute-ability with { \"ability_name\": \"nfd-editor-chat/update-global-palette\", \"parameters\": { \"colors\": [{ \"slug\": \"base\", \"color\": \"#d3d3d3\", \"name\": \"Base\" }] } }\n\nUser: \"Make the text color black\"\nCall: mcp-adapter-execute-ability with { \"ability_name\": \"nfd-editor-chat/update-global-palette\", \"parameters\": { \"colors\": [{ \"slug\": \"contrast\", \"color\": \"#000000\", \"name\": \"Contrast\" }] } }\n\n## Guidelines\n- Use the EXACT color slugs listed above for this theme\n- When changing primary color, generate ALL 6 accent shades\n- For background changes, use \"base\" slug\n- For text changes, use \"contrast\" slug\n- All colors must be in HEX format (#RRGGBB)\n\nSite: ${config.homeUrl} | User: ${config.currentUser?.display_name || \"Unknown\"}`,\n\t\t};\n\t}\n}\n\n// Export a singleton instance\nexport const openaiClient = new CloudflareOpenAIClient();\n\nexport default openaiClient;\n","// extracted by mini-css-extract-plugin\nexport {};","var _path;\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nimport * as React from \"react\";\nvar SvgSparks = function SvgSparks(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: 24,\n    height: 24,\n    baseProfile: \"basic\",\n    viewBox: \"0 0 30 30\"\n  }, props), _path || (_path = /*#__PURE__*/React.createElement(\"path\", {\n    d: \"m14.217 19.707-1.112 2.547a1.199 1.199 0 0 1-2.21 0l-1.112-2.547A9.8 9.8 0 0 0 4.79 14.65l-3.06-1.358c-.973-.432-.973-1.848 0-2.28l2.965-1.316C6.974 8.684 8.787 6.813 9.76 4.47l1.126-2.714a1.2 1.2 0 0 1 2.228 0L14.24 4.47c.973 2.344 2.786 4.215 5.065 5.226l2.965 1.316c.973.432.973 1.848 0 2.28l-3.061 1.359a9.8 9.8 0 0 0-4.992 5.056M24.481 27.796l-.339.777a.696.696 0 0 1-1.284 0l-.339-.777a6 6 0 0 0-3.051-3.092l-1.044-.464c-.565-.251-.565-1.072 0-1.323l.986-.438a6 6 0 0 0 3.095-3.195l.348-.84a.696.696 0 0 1 1.294 0l.348.84a6 6 0 0 0 3.095 3.195l.986.438c.565.251.565 1.072 0 1.323l-1.044.464a6 6 0 0 0-3.051 3.092\"\n  })));\n};\nexport { SvgSparks as ReactComponent };\nexport default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciICB2aWV3Qm94PSIwIDAgMzAgMzAiIHdpZHRoPSIyNHB4IiBoZWlnaHQ9IjI0cHgiIGJhc2VQcm9maWxlPSJiYXNpYyI+PHBhdGggZD0iTTE0LjIxNywxOS43MDdsLTEuMTEyLDIuNTQ3Yy0wLjQyNywwLjk3OS0xLjc4MiwwLjk3OS0yLjIxLDBsLTEuMTEyLTIuNTQ3Yy0wLjk5LTIuMjY3LTIuNzcxLTQuMDcxLTQuOTkzLTUuMDU3CUwxLjczLDEzLjI5MmMtMC45NzMtMC40MzItMC45NzMtMS44NDgsMC0yLjI4bDIuOTY1LTEuMzE2QzYuOTc0LDguNjg0LDguNzg3LDYuODEzLDkuNzYsNC40N2wxLjEyNi0yLjcxNAljMC40MTgtMS4wMDcsMS44MS0xLjAwNywyLjIyOCwwTDE0LjI0LDQuNDdjMC45NzMsMi4zNDQsMi43ODYsNC4yMTUsNS4wNjUsNS4yMjZsMi45NjUsMS4zMTZjMC45NzMsMC40MzIsMC45NzMsMS44NDgsMCwyLjI4CWwtMy4wNjEsMS4zNTlDMTYuOTg4LDE1LjYzNywxNS4yMDYsMTcuNDQxLDE0LjIxNywxOS43MDd6Ii8+PHBhdGggZD0iTTI0LjQ4MSwyNy43OTZsLTAuMzM5LDAuNzc3Yy0wLjI0OCwwLjU2OS0xLjAzNiwwLjU2OS0xLjI4NCwwbC0wLjMzOS0wLjc3N2MtMC42MDQtMS4zODUtMS42OTMtMi40ODgtMy4wNTEtMy4wOTIJbC0xLjA0NC0wLjQ2NGMtMC41NjUtMC4yNTEtMC41NjUtMS4wNzIsMC0xLjMyM2wwLjk4Ni0wLjQzOGMxLjM5My0wLjYxOSwyLjUwMS0xLjc2MywzLjA5NS0zLjE5NWwwLjM0OC0wLjg0CWMwLjI0My0wLjU4NSwxLjA1Mi0wLjU4NSwxLjI5NCwwbDAuMzQ4LDAuODRjMC41OTQsMS40MzIsMS43MDIsMi41NzYsMy4wOTUsMy4xOTVsMC45ODYsMC40MzhjMC41NjUsMC4yNTEsMC41NjUsMS4wNzIsMCwxLjMyMwlsLTEuMDQ0LDAuNDY0QzI2LjE3NCwyNS4zMDgsMjUuMDg1LDI2LjQxMSwyNC40ODEsMjcuNzk2eiIvPjwvc3ZnPg==\";","/**\n * WordPress dependencies\n */\nimport { select, resolveSelect, dispatch } from \"@wordpress/data\";\nimport { serialize } from \"@wordpress/blocks\";\n\n/**\n * Get the current page content\n *\n * @return {Promise<Object>} The page content with template parts\n */\nexport const getCurrentPageContent = async () => {\n\tconst postContent = getPostContent();\n\tconst templatePartBlocks = getAllTemplatePartBlocks();\n\tconst templatePartsMap = await buildTemplatePartsMap(templatePartBlocks);\n\n\treturn { page_content: postContent, ...templatePartsMap };\n};\n\n// Helpers\nconst getPostContent = () => {\n\tconst blockEditor = select(\"core/block-editor\");\n\tconst blocks = blockEditor.getBlocks();\n\n\t// Find the post-content block\n\tconst postContentBlock = blocks.find((block) => block.name === \"core/post-content\");\n\n\tif (!postContentBlock) {\n\t\t// If there's no post-content block, map all blocks\n\t\treturn blocks.map((block) => ({\n\t\t\tclientId: block.clientId,\n\t\t\tcontent: serialize(block),\n\t\t}));\n\t}\n\n\t// Get inner blocks of the post-content block\n\tconst innerBlocks = blockEditor.getBlocks(postContentBlock.clientId);\n\n\t// Map each inner block to the required structure\n\treturn innerBlocks.map((block) => ({\n\t\tclientId: block.clientId,\n\t\tcontent: serialize(block),\n\t}));\n};\n\nconst getAllTemplatePartBlocks = () => {\n\tconst blockEditor = select(\"core/block-editor\");\n\tconst blocks = blockEditor.getBlocks();\n\treturn blocks.filter((b) => b.name === \"core/template-part\");\n};\n\n/**\n * Fetch template part content from entity\n * This ensures we use the same content format that's sent as context to the AI\n *\n * @param {Object} tplBlock    The template part block\n * @param {Object} coreResolve Optional core resolve selector (will be created if not provided)\n * @return {Promise<string>}   The template part content as HTML string\n */\nexport const fetchTemplatePartContent = async (tplBlock, coreResolve = null) => {\n\tif (!tplBlock || !tplBlock.attributes) {\n\t\treturn \"\";\n\t}\n\tconst { ref, slug, theme } = tplBlock.attributes;\n\n\t// Use provided coreResolve or create a new one\n\tconst resolve = coreResolve || resolveSelect(\"core\");\n\n\tif (ref) {\n\t\tconst rec = await resolve.getEntityRecord(\"postType\", \"wp_template_part\", ref);\n\t\treturn (rec && rec.content && (rec.content.raw || rec.content.rendered)) || \"\";\n\t}\n\n\tif (slug && theme) {\n\t\tconst compositeId = `${theme}//${slug}`;\n\t\tconst recByComposite = await resolve.getEntityRecord(\n\t\t\t\"postType\",\n\t\t\t\"wp_template_part\",\n\t\t\tcompositeId\n\t\t);\n\t\tif (recByComposite && recByComposite.content) {\n\t\t\treturn recByComposite.content.raw || recByComposite.content.rendered || \"\";\n\t\t}\n\t}\n\n\tif (slug) {\n\t\tconst query = theme ? { slug: [slug], theme } : { slug: [slug] };\n\t\tconst recs = await resolve.getEntityRecords(\"postType\", \"wp_template_part\", query);\n\t\tif (Array.isArray(recs) && recs.length > 0) {\n\t\t\tconst exact = recs.find((r) => r && r.slug === slug && (!theme || r.theme === theme));\n\t\t\tconst rec = exact || recs[0];\n\t\t\treturn (rec && rec.content && (rec.content.raw || rec.content.rendered)) || \"\";\n\t\t}\n\t}\n\n\treturn \"\";\n};\n\nconst pickTemplatePartKey = (attrs, index) => {\n\treturn (\n\t\tattrs.slug || (attrs.ref ? String(attrs.ref) : null) || attrs.area || `template_part_${index}`\n\t);\n};\n\nconst buildTemplatePartsMap = async (templatePartBlocks) => {\n\tconst coreResolve = resolveSelect(\"core\");\n\n\tconst result = {};\n\tfor (let i = 0; i < templatePartBlocks.length; i++) {\n\t\tconst block = templatePartBlocks[i];\n\t\tconst attrs = block.attributes || {};\n\t\tconst html = await fetchTemplatePartContent(block, coreResolve);\n\n\t\tconst key = pickTemplatePartKey(attrs, i);\n\t\tif (key && !result[key]) {\n\t\t\tresult[key] = {\n\t\t\t\tclientId: block.clientId,\n\t\t\t\tcontent: html,\n\t\t\t};\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Get the current page blocks\n *\n * @return {Object} The page blocks\n */\nexport const getCurrentPageBlocks = () => {\n\tconst blockEditor = select(\"core/block-editor\");\n\n\tconst blocks = blockEditor.getBlocks();\n\n\t// Process blocks to get inner content for post-content and template-part blocks\n\tconst processedBlocks = blocks.map((block) => {\n\t\tif (block.name === \"core/post-content\" || block.name === \"core/template-part\") {\n\t\t\treturn {\n\t\t\t\t...block,\n\t\t\t\tinnerBlocks: blockEditor.getBlocks(block.clientId),\n\t\t\t};\n\t\t}\n\t\treturn block;\n\t});\n\n\treturn processedBlocks;\n};\n\n/**\n * Get the current page ID\n *\n * @return {number} The page ID\n */\nexport const getCurrentPageId = () => {\n\tconst editor = select(\"core/editor\");\n\treturn editor.getCurrentPostId();\n};\n\n/**\n * Get the current page title\n *\n * @return {string} The page title\n */\nexport const getCurrentPageTitle = () => {\n\tconst editor = select(\"core/editor\");\n\treturn editor.getEditedPostAttribute(\"title\") || \"\";\n};\n\n/**\n * Get the currently selected block with its serialized content\n * This is a shared utility that can be used in both React hooks and service functions\n *\n * @return {Object|null} The selected block object with serialized content or null if none selected\n */\nexport const getSelectedBlock = () => {\n\tconst blockEditor = select(\"core/block-editor\");\n\tconst selectedBlock = blockEditor.getSelectedBlock();\n\n\tif (!selectedBlock) {\n\t\treturn null;\n\t}\n\n\treturn selectedBlock;\n};\n\n/**\n * Check if a block is a template part\n *\n * @param {Object} block The block to check\n * @return {boolean} True if the block is a template part\n */\nexport const isTemplatePart = (block) => {\n\treturn block && block.name === \"core/template-part\";\n};\n\n/**\n * Get template part entity record\n * This is the base function that other template part helpers use\n *\n * @param {Object} tplBlock The template part block\n * @return {Promise<Object|null>} The entity record\n */\nexport const getTemplatePartEntity = async (tplBlock) => {\n\tif (!tplBlock || !tplBlock.attributes) {\n\t\treturn null;\n\t}\n\n\tconst { ref, slug, theme } = tplBlock.attributes;\n\tconst coreResolve = resolveSelect(\"core\");\n\n\t// If we have a ref, use it directly\n\tif (ref) {\n\t\treturn await coreResolve.getEntityRecord(\"postType\", \"wp_template_part\", ref);\n\t}\n\n\t// Try composite ID (theme//slug)\n\tif (slug && theme) {\n\t\tconst compositeId = `${theme}//${slug}`;\n\t\tconst rec = await coreResolve.getEntityRecord(\"postType\", \"wp_template_part\", compositeId);\n\t\tif (rec) {\n\t\t\treturn rec;\n\t\t}\n\t}\n\n\t// Try by slug\n\tif (slug) {\n\t\tconst query = theme ? { slug: [slug], theme } : { slug: [slug] };\n\t\tconst recs = await coreResolve.getEntityRecords(\"postType\", \"wp_template_part\", query);\n\t\tif (Array.isArray(recs) && recs.length > 0) {\n\t\t\tconst exact = recs.find((r) => r && r.slug === slug && (!theme || r.theme === theme));\n\t\t\treturn exact || recs[0];\n\t\t}\n\t}\n\n\treturn null;\n};\n\n/**\n * Get template part entity record ID\n *\n * @param {Object} tplBlock The template part block\n * @return {Promise<string|number|null>} The entity record ID\n */\nexport const getTemplatePartEntityId = async (tplBlock) => {\n\t// Use ref directly if available\n\tif (tplBlock?.attributes?.ref) {\n\t\treturn tplBlock.attributes.ref;\n\t}\n\n\t// Otherwise get the full entity and extract the ID\n\tconst entity = await getTemplatePartEntity(tplBlock);\n\treturn entity?.id || null;\n};\n\n/**\n * Update template part content\n *\n * @param {Object} tplBlock           The template part block\n * @param {Array}  updatedInnerBlocks The updated inner blocks\n * @return {Promise<Object>}          Result of the update\n */\nexport const updateTemplatePartContent = async (tplBlock, updatedInnerBlocks) => {\n\ttry {\n\t\tconst entityId = await getTemplatePartEntityId(tplBlock);\n\n\t\tif (!entityId) {\n\t\t\tthrow new Error(\"Could not resolve template part entity ID\");\n\t\t}\n\n\t\t// Serialize the updated blocks to HTML\n\t\tconst updatedContent = updatedInnerBlocks.map((block) => serialize(block)).join(\"\");\n\n\t\t// Get the core dispatcher\n\t\tconst coreDispatch = dispatch(\"core\");\n\n\t\t// Edit the entity record\n\t\tawait coreDispatch.editEntityRecord(\"postType\", \"wp_template_part\", entityId, {\n\t\t\tcontent: updatedContent,\n\t\t});\n\n\t\t// Save the entity\n\t\tconst savedRecord = await coreDispatch.saveEditedEntityRecord(\n\t\t\t\"postType\",\n\t\t\t\"wp_template_part\",\n\t\t\tentityId\n\t\t);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"Template part updated successfully\",\n\t\t\tentityId,\n\t\t\tsavedRecord,\n\t\t};\n\t} catch (error) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.error(\"Error updating template part:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\tmessage: `Failed to update template part: ${error.message}`,\n\t\t\terror,\n\t\t};\n\t}\n};\n","/**\n * Simple hash function to create a unique identifier from a string\n * Uses a variation of the djb2 hash algorithm\n *\n * @param {string} str - The string to hash\n * @return {string} A hexadecimal hash string\n */\nexport const simpleHash = (str) => {\n\t// Handle null, undefined, or empty strings\n\tif (!str || typeof str !== \"string\") {\n\t\treturn \"0\";\n\t}\n\n\tlet hash = 5381;\n\tfor (let i = 0; i < str.length; i++) {\n\t\t// eslint-disable-next-line no-bitwise\n\t\thash = (hash << 5) + hash + str.charCodeAt(i); // hash * 33 + c\n\t\t// eslint-disable-next-line no-bitwise\n\t\thash = hash | 0; // Convert to 32-bit integer\n\t}\n\t// Convert to unsigned and then to hex\n\t// eslint-disable-next-line no-bitwise\n\treturn (hash >>> 0).toString(16);\n};\n","/**\n * Simple Markdown Parser\n *\n * Converts common markdown syntax to HTML for chat messages.\n * Handles: headers, bold, italic, code, lists, links, and line breaks.\n */\n\n/**\n * Check if a string contains markdown syntax\n * @param {string} text - The text to check\n * @return {boolean} True if markdown is detected\n */\nexport function containsMarkdown(text) {\n\tif (!text || typeof text !== \"string\") {\n\t\treturn false;\n\t}\n\n\t// Check for common markdown patterns\n\tconst markdownPatterns = [\n\t\t/^#{1,6}\\s/m, // Headers\n\t\t/\\*\\*[^*]+\\*\\*/, // Bold\n\t\t/\\*[^*]+\\*/, // Italic\n\t\t/__[^_]+__/, // Bold (underscore)\n\t\t/_[^_]+_/, // Italic (underscore)\n\t\t/`[^`]+`/, // Inline code\n\t\t/```[\\s\\S]*?```/, // Code blocks\n\t\t/^\\s*[-*+]\\s/m, // Unordered lists\n\t\t/^\\s*\\d+\\.\\s/m, // Ordered lists\n\t\t/\\[([^\\]]+)\\]\\(([^)]+)\\)/, // Links\n\t];\n\n\treturn markdownPatterns.some((pattern) => pattern.test(text));\n}\n\n/**\n * Parse markdown text to HTML\n * @param {string} text - The markdown text to parse\n * @return {string} HTML string\n */\nexport function parseMarkdown(text) {\n\tif (!text || typeof text !== \"string\") {\n\t\treturn \"\";\n\t}\n\n\tlet html = text;\n\n\t// Escape HTML entities first (but preserve existing HTML)\n\thtml = html\n\t\t.replace(/&(?![\\w#]+;)/g, \"&amp;\")\n\t\t.replace(/<(?![a-zA-Z/])/g, \"&lt;\")\n\t\t.replace(/(?<![a-zA-Z\"])>/g, \"&gt;\");\n\n\t// Code blocks (``` ... ```) - must be done before other processing\n\thtml = html.replace(/```(\\w*)\\n?([\\s\\S]*?)```/g, (match, lang, code) => {\n\t\tconst escapedCode = code.trim().replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n\t\treturn `<pre><code class=\"language-${lang || \"plaintext\"}\">${escapedCode}</code></pre>`;\n\t});\n\n\t// Inline code (` ... `)\n\thtml = html.replace(/`([^`]+)`/g, '<code class=\"inline-code\">$1</code>');\n\n\t// Headers (### ... )\n\thtml = html.replace(/^######\\s+(.+)$/gm, '<h6 class=\"chat-h6\">$1</h6>');\n\thtml = html.replace(/^#####\\s+(.+)$/gm, '<h5 class=\"chat-h5\">$1</h5>');\n\thtml = html.replace(/^####\\s+(.+)$/gm, '<h4 class=\"chat-h4\">$1</h4>');\n\thtml = html.replace(/^###\\s+(.+)$/gm, '<h3 class=\"chat-h3\">$1</h3>');\n\thtml = html.replace(/^##\\s+(.+)$/gm, '<h2 class=\"chat-h2\">$1</h2>');\n\thtml = html.replace(/^#\\s+(.+)$/gm, '<h1 class=\"chat-h1\">$1</h1>');\n\n\t// Bold (**text** or __text__)\n\thtml = html.replace(/\\*\\*([^*]+)\\*\\*/g, \"<strong>$1</strong>\");\n\thtml = html.replace(/__([^_]+)__/g, \"<strong>$1</strong>\");\n\n\t// Italic (*text* or _text_) - but not inside URLs or code\n\thtml = html.replace(/(?<![*_])\\*(?!\\*)([^*\\n]+)(?<!\\*)\\*(?!\\*)/g, \"<em>$1</em>\");\n\thtml = html.replace(/(?<![_*])_(?!_)([^_\\n]+)(?<!_)_(?!_)/g, \"<em>$1</em>\");\n\n\t// Links [text](url)\n\thtml = html.replace(\n\t\t/\\[([^\\]]+)\\]\\(([^)]+)\\)/g,\n\t\t'<a href=\"$2\" target=\"_blank\" rel=\"noopener noreferrer\">$1</a>'\n\t);\n\n\t// Unordered lists\n\thtml = html.replace(/^(\\s*)[-*+]\\s+(.+)$/gm, (match, indent, content) => {\n\t\tconst level = Math.floor(indent.length / 2);\n\t\treturn `<li class=\"chat-li\" data-level=\"${level}\">${content}</li>`;\n\t});\n\n\t// Wrap consecutive list items in <ul>\n\thtml = html.replace(/((?:<li[^>]*>.*?<\\/li>\\n?)+)/g, '<ul class=\"chat-ul\">$1</ul>');\n\n\t// Ordered lists\n\thtml = html.replace(/^(\\s*)\\d+\\.\\s+(.+)$/gm, (match, indent, content) => {\n\t\tconst level = Math.floor(indent.length / 2);\n\t\treturn `<oli class=\"chat-oli\" data-level=\"${level}\">${content}</oli>`;\n\t});\n\n\t// Wrap consecutive ordered list items in <ol>\n\thtml = html.replace(/((?:<oli[^>]*>.*?<\\/oli>\\n?)+)/g, (match) => {\n\t\treturn (\n\t\t\t'<ol class=\"chat-ol\">' + match.replace(/<\\/?oli/g, (m) => m.replace(\"oli\", \"li\")) + \"</ol>\"\n\t\t);\n\t});\n\n\t// Horizontal rules\n\thtml = html.replace(/^---+$/gm, '<hr class=\"chat-hr\" />');\n\n\t// Blockquotes\n\thtml = html.replace(/^>\\s+(.+)$/gm, '<blockquote class=\"chat-blockquote\">$1</blockquote>');\n\n\t// Paragraphs - wrap text blocks that aren't already wrapped\n\t// Split by double newlines and wrap non-HTML blocks\n\tconst blocks = html.split(/\\n\\n+/);\n\thtml = blocks\n\t\t.map((block) => {\n\t\t\tconst trimmed = block.trim();\n\t\t\t// Don't wrap if it's already an HTML block element\n\t\t\tif (\n\t\t\t\ttrimmed.startsWith(\"<h\") ||\n\t\t\t\ttrimmed.startsWith(\"<ul\") ||\n\t\t\t\ttrimmed.startsWith(\"<ol\") ||\n\t\t\t\ttrimmed.startsWith(\"<pre\") ||\n\t\t\t\ttrimmed.startsWith(\"<blockquote\") ||\n\t\t\t\ttrimmed.startsWith(\"<hr\") ||\n\t\t\t\ttrimmed.startsWith(\"<p\")\n\t\t\t) {\n\t\t\t\treturn trimmed;\n\t\t\t}\n\t\t\t// Wrap in paragraph if it has content\n\t\t\tif (trimmed) {\n\t\t\t\treturn `<p class=\"chat-p\">${trimmed}</p>`;\n\t\t\t}\n\t\t\treturn \"\";\n\t\t})\n\t\t.filter(Boolean)\n\t\t.join(\"\\n\");\n\n\t// Convert single line breaks within paragraphs to <br>\n\thtml = html.replace(/<p([^>]*)>([\\s\\S]*?)<\\/p>/g, (match, attrs, content) => {\n\t\t// Trim content to avoid trailing <br> tags, then convert newlines\n\t\tconst processedContent = content.trim().replace(/\\n/g, \"<br />\");\n\t\treturn `<p${attrs}>${processedContent}</p>`;\n\t});\n\n\treturn html;\n}\n\nexport default {\n\tcontainsMarkdown,\n\tparseMarkdown,\n};\n","/**\n * External dependencies\n */\nimport DOMPurify from \"dompurify\";\n\n/**\n * Sanitize HTML content using DOMPurify to prevent XSS attacks\n *\n * @param {string} html - The HTML string to sanitize.\n * @return {string} The sanitized HTML string.\n */\nexport const sanitizeHtml = (html) => {\n\treturn DOMPurify.sanitize(html, {\n\t\tALLOWED_TAGS: [\n\t\t\t\"section\",\n\t\t\t\"div\",\n\t\t\t\"h1\",\n\t\t\t\"h2\",\n\t\t\t\"h3\",\n\t\t\t\"h4\",\n\t\t\t\"h5\",\n\t\t\t\"h6\",\n\t\t\t\"p\",\n\t\t\t\"span\",\n\t\t\t\"strong\",\n\t\t\t\"em\",\n\t\t\t\"b\",\n\t\t\t\"i\",\n\t\t\t\"u\",\n\t\t\t\"s\",\n\t\t\t\"mark\",\n\t\t\t\"small\",\n\t\t\t\"sub\",\n\t\t\t\"sup\",\n\t\t\t\"a\",\n\t\t\t\"br\",\n\t\t\t\"ul\",\n\t\t\t\"ol\",\n\t\t\t\"li\",\n\t\t\t\"dl\",\n\t\t\t\"dt\",\n\t\t\t\"dd\",\n\t\t\t\"blockquote\",\n\t\t\t\"code\",\n\t\t\t\"pre\",\n\t\t\t\"table\",\n\t\t\t\"thead\",\n\t\t\t\"tbody\",\n\t\t\t\"tr\",\n\t\t\t\"th\",\n\t\t\t\"td\",\n\t\t\t\"hr\",\n\t\t\t\"address\",\n\t\t\t\"time\",\n\t\t],\n\t\tALLOWED_ATTR: [\"style\", \"class\", \"id\", \"href\", \"datetime\"],\n\t\tALLOW_DATA_ATTR: false,\n\t\tFORBID_TAGS: [\n\t\t\t\"script\",\n\t\t\t\"object\",\n\t\t\t\"embed\",\n\t\t\t\"iframe\",\n\t\t\t\"form\",\n\t\t\t\"fieldset\",\n\t\t\t\"legend\",\n\t\t\t\"label\",\n\t\t\t\"input\",\n\t\t\t\"textarea\",\n\t\t\t\"select\",\n\t\t\t\"option\",\n\t\t\t\"button\",\n\t\t\t\"details\",\n\t\t\t\"summary\",\n\t\t\t\"progress\",\n\t\t\t\"meter\",\n\t\t],\n\t\tFORBID_ATTR: [\"onerror\", \"onload\", \"onclick\", \"onmouseover\", \"onfocus\", \"onblur\"],\n\t});\n};\n\n/**\n * Check if content contains HTML tags\n *\n * @param {string} content - The content to check.\n * @return {boolean} True if content contains HTML tags.\n */\nexport const containsHtml = (content) => {\n\treturn /<[a-z][\\s\\S]*>/i.test(content);\n};\n","module.exports = window[\"wp\"][\"blocks\"];","module.exports = window[\"wp\"][\"components\"];","module.exports = window[\"wp\"][\"compose\"];","module.exports = window[\"wp\"][\"coreData\"];","module.exports = window[\"wp\"][\"data\"];","module.exports = window[\"wp\"][\"deprecated\"];","module.exports = window[\"wp\"][\"domReady\"];","module.exports = window[\"wp\"][\"editor\"];","module.exports = window[\"wp\"][\"element\"];","module.exports = window[\"wp\"][\"i18n\"];","module.exports = window[\"wp\"][\"plugins\"];","module.exports = window[\"wp\"][\"preferences\"];","module.exports = window[\"wp\"][\"primitives\"];","module.exports = window[\"wp\"][\"viewport\"];","module.exports = window[\"React\"];","module.exports = window[\"ReactJSXRuntime\"];","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Styles.\n */\nimport \"./styles/app.scss\";\n\nimport domReady from \"@wordpress/dom-ready\";\nimport { registerPlugin } from \"@wordpress/plugins\";\nimport ChatEditor from \"./components/ChatEditor\";\n\n// Register the plugin when DOM is ready\ndomReady(() => {\n\tregisterPlugin(\"nfd-editor-chat\", {\n\t\trender: ChatEditor,\n\t});\n});\n\n// Export components for potential reuse\nexport { ChatEditor };\n"],"names":["useDispatch","PluginSidebar","PluginSidebarMoreMenuItem","useEffect","__","store","interfaceStore","useChat","ActionButtons","ChatInput","ChatMessages","WelcomeScreen","SidebarHeader","AILogo","jsx","_jsx","jsxs","_jsxs","Fragment","_Fragment","SIDEBAR_NAME","SIDEBAR_SCOPE","ChatEditor","enableComplementaryArea","messages","isLoading","error","status","isSaving","activeToolCall","handleSendMessage","handleNewChat","handleAcceptChanges","handleDeclineChanges","handleStopRequest","pendingActionsCount","filter","msg","hasActions","length","hasPendingActions","isNewChatDisabled","children","scope","target","icon","width","height","identifier","className","closeLabel","headerClassName","panelClassName","header","onNewChat","onSendMessage","pendingCount","onAccept","onDecline","onStopRequest","disabled","Button","Check","X","changeText","onClick","size","useRef","useState","ArrowUp","CircleStop","useSelectedBlock","ContextTag","message","setMessage","textareaRef","selectedBlock","clearSelectedBlock","current","style","newHeight","Math","min","scrollHeight","setTimeout","focus","handleSubmit","trim","handleKeyDown","e","key","shiftKey","preventDefault","name","ref","value","onChange","onKeyDown","placeholder","rows","block","onRemove","clientId","label","useMemo","containsHtml","sanitizeHtml","containsMarkdown","parseMarkdown","ChatMessage","type","isUser","content","isRichContent","parsed","dangerouslySetInnerHTML","__html","ErrorAlert","TypingIndicator","messagesEndRef","scrollIntoView","behavior","map","index","Edit3","FilePlus","Layers","Palette","SuggestionButton","suggestions","text","action","suggestion","Plus","Sparkles","ReactComponent","SparksIcon","AtSign","getBlockLabel","blockName","cleanName","split","pop","word","charAt","toUpperCase","slice","join","extractBlockText","plainText","replace","blockLabel","metadataName","attributes","metadata","blockType","isTextBlock","includes","blockContent","extractedText","displayLabel","fullDisplayLabel","substring","title","CircleX","getAbilityDetails","abilityName","abilityMap","description","getToolDetails","toolName","args","ability_name","details","params","parameters","colors","colorCount","arguments","getStatusText","statusInfo","useCallback","useSelect","coreStore","mcpClient","openaiClient","actionExecutor","simpleHash","updateGlobalPalette","getCurrentGlobalStyles","getStorageKeys","siteId","window","nfdEditorChat","homeUrl","SESSION_ID","MESSAGES","loadSessionId","STORAGE_KEYS","localStorage","getItem","console","warn","saveSessionId","sessionId","setItem","removeItem","loadMessages","stored","JSON","parse","undoData","isStreaming","rest","saveMessages","cleanMessages","stringify","clearChatData","generateSessionId","crypto","randomUUID","Date","now","random","toString","savedSessionId","savedMessages","setMessages","setIsLoading","setSessionId","setError","setStatus","setIsSaving","hasGlobalStylesChanges","setHasGlobalStylesChanges","mcpConnectionStatus","setMcpConnectionStatus","tools","setTools","setActiveToolCall","hasInitializedRef","abortControllerRef","savePost","saveEditedEntityRecord","__experimentalGetCurrentGlobalStylesId","select","isSavingPost","prev","initializeMCP","connect","initialize","availableTools","listTools","err","abort","messageContent","userMessage","id","role","AbortController","systemMessage","createWordPressSystemMessage","recentMessages","openaiMessages","convertMessagesToOpenAI","toolCalls","toolResults","openaiTools","isConnected","getToolsForOpenAI","assistantMessageId","currentContent","createStreamingCompletion","model","undefined","tool_choice","temperature","max_tokens","chunk","fullMessage","toolCallsResult","handleToolCalls","previousMessages","toolCall","log","replace_all","jsResult","success","push","result","isError","jsError","callTool","palette","rawSettings","styles","some","r","toolResultsSummary","resultText","Array","isArray","item","followUpMessageId","followUpContent","followUpMessages","followUpError","newSessionId","globalStylesId","saveError","firstActionMessage","find","blocks","restoreBlocks","globalStyles","originalStyles","restoreGlobalStyles","msgUndoData","restoreError","refreshMCPConnection","disconnect","conversationId","getSelectedBlock","dispatch","resolveSelect","serialize","createBlock","updateTemplatePartContent","getTemplatePartEntity","isTemplatePart","fetchTemplatePartContent","ActionExecutor","executeActions","actions","results","errors","executeAction","handleEditContentAction","handleChangeSiteColorsAction","Error","data","operationType","operation_type","section","block_content","handleRewriteAction","handleDeleteAction","location","handleAddAction","handlePatchAction","changes","applyContentChanges","getBlock","applyTemplatePartRewrite","originalBlock","innerBlocks","updatedBlocks","updatedBlock","updateBlockAttributes","replaceInnerBlocks","innerBlock","createBlockFromParsed","applyTemplatePartChanges","blockHtml","change","normalizedBlockHtml","normalizeHtml","normalizedFind","normalizedReplace","changesApplied","originalEntity","entityContent","updatedInnerBlocks","parsedBlock","entityUpdateResult","coreResolve","templatePartContent","updatedContent","normalizedContent","blockData","isTemplatePartBlock","contentString","raw","rendered","originalBlocks","updateResult","restoredInnerBlocks","inner","messageType","html","normalized","handleDeleteTemplatePart","removeBlock","getEffectiveRootBlocks","getBlocks","rootBlocks","postContentBlock","postContentInnerBlocks","parentClientId","findBlockContext","rootIndex","findIndex","innerIndex","insertBlocks","blocksToInsert","parsedBlocks","wpBlocks","effectiveRoot","targetBlock","context","insertIndex","insertedClientIds","Boolean","blocksAdded","getEditedEntityRecord","record","settings","rawPalette","color","theme","themePalette","updatedPalette","colorUpdate","slug","newColor","editEntityRecord","colorsUpdated","getWPData","wp","getGlobalStylesId","editSiteStore","getSettings","__experimentalGlobalStylesUserEntityId","getEditedPostId","postId","postType","getEditedPostType","records","getEntityRecords","per_page","customPalette","paletteData","custom","blockEditorStore","editorSettings","__experimentalFeatures","featurePalette","replaceAll","coreDispatch","currentRecord","currentSettings","currentColorSettings","currentPalette","existingCustomPalette","validatedColors","c","newCustomPalette","paletteBySlug","Map","set","from","values","newSettings","updatedColors","isGlobalStylesAvailable","getFormattedPalette","Client","StreamableHTTPClientTransport","MCPError","constructor","code","WordPressMCPClient","client","transport","connected","resources","eventListeners","config","getConfig","nonce","mcpUrl","restUrl","on","event","listener","has","Set","get","add","off","listeners","delete","emit","forEach","serverUrl","mcpEndpoint","version","capabilities","URL","requestInit","headers","mcpError","Promise","all","loadTools","loadResources","initResult","protocolVersion","prompts","serverInfo","normalizeInputSchema","schema","Object","keys","properties","required","tool","inputSchema","annotations","listResources","resource","uri","mimeType","toolResult","meta","readResource","close","getTools","getResources","isToolReadOnly","t","readonly","readOnlyHint","toolToOpenAIFunction","function","OpenAI","DEFAULT_MODEL","OpenAIError","CloudflareOpenAIClient","openai","currentUser","getOpenAIClient","apiKey","baseURL","dangerouslyAllowBrowser","defaultHeaders","createChatCompletion","request","response","chat","completions","create","stream","onChunk","onComplete","onError","toolCallsInProgress","delta","choices","tool_calls","finish_reason","finalToolCalls","tc","assistantMessage","hasToolCalls","call","hasMatchingCall","tool_call_id","convertMCPToolsToOpenAI","mcpTools","processToolCalls","sendMessage","timestamp","choice","display_name","getCurrentPageContent","postContent","getPostContent","templatePartBlocks","getAllTemplatePartBlocks","templatePartsMap","buildTemplatePartsMap","page_content","blockEditor","b","tplBlock","resolve","rec","getEntityRecord","compositeId","recByComposite","query","recs","exact","pickTemplatePartKey","attrs","String","area","i","getCurrentPageBlocks","processedBlocks","getCurrentPageId","editor","getCurrentPostId","getCurrentPageTitle","getEditedPostAttribute","getTemplatePartEntityId","entity","entityId","savedRecord","str","hash","charCodeAt","markdownPatterns","pattern","test","match","lang","escapedCode","indent","level","floor","m","trimmed","startsWith","processedContent","DOMPurify","sanitize","ALLOWED_TAGS","ALLOWED_ATTR","ALLOW_DATA_ATTR","FORBID_TAGS","FORBID_ATTR","domReady","registerPlugin","render"],"sourceRoot":""}